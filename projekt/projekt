<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImmoScout24 - E-Learning Portal</title>
    
    <!-- Favicons -->
    <link rel="shortcut icon" href="assets/favicon.ico" type="image/x-icon">
    
    <!-- CSS-Dateien -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/themes.css">
    
    <!-- Font Awesome für Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- App-Container für die gesamte Anwendung -->
    <div id="app-container">
        
        <!-- Login-Bereich -->
        <div id="login-section" class="active-section">
            <div class="login-container">
                <div class="login-logo">
                    <img src="assets/immoscout24_logo.png" alt="ImmoScout24 Logo">
                </div>
                
                <div class="login-form-container">
                    <h1>E-Learning Portal</h1>
                    <p class="login-intro">Willkommen im E-Learning-Portal von ImmoScout24. Bitte melden Sie sich an, um fortzufahren.</p>
                    
                    <form id="login-form" class="login-form">
                        <div class="form-group">
                            <label for="username">Benutzername</label>
                            <input type="text" id="username" name="username" placeholder="Benutzername eingeben" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="password">Passwort</label>
                            <input type="password" id="password" name="password" placeholder="Passwort eingeben" required>
                        </div>
                        
                        <div id="role-selection" class="form-group" style="display: none;">
                            <label for="role">Als welche Rolle möchten Sie sich anmelden?</label>
                            <select id="role" name="role">
                                <!-- Wird dynamisch befüllt, wenn ein Benutzer mehrere Rollen hat -->
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <button type="submit" class="btn-primary">Anmelden</button>
                        </div>
                        
                        <div id="login-error" class="error-message" style="display: none;">
                            Ungültiger Benutzername oder Passwort. Bitte versuchen Sie es erneut.
                        </div>
                    </form>
                </div>
            </div>
            
            <footer class="login-footer">
                <p>&copy; 2025 ImmoScout24 - Alle Rechte vorbehalten</p>
            </footer>
        </div>
        
        <!-- Hauptbereich der Anwendung (nach Login, initial versteckt) -->
        <div id="main-app" style="display: none;">
            <!-- Header-Bereich mit Navigation -->
            <header id="app-header">
                <div class="header-logo">
                    <img src="assets/immoscout24_logo_small.png" alt="ImmoScout24">
                </div>
                
                <nav id="main-nav">
                    <!-- Navigation wird dynamisch basierend auf der Benutzerrolle geladen -->
                </nav>
                
                <div class="user-menu">
                    <div class="user-avatar">
                        <!-- Avatar-Bild wird dynamisch geladen -->
                        <img id="user-avatar" src="assets/avatars/default.png" alt="Benutzer-Avatar">
                    </div>
                    <div class="user-info">
                        <span id="user-name">Benutzername</span>
                        <span id="user-role">Rolle</span>
                    </div>
                    <div class="user-actions">
                        <button id="btn-logout" class="btn-logout">
                            <i class="fas fa-sign-out-alt"></i> Abmelden
                        </button>
                    </div>
                </div>
            </header>
            
            <!-- Container für alle Sektionen (werden dynamisch ein-/ausgeblendet) -->
            <main id="content-container">
                <!-- Admin-Bereich -->
                <div id="admin-section" class="content-section">
                    <!-- Wird in HTML-Block 2 implementiert -->
                </div>
                
                <!-- Trainer-Bereich -->
                <div id="trainer-section" class="content-section">
                    <!-- Wird in HTML-Block 6 implementiert -->
                </div>
                
                <!-- Teamleiter-Bereich -->
                <div id="teamleader-section" class="content-section">
                    <!-- Wird in HTML-Block 7 implementiert -->
                </div>
                
                <!-- Mitarbeiter-Bereich -->
                <div id="employee-section" class="content-section">
                    <!-- Wird in HTML-Block 8 implementiert -->
                </div>
                
                <!-- Test-Durchführung -->
                <div id="test-execution-section" class="content-section">
                    <!-- Wird in HTML-Block 5 implementiert -->
                </div>
            </main>
            
            <!-- Footer -->
            <footer id="app-footer">
                <p>&copy; 2025 ImmoScout24 - E-Learning Portal</p>
                <p>Version 1.0</p>
            </footer>
        </div>
        
        <!-- Allgemeiner Lade-Indikator -->
        <div id="loading-indicator" style="display: none;">
            <div class="spinner"></div>
            <p>Wird geladen...</p>
        </div>
        
        <!-- Allgemeiner Modal-Dialog -->
        <div id="modal-container" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="modal-close">&times;</span>
                <div id="modal-header"></div>
                <div id="modal-body"></div>
                <div id="modal-footer"></div>
            </div>
        </div>
    </div>
    
    <!-- JavaScript-Dateien -->
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/modules/auth.js"></script>
    <script src="js/modules/dataModel.js"></script>
    <script src="js/modules/ui.js"></script>
    <script src="js/app.js"></script>
</body>
</html>
/* ImmoScout24 E-Learning Portal - Hauptstilregeln */

/* ----- Variablen & Farbschema ----- */
:root {
    /* ImmoScout24 Farbschema */
    --primary-color: #00FFD0;    /* Hauptfarbe ImmoScout24 */
    --primary-dark: #00CCA6;     /* Dunklere Version für Hover-Effekte */
    --primary-light: #80FFE7;    /* Hellere Version für Hintergründe */
    
    --secondary-color: #0E3E53;  /* Sekundärfarbe für Kontraste */
    --secondary-light: #1A5A78;  /* Hellere Version */
    
    --text-dark: #333333;        /* Haupttextfarbe */
    --text-light: #FFFFFF;       /* Heller Text für dunkle Hintergründe */
    --text-muted: #6C757D;       /* Abgeschwächter Text */
    
    --success-color: #28A745;    /* Erfolg-Meldungen */
    --warning-color: #FFC107;    /* Warnungen */
    --danger-color: #DC3545;     /* Fehler/Gefahren */
    --info-color: #17A2B8;       /* Informationen */
    
    --background-light: #F8F9FA; /* Heller Hintergrund */
    --background-white: #FFFFFF; /* Weißer Hintergrund */
    --border-color: #DEE2E6;     /* Rahmenfarbe */
    
    /* Abstände und Größen */
    --spacing-xs: 0.25rem;       /* 4px */
    --spacing-sm: 0.5rem;        /* 8px */
    --spacing-md: 1rem;          /* 16px */
    --spacing-lg: 1.5rem;        /* 24px */
    --spacing-xl: 2rem;          /* 32px */
    
    /* Schriftgrößen */
    --font-size-xs: 0.75rem;     /* 12px */
    --font-size-sm: 0.875rem;    /* 14px */
    --font-size-md: 1rem;        /* 16px */
    --font-size-lg: 1.25rem;     /* 20px */
    --font-size-xl: 1.5rem;      /* 24px */
    --font-size-xxl: 2rem;       /* 32px */
    
    /* Schatten */
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    --shadow-md: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
    --shadow-lg: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
    
    /* Radien */
    --border-radius-sm: 0.25rem; /* 4px */
    --border-radius-md: 0.5rem;  /* 8px */
    --border-radius-lg: 1rem;    /* 16px */
    
    /* Animationen */
    --transition-fast: 0.2s ease;
    --transition-normal: 0.3s ease;
    --transition-slow: 0.5s ease;
}

/* ----- Grundlegende Resets und Standardstile ----- */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 16px;
    line-height: 1.5;
    color: var(--text-dark);
    background-color: var(--background-light);
}

body {
    display: flex;
    flex-direction: column;
}

h1, h2, h3, h4, h5, h6 {
    margin-bottom: var(--spacing-md);
    font-weight: 600;
    line-height: 1.2;
}

h1 { font-size: var(--font-size-xxl); }
h2 { font-size: var(--font-size-xl); }
h3 { font-size: var(--font-size-lg); }
h4 { font-size: var(--font-size-md); }
h5 { font-size: var(--font-size-sm); }
h6 { font-size: var(--font-size-xs); }

a {
    color: var(--secondary-color);
    text-decoration: none;
    transition: color var(--transition-fast);
}

a:hover {
    color: var(--primary-dark);
    text-decoration: underline;
}

button, input, select, textarea {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
}

/* ----- Container-Strukturen ----- */
#app-container {
    width: 100%;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.content-section {
    display: none;
    padding: var(--spacing-lg);
}

.active-section {
    display: block;
}

/* ----- Login-Bereich ----- */
#login-section {
    width: 100%;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, var(--secondary-color) 0%, var(--secondary-light) 100%);
    padding: var(--spacing-lg);
}

.login-container {
    width: 100%;
    max-width: 480px;
    background-color: var(--background-white);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg);
    overflow: hidden;
    animation: fadeIn 0.5s ease-in-out;
}

.login-logo {
    text-align: center;
    padding: var(--spacing-lg) var(--spacing-lg) var(--spacing-md);
}

.login-logo img {
    max-width: 200px;
    height: auto;
}

.login-form-container {
    padding: 0 var(--spacing-xl) var(--spacing-xl);
}

.login-intro {
    margin-bottom: var(--spacing-lg);
    color: var(--text-muted);
    text-align: center;
}

.login-form .form-group {
    margin-bottom: var(--spacing-md);
}

.login-form label {
    display: block;
    margin-bottom: var(--spacing-xs);
    font-weight: 500;
}

.login-form input,
.login-form select {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    transition: border-color var(--transition-fast);
}

.login-form input:focus,
.login-form select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 255, 208, 0.25);
}

.login-footer {
    padding: var(--spacing-md);
    text-align: center;
    color: var(--text-light);
    font-size: var(--font-size-sm);
    margin-top: var(--spacing-xl);
}

/* Buttons */
.btn-primary {
    display: inline-block;
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--primary-color);
    color: var(--secondary-color);
    font-weight: 600;
    text-align: center;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast), transform var(--transition-fast);
}

.btn-primary:hover {
    background-color: var(--primary-dark);
    transform: translateY(-2px);
}

.btn-primary:active {
    transform: translateY(0);
}

/* Error Message */
.error-message {
    color: var(--danger-color);
    margin-top: var(--spacing-sm);
    font-size: var(--font-size-sm);
}

/* Loading Indicator */
#loading-indicator {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 5px solid var(--primary-light);
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

#loading-indicator p {
    margin-top: var(--spacing-md);
    color: var(--text-light);
}

/* Modal Dialog */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.modal-content {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-lg);
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
}

.modal-close {
    position: absolute;
    top: var(--spacing-sm);
    right: var(--spacing-md);
    font-size: var(--font-size-xl);
    color: var(--text-muted);
    cursor: pointer;
}

#modal-header {
    padding: var(--spacing-md) var(--spacing-lg);
    border-bottom: 1px solid var(--border-color);
}

#modal-body {
    padding: var(--spacing-lg);
}

#modal-footer {
    padding: var(--spacing-md) var(--spacing-lg);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-sm);
}

/* Animationen */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* ----- Responsive Design ----- */
@media (max-width: 576px) {
    .login-container {
        max-width: 100%;
    }
    
    .login-form-container {
        padding: 0 var(--spacing-md) var(--spacing-md);
    }
    
    h1 {
        font-size: var(--font-size-xl);
    }
    
    .login-logo img {
        max-width: 150px;
    }
}
/**
 * ImmoScout24 E-Learning Portal
 * app.js - Hauptdatei für die Anwendungsinitialisierung
 */

// Globales App-Objekt
const App = {
    // Konfiguration
    config: {
        appName: 'ImmoScout24 E-Learning Portal',
        version: '1.0.0',
        debugMode: false,
        defaultAvatar: 'assets/avatars/default.png',
        teams: ['B2B', 'Suchenden', 'Eigentümer'],
        roles: ['admin', 'trainer', 'teamleader', 'employee']
    },
    
    // Aktuelle Sitzungsdaten
    session: {
        user: null,
        currentRole: null,
        isLoggedIn: false
    },
    
    // Zentraler Event-Handler
    events: {},
    
    // Initialisierung der Anwendung
    init: function() {
        this.log('Initialisiere Anwendung...');
        
        // Prüfen, ob localStorage verfügbar ist
        if (!this.checkLocalStorage()) {
            this.showError('Diese Anwendung benötigt lokalen Speicher (localStorage). Bitte aktivieren Sie diese Funktion in Ihrem Browser oder verwenden Sie einen anderen Browser.');
            return;
        }
        
        // Initialisiere Module
        UI.init();
        Storage.init();
        DataModel.init();
        Auth.init();
        
        // Registriere Event-Listener
        this.setupEventListeners();
        
        // Prüfe, ob Benutzer angemeldet ist
        this.checkLoginStatus();
        
        this.log('Anwendung initialisiert');
    },
    
    // Prüft, ob localStorage verfügbar ist
    checkLocalStorage: function() {
        try {
            const test = 'test';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (e) {
            return false;
        }
    },
    
    // Zentrale Event-Listener-Einrichtung
    setupEventListeners: function() {
        // Login-Formular
        const loginForm = document.getElementById('login-form');
        if (loginForm) {
            loginForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const roleSelect = document.getElementById('role');
                const role = roleSelect.style.display !== 'none' ? roleSelect.value : null;
                
                Auth.login(username, password, role);
            });
        }
        
        // Logout-Button
        const logoutBtn = document.getElementById('btn-logout');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', function() {
                Auth.logout();
            });
        }
        
        // Modal schließen
        const modalClose = document.querySelector('.modal-close');
        if (modalClose) {
            modalClose.addEventListener('click', function() {
                UI.closeModal();
            });
        }
    },
    
    // Prüft den Login-Status bei Anwendungsstart
    checkLoginStatus: function() {
        const sessionData = Storage.get('session');
        if (sessionData && sessionData.isLoggedIn) {
            this.session = sessionData;
            this.showApp(sessionData.currentRole);
        } else {
            this.showLogin();
        }
    },
    
    // Zeigt die Anwendung mit der entsprechenden Rolle an
    showApp: function(role) {
        this.log(`Zeige Anwendung für Rolle: ${role}`);
        
        // Verstecke Login-Sektion
        document.getElementById('login-section').classList.remove('active-section');
        
        // Zeige Hauptanwendung
        document.getElementById('main-app').style.display = 'flex';
        
        // Benutzerinformationen aktualisieren
        document.getElementById('user-name').textContent = this.session.user.name;
        document.getElementById('user-role').textContent = this.getRoleDisplayName(this.session.currentRole);
        
        // Avatar setzen
        const avatarImg = document.getElementById('user-avatar');
        avatarImg.src = this.session.user.avatar || this.config.defaultAvatar;
        
        // Navigation basierend auf Rolle laden
        UI.loadNavigation(role);
        
        // Entsprechenden Bereich anzeigen
        UI.showSection(`${role}-section`);
    },
    
    // Zeigt die Login-Seite an
    showLogin: function() {
        this.log('Zeige Login-Seite');
        
        // Verstecke Hauptanwendung
        document.getElementById('main-app').style.display = 'none';
        
        // Zeige Login-Sektion
        document.getElementById('login-section').classList.add('active-section');
        
        // Login-Formular zurücksetzen
        document.getElementById('login-form').reset();
        document.getElementById('login-error').style.display = 'none';
        document.getElementById('role-selection').style.display = 'none';
    },
    
    // Zeigt eine Fehlermeldung auf der Login-Seite
    showLoginError: function(message) {
        const errorEl = document.getElementById('login-error');
        errorEl.textContent = message || 'Ungültiger Benutzername oder Passwort. Bitte versuchen Sie es erneut.';
        errorEl.style.display = 'block';
    },
    
    // Zeigt Rollenselektion, wenn ein Benutzer mehrere Rollen hat
    showRoleSelection: function(roles) {
        const roleSelect = document.getElementById('role');
        roleSelect.innerHTML = '';
        
        roles.forEach(role => {
            const option = document.createElement('option');
            option.value = role;
            option.textContent = this.getRoleDisplayName(role);
            roleSelect.appendChild(option);
        });
        
        document.getElementById('role-selection').style.display = 'block';
    },
    
    // Liefert den Anzeigenamen für eine Rolle
    getRoleDisplayName: function(role) {
        const displayNames = {
            'admin': 'Administrator',
            'trainer': 'Trainer',
            'teamleader': 'Teamleiter',
            'employee': 'Mitarbeiter'
        };
        
        return displayNames[role] || role;
    },
    
    // Zeigt einen allgemeinen Fehler
    showError: function(message) {
        UI.showModal('Fehler', message, [
            { text: 'OK', handler: UI.closeModal, isPrimary: true }
        ]);
    },
    
    // Logging-Funktion (nur im Debug-Modus)
    log: function(message) {
        if (this.config.debugMode) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
    }
};

// Starte die Anwendung, wenn das DOM geladen ist
document.addEventListener('DOMContentLoaded', function() {
    App.init();
});
/**
 * ImmoScout24 E-Learning Portal
 * helpers.js - Hilfsfunktionen und Utilities
 */

const Helpers = {
    /**
     * Generiert eine eindeutige ID
     * @returns {string} Eindeutige ID
     */
    generateId: function() {
        return 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },
    
    /**
     * Formatiert ein Datum in ein lesbares Format
     * @param {Date|string|number} date - Datumsobjekt, ISO-String oder Timestamp
     * @param {boolean} includeTime - Ob die Uhrzeit mit angezeigt werden soll
     * @returns {string} Formatiertes Datum
     */
    formatDate: function(date, includeTime = false) {
        const d = new Date(date);
        if (isNaN(d.getTime())) {
            return 'Ungültiges Datum';
        }
        
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        
        let formattedDate = `${day}.${month}.${year}`;
        
        if (includeTime) {
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            formattedDate += ` ${hours}:${minutes}`;
        }
        
        return formattedDate;
    },
    
    /**
     * Berechnet die verstrichene Zeit seit einem Datum
     * @param {Date|string|number} date - Datumsobjekt, ISO-String oder Timestamp
     * @returns {string} Lesbare Zeitdifferenz
     */
    timeAgo: function(date) {
        const d = new Date(date);
        if (isNaN(d.getTime())) {
            return 'Ungültiges Datum';
        }
        
        const seconds = Math.floor((new Date() - d) / 1000);
        
        // Intervalle in Sekunden
        const intervals = {
            'Jahr': 31536000,
            'Monat': 2592000,
            'Woche': 604800,
            'Tag': 86400,
            'Stunde': 3600,
            'Minute': 60,
            'Sekunde': 1
        };
        
        for (const [name, secondsInInterval] of Object.entries(intervals)) {
            const interval = Math.floor(seconds / secondsInInterval);
            
            if (interval >= 1) {
                const plural = interval === 1 ? '' : (name === 'Monat' ? 'e' : 'n');
                return `vor ${interval} ${name}${plural}`;
            }
        }
        
        return 'gerade eben';
    },
    
    /**
     * Berechnet den Prozentsatz
     * @param {number} value - Wert
     * @param {number} total - Gesamtwert
     * @param {number} decimals - Anzahl der Dezimalstellen
     * @returns {number} Prozentsatz
     */
    calculatePercentage: function(value, total, decimals = 1) {
        if (total === 0) {
            return 0;
        }
        
        const percentage = (value / total) * 100;
        return parseFloat(percentage.toFixed(decimals));
    },
    
    /**
     * Filtert ein Array von Objekten
     * @param {Array} array - Das zu filternde Array
     * @param {Object} filters - Filter-Kriterien (key-value Paare)
     * @returns {Array} Gefiltertes Array
     */
    filterArray: function(array, filters) {
        return array.filter(item => {
            for (const [key, value] of Object.entries(filters)) {
                if (item[key] !== value) {
                    return false;
                }
            }
            return true;
        });
    },
    
    /**
     * Sortiert ein Array von Objekten nach einem Schlüssel
     * @param {Array} array - Das zu sortierende Array
     * @param {string} key - Sortierschlüssel
     * @param {boolean} ascending - Aufsteigend sortieren?
     * @returns {Array} Sortiertes Array
     */
    sortArray: function(array, key, ascending = true) {
        return [...array].sort((a, b) => {
            if (a[key] < b[key]) return ascending ? -1 : 1;
            if (a[key] > b[key]) return ascending ? 1 : -1;
            return 0;
        });
    },
    
    /**
     * Gruppiert ein Array von Objekten nach einem Schlüssel
     * @param {Array} array - Das zu gruppierende Array
     * @param {string} key - Gruppierungsschlüssel
     * @returns {Object} Gruppiertes Objekt
     */
    groupArrayBy: function(array, key) {
        return array.reduce((result, item) => {
            (result[item[key]] = result[item[key]] || []).push(item);
            return result;
        }, {});
    },
    
    /**
     * Erstellt ein Deep Copy eines Objekts oder Arrays
     * @param {*} obj - Das zu kopierende Objekt
     * @returns {*} Kopie des Objekts
     */
    deepCopy: function(obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    
    /**
     * Validiert eine E-Mail-Adresse
     * @param {string} email - Die zu prüfende E-Mail-Adresse
     * @returns {boolean} Ob die E-Mail gültig ist
     */
    isValidEmail: function(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(String(email).toLowerCase());
    },
    
    /**
     * Validiert ein Passwort (min. 6 Zeichen)
     * @param {string} password - Das zu prüfende Passwort
     * @returns {boolean} Ob das Passwort gültig ist
     */
    isValidPassword: function(password) {
        return typeof password === 'string' && password.length >= 6;
    },
    
    /**
     * Begrenzt einen Text auf eine bestimmte Länge und fügt ggf. Ellipsis hinzu
     * @param {string} text - Der zu begrenzende Text
     * @param {number} maxLength - Maximale Länge
     * @returns {string} Begrenzter Text
     */
    truncateText: function(text, maxLength = 100) {
        if (text.length <= maxLength) {
            return text;
        }
        return text.substring(0, maxLength) + '...';
    },
    
    /**
     * Konvertiert HTML-Sonderzeichen in Entities
     * @param {string} text - Der zu escapende Text
     * @returns {string} Escapeter Text
     */
    escapeHtml: function(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    /**
     * Erzeugt einen zufälligen String
     * @param {number} length - Länge des Strings
     * @returns {string} Zufallsstring
     */
    randomString: function(length = 8) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    },
    
    /**
     * Mischt ein Array
     * @param {Array} array - Das zu mischende Array
     * @returns {Array} Gemischtes Array
     */
    shuffleArray: function(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    },
    
    /**
     * Konvertiert einen String in einen sicheren Dateinamen
     * @param {string} text - Der zu konvertierende Text
     * @returns {string} Dateiname
     */
    toFileName: function(text) {
        return text
            .toLowerCase()
            .replace(/[äöüß]/g, match => {
                return { 'ä': 'ae', 'ö': 'oe', 'ü': 'ue', 'ß': 'ss' }[match];
            })
            .replace(/[^a-z0-9]/g, '_')
            .replace(/_+/g, '_')
            .replace(/^_|_$/g, '');
    },
    
    /**
     * Erzeugt einen Download einer Textdatei
     * @param {string} content - Dateiinhalt
     * @param {string} fileName - Dateiname
     * @param {string} contentType - MIME-Typ
     */
    downloadFile: function(content, fileName, contentType = 'text/plain') {
        const a = document.createElement('a');
        const file = new Blob([content], { type: contentType });
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    },
    
    /**
     * Liest eine Datei als Text
     * @param {File} file - Die zu lesende Datei
     * @returns {Promise<string>} Der Dateiinhalt
     */
    readFileAsText: function(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = event => resolve(event.target.result);
            reader.onerror = error => reject(error);
            reader.readAsText(file);
        });
    }
};
/**
 * ImmoScout24 E-Learning Portal
 * storage.js - Funktionen für die Datenpersistenz im localStorage
 */

const Storage = {
    // Präfix für alle localStorage-Schlüssel
    keyPrefix: 'immoscout24_e_learning_',
    
    // Aktuelle Version der Datenstruktur (für Migrationen)
    dataVersion: 1,
    
    // Initialisierung
    init: function() {
        App.log('Initialisiere Storage...');
        
        // Überprüfe, ob eine Migration notwendig ist
        this.checkMigration();
        
        // Wenn noch keine Daten existieren, erstelle Initial-Daten
        if (!this.hasData('users')) {
            this.createInitialData();
        }
        
        App.log('Storage initialisiert');
    },
    
    /**
     * Liest Daten aus dem localStorage
     * @param {string} key - Schlüssel
     * @returns {any} Daten oder null
     */
    get: function(key) {
        try {
            const data = localStorage.getItem(this.keyPrefix + key);
            return data ? JSON.parse(data) : null;
        } catch (e) {
            App.log(`Fehler beim Lesen von ${key}: ${e.message}`);
            return null;
        }
    },
    
    /**
     * Speichert Daten im localStorage
     * @param {string} key - Schlüssel
     * @param {any} data - Zu speichernde Daten
     * @returns {boolean} Erfolgsstatus
     */
    set: function(key, data) {
        try {
            localStorage.setItem(this.keyPrefix + key, JSON.stringify(data));
            return true;
        } catch (e) {
            App.log(`Fehler beim Speichern von ${key}: ${e.message}`);
            App.showError(`Beim Speichern ist ein Fehler aufgetreten: ${e.message}`);
            return false;
        }
    },
    
    /**
     * Entfernt Daten aus dem localStorage
     * @param {string} key - Schlüssel
     * @returns {boolean} Erfolgsstatus
     */
    remove: function(key) {
        try {
            localStorage.removeItem(this.keyPrefix + key);
            return true;
        } catch (e) {
            App.log(`Fehler beim Entfernen von ${key}: ${e.message}`);
            return false;
        }
    },
    
    /**
     * Prüft, ob Daten für einen Schlüssel existieren
     * @param {string} key - Schlüssel
     * @returns {boolean} Existenzstatus
     */
    hasData: function(key) {
        return localStorage.getItem(this.keyPrefix + key) !== null;
    },
    
    /**
     * Löscht alle Daten der Anwendung
     * @returns {boolean} Erfolgsstatus
     */
    clearAllData: function() {
        try {
            // Nur Einträge mit unserem Präfix löschen
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith(this.keyPrefix)) {
                    localStorage.removeItem(key);
                }
            });
            return true;
        } catch (e) {
            App.log(`Fehler beim Löschen aller Daten: ${e.message}`);
            return false;
        }
    },
    
    /**
     * Exportiert alle Daten als JSON
     * @returns {string|null} JSON-String oder null bei Fehler
     */
    exportAllData: function() {
        try {
            const exportData = {
                version: this.dataVersion,
                timestamp: new Date().toISOString(),
                data: {}
            };
            
            // Alle Daten mit unserem Präfix sammeln
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith(this.keyPrefix)) {
                    const cleanKey = key.replace(this.keyPrefix, '');
                    exportData.data[cleanKey] = JSON.parse(localStorage.getItem(key));
                }
            });
            
            return JSON.stringify(exportData, null, 2);
        } catch (e) {
            App.log(`Fehler beim Exportieren der Daten: ${e.message}`);
            App.showError(`Beim Exportieren ist ein Fehler aufgetreten: ${e.message}`);
            return null;
        }
    },
    
    /**
     * Importiert Daten aus einem JSON-String
     * @param {string} jsonData - JSON-String
     * @param {boolean} merge - Bestehende Daten überschreiben oder zusammenführen
     * @returns {boolean} Erfolgsstatus
     */
    importData: function(jsonData, merge = false) {
        try {
            const importData = JSON.parse(jsonData);
            
            // Versionsprüfung
            if (!importData.version || importData.version > this.dataVersion) {
                throw new Error(`Nicht kompatible Datenversion: ${importData.version || 'unbekannt'}`);
            }
            
            // Wenn nicht zusammenführen, dann alle bestehenden Daten löschen
            if (!merge) {
                this.clearAllData();
            }
            
            // Daten importieren
            Object.keys(importData.data).forEach(key => {
                if (merge && this.hasData(key)) {
                    // Bei Zusammenführung bestehende Daten mit neuen zusammenführen
                    const existingData = this.get(key);
                    
                    if (Array.isArray(existingData) && Array.isArray(importData.data[key])) {
                        // Bei Arrays: Elemente zusammenführen basierend auf ID
                        const mergedArray = [...existingData];
                        
                        importData.data[key].forEach(newItem => {
                            if (!newItem.id) {
                                // Element ohne ID einfach hinzufügen
                                mergedArray.push(newItem);
                            } else {
                                const existingIndex = mergedArray.findIndex(item => item.id === newItem.id);
                                
                                if (existingIndex >= 0) {
                                    // Existierendes Element aktualisieren
                                    mergedArray[existingIndex] = newItem;
                                } else {
                                    // Neues Element hinzufügen
                                    mergedArray.push(newItem);
                                }
                            }
                        });
                        
                        this.set(key, mergedArray);
                    } else if (typeof existingData === 'object' && existingData !== null &&
                               typeof importData.data[key] === 'object' && importData.data[key] !== null) {
                        // Bei Objekten: Eigenschaften zusammenführen
                        this.set(key, { ...existingData, ...importData.data[key] });
                    } else {
                        // Bei anderen Typen: Einfach überschreiben
                        this.set(key, importData.data[key]);
                    }
                } else {
                    // Einfach überschreiben oder neuen Eintrag erstellen
                    this.set(key, importData.data[key]);
                }
            });
            
            return true;
        } catch (e) {
            App.log(`Fehler beim Importieren der Daten: ${e.message}`);
            App.showError(`Beim Importieren ist ein Fehler aufgetreten: ${e.message}`);
            return false;
        }
    },
    
    /**
     * Prüft, ob eine Migration der Daten notwendig ist
     */
    checkMigration: function() {
        const metaData = this.get('meta') || { version: 1 };
        
        if (metaData.version < this.dataVersion) {
            App.log(`Migration der Daten von Version ${metaData.version} auf ${this.dataVersion} erforderlich`);
            
            // Hier könnten verschiedene Migrationsschritte durchgeführt werden
            // switch (metaData.version) {
            //     case 1:
            //         // Migration von Version 1 auf 2
            //         ...
            //         // Weiter mit case 2 für 2 -> 3 usw.
            // }
            
            // Metadaten aktualisieren
            metaData.version = this.dataVersion;
            metaData.lastMigration = new Date().toISOString();
            this.set('meta', metaData);
            
            App.log('Migration abgeschlossen');
        }
    },
    
    /**
     * Erstellt initiale Daten für die Anwendung
     */
    createInitialData: function() {
        App.log('Erstelle initiale Daten...');
        
        // Metadaten
        this.set('meta', {
            version: this.dataVersion,
            created: new Date().toISOString(),
            lastModified: new Date().toISOString()
        });
        
        // Demo-Benutzer
        const users = [
            {
                id: 'admin_1',
                username: 'frank',
                password: 'admin123', // Im echten System würde hier ein Hash stehen
                name: 'Frank Pausch',
                email: 'frank.pausch@immoscout24.de',
                roles: ['admin', 'trainer'],
                avatar: 'assets/avatars/admin.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'trainer_1',
                username: 'trainer',
                password: 'trainer123',
                name: 'Tim Trainer',
                email: 'tim.trainer@immoscout24.de',
                roles: ['trainer'],
                avatar: 'assets/avatars/trainer.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'teamleader_1',
                username: 'felix',
                password: 'team123',
                name: 'Felix Lessing',
                email: 'felix.lessing@immoscout24.de',
                roles: ['teamleader'],
                team: 'B2B',
                avatar: 'assets/avatars/teamleader1.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'teamleader_2',
                username: 'doreen',
                password: 'team123',
                name: 'Doreen Lewis',
                email: 'doreen.lewis@immoscout24.de',
                roles: ['teamleader'],
                team: 'Suchenden',
                avatar: 'assets/avatars/teamleader2.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'teamleader_3',
                username: 'mathias',
                password: 'team123',
                name: 'Mathias Müthel',
                email: 'mathias.muethel@immoscout24.de',
                roles: ['teamleader'],
                team: 'Eigentümer',
                avatar: 'assets/avatars/teamleader3.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'employee_1',
                username: 'hannah',
                password: 'user123',
                name: 'Hannah Schöne',
                email: 'hannah.schoene@immoscout24.de',
                roles: ['employee'],
                team: 'B2B',
                avatar: 'assets/avatars/employee1.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'employee_2',
                username: 'paul',
                password: 'user123',
                name: 'Paul Krüger',
                email: 'paul.krueger@immoscout24.de',
                roles: ['employee'],
                team: 'Suchenden',
                avatar: 'assets/avatars/employee2.png',
                status: 'active',
                created: new Date().toISOString()
            },
            {
                id: 'employee_3',
                username: 'tim',
                password: 'user123',
                name: 'Tim Radtke',
                email: 'tim.radtke@immoscout24.de',
                roles: ['employee'],
                team: 'Eigentümer',
                avatar: 'assets/avatars/employee3.png',
                status: 'active',
                created: new Date().toISOString()
            }
        ];
        
        this.set('users', users);
        
        // Leere Arrays für Tests, Ergebnisse und Berichte
        this.set('tests', []);
        this.set('testResults', []);
        this.set('reports', []);
        this.set('questionBank', []);
        
        App.log('Initiale Daten erstellt');
    }
};
/**
 * ImmoScout24 E-Learning Portal
 * auth.js - Authentifizierung und Autorisierung
 */

const Auth = {
    // Initialisierung
    init: function() {
        App.log('Initialisiere Auth-Modul...');
        
        // Eventlistener für Sitzungs-Timeout einrichten
        this.setupSessionTimeout();
        
        App.log('Auth-Modul initialisiert');
    },
    
    /**
     * Führt den Login-Prozess durch
     * @param {string} username - Benutzername
     * @param {string} password - Passwort
     * @param {string|null} role - Optional: Ausgewählte Rolle, falls mehrere vorhanden
     * @returns {boolean} Erfolg/Misserfolg
     */
    login: function(username, password, role = null) {
        App.log(`Login-Versuch für Benutzer: ${username}`);
        
        // Login-Logik
        try {
            // Lade Benutzer
            const users = Storage.get('users') || [];
            const user = users.find(u => u.username === username && u.password === password);
            
            if (!user) {
                App.showLoginError('Ungültiger Benutzername oder Passwort.');
                return false;
            }
            
            if (user.status !== 'active') {
                App.showLoginError('Ihr Konto ist deaktiviert. Bitte kontaktieren Sie den Administrator.');
                return false;
            }
            
            // Benutzer hat mehrere Rollen, aber noch keine ausgewählt
            if (user.roles.length > 1 && !role) {
                App.showRoleSelection(user.roles);
                return false;
            }
            
            // Bestimme die zu verwendende Rolle
            const userRole = role || user.roles[0];
            
            if (!user.roles.includes(userRole)) {
                App.showLoginError('Ungültige Rolle.');
                return false;
            }
            
            // Anmeldung erfolgreich
            this.setSession(user, userRole);
            return true;
        } catch (e) {
            App.log(`Login-Fehler: ${e.message}`);
            App.showLoginError('Bei der Anmeldung ist ein Fehler aufgetreten. Bitte versuchen Sie es später erneut.');
            return false;
        }
    },
    
    /**
     * Setzt die aktive Sitzung
     * @param {Object} user - Benutzerobjekt
     * @param {string} role - Aktive Rolle
     */
    setSession: function(user, role) {
        App.log(`Setze Sitzung für Benutzer: ${user.name} mit Rolle: ${role}`);
        
        // Kopie des Benutzers ohne sensible Daten
        const sessionUser = {
            id: user.id,
            name: user.name,
            username: user.username,
            email: user.email,
            roles: user.roles,
            team: user.team,
            avatar: user.avatar
        };
        
        // Setze App-Sitzung
        App.session = {
            user: sessionUser,
            currentRole: role,
            isLoggedIn: true,
            lastActivity: new Date().getTime(),
            created: new Date().getTime()
        };
        
        // Speichere Sitzung im Storage
        Storage.set('session', App.session);
        
        // Protokolliere Login
        this.logAction('login', `Angemeldet als ${role}`);
        
        // Zeige Anwendung
        App.showApp(role);
    },
    
    /**
     * Führt den Logout durch
     */
    logout: function() {
        App.log('Logout durchgeführt');
        
        // Protokolliere Logout
        this.logAction('logout', 'Abgemeldet');
        
        // Lösche Sitzungsdaten
        App.session = {
            user: null,
            currentRole: null,
            isLoggedIn: false
        };
        
        Storage.remove('session');
        
        // Zeige Login-Seite
        App.showLogin();
    },
    
    /**
     * Ändert die aktive Rolle des angemeldeten Benutzers
     * @param {string} newRole - Neue Rolle
     * @returns {boolean} Erfolg/Misserfolg
     */
    switchRole: function(newRole) {
        App.log(`Rollenwechsel zu: ${newRole}`);
        
        if (!App.session.isLoggedIn || !App.session.user) {
            App.showError('Sie sind nicht angemeldet.');
            return false;
        }
        
        if (!App.session.user.roles.includes(newRole)) {
            App.showError('Sie haben keine Berechtigung für diese Rolle.');
            return false;
        }
        
        // Setze neue Rolle
        App.session.currentRole = newRole;
        App.session.lastActivity = new Date().getTime();
        
        // Speichere aktualisierte Sitzung
        Storage.set('session', App.session);
        
        // Protokolliere Rollenwechsel
        this.logAction('switchRole', `Rolle gewechselt zu ${newRole}`);
        
        // Aktualisiere UI
        App.showApp(newRole);
        
        return true;
    },
    
    /**
     * Prüft, ob der Benutzer eine bestimmte Rolle hat
     * @param {string} role - Zu prüfende Rolle
     * @returns {boolean} Hat Rolle oder nicht
     */
    hasRole: function(role) {
        return App.session.isLoggedIn && 
               App.session.user && 
               App.session.user.roles.includes(role);
    },
    
    /**
     * Prüft, ob der Benutzer die aktuelle Rolle hat
     * @param {string} role - Zu prüfende Rolle
     * @returns {boolean} Hat aktuelle Rolle oder nicht
     */
    isCurrentRole: function(role) {
        return App.session.isLoggedIn && 
               App.session.currentRole === role;
    },
    
    /**
     * Prüft, ob der Benutzer einem bestimmten Team angehört
     * @param {string} team - Team-Name
     * @returns {boolean} Gehört zum Team oder nicht
     */
    isInTeam: function(team) {
        return App.session.isLoggedIn && 
               App.session.user && 
               App.session.user.team === team;
    },
    
    /**
     * Richtet einen Timeout für die Sitzung ein
     * Loggt den Benutzer nach 60 Minuten Inaktivität automatisch aus
     */
    setupSessionTimeout: function() {
        // Prüft alle 5 Minuten, ob die Sitzung abgelaufen ist
        setInterval(() => {
            if (App.session.isLoggedIn) {
                const now = new Date().getTime();
                const lastActivity = App.session.lastActivity || now;
                const inactiveTime = now - lastActivity;
                
                // Nach 60 Minuten Inaktivität ausloggen (60 * 60 * 1000 = 3.600.000 ms)
                if (inactiveTime > 3600000) {
                    App.log('Sitzung abgelaufen wegen Inaktivität');
                    UI.showModal('Sitzung abgelaufen', 'Ihre Sitzung ist aufgrund von Inaktivität abgelaufen. Bitte melden Sie sich erneut an.', [
                        { text: 'OK', handler: this.logout.bind(this), isPrimary: true }
                    ]);
                }
            }
        }, 300000); // 5 Minuten = 300.000 ms
        
        // Aktualisiert den Aktivitätszeitstempel bei Benutzeraktionen
        document.addEventListener('click', this.updateActivityTimestamp.bind(this));
        document.addEventListener('keydown', this.updateActivityTimestamp.bind(this));
    },
    
    /**
     * Aktualisiert den Zeitstempel der letzten Aktivität
     */
    updateActivityTimestamp: function() {
        if (App.session.isLoggedIn) {
            App.session.lastActivity = new Date().getTime();
            Storage.set('session', App.session);
        }
    },
    
    /**
     * Protokolliert eine Benutzeraktion im Aktivitätslog
     * @param {string} action - Art der Aktion
     * @param {string} description - Beschreibung
     */
    logAction: function(action, description) {
        // Hole bestehende Logs oder erstelle leeres Array
        const logs = Storage.get('activityLogs') || [];
        
        // Erstelle neuen Log-Eintrag
        const log = {
            timestamp: new Date().toISOString(),
            userId: App.session.isLoggedIn ? App.session.user.id : null,
            username: App.session.isLoggedIn ? App.session.user.username : null,
            role: App.session.isLoggedIn ? App.session.currentRole : null,
            action: action,
            description: description,
            userAgent: navigator.userAgent
        };
        
        // Füge Log hinzu und begrenze auf die neuesten 1000 Einträge
        logs.unshift(log);
        if (logs.length > 1000) {
            logs.length = 1000;
        }
        
        // Speichere aktualisierte Logs
        Storage.set('activityLogs', logs);
    }
};
/**
 * ImmoScout24 E-Learning Portal
 * ui.js - Benutzeroberflächen-Funktionen
 */

const UI = {
    // Initialisierung
    init: function() {
        App.log('Initialisiere UI-Modul...');
        App.log('UI-Modul initialisiert');
    },
    
    /**
     * Zeigt eine bestimmte Sektion an und versteckt alle anderen
     * @param {string} sectionId - ID der anzuzeigenden Sektion
     */
    showSection: function(sectionId) {
        App.log(`Zeige Sektion: ${sectionId}`);
        
        // Alle Sektionen ausblenden
        const sections = document.querySelectorAll('.content-section');
        sections.forEach(section => {
            section.style.display = 'none';
        });
        
        // Gewünschte Sektion einblenden
        const targetSection = document.getElementById(sectionId);
        if (targetSection) {
            targetSection.style.display = 'block';
        } else {
            App.log(`Warnung: Sektion mit ID ${sectionId} nicht gefunden!`);
        }
    },
    
    /**
     * Lädt die Navigation basierend auf der Benutzerrolle
     * @param {string} role - Benutzerrolle
     */
    loadNavigation: function(role) {
        App.log(`Lade Navigation für Rolle: ${role}`);
        
        const navElement = document.getElementById('main-nav');
        if (!navElement) return;
        
        // Navigation basierend auf Rolle erstellen
        let navItems = '';
        
        switch (role) {
            case 'admin':
                navItems = `
                    <ul class="nav-list">
                        <li><a href="#" data-section="admin-section" class="nav-link active">Dashboard</a></li>
                        <li><a href="#" data-section="admin-users-section" class="nav-link">Benutzerverwaltung</a></li>
                        <li><a href="#" data-section="admin-tests-section" class="nav-link">Testverwaltung</a></li>
                        <li><a href="#" data-section="admin-reports-section" class="nav-link">Berichte</a></li>
                        <li><a href="#" data-section="admin-settings-section" class="nav-link">Einstellungen</a></li>
                    </ul>
                `;
                break;
                
            case 'trainer':
                navItems = `
                    <ul class="nav-list">
                        <li><a href="#" data-section="trainer-section" class="nav-link active">Dashboard</a></li>
                        <li><a href="#" data-section="trainer-tests-section" class="nav-link">Tests</a></li>
                        <li><a href="#" data-section="trainer-evaluations-section" class="nav-link">Auswertungen</a></li>
                        <li><a href="#" data-section="trainer-reports-section" class="nav-link">Berichte</a></li>
                    </ul>
                `;
                break;
                
            case 'teamleader':
                navItems = `
                    <ul class="nav-list">
                        <li><a href="#" data-section="teamleader-section" class="nav-link active">Dashboard</a></li>
                        <li><a href="#" data-section="teamleader-team-section" class="nav-link">Team</a></li>
                        <li><a href="#" data-section="teamleader-performance-section" class="nav-link">Leistungsübersicht</a></li>
                        <li><a href="#" data-section="teamleader-reports-section" class="nav-link">Berichte</a></li>
                    </ul>
                `;
                break;
                
            case 'employee':
                navItems = `
                    <ul class="nav-list">
                        <li><a href="#" data-section="employee-section" class="nav-link active">Dashboard</a></li>
                        <li><a href="#" data-section="employee-tests-section" class="nav-link">Verfügbare Tests</a></li>
                        <li><a href="#" data-section="employee-results-section" class="nav-link">Meine Ergebnisse</a></li>
                        <li><a href="#" data-section="employee-progress-section" class="nav-link">Fortschritt</a></li>
                    </ul>
                `;
                break;
                
            default:
                navItems = '<ul class="nav-list"><li>Keine Navigation verfügbar</li></ul>';
        }
        
        // Navigation in DOM einfügen
        navElement.innerHTML = navItems;
        
        // Event-Listener für Navigation hinzufügen
        this.setupNavigationListeners();
    },
    
    /**
     * Fügt Event-Listener für die Navigation hinzu
     */
    setupNavigationListeners: function() {
        const navLinks = document.querySelectorAll('.nav-link');
        
        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                
                // Aktive Klasse entfernen
                navLinks.forEach(l => l.classList.remove('active'));
                
                // Aktive Klasse zum geklickten Link hinzufügen
                this.classList.add('active');
                
                // Entsprechende Sektion anzeigen
                const sectionId = this.getAttribute('data-section');
                UI.showSection(sectionId);
            });
        });
    },
    
    /**
     * Zeigt eine Ladeanimation
     * @param {string} message - Optionale Nachricht
     */
    showLoading: function(message = 'Wird geladen...') {
        const loadingIndicator = document.getElementById('loading-indicator');
        const messageElement = loadingIndicator.querySelector('p');
        
        messageElement.textContent = message;
        loadingIndicator.style.display = 'flex';
    },
    
    /**
     * Versteckt die Ladeanimation
     */
    hideLoading: function() {
        document.getElementById('loading-indicator').style.display = 'none';
    },
    
    /**
     * Zeigt einen Modal-Dialog
     * @param {string} title - Titel des Dialogs
     * @param {string|HTMLElement} content - Inhalt (Text oder HTML-Element)
     * @param {Array} buttons - Array von Button-Definitionen { text, handler, isPrimary }
     */
    showModal: function(title, content, buttons = []) {
        const modal = document.getElementById('modal-container');
        const headerElement = document.getElementById('modal-header');
        const bodyElement = document.getElementById('modal-body');
        const footerElement = document.getElementById('modal-footer');
        
        // Titel setzen
        headerElement.innerHTML = `<h2>${title}</h2>`;
        
        // Inhalt setzen
        if (typeof content === 'string') {
            bodyElement.innerHTML = content;
        } else {
            bodyElement.innerHTML = '';
            bodyElement.appendChild(content);
        }
        
        // Buttons erstellen
        footerElement.innerHTML = '';
        
        buttons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.text;
            btn.className = button.isPrimary ? 'btn-primary' : 'btn-secondary';
            btn.addEventListener('click', button.handler || this.closeModal);
            footerElement.appendChild(btn);
        });
        
        // Wenn keine Buttons definiert wurden, Standard-Close-Button anzeigen
        if (buttons.length === 0) {
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Schließen';
            closeBtn.className = 'btn-primary';
            closeBtn.addEventListener('click', this.closeModal);
            footerElement.appendChild(closeBtn);
        }
        
        // Modal anzeigen
        modal.style.display = 'flex';
    },
    
    /**
     * Schließt den Modal-Dialog
     */
    closeModal: function() {
        document.getElementById('modal-container').style.display = 'none';
    },
    
    /**
     * Zeigt eine kurze Benachrichtigung
     * @param {string} message - Nachricht
     * @param {string} type - Typ der Benachrichtigung (success, warning, error, info)
     * @param {number} duration - Anzeigedauer in ms
     */
    showNotification: function(message, type = 'info', duration = 3000) {
        // Erstelle Benachrichtigungselement, falls es noch nicht existiert
        let notification = document.getElementById('notification');
        
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'notification';
            notification.className = 'notification';
            document.body.appendChild(notification);
            
            // Stil für die Benachrichtigung
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '4px';
            notification.style.color = '#fff';
            notification.style.zIndex = '10000';
            notification.style.boxShadow = '0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)';
            notification.style.transition = 'opacity 0.3s ease';
        }
        
        // Typ der Benachrichtigung
        const colors = {
            'success': '#28A745',
            'warning': '#FFC107',
            'error': '#DC3545',
            'info': '#17A2B8'
        };
        
        notification.style.backgroundColor = colors[type] || colors.info;
        notification.textContent = message;
        notification.style.opacity = '1';
        
        // Timer für das Ausblenden
        clearTimeout(this.notificationTimer);
        this.notificationTimer = setTimeout(() => {
            notification.style.opacity = '0';
        }, duration);
    },
    
    /**
     * Erstellt eine Tabelle aus einem Array von Objekten
     * @param {Array} data - Array von Objekten
     * @param {Array} columns - Spalten-Definitionen [{ key, label, render }]
     * @param {Object} options - Optionale Konfiguration
     * @returns {HTMLElement} Tabellen-Element
     */
    createTable: function(data, columns, options = {}) {
        const table = document.createElement('table');
        table.className = options.tableClass || 'data-table';
        
        // Kopfzeile erstellen
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        columns.forEach(column => {
            const th = document.createElement('th');
            th.textContent = column.label;
            if (column.width) th.style.width = column.width;
            headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Tabellenkörper erstellen
        const tbody = document.createElement('tbody');
        
        if (data.length === 0) {
            // Keine Daten
            const emptyRow = document.createElement('tr');
            const emptyCell = document.createElement('td');
            emptyCell.colSpan = columns.length;
            emptyCell.textContent = options.emptyMessage || 'Keine Daten vorhanden';
            emptyCell.className = 'empty-table-message';
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
        } else {
            // Datenzeilen erstellen
            data.forEach(item => {
                const row = document.createElement('tr');
                
                // Zeilen-ID, falls eine ID vorhanden ist
                if (item.id) row.setAttribute('data-id', item.id);
                
                columns.forEach(column => {
                    const cell = document.createElement('td');
                    
                    if (column.render) {
                        // Benutzerdefinierte Rendering-Funktion
                        const renderedContent = column.render(item[column.key], item);
                        
                        if (typeof renderedContent === 'string') {
                            cell.innerHTML = renderedContent;
                        } else if (renderedContent instanceof HTMLElement) {
                            cell.appendChild(renderedContent);
                        }
                    } else {
                        // Standard-Rendering
                        cell.textContent = item[column.key] !== undefined ? item[column.key] : '';
                    }
                    
                    row.appendChild(cell);
                });
                
                // Zeilen-Klick-Event
                if (options.onRowClick) {
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', () => options.onRowClick(item));
                }
                
                tbody.appendChild(row);
            });
        }
        
        table.appendChild(tbody);
        
        return table;
    },
    
    /**
     * Erstellt ein Formular basierend auf einem Schema
     * @param {Array} fields - Feld-Definitionen
     * @param {Object} values - Anfangswerte
     * @param {Function} onSubmit - Submit-Handler
     * @param {Object} options - Optionale Konfiguration
     * @returns {HTMLElement} Formular-Element
     */
    createForm: function(fields, values = {}, onSubmit, options = {}) {
        const form = document.createElement('form');
        form.className = options.formClass || 'app-form';
        
        if (options.id) form.id = options.id;
        
        // Felder erstellen
        fields.forEach(field => {
            const formGroup = document.createElement('div');
            formGroup.className = 'form-group';
            
            // Label
            if (field.label) {
                const label = document.createElement('label');
                label.setAttribute('for', field.id);
                label.textContent = field.label;
                
                if (field.required) {
                    const requiredMark = document.createElement('span');
                    requiredMark.className = 'required-mark';
                    requiredMark.textContent = ' *';
                    label.appendChild(requiredMark);
                }
                
                formGroup.appendChild(label);
            }
            
            // Hilfstext vor dem Feld
            if (field.helpTextBefore) {
                const helpTextBefore = document.createElement('p');
                helpTextBefore.className = 'help-text';
                helpTextBefore.textContent = field.helpTextBefore;
                formGroup.appendChild(helpTextBefore);
            }
            
            // Feld erstellen
            let inputElement;
            
            switch (field.type) {
                case 'text':
                case 'email':
                case 'password':
                case 'number':
                case 'date':
                case 'time':
                case 'tel':
                case 'url':
                    inputElement = document.createElement('input');
                    inputElement.type = field.type;
                    inputElement.id = field.id;
                    inputElement.name = field.name || field.id;
                    
                    if (field.placeholder) inputElement.placeholder = field.placeholder;
                    if (field.required) inputElement.required = true;
                    if (field.min !== undefined) inputElement.min = field.min;
                    if (field.max !== undefined) inputElement.max = field.max;
                    if (field.step !== undefined) inputElement.step = field.step;
                    if (field.pattern) inputElement.pattern = field.pattern;
                    if (field.autocomplete) inputElement.autocomplete = field.autocomplete;
                    
                    inputElement.value = values[field.name || field.id] || field.defaultValue || '';
                    break;
                
                case 'textarea':
                    inputElement = document.createElement('textarea');
                    inputElement.id = field.id;
                    inputElement.name = field.name || field.id;
                    
                    if (field.placeholder) inputElement.placeholder = field.placeholder;
                    if (field.required) inputElement.required = true;
                    if (field.rows) inputElement.rows = field.rows;
                    if (field.cols) inputElement.cols = field.cols;
                    
                    inputElement.value = values[field.name || field.id] || field.defaultValue || '';
                    break;
                
                case 'select':
                    inputElement = document.createElement('select');
                    inputElement.id = field.id;
                    inputElement.name = field.name || field.id;
                    
                    if (field.required) inputElement.required = true;
                    if (field.multiple) inputElement.multiple = true;
                    
                    // Optionen erstellen
                    if (field.options) {
                        field.options.forEach(option => {
                            const optionElement = document.createElement('option');
                            optionElement.value = option.value;
                            optionElement.textContent = option.label;
                            
                            // Option vorauswählen, wenn der Wert übereinstimmt
                            const fieldValue = values[field.name || field.id];
                            if (fieldValue) {
                                if (Array.isArray(fieldValue)) {
                                    if (fieldValue.includes(option.value)) {
                                        optionElement.selected = true;
                                    }
                                } else if (fieldValue === option.value) {
                                    optionElement.selected = true;
                                }
                            } else if (option.value === field.defaultValue) {
                                optionElement.selected = true;
                            }
                            
                            inputElement.appendChild(optionElement);
                        });
                    }
                    break;
                
                case 'checkbox':
                    const checkboxWrapper = document.createElement('div');
                    checkboxWrapper.className = 'checkbox-wrapper';
                    
                    inputElement = document.createElement('input');
                    inputElement.type = 'checkbox';
                    inputElement.id = field.id;
                    inputElement.name = field.name || field.id;
                    
                    if (field.required) inputElement.required = true;
                    
                    // Status setzen
                    const checkboxValue = values[field.name || field.id];
                    inputElement.checked = checkboxValue !== undefined ? !!checkboxValue : !!field.defaultValue;
                    
                    // Label für Checkbox
                    if (field.checkboxLabel) {
                        const checkboxLabel = document.createElement('label');
                        checkboxLabel.setAttribute('for', field.id);
                        checkboxLabel.textContent = field.checkboxLabel;
                        checkboxWrapper.appendChild(inputElement);
                        checkboxWrapper.appendChild(checkboxLabel);
                        formGroup.appendChild(checkboxWrapper);
                    } else {
                        formGroup.appendChild(inputElement);
                    }
                    break;
                
                case 'radio':
                    const radioWrapper = document.createElement('div');
                    radioWrapper.className = 'radio-wrapper';
                    
                    // Radio-Buttons erstellen
                    if (field.options) {
                        field.options.forEach((option, index) => {
                            const radioItem = document.createElement('div');
                            radioItem.className = 'radio-item';
                            
                            const radioInput = document.createElement('input');
                            radioInput.type = 'radio';
                            radioInput.id = `${field.id}_${index}`;
                            radioInput.name = field.name || field.id;
                            radioInput.value = option.value;
                            
                            if (field.required) radioInput.required = true;
                            
                            // Status setzen
                            const radioValue = values[field.name || field.id];
                            if (radioValue !== undefined) {
                                radioInput.checked = radioValue === option.value;
                            } else {
                                radioInput.checked = option.value === field.defaultValue;
                            }
                            
                            // Label für Radio-Button
                            const radioLabel = document.createElement('label');
                            radioLabel.setAttribute('for', `${field.id}_${index}`);
                            radioLabel.textContent = option.label;
                            
                            radioItem.appendChild(radioInput);
                            radioItem.appendChild(radioLabel);
                            radioWrapper.appendChild(radioItem);
                        });
                    }
                    
                    formGroup.appendChild(radioWrapper);
                    break;
                
                case 'file':
                    inputElement = document.createElement('input');
                    inputElement.type = 'file';
                    inputElement.id = field.id;
                    inputElement.name = field.name || field.id;
                    
                    if (field.required) inputElement.required = true;
                    if (field.accept) inputElement.accept = field.accept;
                    if (field.multiple) inputElement.multiple = true;
                    break;
                
                default:
                    console.warn(`Unbekannter Feldtyp: ${field.type}`);
                    return;
            }
            
            // Event-Handler
            if (field.onChange && inputElement) {
                inputElement.addEventListener('change', (e) => field.onChange(e, form));
            }
            
            // Feld zum Formular hinzufügen, falls nicht bereits geschehen
            if (inputElement && field.type !== 'checkbox' && field.type !== 'radio') {
                formGroup.appendChild(inputElement);
            }
            
            // Hilfstext nach dem Feld
            if (field.helpText) {
                const helpText = document.createElement('p');
                helpText.className = 'help-text';
                helpText.textContent = field.helpText;
                formGroup.appendChild(helpText);
            }
            
            // Fehlermeldungsfeld
            if (field.showError) {
                const errorMessage = document.createElement('div');
                errorMessage.className = 'error-message';
                errorMessage.id = `${field.id}_error`;
                errorMessage.style.display = 'none';
                formGroup.appendChild(errorMessage);
            }
            
            form.appendChild(formGroup);
        });
        
        // Submit-Button-Gruppe
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'form-group button-group';
        
        // Submit-Button
        const submitButton = document.createElement('button');
        submitButton.type = 'submit';
        submitButton.className = 'btn-primary';
        submitButton.textContent = options.submitText || 'Speichern';
        buttonGroup.appendChild(submitButton);
        
        // Abbrechen-Button
        if (options.showCancelButton) {
            const cancelButton = document.createElement('button');
            cancelButton.type = 'button';
            cancelButton.className = 'btn-secondary';
            cancelButton.textContent = options.cancelText || 'Abbrechen';
            cancelButton.addEventListener('click', options.onCancel || function() {});
            buttonGroup.appendChild(cancelButton);
        }
        
        form.appendChild(buttonGroup);
        
        // Submit-Event
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Daten aus dem Formular sammeln
            const formData = new FormData(form);
            const data = {};
            
            formData.forEach((value, key) => {
                // Checkboxen als Boolean behandeln
                const field = fields.find(f => (f.name || f.id) === key);
                
                if (field && field.type === 'checkbox') {
                    data[key] = value === 'on';
                } else {
                    // Falls der Schlüssel bereits existiert, Array erstellen/erweitern
                    if (data[key] !== undefined) {
                        if (!Array.isArray(data[key])) {
                            data[key] = [data[key]];
                        }
                        data[key].push(value);
                    } else {
                        data[key] = value;
                    }
                }
            });
            
            // Callback mit gesammelten Daten aufrufen
            if (onSubmit) {
                onSubmit(data, form);
            }
        });
        
        return form;
    },
    
    /**
     * Zeigt eine Fehlermeldung in einem Formular
     * @param {string} formId - ID des Formulars
     * @param {string} fieldId - ID des Feldes
     * @param {string} message - Fehlermeldung
     */
    showFormError: function(formId, fieldId, message) {
        const errorElement = document.getElementById(`${fieldId}_error`);
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
    },
    
    /**
     * Entfernt alle Fehlermeldungen aus einem Formular
     * @param {string} formId - ID des Formulars
     */
    clearFormErrors: function(formId) {
        const form = document.getElementById(formId);
        if (form) {
            const errorElements = form.querySelectorAll('.error-message');
            errorElements.forEach(el => {
                el.textContent = '';
                el.style.display = 'none';
            });
        }
    },
    
    /**
     * Erstellt ein Fortschrittsbalken-Element
     * @param {number} value - Aktueller Wert (0-100)
     * @param {Object} options - Optionale Konfiguration
     * @returns {HTMLElement} Fortschrittsbalken-Element
     */
    createProgressBar: function(value, options = {}) {
        const container = document.createElement('div');
        container.className = 'progress-container';
        
        const progressBar = document.createElement('div');
        progressBar.className = 'progress-bar';
        
        // Fortschritt setzen
        const progress = Math.min(Math.max(value, 0), 100);
        const progressValue = document.createElement('div');
        progressValue.className = 'progress-value';
        progressValue.style.width = `${progress}%`;
        
        // Farbe basierend auf Fortschritt
        if (options.colorByValue) {
            if (progress < 33) {
                progressValue.style.backgroundColor = options.lowColor || '#DC3545';
            } else if (progress < 66) {
                progressValue.style.backgroundColor = options.mediumColor || '#FFC107';
            } else {
                progressValue.style.backgroundColor = options.highColor || '#28A745';
            }
        } else if (options.color) {
            progressValue.style.backgroundColor = options.color;
        }
        
        progressBar.appendChild(progressValue);
        container.appendChild(progressBar);
        
        // Label hinzufügen
        if (options.showLabel) {
            const label = document.createElement('div');
            label.className = 'progress-label';
            
            if (options.labelPosition === 'inside') {
                progressValue.appendChild(label);
            } else {
                container.appendChild(label);
            }
            
            label.textContent = options.labelText || `${progress}%`;
        }
        
        return container;
    },
    
    /**
     * Erstellt eine Suchfeld-Komponente
     * @param {Function} onSearch - Such-Handler
     * @param {Object} options - Optionale Konfiguration
     * @returns {HTMLElement} Suchfeld-Element
     */
    createSearchField: function(onSearch, options = {}) {
        const container = document.createElement('div');
        container.className = 'search-container';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.className = 'search-input';
        searchInput.placeholder = options.placeholder || 'Suchen...';
        
        const searchButton = document.createElement('button');
        searchButton.className = 'search-button';
        searchButton.innerHTML = '<i class="fas fa-search"></i>';
        
        container.appendChild(searchInput);
        container.appendChild(searchButton);
        
        // Debounce-Funktion für Live-Suche
        let timeout;
        const debounceSearch = function() {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                onSearch(searchInput.value);
            }, options.debounce || 300);
        };
        
        // Event-Handler
        if (options.liveSearch) {
            searchInput.addEventListener('input', debounceSearch);
        }
        
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                onSearch(searchInput.value);
            }
        });
        
        searchButton.addEventListener('click', function() {
            onSearch(searchInput.value);
        });
        
        return container;
    },
    
    /**
     * Erstellt ein Tab-System
     * @param {Array} tabs - Tab-Definitionen [{ id, label, content }]
     * @param {Object} options - Optionale Konfiguration
     * @returns {HTMLElement} Tab-System-Element
     */
    createTabs: function(tabs, options = {}) {
        const container = document.createElement('div');
        container.className = 'tabs-container';
        
        // Tab-Leiste erstellen
        const tabsHeader = document.createElement('div');
        tabsHeader.className = 'tabs-header';
        
        // Tab-Inhalte-Container erstellen
        const tabsContent = document.createElement('div');
        tabsContent.className = 'tabs-content';
        
        // Tabs erstellen
        tabs.forEach((tab, index) => {
            // Tab-Button
            const tabButton = document.createElement('button');
            tabButton.className = 'tab-button';
            tabButton.textContent = tab.label;
            tabButton.setAttribute('data-tab', tab.id);
            
            // Ersten Tab als aktiv markieren
            if (index === 0) {
                tabButton.classList.add('active');
            }
            
            // Tab-Inhalt
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-content';
            tabContent.id = `tab-${tab.id}`;
            
            // Inhalt kann String oder HTML-Element sein
            if (typeof tab.content === 'string') {
                tabContent.innerHTML = tab.content;
            } else {
                tabContent.appendChild(tab.content);
            }
            
            // Ersten Tab anzeigen, alle anderen verstecken
            tabContent.style.display = index === 0 ? 'block' : 'none';
            
            // Zum DOM hinzufügen
            tabsHeader.appendChild(tabButton);
            tabsContent.appendChild(tabContent);
            
            // Event-Handler für Tab-Button
            tabButton.addEventListener('click', function() {
                // Alle Tabs deaktivieren
                const buttons = tabsHeader.querySelectorAll('.tab-button');
                buttons.forEach(btn => btn.classList.remove('active'));
                
                // Alle Inhalte verstecken
                const contents = tabsContent.querySelectorAll('.tab-content');
                contents.forEach(content => content.style.display = 'none');
                
                // Angeklickten Tab aktivieren
                this.classList.add('active');
                
                // Entsprechenden Inhalt anzeigen
                const contentId = `tab-${this.getAttribute('data-tab')}`;
                document.getElementById(contentId).style.display = 'block';
                
                // Callback aufrufen, falls vorhanden
                if (options.onTabChange) {
                    options.onTabChange(tab.id);
                }
            });
        });
        
        container.appendChild(tabsHeader);
        container.appendChild(tabsContent);
        
        return container;
    }
};
/**
 * ImmoScout24 E-Learning Portal
 * dataModel.js - Datenmodell für Tests und Fragen
 */

const DataModel = {
    // Initialisierung
    init: function() {
        App.log('Initialisiere Datenmodell...');
        App.log('Datenmodell initialisiert');
    },
    
    /**
     * Test-Verwaltung
     */
    tests: {
        /**
         * Lädt alle Tests
         * @param {string} [filter] - Optionaler Filter (z.B. team)
         * @returns {Array} Array von Tests
         */
        getAll: function(filter = null) {
            const tests = Storage.get('tests') || [];
            
            if (filter) {
                // Filtern nach bestimmten Kriterien
                return tests.filter(test => {
                    if (filter.team && test.team !== filter.team) {
                        return false;
                    }
                    
                    if (filter.status && test.status !== filter.status) {
                        return false;
                    }
                    
                    if (filter.createdBy && test.createdBy !== filter.createdBy) {
                        return false;
                    }
                    
                    return true;
                });
            }
            
            return tests;
        },
        
        /**
         * Lädt einen Test anhand seiner ID
         * @param {string} id - ID des Tests
         * @returns {Object|null} Test-Objekt oder null, wenn nicht gefunden
         */
        getById: function(id) {
            const tests = Storage.get('tests') || [];
            return tests.find(test => test.id === id) || null;
        },
        
        /**
         * Erstellt einen neuen Test
         * @param {Object} testData - Test-Daten
         * @returns {Object} Erstellter Test
         */
        create: function(testData) {
            const tests = Storage.get('tests') || [];
            
            // Test-Objekt erstellen
            const newTest = {
                id: Helpers.generateId(),
                title: testData.title,
                description: testData.description,
                team: testData.team,
                questions: testData.questions || [],
                passingScore: testData.passingScore || 60,
                timeLimit: testData.timeLimit || null,
                randomizeQuestions: testData.randomizeQuestions || false,
                status: testData.status || 'draft',
                createdBy: App.session.user.id,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // Zum Array hinzufügen
            tests.push(newTest);
            
            // Speichern
            Storage.set('tests', tests);
            
            return newTest;
        },
        
        /**
         * Aktualisiert einen Test
         * @param {string} id - ID des Tests
         * @param {Object} testData - Neue Test-Daten
         * @returns {Object|null} Aktualisierter Test oder null bei Fehler
         */
        update: function(id, testData) {
            const tests = Storage.get('tests') || [];
            const index = tests.findIndex(test => test.id === id);
            
            if (index === -1) {
                App.log(`Test mit ID ${id} nicht gefunden`);
                return null;
            }
            
            // Test aktualisieren
            const updatedTest = {
                ...tests[index],
                ...testData,
                updatedAt: new Date().toISOString()
            };
            
            // ID nicht überschreiben
            updatedTest.id = id;
            
            // Im Array aktualisieren
            tests[index] = updatedTest;
            
            // Speichern
            Storage.set('tests', tests);
            
            return updatedTest;
        },
        
        /**
         * Löscht einen Test
         * @param {string} id - ID des Tests
         * @returns {boolean} Erfolg/Misserfolg
         */
        delete: function(id) {
            const tests = Storage.get('tests') || [];
            const index = tests.findIndex(test => test.id === id);
            
            if (index === -1) {
                App.log(`Test mit ID ${id} nicht gefunden`);
                return false;
            }
            
            // Aus Array entfernen
            tests.splice(index, 1);
            
            // Speichern
            Storage.set('tests', tests);
            
            return true;
        },
        
        /**
         * Fügt eine Frage zu einem Test hinzu
         * @param {string} testId - ID des Tests
         * @param {Object} questionData - Frage-Daten
         * @returns {Object|null} Aktualisierter Test oder null bei Fehler
         */
        addQuestion: function(testId, questionData) {
            const test = this.getById(testId);
            
            if (!test) {
                App.log(`Test mit ID ${testId} nicht gefunden`);
                return null;
            }
            
            // Frage erstellen
            const newQuestion = {
                id: Helpers.generateId(),
                type: questionData.type,
                text: questionData.text,
                options: questionData.options || [],
                correctAnswer: questionData.correctAnswer,
                points: questionData.points || 1,
                createdAt: new Date().toISOString()
            };
            
            // Zum Test hinzufügen
            test.questions.push(newQuestion);
            test.updatedAt = new Date().toISOString();
            
            // Test aktualisieren
            return this.update(testId, test);
        },
        
        /**
         * Aktualisiert eine Frage in einem Test
         * @param {string} testId - ID des Tests
         * @param {string} questionId - ID der Frage
         * @param {Object} questionData - Neue Frage-Daten
         * @returns {Object|null} Aktualisierter Test oder null bei Fehler
         */
        updateQuestion: function(testId, questionId, questionData) {
            const test = this.getById(testId);
            
            if (!test) {
                App.log(`Test mit ID ${testId} nicht gefunden`);
                return null;
            }
            
            const questionIndex = test.questions.findIndex(q => q.id === questionId);
            
            if (questionIndex === -1) {
                App.log(`Frage mit ID ${questionId} nicht gefunden`);
                return null;
            }
            
            // Frage aktualisieren
            const updatedQuestion = {
                ...test.questions[questionIndex],
                ...questionData
            };
            
            // ID nicht überschreiben
            updatedQuestion.id = questionId;
            
            // Im Test aktualisieren
            test.questions[questionIndex] = updatedQuestion;
            test.updatedAt = new Date().toISOString();
            
            // Test aktualisieren
            return this.update(testId, test);
        },
        
        /**
         * Entfernt eine Frage aus einem Test
         * @param {string} testId - ID des Tests
         * @param {string} questionId - ID der Frage
         * @returns {Object|null} Aktualisierter Test oder null bei Fehler
         */
        removeQuestion: function(testId, questionId) {
            const test = this.getById(testId);
            
            if (!test) {
                App.log(`Test mit ID ${testId} nicht gefunden`);
                return null;
            }
            
            const questionIndex = test.questions.findIndex(q => q.id === questionId);
            
            if (questionIndex === -1) {
                App.log(`Frage mit ID ${questionId} nicht gefunden`);
                return null;
            }
            
            // Aus Array entfernen
            test.questions.splice(questionIndex, 1);
            test.updatedAt = new Date().toISOString();
            
            // Test aktualisieren
            return this.update(testId, test);
        },
        
        /**
         * Verändert die Reihenfolge der Fragen
         * @param {string} testId - ID des Tests
         * @param {Array} newOrder - Array von Frage-IDs in der neuen Reihenfolge
         * @returns {Object|null} Aktualisierter Test oder null bei Fehler
         */
        reorderQuestions: function(testId, newOrder) {
            const test = this.getById(testId);
            
            if (!test) {
                App.log(`Test mit ID ${testId} nicht gefunden`);
                return null;
            }
            
            // Prüfen, ob alle IDs vorhanden sind
            const allQuestionsIncluded = newOrder.every(id => 
                test.questions.some(q => q.id === id)
            );
            
            if (!allQuestionsIncluded || newOrder.length !== test.questions.length) {
                App.log('Ungültige Fragen-Reihenfolge');
                return null;
            }
            
            // Fragen neu anordnen
            const reorderedQuestions = newOrder.map(id => 
                test.questions.find(q => q.id === id)
            );
            
            test.questions = reorderedQuestions;
            test.updatedAt = new Date().toISOString();
            
            // Test aktualisieren
            return this.update(testId, test);
        },
        
        /**
         * Gibt einen Test für die Durchführung zurück
         * @param {string} id - ID des Tests
         * @returns {Object|null} Test für die Durchführung oder null bei Fehler
         */
        getForExecution: function(id) {
            const test = this.getById(id);
            
            if (!test) {
                App.log(`Test mit ID ${id} nicht gefunden`);
                return null;
            }
            
            // Kopie des Tests erstellen
            const executionTest = Helpers.deepCopy(test);
            
            // Wenn Test zufällige Fragenreihenfolge haben soll, mischen
            if (executionTest.randomizeQuestions) {
                executionTest.questions = Helpers.shuffleArray(executionTest.questions);
            }
            
            // Korrekte Antworten für die Auswertung beibehalten,
            // aber getrennt speichern, damit sie nicht direkt sichtbar sind
            executionTest.questionAnswers = executionTest.questions.map(q => ({
                id: q.id,
                correctAnswer: q.correctAnswer,
                points: q.points
            }));
            
            // Korrekte Antworten aus den Fragen entfernen
            executionTest.questions = executionTest.questions.map(q => {
                const { correctAnswer, ...questionWithoutAnswer } = q;
                return questionWithoutAnswer;
            });
            
            return executionTest;
        },
        
        /**
         * Wertet einen Test aus
         * @param {string} testId - ID des Tests
         * @param {Object} answers - Gegebene Antworten { questionId: answer }
         * @returns {Object} Auswertungsergebnis
         */
        evaluate: function(testId, answers) {
            const test = this.getById(testId);
            
            if (!test) {
                App.log(`Test mit ID ${testId} nicht gefunden`);
                return null;
            }
            
            let totalPoints = 0;
            let earnedPoints = 0;
            let correctAnswers = 0;
            let evaluationComplete = true;
            
            // Ergebnisse pro Frage
            const questionResults = test.questions.map(question => {
                const userAnswer = answers[question.id];
                totalPoints += question.points;
                
                // Für Freitext-Fragen ist manuelle Bewertung erforderlich
                if (question.type === 'text') {
                    evaluationComplete = false;
                    
                    return {
                        questionId: question.id,
                        type: question.type,
                        text: question.text,
                        userAnswer: userAnswer || '',
                        correctAnswer: question.correctAnswer,
                        points: question.points,
                        earnedPoints: null, // Muss manuell bewertet werden
                        correct: null, // Unbekannt bis zur Bewertung
                        evaluated: false
                    };
                }
                
                // Für alle anderen Fragetypen automatische Bewertung
                let isCorrect = false;
                
                switch (question.type) {
                    case 'multiple':
                        // Bei Multiple-Choice müssen alle korrekten Optionen ausgewählt sein
                        const selectedOptions = userAnswer || [];
                        const correctOptions = question.correctAnswer || [];
                        
                        isCorrect = 
                            // Alle korrekten Optionen müssen ausgewählt sein
                            correctOptions.every(opt => selectedOptions.includes(opt)) &&
                            // Keine falschen Optionen dürfen ausgewählt sein
                            selectedOptions.every(opt => correctOptions.includes(opt));
                        break;
                        
                    case 'single':
                        // Bei Single-Choice muss die korrekte Option ausgewählt sein
                        isCorrect = userAnswer === question.correctAnswer;
                        break;
                        
                    case 'boolean':
                        // Bei Wahr/Falsch muss die korrekte Option ausgewählt sein
                        isCorrect = userAnswer === question.correctAnswer;
                        break;
                        
                    default:
                        App.log(`Unbekannter Fragetyp: ${question.type}`);
                        isCorrect = false;
                }
                
                // Punkte bei richtiger Antwort
                const earnedQuestionPoints = isCorrect ? question.points : 0;
                earnedPoints += earnedQuestionPoints;
                
                if (isCorrect) {
                    correctAnswers++;
                }
                
                return {
                    questionId: question.id,
                    type: question.type,
                    text: question.text,
                    userAnswer: userAnswer || '',
                    correctAnswer: question.correctAnswer,
                    points: question.points,
                    earnedPoints: earnedQuestionPoints,
                    correct: isCorrect,
                    evaluated: true
                };
            });
            
            // Gesamtergebnis berechnen
            const percentage = totalPoints > 0 ? (earnedPoints / totalPoints) * 100 : 0;
            const passed = percentage >= test.passingScore;
            
            // Ergebnisobjekt
            const result = {
                testId: test.id,
                testTitle: test.title,
                userId: App.session.user.id,
                userName: App.session.user.name,
                team: App.session.user.team,
                submittedAt: new Date().toISOString(),
                totalQuestions: test.questions.length,
                correctAnswers: correctAnswers,
                totalPoints: totalPoints,
                earnedPoints: earnedPoints,
                percentage: Math.round(percentage * 10) / 10, // Auf eine Dezimalstelle gerundet
                passed: passed,
                evaluationComplete: evaluationComplete,
                questionResults: questionResults,
                feedbackByTrainer: ''
            };
            
            return result;
        },
        
        /**
         * Speichert ein Testergebnis
         * @param {Object} result - Testergebnis
         * @returns {string} ID des gespeicherten Ergebnisses
         */
        saveResult: function(result) {
            const testResults = Storage.get('testResults') || [];
            
            // ID hinzufügen, falls noch nicht vorhanden
            if (!result.id) {
                result.id = Helpers.generateId();
            }
            
            // Zum Array hinzufügen
            testResults.push(result);
            
            // Speichern
            Storage.set('testResults', testResults);
            
            return result.id;
        },
        
        /**
         * Aktualisiert die manuelle Bewertung für Freitext-Fragen
         * @param {string} resultId - ID des Testergebnisses
         * @param {Array} evaluations - Array von Bewertungen { questionId, earnedPoints, feedback }
         * @returns {Object|null} Aktualisiertes Ergebnis oder null bei Fehler
         */
        updateEvaluation: function(resultId, evaluations) {
            const testResults = Storage.get('testResults') || [];
            const resultIndex = testResults.findIndex(r => r.id === resultId);
            
            if (resultIndex === -1) {
                App.log(`Testergebnis mit ID ${resultId} nicht gefunden`);
                return null;
            }
            
            const result = testResults[resultIndex];
            
            // Bewertungen aktualisieren
            let totalEarnedPoints = 0;
            let totalCorrectAnswers = 0;
            
            result.questionResults.forEach(qResult => {
                // Für bereits ausgewertete Fragen Punkte hinzufügen
                if (qResult.evaluated) {
                    totalEarnedPoints += qResult.earnedPoints;
                    if (qResult.correct) {
                        totalCorrectAnswers++;
                    }
                } else {
                    // Für Freitext-Fragen die Bewertung suchen
                    const evaluation = evaluations.find(e => e.questionId === qResult.questionId);
                    
                    if (evaluation) {
                        // Bewertung aktualisieren
                        qResult.earnedPoints = evaluation.earnedPoints;
                        qResult.feedback = evaluation.feedback;
                        qResult.evaluated = true;
                        qResult.correct = evaluation.earnedPoints === qResult.points;
                        
                        // Zum Gesamtergebnis hinzufügen
                        totalEarnedPoints += evaluation.earnedPoints;
                        if (qResult.correct) {
                            totalCorrectAnswers++;
                        }
                    }
                }
            });
            
            // Prüfen, ob alle Fragen bewertet wurden
            result.evaluationComplete = result.questionResults.every(qr => qr.evaluated);
            
            // Gesamtergebnis aktualisieren
            result.earnedPoints = totalEarnedPoints;
            result.correctAnswers = totalCorrectAnswers;
            result.percentage = Math.round((totalEarnedPoints / result.totalPoints) * 1000) / 10;
            result.passed = result.percentage >= test.passingScore;
            result.evaluatedAt = new Date().toISOString();
            result.evaluatedBy = App.session.user.id;
            
            // Trainer-Feedback aktualisieren, falls vorhanden
            if (evaluations[0] && evaluations[0].trainerFeedback) {
                result.feedbackByTrainer = evaluations[0].trainerFeedback;
            }
            
            // Im Array aktualisieren
            testResults[resultIndex] = result;
            
            // Speichern
            Storage.set('testResults', testResults);
            
            return result;
        },
        
        /**
         * Lädt alle Testergebnisse
         * @param {Object} filter - Optionale Filter
         * @returns {Array} Array von Testergebnissen
         */
        getResults: function(filter = {}) {
            const testResults = Storage.get('testResults') || [];
            
            // Filtern, falls Filter vorhanden
            return testResults.filter(result => {
                if (filter.userId && result.userId !== filter.userId) {
                    return false;
                }
                
                if (filter.testId && result.testId !== filter.testId) {
                    return false;
                }
                
                if (filter.team && result.team !== filter.team) {
                    return false;
                }
                
                if (filter.evaluationComplete !== undefined && 
                    result.evaluationComplete !== filter.evaluationComplete) {
                    return false;
                }
                
                if (filter.passed !== undefined && result.passed !== filter.passed) {
                    return false;
                }
                
                return true;
            });
        },
        
        /**
         * Lädt ein bestimmtes Testergebnis
         * @param {string} resultId - ID des Testergebnisses
         * @returns {Object|null} Testergebnis oder null, wenn nicht gefunden
         */
        getResultById: function(resultId) {
            const testResults = Storage.get('testResults') || [];
            return testResults.find(r => r.id === resultId) || null;
        }
    },
    
    /**
     * Fragenpool-Verwaltung
     */
    questionBank: {
        /**
         * Lädt alle Fragen aus dem Fragenpool
         * @param {Object} filter - Optionale Filter
         * @returns {Array} Array von Fragen
         */
        getAll: function(filter = {}) {
            const questions = Storage.get('questionBank') || [];
            
            // Filtern, falls Filter vorhanden
            return questions.filter(question => {
                if (filter.type && question.type !== filter.type) {
                    return false;
                }
                
                if (filter.category && question.category !== filter.category) {
                    return false;
                }
                
                if (filter.createdBy && question.createdBy !== filter.createdBy) {
                    return false;
                }
                
                if (filter.search && !question.text.toLowerCase().includes(filter.search.toLowerCase())) {
                    return false;
                }
                
                return true;
            });
        },
        
        /**
         * Fügt eine Frage zum Fragenpool hinzu
         * @param {Object} questionData - Frage-Daten
         * @returns {Object} Hinzugefügte Frage
         */
        add: function(questionData) {
            const questions = Storage.get('questionBank') || [];
            
            // Frage erstellen
            const newQuestion = {
                id: Helpers.generateId(),
                type: questionData.type,
                text: questionData.text,
                category: questionData.category || 'Allgemein',
                options: questionData.options || [],
                correctAnswer: questionData.correctAnswer,
                points: questionData.points || 1,
                createdBy: App.session.user.id,
                createdAt: new Date().toISOString()
            };
            
            // Zum Array hinzufügen
            questions.push(newQuestion);
            
            // Speichern
            Storage.set('questionBank', questions);
            
            return newQuestion;
        },
        
        /**
         * Aktualisiert eine Frage im Fragenpool
         * @param {string} id - ID der Frage
         * @param {Object} questionData - Neue Frage-Daten
         * @returns {Object|null} Aktualisierte Frage oder null bei Fehler
         */
        update: function(id, questionData) {
            const questions = Storage.get('questionBank') || [];
            const index = questions.findIndex(q => q.id === id);
            
            if (index === -1) {
                App.log(`Frage mit ID ${id} nicht gefunden`);
                return null;
            }
            
            // Frage aktualisieren
            const updatedQuestion = {
                ...questions[index],
                ...questionData,
                updatedAt: new Date().toISOString()
            };
            
            // ID nicht überschreiben
            updatedQuestion.id = id;
            
            // Im Array aktualisieren
            questions[index] = updatedQuestion;
            
            // Speichern
            Storage.set('questionBank', questions);
            
            return updatedQuestion;
        },
        
        /**
         * Löscht eine Frage aus dem Fragenpool
         * @param {string} id - ID der Frage
         * @returns {boolean} Erfolg/Misserfolg
         */
        delete: function(id) {
            const questions = Storage.get('questionBank') || [];
            const index = questions.findIndex(q => q.id === id);
            
            if (index === -1) {
                App.log(`Frage mit ID ${id} nicht gefunden`);
                return false;
            }
            
            // Aus Array entfernen
            questions.splice(index, 1);
            
            // Speichern
            Storage.set('questionBank', questions);
            
            return true;
        },
        
        /**
         * Importiert Fragen aus einer Word-Datei
         * @param {string} content - Inhalt der Word-Datei als Text
         * @returns {Object} Import-Ergebnis { success, imported, failed, questions }
         */
        importFromWord: function(content) {
            // Diese Funktion ist ein Platzhalter für den tatsächlichen Word-Import
            // Hier wird angenommen, dass der Inhalt bereits als Text vorliegt
            
            const result = {
                success: true,
                imported: 0,
                failed: 0,
                questions: []
            };
            
            try {
                // Annahme: Jeder Block beginnt mit "Überschrift:", gefolgt von "Frage:" und "Antwort:"
                const blocks = content.split(/Überschrift:/i).filter(Boolean);
                
                blocks.forEach(block => {
                    try {
                        // Block in Zeilen aufteilen
                        const lines = block.trim().split('\n');
                        const category = lines[0].trim();
                        
                        // Frage und Antwort extrahieren
                        let questionText = '';
                        let answer = '';
                        
                        const questionIndex = block.indexOf('Frage:');
                        const answerIndex = block.indexOf('Antwort:');
                        
                        if (questionIndex !== -1 && answerIndex !== -1 && questionIndex < answerIndex) {
                            questionText = block.substring(questionIndex + 6, answerIndex).trim();
                            answer = block.substring(answerIndex + 8).trim();
                            
                            // Frage zum Fragenpool hinzufügen
                            const newQuestion = this.add({
                                type: 'text', // Standardmäßig als Freitext-Frage
                                text: questionText,
                                category: category,
                                correctAnswer: answer,
                                points: 1
                            });
                            
                            result.questions.push(newQuestion);
                            result.imported++;
                        } else {
                            result.failed++;
                        }
                    } catch (e) {
                        App.log(`Fehler beim Parsen eines Blocks: ${e.message}`);
                        result.failed++;
                    }
                });
                
                return result;
            } catch (e) {
                App.log(`Fehler beim Import: ${e.message}`);
                result.success = false;
                return result;
            }
        }
    }
};
/* ImmoScout24 E-Learning Portal - Komponenten-Stilregeln */

/* ----- UI-Komponenten ----- */

/* Navigation */
#main-nav {
    background-color: var(--background-white);
    border-right: 1px solid var(--border-color);
}

.nav-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.nav-link {
    display: block;
    padding: var(--spacing-md) var(--spacing-lg);
    color: var(--text-dark);
    text-decoration: none;
    border-left: 3px solid transparent;
    transition: background-color var(--transition-fast), border-color var(--transition-fast);
}

.nav-link:hover {
    background-color: var(--background-light);
    text-decoration: none;
}

.nav-link.active {
    border-left-color: var(--primary-color);
    background-color: rgba(0, 255, 208, 0.1);
    color: var(--secondary-color);
    font-weight: 600;
}

/* Header */
#app-header {
    display: flex;
    align-items: center;
    padding: var(--spacing-md) var(--spacing-lg);
    background-color: var(--secondary-color);
    color: var(--text-light);
    box-shadow: var(--shadow-sm);
}

.header-logo {
    flex: 0 0 auto;
    margin-right: var(--spacing-lg);
}

.header-logo img {
    height: 40px;
    width: auto;
}

#main-nav {
    flex: 1;
}

.user-menu {
    display: flex;
    align-items: center;
    margin-left: auto;
}

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    overflow: hidden;
    margin-right: var(--spacing-sm);
    border: 2px solid var(--primary-color);
}

.user-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.user-info {
    display: flex;
    flex-direction: column;
    margin-right: var(--spacing-md);
}

#user-name {
    font-weight: 600;
    font-size: var(--font-size-sm);
}

#user-role {
    font-size: var(--font-size-xs);
    opacity: 0.8;
}

.user-actions {
    margin-left: var(--spacing-md);
}

.btn-logout {
    background: transparent;
    border: 1px solid var(--primary-color);
    color: var(--primary-color);
    padding: var(--spacing-xs) var(--spacing-md);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast), color var(--transition-fast);
}

.btn-logout:hover {
    background-color: var(--primary-color);
    color: var(--secondary-color);
}

/* Buttons */
.btn-primary {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--primary-color);
    color: var(--secondary-color);
    font-weight: 600;
    text-align: center;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast), transform var(--transition-fast);
}

.btn-primary:hover {
    background-color: var(--primary-dark);
    transform: translateY(-2px);
}

.btn-primary:active {
    transform: translateY(0);
}

.btn-secondary {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: transparent;
    color: var(--secondary-color);
    font-weight: 600;
    text-align: center;
    border: 1px solid var(--secondary-color);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast), color var(--transition-fast);
}

.btn-secondary:hover {
    background-color: var(--secondary-color);
    color: var(--text-light);
}

.btn-danger {
    display: inline-block;
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--danger-color);
    color: var(--text-light);
    font-weight: 600;
    text-align: center;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.btn-danger:hover {
    background-color: #c82333;
}

.button-group {
    display: flex;
    gap: var(--spacing-md);
    justify-content: flex-end;
}

/* Cards */
.card {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-sm);
    margin-bottom: var(--spacing-md);
    overflow: hidden;
    transition: box-shadow var(--transition-fast), transform var(--transition-fast);
}

.card:hover {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.card-header {
    padding: var(--spacing-md) var(--spacing-lg);
    border-bottom: 1px solid var(--border-color);
    background-color: rgba(0, 255, 208, 0.05);
}

.card-title {
    margin: 0;
    font-size: var(--font-size-lg);
    color: var(--secondary-color);
}

.card-body {
    padding: var(--spacing-lg);
}

.card-footer {
    padding: var(--spacing-md) var(--spacing-lg);
    border-top: 1px solid var(--border-color);
    background-color: rgba(0, 0, 0, 0.02);
}

/* Forms */
.app-form {
    margin-bottom: var(--spacing-lg);
}

.form-group {
    margin-bottom: var(--spacing-md);
}

.form-group label {
    display: block;
    margin-bottom: var(--spacing-xs);
    font-weight: 500;
}

.required-mark {
    color: var(--danger-color);
}

.form-group input,
.form-group select,
.form-group textarea {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 255, 208, 0.25);
}

.checkbox-wrapper,
.radio-wrapper {
    margin-top: var(--spacing-xs);
}

.radio-item {
    display: flex;
    align-items: center;
    margin-bottom: var(--spacing-xs);
}

.radio-item input,
.checkbox-wrapper input {
    width: auto;
    margin-right: var(--spacing-sm);
}

.help-text {
    color: var(--text-muted);
    font-size: var(--font-size-sm);
    margin-top: var(--spacing-xs);
}

.error-message {
    color: var(--danger-color);
    font-size: var(--font-size-sm);
    margin-top: var(--spacing-xs);
}

/* Tables */
.data-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: var(--spacing-lg);
}

.data-table th,
.data-table td {
    padding: var(--spacing-sm) var(--spacing-md);
    text-align: left;
    border-bottom: 1px solid var(--border-color);
}

.data-table th {
    background-color: rgba(0, 255, 208, 0.1);
    font-weight: 600;
    color: var(--secondary-color);
}

.data-table tr:hover td {
    background-color: rgba(0, 255, 208, 0.05);
}

.data-table tr:last-child td {
    border-bottom: none;
}

.empty-table-message {
    text-align: center;
    color: var(--text-muted);
    padding: var(--spacing-lg) !important;
}

/* Progress Bar */
.progress-container {
    margin: var(--spacing-md) 0;
}

.progress-bar {
    background-color: var(--border-color);
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
}

.progress-value {
    height: 100%;
    background-color: var(--primary-color);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.progress-label {
    margin-top: var(--spacing-xs);
    font-size: var(--font-size-sm);
    text-align: right;
}

/* Search */
.search-container {
    display: flex;
    margin-bottom: var(--spacing-md);
}

.search-input {
    flex: 1;
    padding: var(--spacing-sm) var(--spacing-md);
    border: 1px solid var(--border-color);
    border-right: none;
    border-radius: var(--border-radius-sm) 0 0 var(--border-radius-sm);
}

.search-button {
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--primary-color);
    color: var(--secondary-color);
    border: none;
    border-radius: 0 var(--border-radius-sm) var(--border-radius-sm) 0;
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.search-button:hover {
    background-color: var(--primary-dark);
}

/* Tabs */
.tabs-container {
    margin-bottom: var(--spacing-lg);
}

.tabs-header {
    display: flex;
    border-bottom: 1px solid var(--border-color);
}

.tab-button {
    padding: var(--spacing-sm) var(--spacing-lg);
    background-color: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    transition: border-color var(--transition-fast);
    font-weight: 500;
}

.tab-button.active {
    border-bottom-color: var(--primary-color);
    color: var(--secondary-color);
}

.tab-button:hover {
    border-bottom-color: var(--primary-light);
}

.tab-content {
    padding: var(--spacing-lg) 0;
}

/* Notifications */
.notification {
    background-color: var(--info-color);
    color: var(--text-light);
    padding: var(--spacing-md) var(--spacing-lg);
    border-radius: var(--border-radius-sm);
    margin-bottom: var(--spacing-md);
    animation: slideIn 0.3s ease-out;
}

/* Badges */
.badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: var(--font-size-xs);
    font-weight: 600;
    text-transform: uppercase;
}

.badge-primary {
    background-color: var(--primary-color);
    color: var(--secondary-color);
}

.badge-secondary {
    background-color: var(--secondary-color);
    color: var(--text-light);
}

.badge-success {
    background-color: var(--success-color);
    color: var(--text-light);
}

.badge-warning {
    background-color: var(--warning-color);
    color: var(--text-dark);
}

.badge-danger {
    background-color: var(--danger-color);
    color: var(--text-light);
}

.badge-info {
    background-color: var(--info-color);
    color: var(--text-light);
}

/* Alerts */
.alert {
    padding: var(--spacing-md) var(--spacing-lg);
    border-radius: var(--border-radius-sm);
    margin-bottom: var(--spacing-md);
    border-left: 4px solid transparent;
}

.alert-info {
    background-color: rgba(23, 162, 184, 0.1);
    border-left-color: var(--info-color);
    color: var(--info-color);
}

.alert-success {
    background-color: rgba(40, 167, 69, 0.1);
    border-left-color: var(--success-color);
    color: var(--success-color);
}

.alert-warning {
    background-color: rgba(255, 193, 7, 0.1);
    border-left-color: var(--warning-color);
    color: var(--text-dark);
}

.alert-danger {
    background-color: rgba(220, 53, 69, 0.1);
    border-left-color: var(--danger-color);
    color: var(--danger-color);
}

/* Tooltips */
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip .tooltip-text {
    visibility: hidden;
    width: 200px;
    background-color: var(--secondary-color);
    color: var(--text-light);
    text-align: center;
    border-radius: var(--border-radius-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.3s;
}

.tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

/* Animationen */
@keyframes slideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Layout Grid */
.grid {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: var(--spacing-md);
}

.col-1 { grid-column: span 1; }
.col-2 { grid-column: span 2; }
.col-3 { grid-column: span 3; }
.col-4 { grid-column: span 4; }
.col-5 { grid-column: span 5; }
.col-6 { grid-column: span 6; }
.col-7 { grid-column: span 7; }
.col-8 { grid-column: span 8; }
.col-9 { grid-column: span 9; }
.col-10 { grid-column: span 10; }
.col-11 { grid-column: span 11; }
.col-12 { grid-column: span 12; }

/* Responsive */
@media (max-width: 768px) {
    .col-md-1 { grid-column: span 1; }
    .col-md-2 { grid-column: span 2; }
    .col-md-3 { grid-column: span 3; }
    .col-md-4 { grid-column: span 4; }
    .col-md-5 { grid-column: span 5; }
    .col-md-6 { grid-column: span 6; }
    .col-md-7 { grid-column: span 7; }
    .col-md-8 { grid-column: span 8; }
    .col-md-9 { grid-column: span 9; }
    .col-md-10 { grid-column: span 10; }
    .col-md-11 { grid-column: span 11; }
    .col-md-12 { grid-column: span 12; }
}

@media (max-width: 576px) {
    .col-sm-1 { grid-column: span 1; }
    .col-sm-2 { grid-column: span 2; }
    .col-sm-3 { grid-column: span 3; }
    .col-sm-4 { grid-column: span 4; }
    .col-sm-5 { grid-column: span 5; }
    .col-sm-6 { grid-column: span 6; }
    .col-sm-7 { grid-column: span 7; }
    .col-sm-8 { grid-column: span 8; }
    .col-sm-9 { grid-column: span 9; }
    .col-sm-10 { grid-column: span 10; }
    .col-sm-11 { grid-column: span 11; }
    .col-sm-12 { grid-column: span 12; }
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 1 */

/* ----- Hauptlayout ----- */
#main-app {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

#content-container {
    flex: 1;
    padding: var(--spacing-lg);
    background-color: var(--background-light);
}

#app-footer {
    background-color: var(--secondary-color);
    color: var(--text-light);
    text-align: center;
    padding: var(--spacing-md);
    font-size: var(--font-size-sm);
}

/* ----- Dashboard-Komponenten ----- */

/* Statistik-Kacheln */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.stat-card {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-sm);
    overflow: hidden;
    transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.stat-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.stat-header {
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--secondary-color);
    color: var(--text-light);
    font-weight: bold;
    font-size: var(--font-size-sm);
}

.stat-body {
    padding: var(--spacing-md);
    text-align: center;
}

.stat-value {
    font-size: var(--font-size-xxl);
    font-weight: 700;
    color: var(--primary-color);
    margin-bottom: var(--spacing-xs);
}

.stat-label {
    color: var(--text-muted);
    font-size: var(--font-size-sm);
}

.stat-icon {
    font-size: 2.5rem;
    margin-bottom: var(--spacing-sm);
    color: var(--primary-light);
}

/* Dashboard-Sections */
.dashboard-section {
    margin-bottom: var(--spacing-xl);
}

.dashboard-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md);
}

.dashboard-section-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    color: var(--secondary-color);
    margin: 0;
}

/* Test-Karten */
.test-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: var(--spacing-md);
}

.test-card {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-sm);
    overflow: hidden;
    transition: transform var(--transition-fast), box-shadow var(--transition-fast);
    display: flex;
    flex-direction: column;
}

.test-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.test-card-header {
    padding: var(--spacing-md);
    border-bottom: 1px solid var(--border-color);
    position: relative;
}

.test-card-title {
    margin: 0;
    font-size: var(--font-size-md);
    font-weight: 600;
    color: var(--secondary-color);
}

.test-card-team {
    position: absolute;
    top: var(--spacing-md);
    right: var(--spacing-md);
}

.test-card-body {
    padding: var(--spacing-md);
    flex: 1;
}

.test-card-description {
    color: var(--text-dark);
    margin-bottom: var(--spacing-md);
}

.test-card-stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: var(--spacing-md);
    color: var(--text-muted);
    font-size: var(--font-size-sm);
}

.test-card-footer {
    padding: var(--spacing-md);
    background-color: rgba(0, 0, 0, 0.02);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 2 */

/* ----- Tests & Fragen ----- */

/* Test-Erstellung */
.question-builder {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-lg);
    box-shadow: var(--shadow-sm);
}

.question-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.question-item {
    background-color: var(--background-light);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    position: relative;
}

.question-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-sm);
}

.question-item-title {
    font-weight: 600;
    margin: 0;
}

.question-item-type {
    font-size: var(--font-size-sm);
    color: var(--text-muted);
}

.question-item-actions {
    position: absolute;
    top: var(--spacing-md);
    right: var(--spacing-md);
}

.question-item-content {
    margin-bottom: var(--spacing-md);
}

.question-options {
    list-style: none;
    padding: 0;
    margin: 0;
}

.question-option {
    display: flex;
    align-items: center;
    margin-bottom: var(--spacing-xs);
}

.question-option-indicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: var(--border-color);
    margin-right: var(--spacing-sm);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: var(--font-size-xs);
    color: var(--text-light);
}

.question-option-indicator.correct {
    background-color: var(--success-color);
}

/* Test-Durchführung */
.test-execution {
    max-width: 800px;
    margin: 0 auto;
}

.test-info {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-lg);
    box-shadow: var(--shadow-sm);
}

.test-info-header {
    margin-bottom: var(--spacing-md);
}

.test-info-title {
    font-size: var(--font-size-xl);
    margin: 0 0 var(--spacing-sm);
    color: var(--secondary-color);
}

.test-info-meta {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-md);
    color: var(--text-muted);
    font-size: var(--font-size-sm);
}

.test-progress {
    margin-bottom: var(--spacing-lg);
}

.test-question {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-lg);
    box-shadow: var(--shadow-sm);
    animation: fadeIn 0.3s ease-out;
}

.test-question-number {
    color: var(--primary-color);
    font-weight: 600;
    margin-bottom: var(--spacing-sm);
}

.test-question-text {
    font-size: var(--font-size-lg);
    margin-bottom: var(--spacing-lg);
}

.test-options {
    list-style: none;
    padding: 0;
    margin: 0 0 var(--spacing-lg);
}

.test-option {
    background-color: var(--background-light);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast), border-color var(--transition-fast);
}

.test-option:hover {
    background-color: rgba(0, 255, 208, 0.05);
    border-color: var(--primary-color);
}

.test-option.selected {
    background-color: rgba(0, 255, 208, 0.1);
    border-color: var(--primary-color);
}

.test-navigation {
    display: flex;
    justify-content: space-between;
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 3 */

/* Test-Auswertung */
.test-result {
    max-width: 800px;
    margin: 0 auto;
}

.test-result-header {
    text-align: center;
    margin-bottom: var(--spacing-xl);
}

.test-result-status {
    font-size: var(--font-size-xxl);
    font-weight: 700;
    margin-bottom: var(--spacing-md);
}

.test-result-status.passed {
    color: var(--success-color);
}

.test-result-status.failed {
    color: var(--danger-color);
}

.test-result-score {
    font-size: var(--font-size-xl);
    margin-bottom: var(--spacing-md);
}

.test-result-summary {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
}

.test-result-stat {
    text-align: center;
}

.test-result-stat-value {
    font-size: var(--font-size-xl);
    font-weight: 600;
    color: var(--secondary-color);
}

.test-result-stat-label {
    color: var(--text-muted);
    font-size: var(--font-size-sm);
}

.test-result-questions {
    margin-bottom: var(--spacing-xl);
}

.test-result-question {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-md);
    box-shadow: var(--shadow-sm);
}

.test-result-question-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md);
}

.test-result-question-text {
    font-weight: 600;
    margin: 0;
}

.test-result-question-points {
    font-size: var(--font-size-sm);
}

.test-result-answer {
    margin-bottom: var(--spacing-md);
    padding: var(--spacing-md);
    border-radius: var(--border-radius-sm);
}

.test-result-answer.correct {
    background-color: rgba(40, 167, 69, 0.1);
    border-left: 3px solid var(--success-color);
}

.test-result-answer.incorrect {
    background-color: rgba(220, 53, 69, 0.1);
    border-left: 3px solid var(--danger-color);
}

.test-result-answer-label {
    font-weight: 600;
    display: block;
    margin-bottom: var(--spacing-xs);
}

.test-result-correct-answer {
    margin-top: var(--spacing-md);
    font-style: italic;
    color: var(--success-color);
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 4 */

/* ----- Benutzerverwaltung ----- */
.user-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: var(--spacing-md);
}

.user-card {
    background-color: var(--background-white);
    border-radius: var(--border-radius-md);
    box-shadow: var(--shadow-sm);
    overflow: hidden;
    transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.user-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.user-card-header {
    background-color: var(--secondary-light);
    padding: var(--spacing-md);
    display: flex;
    align-items: center;
}

.user-card-avatar {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    overflow: hidden;
    margin-right: var(--spacing-md);
    border: 2px solid var(--primary-color);
}

.user-card-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.user-card-name {
    color: var(--text-light);
    font-weight: 600;
    margin: 0 0 var(--spacing-xs);
}

.user-card-role {
    color: rgba(255, 255, 255, 0.8);
    font-size: var(--font-size-sm);
}

.user-card-body {
    padding: var(--spacing-md);
}

.user-card-details {
    margin-bottom: var(--spacing-md);
}

.user-card-detail {
    display: flex;
    margin-bottom: var(--spacing-xs);
}

.user-card-detail-label {
    font-weight: 600;
    width: 100px;
    flex-shrink: 0;
}

.user-card-detail-value {
    flex: 1;
}

.user-card-actions {
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-md);
    display: flex;
    justify-content: flex-end;
    gap: var(--spacing-sm);
}

/* Avatar-Auswahl */
.avatar-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: var(--spacing-sm);
}

.avatar-item {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid transparent;
    cursor: pointer;
    transition: transform var(--transition-fast), border-color var(--transition-fast);
}

.avatar-item:hover {
    transform: scale(1.1);
}

.avatar-item.selected {
    border-color: var(--primary-color);
}

.avatar-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 5 */

/* ----- Footer Anpassungen ----- */
#app-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Game-Elemente */
.badge-display {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
}

.achievement-badge {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: var(--primary-light);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: var(--secondary-color);
    font-weight: 600;
    font-size: var(--font-size-xs);
    text-align: center;
    position: relative;
    overflow: hidden;
    box-shadow: var(--shadow-sm);
}

.achievement-badge i {
    font-size: 24px;
    margin-bottom: var(--spacing-xs);
}

.achievement-badge.locked {
    filter: grayscale(1);
    opacity: 0.5;
}

.achievement-badge.locked::before {
    content: '\f023';
    font-family: 'Font Awesome 5 Free';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0.7;
}

.level-indicator {
    display: flex;
    align-items: center;
    margin-bottom: var(--spacing-md);
}

.level-badge {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--primary-color);
    color: var(--secondary-color);
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    margin-right: var(--spacing-md);
}

.level-progress {
    flex: 1;
}

.level-info {
    display: flex;
    justify-content: space-between;
    font-size: var(--font-size-sm);
    color: var(--text-muted);
    margin-top: var(--spacing-xs);
}

/* Animationen */
@keyframes slideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
/* ImmoScout24 E-Learning Portal - Themes und Anpassungen Teil 6 */

/* Layout Grid */
.grid {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: var(--spacing-md);
}

.col-1 { grid-column: span 1; }
.col-2 { grid-column: span 2; }
.col-3 { grid-column: span 3; }
.col-4 { grid-column: span 4; }
.col-5 { grid-column: span 5; }
.col-6 { grid-column: span 6; }
.col-7 { grid-column: span 7; }
.col-8 { grid-column: span 8; }
.col-9 { grid-column: span 9; }
.col-10 { grid-column: span 10; }
.col-11 { grid-column: span 11; }
.col-12 { grid-column: span 12; }

/* ----- Responsivitätsanpassungen ----- */
@media (max-width: 768px) {
    #app-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .header-logo {
        margin-bottom: var(--spacing-sm);
    }
    
    .user-menu {
        margin-left: 0;
        margin-top: var(--spacing-md);
        width: 100%;
        justify-content: space-between;
    }
    
    .test-cards,
    .user-grid {
        grid-template-columns: 1fr;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .dashboard-section-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .dashboard-section-title {
        margin-bottom: var(--spacing-sm);
    }
    
    .col-md-1 { grid-column: span 1; }
    .col-md-2 { grid-column: span 2; }
    .col-md-3 { grid-column: span 3; }
    .col-md-4 { grid-column: span 4; }
    .col-md-5 { grid-column: span 5; }
    .col-md-6 { grid-column: span 6; }
    .col-md-7 { grid-column: span 7; }
    .col-md-8 { grid-column: span 8; }
    .col-md-9 { grid-column: span 9; }
    .col-md-10 { grid-column: span 10; }
    .col-md-11 { grid-column: span 11; }
    .col-md-12 { grid-column: span 12; }
}

@media (max-width: 576px) {
    #content-container {
        padding: var(--spacing-md);
    }
    
    .stats-grid {
        grid-template-columns: 1fr;
    }
    
    .test-info-meta {
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .test-navigation {
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .test-navigation button {
        width: 100%;
    }
    
    .avatar-grid {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .col-sm-1 { grid-column: span 1; }
    .col-sm-2 { grid-column: span 2; }
    .col-sm-3 { grid-column: span 3; }
    .col-sm-4 { grid-column: span 4; }
    .col-sm-5 { grid-column: span 5; }
    .col-sm-6 { grid-column: span 6; }
    .col-sm-7 { grid-column: span 7; }
    .col-sm-8 { grid-column: span 8; }
    .col-sm-9 { grid-column: span 9; }
    .col-sm-10 { grid-column: span 10; }
    .col-sm-11 { grid-column: span 11; }
    .col-sm-12 { grid-column: span 12; }
}
<!-- HTML-Block 2: Admin-Dashboard -->

<!-- Admin-Bereich -->
<div id="admin-section" class="content-section">
    <div class="dashboard-section">
        <div class="dashboard-section-header">
            <h2 class="dashboard-section-title">Admin-Dashboard</h2>
            <div class="dashboard-actions">
                <button id="btn-export-all" class="btn-secondary">
                    <i class="fas fa-file-export"></i> Alle Daten exportieren
                </button>
                <button id="btn-import-data" class="btn-secondary">
                    <i class="fas fa-file-import"></i> Daten importieren
                </button>
            </div>
        </div>
        
        <!-- Statistiken -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-header">Benutzer</div>
                <div class="stat-body">
                    <div class="stat-icon"><i class="fas fa-users"></i></div>
                    <div class="stat-value" id="stat-total-users">0</div>
                    <div class="stat-label">Registrierte Benutzer</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">Tests</div>
                <div class="stat-body">
                    <div class="stat-icon"><i class="fas fa-clipboard-list"></i></div>
                    <div class="stat-value" id="stat-total-tests">0</div>
                    <div class="stat-label">Erstellte Tests</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">Teilnahmen</div>
                <div class="stat-body">
                    <div class="stat-icon"><i class="fas fa-tasks"></i></div>
                    <div class="stat-value" id="stat-total-participations">0</div>
                    <div class="stat-label">Test-Teilnahmen</div>
                </div>
            </div>
            
            <div class="stat-card">
                <div class="stat-header">Fragen</div>
                <div class="stat-body">
                    <div class="stat-icon"><i class="fas fa-question-circle"></i></div>
                    <div class="stat-value" id="stat-total-questions">0</div>
                    <div class="stat-label">Fragen im System</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Schnellzugriff -->
    <div class="dashboard-section">
        <div class="dashboard-section-header">
            <h2 class="dashboard-section-title">Schnellzugriff</h2>
        </div>
        
        <div class="grid">
            <div class="col-3 col-md-6 col-sm-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Benutzerverwaltung</h3>
                    </div>
                    <div class="card-body">
                        <p>Benutzer hinzufügen, bearbeiten und Teams zuweisen.</p>
                        <button id="btn-manage-users" class="btn-primary">
                            <i class="fas fa-users"></i> Benutzer verwalten
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="col-3 col-md-6 col-sm-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Neuen Test erstellen</h3>
                    </div>
                    <div class="card-body">
                        <p>Erstellen Sie einen neuen Test mit verschiedenen Fragetypen.</p>
                        <button id="btn-create-test" class="btn-primary">
                            <i class="fas fa-plus-circle"></i> Test erstellen
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="col-3 col-md-6 col-sm-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Fragenpool</h3>
                    </div>
                    <div class="card-body">
                        <p>Verwalten Sie Ihren Fragenpool und importieren Sie Fragen.</p>
                        <button id="btn-question-bank" class="btn-primary">
                            <i class="fas fa-database"></i> Fragenpool öffnen
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="col-3 col-md-6 col-sm-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Auswertungen</h3>
                    </div>
                    <div class="card-body">
                        <p>Sehen Sie sich die Testergebnisse und Auswertungen an.</p>
                        <button id="btn-view-results" class="btn-primary">
                            <i class="fas fa-chart-bar"></i> Auswertungen anzeigen
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Neueste Tests -->
    <div class="dashboard-section">
        <div class="dashboard-section-header">
            <h2 class="dashboard-section-title">Neueste Tests</h2>
            <a href="#" id="link-view-all-tests" class="btn-secondary">Alle Tests anzeigen</a>
        </div>
        
        <div id="recent-tests-container" class="test-cards">
            <!-- Wird dynamisch gefüllt -->
            <div class="card" style="grid-column: 1 / -1; text-align: center; padding: 2rem;">
                <p>Keine Tests vorhanden. Erstellen Sie Ihren ersten Test!</p>
                <button id="btn-create-first-test" class="btn-primary">
                    <i class="fas fa-plus-circle"></i> Test erstellen
                </button>
            </div>
        </div>
    </div>
    
    <!-- Neueste Aktivitäten -->
    <div class="dashboard-section">
        <div class="dashboard-section-header">
            <h2 class="dashboard-section-title">Neueste Aktivitäten</h2>
        </div>
        
        <div class="card">
            <div class="card-body">
                <table class="data-table" id="recent-activities-table">
                    <thead>
                        <tr>
                            <th>Zeitpunkt</th>
                            <th>Benutzer</th>
                            <th>Rolle</th>
                            <th>Aktion</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Wird dynamisch gefüllt -->
                        <tr>
                            <td colspan="5" class="empty-table-message">Keine Aktivitäten vorhanden.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<!-- Admin-Benutzerverwaltung -->
<div id="admin-users-section" class="content-section">
    <div class="dashboard-section-header">
        <h2 class="dashboard-section-title">Benutzerverwaltung</h2>
        <div class="dashboard-actions">
            <button id="btn-add-user" class="btn-primary">
                <i class="fas fa-user-plus"></i> Neuen Benutzer hinzufügen
            </button>
        </div>
    </div>
    
    <!-- Benutzersuche und Filter -->
    <div class="card">
        <div class="card-body">
            <div class="grid">
                <div class="col-6 col-md-12">
                    <div id="user-search-container"></div>
                </div>
                <div class="col-6 col-md-12">
                    <div class="form-group">
                        <label for="user-filter-role">Nach Rolle filtern</label>
                        <select id="user-filter-role" class="form-control">
                            <option value="">Alle Rollen</option>
                            <option value="admin">Administrator</option>
                            <option value="trainer">Trainer</option>
                            <option value="teamleader">Teamleiter</option>
                            <option value="employee">Mitarbeiter</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Benutzerliste -->
    <div id="users-container" class="user-grid">
        <!-- Wird dynamisch gefüllt -->
    </div>
</div>

<!-- Admin-Testverwaltung -->
<div id="admin-tests-section" class="content-section">
    <div class="dashboard-section-header">
        <h2 class="dashboard-section-title">Testverwaltung</h2>
        <div class="dashboard-actions">
            <button id="btn-add-test" class="btn-primary">
                <i class="fas fa-plus-circle"></i> Neuen Test erstellen
            </button>
            <button id="btn-import-word" class="btn-secondary">
                <i class="fas fa-file-word"></i> Word-Datei importieren
            </button>
        </div>
    </div>
    
    <!-- Test-Suche und Filter -->
    <div class="card">
        <div class="card-body">
            <div class="grid">
                <div class="col-6 col-md-12">
                    <div id="test-search-container"></div>
                </div>
                <div class="col-6 col-md-12">
                    <div class="form-group">
                        <label for="test-filter-team">Nach Team filtern</label>
                        <select id="test-filter-team" class="form-control">
                            <option value="">Alle Teams</option>
                            <option value="B2B">B2B</option>
                            <option value="Suchenden">Suchenden</option>
                            <option value="Eigentümer">Eigentümer</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Testliste -->
    <div id="tests-container" class="test-cards">
        <!-- Wird dynamisch gefüllt -->
    </div>
</div>

<!-- Admin-Berichte -->
<div id="admin-reports-section" class="content-section">
    <div class="dashboard-section-header">
        <h2 class="dashboard-section-title">Berichte</h2>
        <div class="dashboard-actions">
            <button id="btn-export-reports" class="btn-secondary">
                <i class="fas fa-file-export"></i> Berichte exportieren
            </button>
        </div>
    </div>
    
    <!-- Berichts-Tabs -->
    <div id="reports-tabs-container">
        <!-- Wird dynamisch gefüllt -->
    </div>
</div>

<!-- Admin-Einstellungen -->
<div id="admin-settings-section" class="content-section">
    <div class="dashboard-section-header">
        <h2 class="dashboard-section-title">Einstellungen</h2>
        <div class="dashboard-actions">
            <button id="btn-save-settings" class="btn-primary">
                <i class="fas fa-save"></i> Einstellungen speichern
            </button>
        </div>
    </div>
    
    <!-- Einstellungs-Tabs -->
    <div id="settings-tabs-container">
        <!-- Wird dynamisch gefüllt -->
    </div>
</div>
/**
 * ImmoScout24 E-Learning Portal
 * userManagement.js - Benutzerverwaltungsmodul
 */

const UserManagement = {
    // Initialisierung
    init: function() {
        App.log('Initialisiere Benutzerverwaltung...');
        
        // Event-Handler registrieren
        this.setupEventListeners();
        
        App.log('Benutzerverwaltung initialisiert');
    },
    
    /**
     * Event-Listener einrichten
     */
    setupEventListeners: function() {
        // Benutzer hinzufügen Button
        const addUserBtn = document.getElementById('btn-add-user');
        if (addUserBtn) {
            addUserBtn.addEventListener('click', this.showAddUserForm.bind(this));
        }
        
        // Dashboard-Button zur Benutzerverwaltung
        const manageUsersBtn = document.getElementById('btn-manage-users');
        if (manageUsersBtn) {
            manageUsersBtn.addEventListener('click', function() {
                UI.showSection('admin-users-section');
                document.querySelector('.nav-link[data-section="admin-users-section"]').classList.add('active');
                document.querySelector('.nav-link[data-section="admin-section"]').classList.remove('active');
            });
        }
        
        // Benutzerfilter nach Rolle
        const userFilterRole = document.getElementById('user-filter-role');
        if (userFilterRole) {
            userFilterRole.addEventListener('change', this.filterUsers.bind(this));
        }
    },
    
    /**
     * Lädt die Benutzerliste und zeigt sie an
     */
    loadUsers: function() {
        App.log('Lade Benutzerliste...');
        
        // Lade alle Benutzer
        const users = Storage.get('users') || [];
        const container = document.getElementById('users-container');
        
        if (!container) return;
        
        // Container leeren
        container.innerHTML = '';
        
        if (users.length === 0) {
            container.innerHTML = `
                <div class="card" style="grid-column: 1 / -1; text-align: center; padding: 2rem;">
                    <p>Keine Benutzer vorhanden. Fügen Sie einen neuen Benutzer hinzu!</p>
                    <button id="btn-add-first-user" class="btn-primary">
                        <i class="fas fa-user-plus"></i> Benutzer hinzufügen
                    </button>
                </div>
            `;
            
            const addFirstUserBtn = document.getElementById('btn-add-first-user');
            if (addFirstUserBtn) {
                addFirstUserBtn.addEventListener('click', this.showAddUserForm.bind(this));
            }
            
            return;
        }
        
        // Filterwert abrufen
        const roleFilter = document.getElementById('user-filter-role').value;
        
        // Gefilterte Benutzer anzeigen
        const filteredUsers = roleFilter 
            ? users.filter(user => user.roles.includes(roleFilter))
            : users;
        
        // Benutzer nach Namen sortieren
        filteredUsers.sort((a, b) => a.name.localeCompare(b.name));
        
        filteredUsers.forEach(user => {
            const userCard = this.createUserCard(user);
            container.appendChild(userCard);
        });
        
        // Benutzersuche erstellen
        this.setupUserSearch();
    },
    
    /**
     * Erstellt eine User-Card
     * @param {Object} user - Benutzerobjekt
     * @returns {HTMLElement} Benutzer-Karte
     */
    createUserCard: function(user) {
        // Container erstellen
        const card = document.createElement('div');
        card.className = 'user-card';
        card.setAttribute('data-user-id', user.id);
        
        // Rollentext für Anzeige erstellen
        const roleTexts = {
            'admin': 'Administrator',
            'trainer': 'Trainer',
            'teamleader': 'Teamleiter',
            'employee': 'Mitarbeiter'
        };
        
        const roleLabels = user.roles.map(role => roleTexts[role] || role).join(', ');
        
        // Statusbadge erstellen
        const statusBadge = user.status === 'active' 
            ? '<span class="badge badge-success">Aktiv</span>' 
            : '<span class="badge badge-danger">Inaktiv</span>';
        
        // HTML-Inhalt setzen
        card.innerHTML = `
            <div class="user-card-header">
                <div class="user-card-avatar">
                    <img src="${user.avatar || 'assets/avatars/default.png'}" alt="${user.name}">
                </div>
                <div>
                    <h3 class="user-card-name">${user.name}</h3>
                    <div class="user-card-role">${roleLabels}</div>
                </div>
            </div>
            <div class="user-card-body">
                <div class="user-card-details">
                    <div class="user-card-detail">
                        <span class="user-card-detail-label">Benutzername:</span>
                        <span class="user-card-detail-value">${user.username}</span>
                    </div>
                    <div class="user-card-detail">
                        <span class="user-card-detail-label">E-Mail:</span>
                        <span class="user-card-detail-value">${user.email || '-'}</span>
                    </div>
                    <div class="user-card-detail">
                        <span class="user-card-detail-label">Team:</span>
                        <span class="user-card-detail-value">${user.team || '-'}</span>
                    </div>
                    <div class="user-card-detail">
                        <span class="user-card-detail-label">Status:</span>
                        <span class="user-card-detail-value">${statusBadge}</span>
                    </div>
                </div>
                <div class="user-card-actions">
                    <button class="btn-secondary btn-edit-user" data-user-id="${user.id}">
                        <i class="fas fa-edit"></i> Bearbeiten
                    </button>
                    <button class="btn-danger btn-delete-user" data-user-id="${user.id}">
                        <i class="fas fa-trash-alt"></i> Löschen
                    </button>
                </div>
            </div>
        `;
        
        // Event-Handler für die Buttons hinzufügen
        card.querySelector('.btn-edit-user').addEventListener('click', () => {
            this.showEditUserForm(user.id);
        });
        
        card.querySelector('.btn-delete-user').addEventListener('click', () => {
            this.confirmDeleteUser(user.id);
        });
        
        return card;
    },
    
    /**
     * Zeigt das Formular zum Hinzufügen eines Benutzers an
     */
    showAddUserForm: function() {
        App.log('Zeige Formular zum Hinzufügen eines Benutzers');
        
        // Formularfelder definieren
        const fields = [
            {
                id: 'user-name',
                label: 'Name',
                type: 'text',
                placeholder: 'Vollständiger Name',
                required: true
            },
            {
                id: 'user-username',
                label: 'Benutzername',
                type: 'text',
                placeholder: 'Benutzername für die Anmeldung',
                required: true
            },
            {
                id: 'user-email',
                label: 'E-Mail',
                type: 'email',
                placeholder: 'E-Mail-Adresse',
                required: true
            },
            {
                id: 'user-password',
                label: 'Passwort',
                type: 'password',
                placeholder: 'Passwort (mind. 6 Zeichen)',
                required: true,
                helpText: 'Das Passwort sollte mindestens 6 Zeichen lang sein.'
            },
            {
                id: 'user-roles',
                label: 'Rollen',
                type: 'select',
                multiple: true,
                required: true,
                options: [
                    { value: 'admin', label: 'Administrator' },
                    { value: 'trainer', label: 'Trainer' },
                    { value: 'teamleader', label: 'Teamleiter' },
                    { value: 'employee', label: 'Mitarbeiter' }
                ],
                helpText: 'Mehrere Rollen können durch Halten der Strg-Taste ausgewählt werden.'
            },
            {
                id: 'user-team',
                label: 'Team',
                type: 'select',
                options: [
                    { value: '', label: 'Kein Team' },
                    { value: 'B2B', label: 'B2B' },
                    { value: 'Suchenden', label: 'Suchenden' },
                    { value: 'Eigentümer', label: 'Eigentümer' }
                ],
                helpText: 'Weisen Sie den Benutzer einem Team zu.'
            },
            {
                id: 'user-status',
                label: 'Status',
                type: 'select',
                options: [
                    { value: 'active', label: 'Aktiv' },
                    { value: 'inactive', label: 'Inaktiv' }
                ],
                defaultValue: 'active'
            }
        ];
        
        // Formular erstellen
        const form = UI.createForm(fields, {}, (data) => {
            this.addUser(data);
        }, { 
            id: 'add-user-form',
            submitText: 'Benutzer anlegen',
            showCancelButton: true,
            onCancel: () => UI.closeModal()
        });
        
        // Modal mit Formular anzeigen
        UI.showModal('Neuen Benutzer hinzufügen', form);
        
        // Validierungslogik hinzufügen
        document.getElementById('add-user-form').addEventListener('submit', function(e) {
            if (!this.validateUserForm(e.target)) {
                e.preventDefault();
                return false;
            }
        }.bind(this));
        
        // Avatar-Auswahl hinzufügen
        this.addAvatarSelectionToForm();
    },
    
    /**
     * Fügt eine Avatar-Auswahl zum Formular hinzu
     */
    addAvatarSelectionToForm: function() {
        const modalBody = document.getElementById('modal-body');
        
        // Avatar-Auswahl erstellen
        const avatarSection = document.createElement('div');
        avatarSection.className = 'form-group';
        avatarSection.innerHTML = `
            <label>Avatar auswählen</label>
            <input type="hidden" id="user-avatar" name="user-avatar" value="assets/avatars/default.png">
            <div class="avatar-grid" id="avatar-selection">
                <div class="avatar-item selected" data-avatar="assets/avatars/default.png">
                    <img src="assets/avatars/default.png" alt="Standard">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar1.png">
                    <img src="assets/avatars/avatar1.png" alt="Avatar 1">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar2.png">
                    <img src="assets/avatars/avatar2.png" alt="Avatar 2">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar3.png">
                    <img src="assets/avatars/avatar3.png" alt="Avatar 3">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar4.png">
                    <img src="assets/avatars/avatar4.png" alt="Avatar 4">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar5.png">
                    <img src="assets/avatars/avatar5.png" alt="Avatar 5">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar6.png">
                    <img src="assets/avatars/avatar6.png" alt="Avatar 6">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar7.png">
                    <img src="assets/avatars/avatar7.png" alt="Avatar 7">
                </div>
                <div class="avatar-item" data-avatar="assets/avatars/avatar8.png">
                    <img src="assets/avatars/avatar8.png" alt="Avatar 8">
                </div>
            </div>
        `;
        
        // Vor dem Formular einfügen
        const form = document.getElementById('add-user-form');
        modalBody.insertBefore(avatarSection, form);
        
        // Event-Handler für Avatar-Auswahl
        const avatarItems = document.querySelectorAll('.avatar-item');
        avatarItems.forEach(item => {
            item.addEventListener('click', function() {
                // Alle Auswahlmarkierungen entfernen
                avatarItems.forEach(i => i.classList.remove('selected'));
                
                // Ausgewählten Avatar markieren
                this.classList.add('selected');
                
                // Avatar-Wert setzen
                document.getElementById('user-avatar').value = this.getAttribute('data-avatar');
            });
        });
    },
    
    /**
     * Validiert das Benutzerformular
     * @param {HTMLElement} form - Formular-Element
     * @returns {boolean} Gültigkeit des Formulars
     */
    validateUserForm: function(form) {
        let isValid = true;
        
        // Fehlermeldungen zurücksetzen
        UI.clearFormErrors('add-user-form');
        
        // Name validieren
        const nameInput = form.querySelector('#user-name');
        if (!nameInput.value.trim()) {
            UI.showFormError('add-user-form', 'user-name', 'Bitte geben Sie einen Namen ein.');
            isValid = false;
        }
        
        // Benutzername validieren
        const usernameInput = form.querySelector('#user-username');
        if (!usernameInput.value.trim()) {
            UI.showFormError('add-user-form', 'user-username', 'Bitte geben Sie einen Benutzernamen ein.');
            isValid = false;
        } else {
            // Prüfen, ob Benutzername bereits existiert
            const users = Storage.get('users') || [];
            const existingUser = users.find(user => user.username === usernameInput.value.trim());
            
            if (existingUser) {
                UI.showFormError('add-user-form', 'user-username', 'Dieser Benutzername ist bereits vergeben.');
                isValid = false;
            }
        }
        
        // E-Mail validieren
        const emailInput = form.querySelector('#user-email');
        if (!emailInput.value.trim()) {
            UI.showFormError('add-user-form', 'user-email', 'Bitte geben Sie eine E-Mail-Adresse ein.');
            isValid = false;
        } else if (!Helpers.isValidEmail(emailInput.value.trim())) {
            UI.showFormError('add-user-form', 'user-email', 'Bitte geben Sie eine gültige E-Mail-Adresse ein.');
            isValid = false;
        }
        
        // Passwort validieren
        const passwordInput = form.querySelector('#user-password');
        if (!passwordInput.value) {
            UI.showFormError('add-user-form', 'user-password', 'Bitte geben Sie ein Passwort ein.');
            isValid = false;
        } else if (passwordInput.value.length < 6) {
            UI.showFormError('add-user-form', 'user-password', 'Das Passwort muss mindestens 6 Zeichen lang sein.');
            isValid = false;
        }
        
        // Rollen validieren
        const rolesSelect = form.querySelector('#user-roles');
        if (rolesSelect.selectedOptions.length === 0) {
            UI.showFormError('add-user-form', 'user-roles', 'Bitte wählen Sie mindestens eine Rolle aus.');
            isValid = false;
        }
        
        // Bei Teamleiter oder Mitarbeiter muss ein Team ausgewählt sein
        const hasTeamRole = Array.from(rolesSelect.selectedOptions).some(option => 
            option.value === 'teamleader' || option.value === 'employee'
        );
        
        const teamSelect = form.querySelector('#user-team');
        if (hasTeamRole && !teamSelect.value) {
            UI.showFormError('add-user-form', 'user-team', 'Für Teamleiter und Mitarbeiter muss ein Team ausgewählt werden.');
            isValid = false;
        }
        
        return isValid;
    },
    
    /**
     * Fügt einen neuen Benutzer hinzu
     * @param {Object} data - Formulardaten
     */
    addUser: function(data) {
        App.log('Füge neuen Benutzer hinzu...');
        
        // Benutzer-Objekt erstellen
        const newUser = {
            id: Helpers.generateId(),
            name: data['user-name'],
            username: data['user-username'],
            email: data['user-email'],
            password: data['user-password'],
            roles: data['user-roles'],
            team: data['user-team'],
            avatar: data['user-avatar'] || 'assets/avatars/default.png',
            status: data['user-status'] || 'active',
            created: new Date().toISOString()
        };
        
        // Benutzer speichern
        try {
            const users = Storage.get('users') || [];
            users.push(newUser);
            Storage.set('users', users);
            
            // Statistik aktualisieren
            document.getElementById('stat-total-users').textContent = users.length;
            
            // Modal schließen
            UI.closeModal();
            
            // Erfolgsmeldung anzeigen
            UI.showNotification(`Benutzer ${newUser.name} wurde erfolgreich angelegt.`, 'success');
            
            // Benutzerliste aktualisieren
            this.loadUsers();
            
            // Aktivität protokollieren
            Auth.logAction('user_created', `Benutzer ${newUser.name} (${newUser.username}) erstellt`);
        } catch (e) {
            App.log(`Fehler beim Hinzufügen des Benutzers: ${e.message}`);
            UI.showNotification('Beim Hinzufügen des Benutzers ist ein Fehler aufgetreten.', 'error');
        }
    },
    
    /**
     * Filtert die Benutzerliste
     */
    filterUsers: function() {
        App.log('Filtere Benutzerliste...');
        this.loadUsers();
    },
    
    /**
     * Richtet die Benutzersuche ein
     */
    setupUserSearch: function() {
        const searchContainer = document.getElementById('user-search-container');
        if (!searchContainer) return;
        
        // Suchfeld erstellen
        const searchField = UI.createSearchField(
            this.searchUsers.bind(this),
            {
                placeholder: 'Nach Namen oder Benutzernamen suchen...',
                liveSearch: true
            }
        );
        
        // In Container einfügen
        searchContainer.innerHTML = '';
        searchContainer.appendChild(searchField);
    },
    
    /**
     * Sucht nach Benutzern
     * @param {string} query - Suchbegriff
     */
    searchUsers: function(query) {
        App.log(`Suche nach Benutzern mit Query: ${query}`);
        
        if (!query.trim()) {
            // Bei leerer Suche alle anzeigen
            this.loadUsers();
            return;
        }
        
        // Benutzer laden und filtern
        const users = Storage.get('users') || [];
        const roleFilter = document.getElementById('user-filter-role').value;
        
        // Filtere zuerst nach Rolle, wenn angegeben
        let filteredUsers = roleFilter 
            ? users.filter(user => user.roles.includes(roleFilter))
            : users;
        
        // Dann nach Suchbegriff filtern
        const lowerQuery = query.toLowerCase().trim();
        filteredUsers = filteredUsers.filter(user => 
            user.name.toLowerCase().includes(lowerQuery) ||
            user.username.toLowerCase().includes(lowerQuery) ||
            (user.email && user.email.toLowerCase().includes(lowerQuery))
        );
        
        // Anzeigen
        const container = document.getElementById('users-container');
        if (!container) return;
        
        // Container leeren
        container.innerHTML = '';
        
        if (filteredUsers.length === 0) {
            container.innerHTML = `
                <div class="card" style="grid-column: 1 / -1; text-align: center; padding: 2rem;">
                    <p>Keine Benutzer gefunden, die dem Suchbegriff "${query}" entsprechen.</p>
                </div>
            `;
            return;
        }
        
        // Benutzer nach Namen sortieren
        filteredUsers.sort((a, b) => a.name.localeCompare(b.name));
        
        // Benutzer anzeigen
        filteredUsers.forEach(user => {
            const userCard = this.createUserCard(user);
            container.appendChild(userCard);
        });
    }
};
/**
 * ImmoScout24 E-Learning Portal
 * userManagement.js - Teil 2: Benutzer bearbeiten
 */

// Ergänzung des UserManagement-Objekts um Bearbeitungsfunktionen
Object.assign(UserManagement, {
    /**
     * Zeigt das Formular zum Bearbeiten eines Benutzers an
     * @param {string} userId - ID des zu bearbeitenden Benutzers
     */
    showEditUserForm: function(userId) {
        App.log(`Zeige Formular zum Bearbeiten des Benutzers mit ID: ${userId}`);
        
        // Benutzer laden
        const users = Storage.get('users') || [];
        const user = users.find(u => u.id === userId);
        
        if (!user) {
            UI.showNotification('Benutzer nicht gefunden.', 'error');
            return;
        }
        
        // Formulardaten vorbereiten
        const formData = {
            'user-name': user.name,
            'user-username': user.username,
            'user-email': user.email,
            'user-roles': user.roles,
            'user-team': user.team || '',
            'user-status': user.status,
            'user-avatar': user.avatar
        };
        
        // Formularfelder definieren
        const fields = [
            {
                id: 'user-name',
                label: 'Name',
                type: 'text',
                placeholder: 'Vollständiger Name',
                required: true
            },
            {
                id: 'user-username',
                label: 'Benutzername',
                type: 'text',
                placeholder: 'Benutzername für die Anmeldung',
                required: true,
                readOnly: true, // Benutzername kann nicht geändert werden
                helpText: 'Der Benutzername kann nicht geändert werden.'
            },
            {
                id: 'user-email',
                label: 'E-Mail',
                type: 'email',
                placeholder: 'E-Mail-Adresse',
                required: true
            },
            {
                id: 'user-password',
                label: 'Neues Passwort',
                type: 'password',
                placeholder: 'Leer lassen, um das bestehende Passwort beizubehalten',
                required: false,
                helpText: 'Nur ausfüllen, wenn das Passwort geändert werden soll.'
            },
            {
                id: 'user-roles',
                label: 'Rollen',
                type: 'select',
                multiple: true,
                required: true,
                options: [
                    { value: 'admin', label: 'Administrator' },
                    { value: 'trainer', label: 'Trainer' },
                    { value: 'teamleader', label: 'Teamleiter' },
                    { value: 'employee', label: 'Mitarbeiter' }
                ],
                helpText: 'Mehrere Rollen können durch Halten der Strg-Taste ausgewählt werden.'
            },
            {
                id: 'user-team',
                label: 'Team',
                type: 'select',
                options: [
                    { value: '', label: 'Kein Team' },
                    { value: 'B2B', label: 'B2B' },
                    { value: 'Suchenden', label: 'Suchenden' },
                    { value: 'Eigentümer', label: 'Eigentümer' }
                ],
                helpText: 'Weisen Sie den Benutzer einem Team zu.'
            },
            {
                id: 'user-status',
                label: 'Status',
                type: 'select',
                options: [
                    { value: 'active', label: 'Aktiv' },
                    { value: 'inactive', label: 'Inaktiv' }
                ],
                defaultValue: 'active'
            },
            {
                id: 'user-id',
                type: 'hidden',
                value: userId
            }
        ];
        
        // Formular erstellen
        const form = UI.createForm(fields, formData, (data) => {
            this.updateUser(data);
        }, { 
            id: 'edit-user-form',
            submitText: 'Änderungen speichern',
            showCancelButton: true,
            onCancel: () => UI.closeModal()
        });
        
        // Modal mit Formular anzeigen
        UI.showModal(`Benutzer bearbeiten: ${user.name}`, form);
        
        // Validierungslogik hinzufügen
        document.getElementById('edit-user-form').addEventListener('submit', function(e) {
            if (!this.validateEditUserForm(e.target)) {
                e.preventDefault();
                return false;
            }
        }.bind(this));
        
        // Avatar-Auswahl hinzufügen
        this.addAvatarSelectionToEditForm(user.avatar);
    },
    
    /**
     * Fügt eine Avatar-Auswahl zum Bearbeitungsformular hinzu
     * @param {string} currentAvatar - Aktueller Avatar des Benutzers
     */
    addAvatarSelectionToEditForm: function(currentAvatar) {
        const modalBody = document.getElementById('modal-body');
        
        // Avatar-Auswahl erstellen
        const avatarSection = document.createElement('div');
        avatarSection.className = 'form-group';
        avatarSection.innerHTML = `
            <label>Avatar auswählen</label>
            <input type="hidden" id="user-avatar" name="user-avatar" value="${currentAvatar || 'assets/avatars/default.png'}">
            <div class="avatar-grid" id="avatar-selection">
                <div class="avatar-item ${currentAvatar === 'assets/avatars/default.png' ? 'selected' : ''}" data-avatar="assets/avatars/default.png">
                    <img src="assets/avatars/default.png" alt="Standard">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar1.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar1.png">
                    <img src="assets/avatars/avatar1.png" alt="Avatar 1">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar2.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar2.png">
                    <img src="assets/avatars/avatar2.png" alt="Avatar 2">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar3.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar3.png">
                    <img src="assets/avatars/avatar3.png" alt="Avatar 3">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar4.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar4.png">
                    <img src="assets/avatars/avatar4.png" alt="Avatar 4">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar5.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar5.png">
                    <img src="assets/avatars/avatar5.png" alt="Avatar 5">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar6.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar6.png">
                    <img src="assets/avatars/avatar6.png" alt="Avatar 6">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar7.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar7.png">
                    <img src="assets/avatars/avatar7.png" alt="Avatar 7">
                </div>
                <div class="avatar-item ${currentAvatar === 'assets/avatars/avatar8.png' ? 'selected' : ''}" data-avatar="assets/avatars/avatar8.png">
                    <img src="assets/avatars/avatar8.png" alt="Avatar 8">
                </div>
            </div>
        `;
        
        // Vor dem Formular einfügen
        const form = document.getElementById('edit-user-form');
        modalBody.insertBefore(avatarSection, form);
        
        // Event-Handler für Avatar-Auswahl
        const avatarItems = document.querySelectorAll('.avatar-item');
        avatarItems.forEach(item => {
            item.addEventListener('click', function() {
                // Alle Auswahlmarkierungen entfernen
                avatarItems.forEach(i => i.classList.remove('selected'));
                
                // Ausgewählten Avatar markieren
                this.classList.add('selected');
                
                // Avatar-Wert setzen
                document.getElementById('user-avatar').value = this.getAttribute('data-avatar');
            });
        });
    },
    
    /**
     * Validiert das Bearbeitungsformular
     * @param {HTMLElement} form - Formular-Element
     * @returns {boolean} Gültigkeit des Formulars
     */
    validateEditUserForm: function(form) {
        let isValid = true;
        
        // Fehlermeldungen zurücksetzen
        UI.clearFormErrors('edit-user-form');
        
        // Name validieren
        const nameInput = form.querySelector('#user-name');
        if (!nameInput.value.trim()) {
            UI.showFormError('edit-user-form', 'user-name', 'Bitte geben Sie einen Namen ein.');
            isValid = false;
        }
        
        // E-Mail validieren
        const emailInput = form.querySelector('#user-email');
        if (!emailInput.value.trim()) {
            UI.showFormError('edit-user-form', 'user-email', 'Bitte geben Sie eine E-Mail-Adresse ein.');
            isValid = false;
        } else if (!Helpers.isValidEmail(emailInput.value.trim())) {
            UI.showFormError('edit-user-form', 'user-email', 'Bitte geben Sie eine gültige E-Mail-Adresse ein.');
            isValid = false;
        }
        
        // Passwort validieren (nur, wenn etwas eingegeben wurde)
        const passwordInput = form.querySelector('#user-password');
        if (passwordInput.value && passwordInput.value.length < 6) {
            UI.showFormError('edit-user-form', 'user-password', 'Das Passwort muss mindestens 6 Zeichen lang sein.');
            isValid = false;
        }
        
        // Rollen validieren
        const rolesSelect = form.querySelector('#user-roles');
        if (rolesSelect.selectedOptions.length === 0) {
            UI.showFormError('edit-user-form', 'user-roles', 'Bitte wählen Sie mindestens eine Rolle aus.');
            isValid = false;
        }
        
        // Bei Teamleiter oder Mitarbeiter muss ein Team ausgewählt sein
        const hasTeamRole = Array.from(rolesSelect.selectedOptions).some(option => 
            option.value === 'teamleader' || option.value === 'employee'
        );
        
        const teamSelect = form.querySelector('#user-team');
        if (hasTeamRole && !teamSelect.value) {
            UI.showFormError('edit-user-form', 'user-team', 'Für Teamleiter und Mitarbeiter muss ein Team ausgewählt werden.');
            isValid = false;
        }
        
        return isValid;
    },
    
    /**
     * Aktualisiert einen bestehenden Benutzer
     * @param {Object} data - Formulardaten
     */
    updateUser: function(data) {
        App.log(`Aktualisiere Benutzer mit ID: ${data['user-id']}`);
        
        // Benutzer laden
        const users = Storage.get('users') || [];
        const index = users.findIndex(u => u.id === data['user-id']);
        
        if (index === -1) {
            UI.showNotification('Benutzer nicht gefunden.', 'error');
            return;
        }
        
        const user = users[index];
        
        // Aktualisierte Benutzerdaten
        const updatedUser = {
            ...user,
            name: data['user-name'],
            email: data['user-email'],
            roles: data['user-roles'],
            team: data['user-team'],
            avatar: data['user-avatar'],
            status: data['user-status'],
            updated: new Date().toISOString()
        };
        
        // Passwort nur aktualisieren, wenn ein neues eingegeben wurde
        if (data['user-password']) {
            updatedUser.password = data['user-password'];
        }
        
        // Benutzer speichern
        try {
            users[index] = updatedUser;
            Storage.set('users', users);
            
            // Modal schließen
            UI.closeModal();
            
            // Erfolgsmeldung anzeigen
            UI.showNotification(`Benutzer ${updatedUser.name} wurde erfolgreich aktualisiert.`, 'success');
            
            // Benutzerliste aktualisieren
            this.loadUsers();
            
            // Aktivität protokollieren
            Auth.logAction('user_updated', `Benutzer ${updatedUser.name} (${updatedUser.username}) aktualisiert`);
            
            // Falls der aktuell angemeldete Benutzer aktualisiert wurde, Session aktualisieren
            if (App.session.user && App.session.user.id === updatedUser.id) {
                this.updateSessionUser(updatedUser);
            }
        } catch (e) {
            App.log(`Fehler beim Aktualisieren des Benutzers: ${e.message}`);
            UI.showNotification('Beim Aktualisieren des Benutzers ist ein Fehler aufgetreten.', 'error');
        }
    },
    
    /**
     * Aktualisiert den aktuell angemeldeten Benutzer in der Session
     * @param {Object} updatedUser - Aktualisierter Benutzer
     */
    updateSessionUser: function(updatedUser) {
        App.log('Aktualisiere Session-Benutzer');
        
        // Kopie des aktualisierten Benutzers ohne sensible Daten
        const sessionUser = {
            id: updatedUser.id,
            name: updatedUser.name,
            username: updatedUser.username,
            email: updatedUser.email,
            roles: updatedUser.roles,
            team: updatedUser.team,
            avatar: updatedUser.avatar
        };
        
        // App-Session aktualisieren
        App.session.user = sessionUser;
        
        // Speichere aktualisierte Sitzung
        Storage.set('session', App.session);
        
        // UI aktualisieren
        document.getElementById('user-name').textContent = sessionUser.name;
        document.getElementById('user-avatar').src = sessionUser.avatar || App.config.defaultAvatar;
        
        // Rolle prüfen und ggf. Rolle wechseln, wenn die aktuelle Rolle nicht mehr verfügbar ist
        if (!sessionUser.roles.includes(App.session.currentRole)) {
            // Rolle wechseln zur ersten verfügbaren Rolle
            Auth.switchRole(sessionUser.roles[0]);
        }
    },
    
    /**
     * Zeigt eine Bestätigungsaufforderung vor dem Löschen eines Benutzers
     * @param {string} userId - ID des zu löschenden Benutzers
     */
    confirmDeleteUser: function(userId) {
        App.log(`Bestätigungsdialog zum Löschen des Benutzers mit ID: ${userId}`);
        
        // Benutzer laden
        const users = Storage.get('users') || [];
        const user = users.find(u => u.id === userId);
        
        if (!user) {
            UI.showNotification('Benutzer nicht gefunden.', 'error');
            return;
        }
        
        // Bestätigungsdialog anzeigen
        const content = `
            <p>Sind Sie sicher, dass Sie den Benutzer <strong>${user.name}</strong> (${user.username}) löschen möchten?</p>
            <p>Diese Aktion kann nicht rückgängig gemacht werden.</p>
        `;
        
        const buttons = [
            {
                text: 'Abbrechen',
                handler: () => UI.closeModal(),
                isPrimary: false
            },
            {
                text: 'Löschen',
                handler: () => this.deleteUser(userId),
                isPrimary: true
            }
        ];
        
        UI.showModal('Benutzer löschen', content, buttons);
    }
});
/**
 * JS-Block 3.3: Benutzer löschen
 * 
 * Dieser Modul enthält Funktionen zum sicheren Löschen von Benutzern
 * und die dazugehörige UI-Logik.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const UserDeletion = (function() {
  // Private Variablen und Funktionen
  let confirmedCallback = null;
  
  /**
   * Öffnet den Bestätigungsdialog zum Löschen eines Benutzers
   * @param {string} userId - ID des zu löschenden Benutzers
   * @param {string} userName - Name des zu löschenden Benutzers (für die Anzeige)
   * @param {Function} onConfirm - Callback-Funktion bei Bestätigung
   */
  function showDeleteConfirmation(userId, userName, onConfirm) {
    confirmedCallback = onConfirm;
    
    // Dialog-Element abrufen
    const deleteDialog = document.getElementById('delete-user-dialog');
    const userNameSpan = document.getElementById('delete-user-name');
    const confirmBtn = document.getElementById('confirm-delete-user');
    
    // Benutzernamen im Dialog anzeigen
    userNameSpan.textContent = userName;
    
    // Event-Listener für den Bestätigungsbutton
    confirmBtn.onclick = function() {
      if (typeof confirmedCallback === 'function') {
        confirmedCallback(userId);
      }
      closeDeleteConfirmation();
    };
    
    // Dialog anzeigen
    deleteDialog.classList.remove('hidden');
    document.getElementById('modal-overlay').classList.remove('hidden');
  }
  
  /**
   * Schließt den Bestätigungsdialog
   */
  function closeDeleteConfirmation() {
    const deleteDialog = document.getElementById('delete-user-dialog');
    deleteDialog.classList.add('hidden');
    document.getElementById('modal-overlay').classList.add('hidden');
    confirmedCallback = null;
  }
  
  /**
   * Löscht einen Benutzer aus dem System
   * @param {string} userId - ID des zu löschenden Benutzers
   * @returns {Promise<boolean>} - True wenn erfolgreich gelöscht, sonst false
   */
  async function deleteUser(userId) {
    try {
      // Benutzer aus dem LocalStorage laden
      const users = UserManagement.getAllUsers();
      
      // Prüfen ob der Benutzer existiert
      const userIndex = users.findIndex(user => user.id === userId);
      if (userIndex === -1) {
        console.error('Benutzer nicht gefunden:', userId);
        return false;
      }
      
      // Admin-Benutzer kann nicht gelöscht werden
      if (users[userIndex].role === 'admin' && users[userIndex].username === 'admin') {
        NotificationSystem.showError('Der Hauptadministrator kann nicht gelöscht werden.');
        return false;
      }
      
      // Prüfen, ob der Benutzer Testergebnisse hat, die gelöscht werden müssen
      await cleanupUserData(userId);
      
      // Benutzer aus dem Array entfernen
      users.splice(userIndex, 1);
      
      // Aktualisierte Benutzerliste speichern
      localStorage.setItem('elearning_users', JSON.stringify(users));
      
      // Erfolgsmeldung anzeigen
      NotificationSystem.showSuccess('Benutzer erfolgreich gelöscht.');
      
      // UI aktualisieren
      updateUserList();
      
      return true;
    } catch (error) {
      console.error('Fehler beim Löschen des Benutzers:', error);
      NotificationSystem.showError('Beim Löschen des Benutzers ist ein Fehler aufgetreten.');
      return false;
    }
  }
  
  /**
   * Bereinigt alle mit dem Benutzer verbundenen Daten
   * @param {string} userId - ID des Benutzers
   */
  async function cleanupUserData(userId) {
    try {
      // Testergebnisse des Benutzers löschen
      let testResults = JSON.parse(localStorage.getItem('elearning_test_results') || '[]');
      testResults = testResults.filter(result => result.userId !== userId);
      localStorage.setItem('elearning_test_results', JSON.stringify(testResults));
      
      // Team-Zuweisungen bereinigen
      let teams = JSON.parse(localStorage.getItem('elearning_teams') || '[]');
      teams.forEach(team => {
        if (team.members && team.members.includes(userId)) {
          team.members = team.members.filter(memberId => memberId !== userId);
        }
        
        // Falls der Benutzer ein Teamleiter war, diesen Status entfernen
        if (team.leaderId === userId) {
          team.leaderId = null;
        }
      });
      localStorage.setItem('elearning_teams', JSON.stringify(teams));
      
      // Weitere Datenbereinigungen können hier ergänzt werden
      
      return true;
    } catch (error) {
      console.error('Fehler bei der Datenbereinigung:', error);
      return false;
    }
  }
  
  /**
   * Aktualisiert die Benutzerliste in der UI
   */
  function updateUserList() {
    // Falls die Aktualisierungsfunktion verfügbar ist, aufrufen
    if (typeof UserManagement.renderUserList === 'function') {
      UserManagement.renderUserList();
    }
  }
  
  /**
   * Initialisiert die Event-Listener für die Benutzer-Löschfunktionen
   */
  function initDeleteFunctionality() {
    // Event-Listener für Abbrechen-Button im Dialog
    document.getElementById('cancel-delete-user').addEventListener('click', closeDeleteConfirmation);
    
    // Event-Delegation für Lösch-Buttons in der Benutzerliste
    document.getElementById('user-list-container').addEventListener('click', function(event) {
      // Prüfen, ob auf einen Lösch-Button geklickt wurde
      if (event.target.classList.contains('delete-user-btn') || 
          event.target.closest('.delete-user-btn')) {
        
        const button = event.target.classList.contains('delete-user-btn') ? 
                      event.target : 
                      event.target.closest('.delete-user-btn');
        
        const userId = button.getAttribute('data-user-id');
        const userName = button.getAttribute('data-user-name');
        
        // Bestätigungsdialog anzeigen
        showDeleteConfirmation(userId, userName, deleteUser);
      }
    });
    
    console.log('Benutzer-Löschfunktionalität initialisiert');
  }
  
  // Event-Listener beim Laden der Seite hinzufügen
  document.addEventListener('DOMContentLoaded', function() {
    // Überprüfen, ob wir uns auf der entsprechenden Seite befinden
    if (document.getElementById('user-management-page') || 
        document.getElementById('admin-dashboard')) {
      initDeleteFunctionality();
    }
  });
  
  // Öffentliche API
  return {
    deleteUser: deleteUser,
    showDeleteConfirmation: showDeleteConfirmation,
    closeDeleteConfirmation: closeDeleteConfirmation,
    initDeleteFunctionality: initDeleteFunctionality
  };
})();

// Wenn wir einen NotificationSystem noch nicht haben, fügen wir einen einfachen hinzu
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    }
  };
}

// HTML für den Lösch-Dialog, falls er noch nicht existiert
document.addEventListener('DOMContentLoaded', function() {
  if (!document.getElementById('delete-user-dialog')) {
    const dialogHTML = `
      <div id="modal-overlay" class="modal-overlay hidden"></div>
      <div id="delete-user-dialog" class="modal-dialog hidden">
        <div class="modal-header">
          <h3>Benutzer löschen</h3>
          <button class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <p>Sind Sie sicher, dass Sie den Benutzer <span id="delete-user-name"></span> löschen möchten?</p>
          <p class="warning-text">Dies kann nicht rückgängig gemacht werden. Alle mit diesem Benutzer verbundenen Daten werden gelöscht.</p>
        </div>
        <div class="modal-footer">
          <button id="cancel-delete-user" class="btn btn-secondary">Abbrechen</button>
          <button id="confirm-delete-user" class="btn btn-danger">Löschen</button>
        </div>
      </div>
    `;
    
    // Dialog zum DOM hinzufügen
    const dialogContainer = document.createElement('div');
    dialogContainer.innerHTML = dialogHTML;
    document.body.appendChild(dialogContainer);
  }
});
/**
 * JS-Block 3.4: Teamzuweisung
 * 
 * Dieses Modul enthält Funktionen zur Verwaltung von Teamzuweisungen,
 * einschließlich dem Erstellen von Teams, Hinzufügen und Entfernen von Mitarbeitern 
 * und der Zuweisung von Teamleitern.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const TeamAssignment = (function() {
  // Private Variablen
  let teams = [];
  let currentTeam = null;
  
  /**
   * Team-Datenstruktur:
   * {
   *   id: string,            // Eindeutige ID
   *   name: string,          // Teamname
   *   description: string,   // Teambeschreibung
   *   leaderId: string,      // ID des Teamleiters
   *   members: string[],     // Array von Benutzer-IDs
   *   createdAt: Date,       // Erstellungsdatum
   *   updatedAt: Date        // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Lädt alle Teams aus dem LocalStorage
   * @returns {Array} - Array mit allen Teams
   */
  function loadTeams() {
    try {
      teams = JSON.parse(localStorage.getItem('elearning_teams') || '[]');
      return teams;
    } catch (error) {
      console.error('Fehler beim Laden der Teams:', error);
      return [];
    }
  }
  
  /**
   * Speichert alle Teams im LocalStorage
   */
  function saveTeams() {
    try {
      localStorage.setItem('elearning_teams', JSON.stringify(teams));
      return true;
    } catch (error) {
      console.error('Fehler beim Speichern der Teams:', error);
      return false;
    }
  }
  
  /**
   * Erstellt ein neues Team
   * @param {Object} teamData - Daten des neuen Teams
   * @returns {Object} - Das erstellte Team-Objekt
   */
  function createTeam(teamData) {
    // Erstellen einer eindeutigen ID
    const teamId = 'team_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Neues Team-Objekt
    const newTeam = {
      id: teamId,
      name: teamData.name,
      description: teamData.description || '',
      leaderId: teamData.leaderId || null,
      members: teamData.members || [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Team zum Array hinzufügen
    teams.push(newTeam);
    
    // Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Team erfolgreich erstellt.');
    
    return newTeam;
  }
  
  /**
   * Aktualisiert ein bestehendes Team
   * @param {string} teamId - ID des zu aktualisierenden Teams
   * @param {Object} teamData - Neue Daten für das Team
   * @returns {Object|null} - Das aktualisierte Team oder null bei Fehler
   */
  function updateTeam(teamId, teamData) {
    // Team in der Liste finden
    const teamIndex = teams.findIndex(team => team.id === teamId);
    
    if (teamIndex === -1) {
      console.error('Team nicht gefunden:', teamId);
      return null;
    }
    
    // Team-Objekt aktualisieren
    const updatedTeam = {
      ...teams[teamIndex],
      name: teamData.name || teams[teamIndex].name,
      description: teamData.description !== undefined ? teamData.description : teams[teamIndex].description,
      leaderId: teamData.leaderId !== undefined ? teamData.leaderId : teams[teamIndex].leaderId,
      updatedAt: new Date().toISOString()
    };
    
    // Wenn Mitglieder aktualisiert werden sollen
    if (teamData.members !== undefined) {
      updatedTeam.members = teamData.members;
    }
    
    // Aktualisiertes Team speichern
    teams[teamIndex] = updatedTeam;
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Team erfolgreich aktualisiert.');
    
    return updatedTeam;
  }
  
  /**
   * Löscht ein Team
   * @param {string} teamId - ID des zu löschenden Teams
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteTeam(teamId) {
    // Team-Index finden
    const teamIndex = teams.findIndex(team => team.id === teamId);
    
    if (teamIndex === -1) {
      console.error('Team nicht gefunden:', teamId);
      return false;
    }
    
    // Team aus dem Array entfernen
    teams.splice(teamIndex, 1);
    
    // Aktualisierte Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Team erfolgreich gelöscht.');
    
    return true;
  }
  
  /**
   * Fügt einen Benutzer zu einem Team hinzu
   * @param {string} teamId - ID des Teams
   * @param {string} userId - ID des hinzuzufügenden Benutzers
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function addMemberToTeam(teamId, userId) {
    // Team finden
    const team = teams.find(t => t.id === teamId);
    
    if (!team) {
      console.error('Team nicht gefunden:', teamId);
      return false;
    }
    
    // Prüfen ob Benutzer bereits im Team ist
    if (team.members.includes(userId)) {
      NotificationSystem.showInfo('Benutzer ist bereits Mitglied dieses Teams.');
      return false;
    }
    
    // Benutzer zum Team hinzufügen
    team.members.push(userId);
    team.updatedAt = new Date().toISOString();
    
    // Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Benutzer erfolgreich zum Team hinzugefügt.');
    
    return true;
  }
  
  /**
   * Entfernt einen Benutzer aus einem Team
   * @param {string} teamId - ID des Teams
   * @param {string} userId - ID des zu entfernenden Benutzers
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function removeMemberFromTeam(teamId, userId) {
    // Team finden
    const team = teams.find(t => t.id === teamId);
    
    if (!team) {
      console.error('Team nicht gefunden:', teamId);
      return false;
    }
    
    // Prüfen ob Benutzer im Team ist
    const memberIndex = team.members.indexOf(userId);
    if (memberIndex === -1) {
      console.error('Benutzer ist kein Mitglied dieses Teams:', userId);
      return false;
    }
    
    // Wenn der zu entfernende Benutzer der Teamleiter ist, Teamleiter zurücksetzen
    if (team.leaderId === userId) {
      team.leaderId = null;
    }
    
    // Benutzer aus dem Team entfernen
    team.members.splice(memberIndex, 1);
    team.updatedAt = new Date().toISOString();
    
    // Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Benutzer erfolgreich aus dem Team entfernt.');
    
    return true;
  }
  
  /**
   * Setzt einen Benutzer als Teamleiter
   * @param {string} teamId - ID des Teams
   * @param {string} userId - ID des Benutzers, der Teamleiter werden soll
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function setTeamLeader(teamId, userId) {
    // Team finden
    const team = teams.find(t => t.id === teamId);
    
    if (!team) {
      console.error('Team nicht gefunden:', teamId);
      return false;
    }
    
    // Prüfen ob Benutzer im Team ist, wenn nicht, hinzufügen
    if (!team.members.includes(userId)) {
      team.members.push(userId);
    }
    
    // Benutzer als Teamleiter setzen
    team.leaderId = userId;
    team.updatedAt = new Date().toISOString();
    
    // Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Teamleiter erfolgreich gesetzt.');
    
    return true;
  }
  
  /**
   * Entfernt den Teamleiter (setzt auf null)
   * @param {string} teamId - ID des Teams
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function removeTeamLeader(teamId) {
    // Team finden
    const team = teams.find(t => t.id === teamId);
    
    if (!team) {
      console.error('Team nicht gefunden:', teamId);
      return false;
    }
    
    // Teamleiter entfernen
    team.leaderId = null;
    team.updatedAt = new Date().toISOString();
    
    // Teams speichern
    saveTeams();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Teamleiter erfolgreich entfernt.');
    
    return true;
  }
  
  /**
   * Gibt alle Teams zurück
   * @returns {Array} - Array mit allen Teams
   */
  function getAllTeams() {
    return loadTeams();
  }
  
  /**
   * Gibt ein Team anhand seiner ID zurück
   * @param {string} teamId - ID des Teams
   * @returns {Object|null} - Das Team-Objekt oder null, wenn nicht gefunden
   */
  function getTeamById(teamId) {
    const team = teams.find(t => t.id === teamId);
    return team || null;
  }
  
  /**
   * Gibt alle Teams zurück, in denen ein Benutzer Mitglied ist
   * @param {string} userId - ID des Benutzers
   * @returns {Array} - Array mit allen Teams des Benutzers
   */
  function getTeamsByMember(userId) {
    return teams.filter(team => team.members.includes(userId));
  }
  
  /**
   * Gibt alle Teams zurück, in denen ein Benutzer Teamleiter ist
   * @param {string} userId - ID des Benutzers
   * @returns {Array} - Array mit allen Teams, in denen der Benutzer Teamleiter ist
   */
  function getTeamsByLeader(userId) {
    return teams.filter(team => team.leaderId === userId);
  }
  
  /**
   * Rendert die Team-Verwaltungsoberfläche
   */
  function renderTeamManagement() {
    const container = document.getElementById('team-management-container');
    if (!container) return;
    
    // Aktualisierte Teams laden
    loadTeams();
    
    // HTML für die Teamverwaltung erstellen
    let html = `
      <div class="team-management">
        <div class="team-list-section">
          <h2>Teams</h2>
          <button id="create-team-btn" class="btn btn-primary">Neues Team erstellen</button>
          <div class="team-list">
    `;
    
    // Teams auflisten
    if (teams.length === 0) {
      html += `<p class="no-data-message">Keine Teams vorhanden. Erstellen Sie ein neues Team.</p>`;
    } else {
      html += `<ul class="team-list-items">`;
      teams.forEach(team => {
        html += `
          <li class="team-item" data-team-id="${team.id}">
            <div class="team-name">${team.name}</div>
            <div class="team-actions">
              <button class="btn btn-sm btn-edit edit-team-btn" data-team-id="${team.id}">Bearbeiten</button>
              <button class="btn btn-sm btn-danger delete-team-btn" data-team-id="${team.id}">Löschen</button>
            </div>
          </li>
        `;
      });
      html += `</ul>`;
    }
    
    html += `
          </div>
        </div>
        <div id="team-details-section" class="team-details-section">
          <h2>Team-Details</h2>
          <p class="select-team-message">Wählen Sie ein Team aus oder erstellen Sie ein neues Team.</p>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addTeamManagementEventListeners();
  }
  
  /**
   * Fügt Event-Listener für die Team-Verwaltung hinzu
   */
  function addTeamManagementEventListeners() {
    // Neues Team erstellen
    const createTeamBtn = document.getElementById('create-team-btn');
    if (createTeamBtn) {
      createTeamBtn.addEventListener('click', showCreateTeamForm);
    }
    
    // Event-Delegation für Team-Liste
    const teamList = document.querySelector('.team-list');
    if (teamList) {
      teamList.addEventListener('click', function(event) {
        // Team bearbeiten
        if (event.target.classList.contains('edit-team-btn') || 
            event.target.closest('.edit-team-btn')) {
          const button = event.target.classList.contains('edit-team-btn') ? 
                        event.target : 
                        event.target.closest('.edit-team-btn');
          
          const teamId = button.getAttribute('data-team-id');
          showTeamDetails(teamId);
        }
        
        // Team löschen
        if (event.target.classList.contains('delete-team-btn') || 
            event.target.closest('.delete-team-btn')) {
          const button = event.target.classList.contains('delete-team-btn') ? 
                        event.target : 
                        event.target.closest('.delete-team-btn');
          
          const teamId = button.getAttribute('data-team-id');
          showDeleteTeamConfirmation(teamId);
        }
        
        // Team auswählen
        if (event.target.classList.contains('team-item') || 
            event.target.closest('.team-item')) {
          const listItem = event.target.classList.contains('team-item') ? 
                          event.target : 
                          event.target.closest('.team-item');
          
          const teamId = listItem.getAttribute('data-team-id');
          showTeamDetails(teamId);
        }
      });
    }
  }
  
  /**
   * Zeigt das Formular zum Erstellen eines neuen Teams an
   */
  function showCreateTeamForm() {
    currentTeam = null;
    const detailsSection = document.getElementById('team-details-section');
    
    if (!detailsSection) return;
    
    // Alle Benutzer für die Auswahl laden
    const users = UserManagement.getAllUsers();
    
    // Formular erstellen
    let html = `
      <h2>Neues Team erstellen</h2>
      <form id="team-form">
        <div class="form-group">
          <label for="team-name">Teamname *</label>
          <input type="text" id="team-name" class="form-control" required>
        </div>
        <div class="form-group">
          <label for="team-description">Beschreibung</label>
          <textarea id="team-description" class="form-control"></textarea>
        </div>
        <div class="form-group">
          <label for="team-leader">Teamleiter</label>
          <select id="team-leader" class="form-control">
            <option value="">-- Kein Teamleiter --</option>
    `;
    
    // Benutzer für Teamleiter-Auswahl hinzufügen
    users.forEach(user => {
      // Nur Benutzer mit Teamleiter- oder Admin-Rolle anzeigen
      if (user.role === 'team_leader' || user.role === 'trainer' || user.role === 'admin') {
        html += `<option value="${user.id}">${user.firstName} ${user.lastName} (${user.username})</option>`;
      }
    });
    
    html += `
          </select>
        </div>
        <div class="form-group">
          <label>Teammitglieder</label>
          <div class="member-selection">
    `;
    
    // Benutzer für Mitglieder-Auswahl hinzufügen
    users.forEach(user => {
      html += `
        <div class="member-checkbox">
          <input type="checkbox" id="member-${user.id}" class="member-check" value="${user.id}">
          <label for="member-${user.id}">${user.firstName} ${user.lastName} (${user.username})</label>
        </div>
      `;
    });
    
    html += `
          </div>
        </div>
        <div class="form-actions">
          <button type="button" id="cancel-team-btn" class="btn btn-secondary">Abbrechen</button>
          <button type="submit" class="btn btn-primary">Team speichern</button>
        </div>
      </form>
    `;
    
    // HTML in den Details-Bereich einfügen
    detailsSection.innerHTML = html;
    
    // Event-Listener für das Formular hinzufügen
    const teamForm = document.getElementById('team-form');
    if (teamForm) {
      teamForm.addEventListener('submit', handleTeamFormSubmit);
    }
    
    // Event-Listener für Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-team-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        detailsSection.innerHTML = `
          <h2>Team-Details</h2>
          <p class="select-team-message">Wählen Sie ein Team aus oder erstellen Sie ein neues Team.</p>
        `;
      });
    }
  }
  
  /**
   * Zeigt die Details eines Teams an
   * @param {string} teamId - ID des Teams
   */
  function showTeamDetails(teamId) {
    // Team laden
    currentTeam = getTeamById(teamId);
    if (!currentTeam) return;
    
    const detailsSection = document.getElementById('team-details-section');
    if (!detailsSection) return;
    
    // Alle Benutzer für die Auswahl laden
    const users = UserManagement.getAllUsers();
    
    // Formular erstellen
    let html = `
      <h2>Team bearbeiten: ${currentTeam.name}</h2>
      <form id="team-form">
        <div class="form-group">
          <label for="team-name">Teamname *</label>
          <input type="text" id="team-name" class="form-control" value="${currentTeam.name}" required>
        </div>
        <div class="form-group">
          <label for="team-description">Beschreibung</label>
          <textarea id="team-description" class="form-control">${currentTeam.description || ''}</textarea>
        </div>
        <div class="form-group">
          <label for="team-leader">Teamleiter</label>
          <select id="team-leader" class="form-control">
            <option value="">-- Kein Teamleiter --</option>
    `;
    
    // Benutzer für Teamleiter-Auswahl hinzufügen
    users.forEach(user => {
      // Nur Benutzer mit Teamleiter- oder Admin-Rolle anzeigen
      if (user.role === 'team_leader' || user.role === 'trainer' || user.role === 'admin') {
        const selected = user.id === currentTeam.leaderId ? 'selected' : '';
        html += `<option value="${user.id}" ${selected}>${user.firstName} ${user.lastName} (${user.username})</option>`;
      }
    });
    
    html += `
          </select>
        </div>
        <div class="form-group">
          <label>Teammitglieder</label>
          <div class="member-selection">
    `;
    
    // Benutzer für Mitglieder-Auswahl hinzufügen
    users.forEach(user => {
      const checked = currentTeam.members.includes(user.id) ? 'checked' : '';
      html += `
        <div class="member-checkbox">
          <input type="checkbox" id="member-${user.id}" class="member-check" value="${user.id}" ${checked}>
          <label for="member-${user.id}">${user.firstName} ${user.lastName} (${user.username})</label>
        </div>
      `;
    });
    
    html += `
          </div>
        </div>
        <div class="form-actions">
          <button type="button" id="cancel-team-btn" class="btn btn-secondary">Abbrechen</button>
          <button type="submit" class="btn btn-primary">Team speichern</button>
        </div>
      </form>
    `;
    
    // HTML in den Details-Bereich einfügen
    detailsSection.innerHTML = html;
    
    // Event-Listener für das Formular hinzufügen
    const teamForm = document.getElementById('team-form');
    if (teamForm) {
      teamForm.addEventListener('submit', handleTeamFormSubmit);
    }
    
    // Event-Listener für Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-team-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        detailsSection.innerHTML = `
          <h2>Team-Details</h2>
          <p class="select-team-message">Wählen Sie ein Team aus oder erstellen Sie ein neues Team.</p>
        `;
        currentTeam = null;
      });
    }
  }
  
  /**
   * Verarbeitet das Absenden des Team-Formulars
   * @param {Event} event - Das Formular-Event
   */
  function handleTeamFormSubmit(event) {
    event.preventDefault();
    
    // Formulardaten sammeln
    const name = document.getElementById('team-name').value.trim();
    const description = document.getElementById('team-description').value.trim();
    const leaderId = document.getElementById('team-leader').value;
    
    // Teammitglieder auslesen
    const members = [];
    const memberCheckboxes = document.querySelectorAll('.member-check:checked');
    memberCheckboxes.forEach(checkbox => {
      members.push(checkbox.value);
    });
    
    // Sicherstellen, dass der Teamleiter auch Mitglied ist
    if (leaderId && !members.includes(leaderId)) {
      members.push(leaderId);
    }
    
    // Team-Daten zusammenstellen
    const teamData = {
      name,
      description,
      leaderId: leaderId || null,
      members
    };
    
    // Neues Team erstellen oder bestehendes aktualisieren
    if (currentTeam) {
      updateTeam(currentTeam.id, teamData);
    } else {
      createTeam(teamData);
    }
    
    // Team-Verwaltung neu rendern
    renderTeamManagement();
  }
  
  /**
   * Zeigt eine Bestätigungsabfrage zum Löschen eines Teams
   * @param {string} teamId - ID des zu löschenden Teams
   */
  function showDeleteTeamConfirmation(teamId) {
    const team = getTeamById(teamId);
    if (!team) return;
    
    // Bestätigungsdialog anzeigen
    if (confirm(`Sind Sie sicher, dass Sie das Team "${team.name}" löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.`)) {
      deleteTeam(teamId);
      renderTeamManagement();
    }
  }
  
  /**
   * Initialisiert das Team-Management-Modul
   */
  function init() {
    // Teams laden
    loadTeams();
    
    // Event-Listener für Team-Verwaltungsseite
    document.addEventListener('DOMContentLoaded', function() {
      // Prüfen, ob wir uns auf der Team-Verwaltungsseite befinden
      if (document.getElementById('team-management-container')) {
        renderTeamManagement();
      }
    });
    
    console.log('Team-Zuweisungsmodul initialisiert');
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    getAllTeams: getAllTeams,
    getTeamById: getTeamById,
    getTeamsByMember: getTeamsByMember,
    getTeamsByLeader: getTeamsByLeader,
    createTeam: createTeam,
    updateTeam: updateTeam,
    deleteTeam: deleteTeam,
    addMemberToTeam: addMemberToTeam,
    removeMemberFromTeam: removeMemberFromTeam,
    setTeamLeader: setTeamLeader,
    removeTeamLeader: removeTeamLeader,
    renderTeamManagement: renderTeamManagement
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
}
/**
 * JS-Block 3.5: Avatar-Verwaltung
 * 
 * Dieses Modul ermöglicht die Verwaltung von Benutzeravataren,
 * einschließlich der Auswahl von Standardavataren und dem Hochladen
 * eigener Bilder.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const AvatarManagement = (function() {
  // Private Variablen
  const DEFAULT_AVATAR = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2U0ZTRlNCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiNhYWEiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iI2FhYSIvPjwvc3ZnPg==';
  const MAX_AVATAR_SIZE = 500 * 1024; // 500KB max size
  const AVATAR_DIMENSION = 256; // Standardgröße für Avatare
  
  // Standardavatare
  const defaultAvatars = [
    // Einfaches Gesicht mit ImmoScout-Farbe
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iIzAwRkZEMCIvPjxjaXJjbGUgY3g9IjgwIiBjeT0iOTAiIHI9IjE1IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTc2IiBjeT0iOTAiIHI9IjE1IiBmaWxsPSIjMDAwIi8+PHBhdGggZD0iTTY0LDE1NiBhODAgNTAgMCAwIDAgMTI4IDAiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIi8+PC9zdmc+',
    
    // Benutzer-Icon mit ImmoScout-Farbe
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iIzAwRkZEMCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiMwMDMwNDQiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iIzAwMzA0NCIvPjwvc3ZnPg==',
    
    // Haus-Icon mit ImmoScout-Farbe
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMjggNDBMMzAgMTEwaDE4MHoiIGZpbGw9IiMwMEZGRDAiLz48cmVjdCB4PSI2MCIgeT0iMTEwIiB3aWR0aD0iMTM2IiBoZWlnaHQ9IjEwNiIgZmlsbD0iIzAwRkZEMCIvPjxyZWN0IHg9IjEwMCIgeT0iMTYwIiB3aWR0aD0iNTYiIGhlaWdodD0iNTYiIGZpbGw9IiNmZmYiLz48cmVjdCB4PSIxMTgiIHk9IjE0MCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiBmaWxsPSIjMDAzMDQ0Ii8+PC9zdmc+',
    
    // Abstrakte Form mit ImmoScout-Farbe
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2ZmZiIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEyOCIgcj0iODAiIGZpbGw9IiMwMEZGRDAiLz48cmVjdCB4PSI5OCIgeT0iOTgiIHdpZHRoPSI2MCIgaGVpZ2h0PSI2MCIgZmlsbD0iIzAwMzA0NCIvPjwvc3ZnPg==',
    
    // Immobilien-Agent mit ImmoScout-Farbe
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2ZmZiIvPjxyZWN0IHg9IjcwIiB5PSI2MCIgd2lkdGg9IjExNiIgaGVpZ2h0PSIxMzYiIGZpbGw9IiMwMEZGRDAiLz48Y2lyY2xlIGN4PSIxMjgiIGN5PSI2MCIgcj0iMzAiIGZpbGw9IiMwMDMwNDQiLz48cmVjdCB4PSIxMTMiIHk9IjkwIiB3aWR0aD0iMzAiIGhlaWdodD0iNzYiIGZpbGw9IiMwMDMwNDQiLz48cGF0aCBkPSJNODUgMTIwIEw2MCAxODAgTDExMCAxODAiIGZpbGw9IiMwMDMwNDQiLz48cGF0aCBkPSJNMTcxIDEyMCBMMTk2IDE4MCBMMTQ2IDE4MCIgZmlsbD0iIzAwMzA0NCIvPjwvc3ZnPg==',
    
    // Abstrakte Form mit ImmoScout-Farbe 2
    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0zMCAzMCBMMjI2IDMwIEwxMjggMTI4IFoiIGZpbGw9IiMwMEZGRDAiLz48cGF0aCBkPSJNMzAgMjI2IEwyMjYgMjI2IEwxMjggMTI4IFoiIGZpbGw9IiMwMDMwNDQiLz48Y2lyY2xlIGN4PSIxMjgiIGN5PSIxMjgiIHI9IjIwIiBmaWxsPSIjZmZmIi8+PC9zdmc+',
  ];
  
  /**
   * Initialisiert die Avatar-Verwaltung
   */
  function init() {
    // Event-Listener beim Laden der Seite hinzufügen
    document.addEventListener('DOMContentLoaded', function() {
      // Überprüfen, ob wir uns auf der entsprechenden Seite befinden
      if (document.getElementById('avatar-selection-container')) {
        renderAvatarSelection();
      }
    });
    
    console.log('Avatar-Verwaltung initialisiert');
  }
  
  /**
   * Rendert die Avatar-Auswahl in einen Container
   * @param {string} containerId - ID des Containers
   * @param {string} selectedAvatar - URL des aktuell ausgewählten Avatars
   * @param {Function} onSelect - Callback-Funktion, die bei Auswahl aufgerufen wird
   */
  function renderAvatarSelection(containerId = 'avatar-selection-container', selectedAvatar = null, onSelect = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // HTML für die Avatar-Auswahl erstellen
    let html = `
      <div class="avatar-selection">
        <div class="avatar-selection-header">
          <h3>Avatar auswählen</h3>
        </div>
        
        <div class="current-avatar-container">
          <div class="current-avatar-label">Aktueller Avatar:</div>
          <div class="current-avatar">
            <img src="${selectedAvatar || DEFAULT_AVATAR}" alt="Aktueller Avatar" id="current-avatar-img">
          </div>
        </div>
        
        <div class="avatar-options-container">
          <div class="avatar-options-label">Standard-Avatare:</div>
          <div class="avatar-options">
    `;
    
    // Standardavatare hinzufügen
    defaultAvatars.forEach((avatarSrc, index) => {
      const isSelected = avatarSrc === selectedAvatar;
      html += `
        <div class="avatar-option ${isSelected ? 'selected' : ''}" data-avatar-src="${avatarSrc}">
          <img src="${avatarSrc}" alt="Avatar Option ${index + 1}">
        </div>
      `;
    });
    
    html += `
          </div>
        </div>
        
        <div class="avatar-upload-container">
          <div class="avatar-upload-label">Eigenen Avatar hochladen:</div>
          <div class="avatar-upload">
            <input type="file" id="avatar-upload-input" accept="image/*" class="hidden">
            <label for="avatar-upload-input" class="btn btn-secondary">Bild auswählen</label>
            <div class="upload-info">Max. 500KB, wird auf 256x256px angepasst</div>
          </div>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener für die Avatar-Auswahl hinzufügen
    addAvatarSelectionEventListeners(container, onSelect);
  }
  
  /**
   * Fügt Event-Listener für die Avatar-Auswahl hinzu
   * @param {HTMLElement} container - Der Container mit der Avatar-Auswahl
   * @param {Function} onSelect - Callback-Funktion, die bei Auswahl aufgerufen wird
   */
  function addAvatarSelectionEventListeners(container, onSelect) {
    // Event-Listener für die Standard-Avatare
    const avatarOptions = container.querySelectorAll('.avatar-option');
    avatarOptions.forEach(option => {
      option.addEventListener('click', function() {
        // Ausgewählten Avatar markieren
        avatarOptions.forEach(opt => opt.classList.remove('selected'));
        this.classList.add('selected');
        
        // Avatar-URL abrufen
        const avatarSrc = this.getAttribute('data-avatar-src');
        
        // Aktuellen Avatar aktualisieren
        document.getElementById('current-avatar-img').src = avatarSrc;
        
        // Callback aufrufen, wenn vorhanden
        if (typeof onSelect === 'function') {
          onSelect(avatarSrc);
        }
      });
    });
    
    // Event-Listener für den Datei-Upload
    const fileInput = container.querySelector('#avatar-upload-input');
    if (fileInput) {
      fileInput.addEventListener('change', handleAvatarUpload);
    }
  }
  
  /**
   * Verarbeitet den Upload eines Avatarbildes
   * @param {Event} event - Das Change-Event des Datei-Inputs
   */
  function handleAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Dateigröße prüfen
    if (file.size > MAX_AVATAR_SIZE) {
      NotificationSystem.showError('Die ausgewählte Datei ist zu groß. Maximale Größe: 500KB.');
      event.target.value = ''; // Dateiauswahl zurücksetzen
      return;
    }
    
    // Prüfen, ob es sich um ein Bild handelt
    if (!file.type.startsWith('image/')) {
      NotificationSystem.showError('Bitte wählen Sie eine Bilddatei aus.');
      event.target.value = ''; // Dateiauswahl zurücksetzen
      return;
    }
    
    // Bild einlesen und verarbeiten
    const reader = new FileReader();
    reader.onload = function(e) {
      resizeAndCropImage(e.target.result, function(resizedImageData) {
        // Aktuellen Avatar aktualisieren
        document.getElementById('current-avatar-img').src = resizedImageData;
        
        // Alle Avatar-Optionen deselektieren
        const avatarOptions = document.querySelectorAll('.avatar-option');
        avatarOptions.forEach(opt => opt.classList.remove('selected'));
        
        // Callback aufrufen, wenn vorhanden
        const container = document.getElementById('avatar-selection-container');
        if (container && container.onSelectCallback) {
          container.onSelectCallback(resizedImageData);
        }
      });
    };
    reader.readAsDataURL(file);
  }
  
  /**
   * Passt ein Bild auf die Standardgröße an und schneidet es zu
   * @param {string} imageData - Das Bild als Data-URL
   * @param {Function} callback - Callback-Funktion, die mit dem angepassten Bild aufgerufen wird
   */
  function resizeAndCropImage(imageData, callback) {
    const img = new Image();
    img.onload = function() {
      const canvas = document.createElement('canvas');
      canvas.width = AVATAR_DIMENSION;
      canvas.height = AVATAR_DIMENSION;
      const ctx = canvas.getContext('2d');
      
      // Bildgröße berechnen, um quadratischen Ausschnitt zu erhalten
      const size = Math.min(img.width, img.height);
      const x = (img.width - size) / 2;
      const y = (img.height - size) / 2;
      
      // Bild auf Canvas zeichnen und zuschneiden
      ctx.drawImage(img, x, y, size, size, 0, 0, AVATAR_DIMENSION, AVATAR_DIMENSION);
      
      // Angepasstes Bild als Data-URL zurückgeben
      callback(canvas.toDataURL('image/png'));
    };
    img.src = imageData;
  }
  
  /**
   * Aktualisiert den Avatar eines Benutzers
   * @param {string} userId - ID des Benutzers
   * @param {string} avatarSrc - URL des Avatars
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateUserAvatar(userId, avatarSrc) {
    try {
      // Benutzer aus dem LocalStorage laden
      const users = JSON.parse(localStorage.getItem('elearning_users') || '[]');
      
      // Benutzer finden
      const userIndex = users.findIndex(user => user.id === userId);
      if (userIndex === -1) {
        console.error('Benutzer nicht gefunden:', userId);
        return false;
      }
      
      // Avatar aktualisieren
      users[userIndex].avatar = avatarSrc;
      
      // Aktualisierte Benutzerliste speichern
      localStorage.setItem('elearning_users', JSON.stringify(users));
      
      // Erfolgsmeldung anzeigen
      NotificationSystem.showSuccess('Avatar erfolgreich aktualisiert.');
      
      return true;
    } catch (error) {
      console.error('Fehler beim Aktualisieren des Avatars:', error);
      NotificationSystem.showError('Beim Aktualisieren des Avatars ist ein Fehler aufgetreten.');
      return false;
    }
  }
  
  /**
   * Gibt den Avatar eines Benutzers zurück
   * @param {string} userId - ID des Benutzers
   * @returns {string} - URL des Avatars oder Standard-Avatar, wenn nicht gefunden
   */
  function getUserAvatar(userId) {
    try {
      // Benutzer aus dem LocalStorage laden
      const users = JSON.parse(localStorage.getItem('elearning_users') || '[]');
      
      // Benutzer finden
      const user = users.find(user => user.id === userId);
      if (!user) {
        console.error('Benutzer nicht gefunden:', userId);
        return DEFAULT_AVATAR;
      }
      
      // Avatar zurückgeben oder Standard-Avatar, wenn nicht vorhanden
      return user.avatar || DEFAULT_AVATAR;
    } catch (error) {
      console.error('Fehler beim Abrufen des Avatars:', error);
      return DEFAULT_AVATAR;
    }
  }
  
  /**
   * Rendert einen Avatar-Auswahl-Dialog
   * @param {string} userId - ID des Benutzers
   * @param {Function} onSave - Callback-Funktion, die beim Speichern aufgerufen wird
   */
  function showAvatarSelectionDialog(userId, onSave = null) {
    // Aktuellen Avatar des Benutzers abrufen
    const currentAvatar = getUserAvatar(userId);
    
    // Dialog-Element erstellen
    const dialog = document.createElement('div');
    dialog.className = 'modal-dialog avatar-selection-dialog';
    dialog.id = 'avatar-selection-dialog';
    
    // Dialog-Inhalt erstellen
    dialog.innerHTML = `
      <div class="modal-header">
        <h3>Avatar ändern</h3>
        <button class="close-btn">&times;</button>
      </div>
      <div class="modal-body">
        <div id="avatar-dialog-container"></div>
      </div>
      <div class="modal-footer">
        <button id="cancel-avatar-btn" class="btn btn-secondary">Abbrechen</button>
        <button id="save-avatar-btn" class="btn btn-primary">Speichern</button>
      </div>
    `;
    
    // Dialog zum DOM hinzufügen
    document.body.appendChild(dialog);
    
    // Modal-Overlay erstellen und hinzufügen
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'avatar-dialog-overlay';
    document.body.appendChild(overlay);
    
    // Avatar-Auswahl im Dialog anzeigen
    renderAvatarSelection('avatar-dialog-container', currentAvatar);
    
    // Ausgewählten Avatar speichern
    let selectedAvatar = currentAvatar;
    const avatarDialogContainer = document.getElementById('avatar-dialog-container');
    avatarDialogContainer.onSelectCallback = function(avatarSrc) {
      selectedAvatar = avatarSrc;
    };
    
    // Event-Listener für Buttons hinzufügen
    document.querySelector('#avatar-selection-dialog .close-btn').addEventListener('click', closeAvatarDialog);
    document.getElementById('cancel-avatar-btn').addEventListener('click', closeAvatarDialog);
    document.getElementById('save-avatar-btn').addEventListener('click', function() {
      // Avatar speichern
      if (updateUserAvatar(userId, selectedAvatar)) {
        // Callback aufrufen, wenn vorhanden
        if (typeof onSave === 'function') {
          onSave(selectedAvatar);
        }
      }
      
      // Dialog schließen
      closeAvatarDialog();
    });
  }
  
  /**
   * Schließt den Avatar-Auswahl-Dialog
   */
  function closeAvatarDialog() {
    // Dialog und Overlay entfernen
    const dialog = document.getElementById('avatar-selection-dialog');
    const overlay = document.getElementById('avatar-dialog-overlay');
    
    if (dialog) {
      dialog.parentNode.removeChild(dialog);
    }
    
    if (overlay) {
      overlay.parentNode.removeChild(overlay);
    }
  }
  
  /**
   * Rendert einen Avatar in einem Element
   * @param {string} elementId - ID des Elements
   * @param {string} userId - ID des Benutzers
   * @param {string} size - Größe des Avatars ('small', 'medium', 'large')
   */
  function renderAvatar(elementId, userId, size = 'medium') {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    // Avatar-URL abrufen
    const avatarSrc = getUserAvatar(userId);
    
    // CSS-Klasse basierend auf der Größe
    const sizeClass = `avatar-${size}`;
    
    // Avatar-HTML erstellen
    const avatarHTML = `
      <div class="avatar ${sizeClass}">
        <img src="${avatarSrc}" alt="Benutzer-Avatar" class="avatar-img">
      </div>
    `;
    
    // HTML in das Element einfügen
    element.innerHTML = avatarHTML;
  }
  
  /**
   * Fügt eine Avatar-Auswahl zu einem Benutzerformular hinzu
   * @param {string} formId - ID des Formulars
   * @param {string} userId - ID des Benutzers (null für neuen Benutzer)
   */
  function addAvatarToUserForm(formId, userId = null) {
    const form = document.getElementById(formId);
    if (!form) return;
    
    // Prüfen, ob bereits ein Avatar-Container existiert
    let avatarContainer = form.querySelector('.avatar-form-container');
    if (!avatarContainer) {
      // Container erstellen
      avatarContainer = document.createElement('div');
      avatarContainer.className = 'avatar-form-container';
      
      // Vor dem ersten Input einfügen
      const firstInput = form.querySelector('input, select, textarea');
      if (firstInput) {
        firstInput.parentNode.insertBefore(avatarContainer, firstInput);
      } else {
        form.appendChild(avatarContainer);
      }
    }
    
    // Aktuellen Avatar abrufen oder Standard-Avatar verwenden
    const avatarSrc = userId ? getUserAvatar(userId) : DEFAULT_AVATAR;
    
    // Avatar-Container füllen
    avatarContainer.innerHTML = `
      <div class="avatar-preview">
        <img src="${avatarSrc}" alt="Avatar" id="avatar-preview-img">
      </div>
      <input type="hidden" name="avatar" id="avatar-input" value="${avatarSrc}">
      <button type="button" class="btn btn-secondary btn-sm" id="change-avatar-btn">Avatar ändern</button>
    `;
    
    // Event-Listener für den Avatar-Ändern-Button
    document.getElementById('change-avatar-btn').addEventListener('click', function() {
      showAvatarSelectionDialog(userId, function(newAvatarSrc) {
        // Avatar im Formular aktualisieren
        document.getElementById('avatar-preview-img').src = newAvatarSrc;
        document.getElementById('avatar-input').value = newAvatarSrc;
      });
    });
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    DEFAULT_AVATAR: DEFAULT_AVATAR,
    defaultAvatars: defaultAvatars,
    renderAvatarSelection: renderAvatarSelection,
    updateUserAvatar: updateUserAvatar,
    getUserAvatar: getUserAvatar,
    showAvatarSelectionDialog: showAvatarSelectionDialog,
    renderAvatar: renderAvatar,
    addAvatarToUserForm: addAvatarToUserForm
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
}

// CSS für die Avatar-Verwaltung
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Avatare existiert
  if (!document.getElementById('avatar-management-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'avatar-management-styles';
    styleElement.textContent = `
      /* Avatar-Größen */
      .avatar {
        border-radius: 50%;
        overflow: hidden;
        background-color: #f0f0f0;
      }
      
      .avatar-small {
        width: 32px;
        height: 32px;
      }
      
      .avatar-medium {
        width: 64px;
        height: 64px;
      }
      
      .avatar-large {
        width: 128px;
        height: 128px;
      }
      
      .avatar-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      /* Avatar-Auswahl */
      .avatar-selection {
        padding: 15px;
      }
      
      .avatar-selection-header {
        margin-bottom: 15px;
      }
      
      .current-avatar-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .current-avatar-label {
        margin-right: 15px;
        font-weight: bold;
      }
      
      .current-avatar {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        overflow: hidden;
        border: 2px solid #00FFD0;
      }
      
      .current-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .avatar-options-container {
        margin-bottom: 20px;
      }
      
      .avatar-options-label {
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .avatar-options {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .avatar-option {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        overflow: hidden;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.2s ease;
      }
      
      .avatar-option:hover {
        border-color: #00FFD0;
      }
      
      .avatar-option.selected {
        border-color: #00FFD0;
        box-shadow: 0 0 0 2px rgba(0, 255, 208, 0.5);
      }
      
      .avatar-option img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .avatar-upload-container {
        margin-top: 20px;
      }
      
      .avatar-upload-label {
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .upload-info {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
      }
      
      .hidden {
        display: none;
      }
      
      /* Avatar im Formular */
      .avatar-form-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .avatar-preview {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        overflow: hidden;
        margin-right: 15px;
        border: 2px solid #00FFD0;
      }
      
      .avatar-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      /* Avatar-Dialog */
      .avatar-selection-dialog {
        width: 90%;
        max-width: 600px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1001;
      }
      
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
      }
      
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .modal-header h3 {
        margin: 0;
      }
      
      .close-btn {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
      }
      
      .modal-body {
        padding: 15px;
        max-height: 70vh;
        overflow-y: auto;
      }
      
      .modal-footer {
        padding: 15px;
        border-top: 1px solid #eee;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 3.6: Benutzersuche
 * 
 * Dieses Modul ermöglicht die Suche nach Benutzern
 * mit verschiedenen Filtermöglichkeiten und
 * einer benutzerfreundlichen Oberfläche.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const UserSearch = (function() {
  // Private Variablen
  let lastSearchQuery = '';
  let lastSearchFilter = 'all';
  
  /**
   * Sucht nach Benutzern basierend auf Suchbegriff und Filter
   * @param {string} query - Suchbegriff
   * @param {string} filter - Filterkriterium (all, name, username, email, role, team)
   * @param {Array} [users] - Optional: Benutzerliste für die Suche
   * @returns {Array} - Gefilterte Benutzerliste
   */
  function searchUsers(query, filter = 'all', users = null) {
    // Suche speichern für eventuelle Wiederholung
    lastSearchQuery = query;
    lastSearchFilter = filter;
    
    // Suchbegriff normalisieren
    query = query.trim().toLowerCase();
    
    // Wenn kein Suchbegriff, alle Benutzer zurückgeben
    if (query === '') {
      return users || UserManagement.getAllUsers();
    }
    
    // Benutzerliste abrufen, wenn nicht übergeben
    if (!users) {
      users = UserManagement.getAllUsers();
    }
    
    // Filtern der Benutzer nach Suchbegriff und Filter
    return users.filter(user => {
      switch (filter) {
        case 'name':
          // Nach Vor- und Nachname suchen
          return (
            (user.firstName?.toLowerCase() || '').includes(query) ||
            (user.lastName?.toLowerCase() || '').includes(query) ||
            (user.firstName + ' ' + user.lastName).toLowerCase().includes(query)
          );
        
        case 'username':
          // Nach Benutzernamen suchen
          return (user.username?.toLowerCase() || '').includes(query);
        
        case 'email':
          // Nach E-Mail suchen
          return (user.email?.toLowerCase() || '').includes(query);
        
        case 'role':
          // Nach Rolle suchen
          return (user.role?.toLowerCase() || '').includes(query);
        
        case 'team':
          // Nach Team suchen
          // Hier müssen wir die Teams des Benutzers überprüfen
          return isUserInTeamByName(user.id, query);
        
        case 'all':
        default:
          // In allen Feldern suchen
          return (
            (user.firstName?.toLowerCase() || '').includes(query) ||
            (user.lastName?.toLowerCase() || '').includes(query) ||
            (user.username?.toLowerCase() || '').includes(query) ||
            (user.email?.toLowerCase() || '').includes(query) ||
            (user.role?.toLowerCase() || '').includes(query) ||
            isUserInTeamByName(user.id, query)
          );
      }
    });
  }
  
  /**
   * Prüft, ob ein Benutzer in einem Team mit bestimmtem Namen ist
   * @param {string} userId - ID des Benutzers
   * @param {string} teamNameQuery - Suchbegriff für den Teamnamen
   * @returns {boolean} - true, wenn der Benutzer in einem Team mit entsprechendem Namen ist
   */
  function isUserInTeamByName(userId, teamNameQuery) {
    // Prüfen, ob das TeamAssignment-Modul verfügbar ist
    if (typeof TeamAssignment === 'undefined' || !TeamAssignment.getAllTeams) {
      return false;
    }
    
    // Teams des Benutzers abrufen
    const teams = TeamAssignment.getTeamsByMember(userId);
    
    // Prüfen, ob der Benutzer in einem Team mit entsprechendem Namen ist
    return teams.some(team => 
      (team.name?.toLowerCase() || '').includes(teamNameQuery.toLowerCase())
    );
  }
  
  /**
   * Rendert die Benutzersuche in einen Container
   * @param {string} containerId - ID des Containers
   * @param {Function} onResultsRendered - Callback-Funktion nach dem Rendern der Ergebnisse
   */
  function renderUserSearch(containerId, onResultsRendered = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // HTML für die Suchoberfläche erstellen
    let html = `
      <div class="user-search">
        <div class="search-form">
          <div class="search-input-group">
            <input type="text" id="search-query" class="form-control" placeholder="Benutzer suchen..." value="${lastSearchQuery}">
            <select id="search-filter" class="form-control">
              <option value="all" ${lastSearchFilter === 'all' ? 'selected' : ''}>Alle Felder</option>
              <option value="name" ${lastSearchFilter === 'name' ? 'selected' : ''}>Name</option>
              <option value="username" ${lastSearchFilter === 'username' ? 'selected' : ''}>Benutzername</option>
              <option value="email" ${lastSearchFilter === 'email' ? 'selected' : ''}>E-Mail</option>
              <option value="role" ${lastSearchFilter === 'role' ? 'selected' : ''}>Rolle</option>
              <option value="team" ${lastSearchFilter === 'team' ? 'selected' : ''}>Team</option>
            </select>
            <button id="search-button" class="btn btn-primary">Suchen</button>
          </div>
          <div class="search-filter-tags" id="search-filter-tags"></div>
        </div>
        
        <div class="search-results-container" id="search-results">
          <p class="search-prompt">Geben Sie einen Suchbegriff ein, um Benutzer zu finden.</p>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addSearchEventListeners(containerId, onResultsRendered);
    
    // Wenn bereits eine Suche durchgeführt wurde, Ergebnisse anzeigen
    if (lastSearchQuery) {
      performSearch(containerId, onResultsRendered);
    }
  }
  
  /**
   * Fügt Event-Listener für die Suche hinzu
   * @param {string} containerId - ID des Containers
   * @param {Function} onResultsRendered - Callback-Funktion nach dem Rendern der Ergebnisse
   */
  function addSearchEventListeners(containerId, onResultsRendered) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Event-Listener für den Such-Button
    const searchButton = container.querySelector('#search-button');
    if (searchButton) {
      searchButton.addEventListener('click', function() {
        performSearch(containerId, onResultsRendered);
      });
    }
    
    // Event-Listener für Eingabefeld (Suche bei Enter)
    const searchInput = container.querySelector('#search-query');
    if (searchInput) {
      searchInput.addEventListener('keyup', function(event) {
        if (event.key === 'Enter') {
          performSearch(containerId, onResultsRendered);
        }
      });
    }
    
    // Event-Listener für Filter-Tags
    updateFilterTags(container);
  }
  
  /**
   * Führt die Suche durch und rendert die Ergebnisse
   * @param {string} containerId - ID des Containers
   * @param {Function} onResultsRendered - Callback-Funktion nach dem Rendern der Ergebnisse
   */
  function performSearch(containerId, onResultsRendered) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Suchparameter abrufen
    const query = container.querySelector('#search-query').value;
    const filter = container.querySelector('#search-filter').value;
    
    // Suche durchführen
    const results = searchUsers(query, filter);
    
    // Ergebnisse anzeigen
    renderSearchResults(containerId, results, onResultsRendered);
    
    // Filter-Tags aktualisieren
    updateFilterTags(container);
  }
  
  /**
   * Rendert die Suchergebnisse
   * @param {string} containerId - ID des Containers
   * @param {Array} results - Suchergebnisse
   * @param {Function} onResultsRendered - Callback-Funktion nach dem Rendern der Ergebnisse
   */
  function renderSearchResults(containerId, results, onResultsRendered) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const resultsContainer = container.querySelector('#search-results');
    if (!resultsContainer) return;
    
    // Wenn keine Ergebnisse, entsprechende Nachricht anzeigen
    if (results.length === 0) {
      resultsContainer.innerHTML = `
        <div class="no-results">
          <p>Keine Benutzer gefunden.</p>
        </div>
      `;
      
      // Callback aufrufen
      if (typeof onResultsRendered === 'function') {
        onResultsRendered(results);
      }
      
      return;
    }
    
    // HTML für die Ergebnistabelle erstellen
    let html = `
      <div class="search-results">
        <div class="results-header">
          <span>${results.length} Benutzer gefunden</span>
        </div>
        <table class="results-table">
          <thead>
            <tr>
              <th>Avatar</th>
              <th>Name</th>
              <th>Benutzername</th>
              <th>E-Mail</th>
              <th>Rolle</th>
              <th>Teams</th>
              <th>Aktionen</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    // Zeilen für jeden Benutzer hinzufügen
    results.forEach(user => {
      // Avatar-URL abrufen oder Standard-Avatar verwenden
      const avatarSrc = typeof AvatarManagement !== 'undefined' && AvatarManagement.getUserAvatar
                      ? AvatarManagement.getUserAvatar(user.id)
                      : (user.avatar || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2U0ZTRlNCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiNhYWEiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iI2FhYSIvPjwvc3ZnPg==');
      
      // Benutzer-Teams abrufen
      let teamNames = [];
      if (typeof TeamAssignment !== 'undefined' && TeamAssignment.getTeamsByMember) {
        const userTeams = TeamAssignment.getTeamsByMember(user.id);
        teamNames = userTeams.map(team => team.name);
      }
      
      // Lokalisierte Rollennamen
      const roleNames = {
        'admin': 'Administrator',
        'trainer': 'Trainer',
        'team_leader': 'Teamleiter',
        'employee': 'Mitarbeiter'
      };
      
      // Formatierte Rolle
      const roleName = roleNames[user.role] || user.role;
      
      html += `
        <tr data-user-id="${user.id}">
          <td>
            <div class="user-avatar">
              <img src="${avatarSrc}" alt="Avatar" class="avatar-small">
            </div>
          </td>
          <td>${user.firstName} ${user.lastName}</td>
          <td>${user.username}</td>
          <td>${user.email || '-'}</td>
          <td>${roleName}</td>
          <td>${teamNames.length > 0 ? teamNames.join(', ') : '-'}</td>
          <td>
            <div class="action-buttons">
              <button class="btn btn-sm btn-primary view-user-btn" data-user-id="${user.id}">Ansehen</button>
              <button class="btn btn-sm btn-edit edit-user-btn" data-user-id="${user.id}">Bearbeiten</button>
            </div>
          </td>
        </tr>
      `;
    });
    
    html += `
          </tbody>
        </table>
      </div>
    `;
    
    // HTML in den Container einfügen
    resultsContainer.innerHTML = html;
    
    // Event-Listener für Aktionsbuttons hinzufügen
    addResultActionListeners(resultsContainer);
    
    // Callback aufrufen
    if (typeof onResultsRendered === 'function') {
      onResultsRendered(results);
    }
  }
  
  /**
   * Fügt Event-Listener für die Aktionsbuttons in den Suchergebnissen hinzu
   * @param {HTMLElement} resultsContainer - Container mit den Suchergebnissen
   */
  function addResultActionListeners(resultsContainer) {
    // Event-Listener für "Ansehen"-Buttons
    const viewButtons = resultsContainer.querySelectorAll('.view-user-btn');
    viewButtons.forEach(button => {
      button.addEventListener('click', function() {
        const userId = this.getAttribute('data-user-id');
        viewUser(userId);
      });
    });
    
    // Event-Listener für "Bearbeiten"-Buttons
    const editButtons = resultsContainer.querySelectorAll('.edit-user-btn');
    editButtons.forEach(button => {
      button.addEventListener('click', function() {
        const userId = this.getAttribute('data-user-id');
        editUser(userId);
      });
    });
  }
  
  /**
   * Zeigt Benutzerdetails an
   * @param {string} userId - ID des Benutzers
   */
  function viewUser(userId) {
    // Prüfen, ob UserManagement-Modul verfügbar ist
    if (typeof UserManagement === 'undefined' || !UserManagement.viewUserDetails) {
      console.error('UserManagement-Modul nicht verfügbar');
      return;
    }
    
    // Benutzerdetails anzeigen
    UserManagement.viewUserDetails(userId);
  }
  
  /**
   * Öffnet das Bearbeitungsformular für einen Benutzer
   * @param {string} userId - ID des Benutzers
   */
  function editUser(userId) {
    // Prüfen, ob UserManagement-Modul verfügbar ist
    if (typeof UserManagement === 'undefined' || !UserManagement.editUser) {
      console.error('UserManagement-Modul nicht verfügbar');
      return;
    }
    
    // Benutzerformular öffnen
    UserManagement.editUser(userId);
  }
  
  /**
   * Aktualisiert die Filter-Tags basierend auf der aktuellen Suche
   * @param {HTMLElement} container - Der Container mit der Suchoberfläche
   */
  function updateFilterTags(container) {
    const tagsContainer = container.querySelector('#search-filter-tags');
    if (!tagsContainer) return;
    
    // Wenn kein Suchbegriff, Container leeren
    if (!lastSearchQuery) {
      tagsContainer.innerHTML = '';
      return;
    }
    
    // Filtertext basierend auf dem gewählten Filter
    let filterText = '';
    switch (lastSearchFilter) {
      case 'name':
        filterText = 'Name';
        break;
      case 'username':
        filterText = 'Benutzername';
        break;
      case 'email':
        filterText = 'E-Mail';
        break;
      case 'role':
        filterText = 'Rolle';
        break;
      case 'team':
        filterText = 'Team';
        break;
      case 'all':
        filterText = 'Alle Felder';
        break;
    }
    
    // HTML für Filter-Tag erstellen
    tagsContainer.innerHTML = `
      <div class="filter-tag">
        <span class="filter-tag-text">${filterText}: ${lastSearchQuery}</span>
        <button class="filter-tag-remove" title="Filter entfernen">&times;</button>
      </div>
    `;
    
    // Event-Listener für das Entfernen des Tags
    const removeButton = tagsContainer.querySelector('.filter-tag-remove');
    if (removeButton) {
      removeButton.addEventListener('click', function() {
        // Suche zurücksetzen
        lastSearchQuery = '';
        lastSearchFilter = 'all';
        
        // Such-Eingabefeld zurücksetzen
        container.querySelector('#search-query').value = '';
        container.querySelector('#search-filter').value = 'all';
        
        // Filter-Tags aktualisieren
        updateFilterTags(container);
        
        // Suchergebnisse zurücksetzen
        const resultsContainer = container.querySelector('#search-results');
        if (resultsContainer) {
          resultsContainer.innerHTML = `
            <p class="search-prompt">Geben Sie einen Suchbegriff ein, um Benutzer zu finden.</p>
          `;
        }
      });
    }
  }
  
  /**
   * Führt eine Schnellsuche durch und gibt die Ergebnisse zurück
   * @param {string} query - Suchbegriff
   * @returns {Array} - Suchergebnisse
   */
  function quickSearch(query) {
    return searchUsers(query, 'all');
  }
  
  /**
   * Erstellt eine erweiterte Suchfunktion mit benutzerdefinierten Filtern
   * @param {Object} filters - Filterobjekt mit Schlüssel-Wert-Paaren
   * @returns {Array} - Gefilterte Benutzerliste
   */
  function advancedSearch(filters) {
    // Benutzerliste abrufen
    let users = UserManagement.getAllUsers();
    
    // Filter anwenden
    if (filters) {
      Object.keys(filters).forEach(key => {
        const value = filters[key];
        
        // Leere Werte überspringen
        if (value === null || value === undefined || value === '') {
          return;
        }
        
        // Filter anwenden
        switch (key) {
          case 'name':
            // Nach Vor- und Nachname filtern
            const nameLower = value.toLowerCase();
            users = users.filter(user => 
              (user.firstName?.toLowerCase() || '').includes(nameLower) ||
              (user.lastName?.toLowerCase() || '').includes(nameLower) ||
              (user.firstName + ' ' + user.lastName).toLowerCase().includes(nameLower)
            );
            break;
            
          case 'username':
            // Nach Benutzernamen filtern
            users = users.filter(user => 
              (user.username?.toLowerCase() || '').includes(value.toLowerCase())
            );
            break;
            
          case 'email':
            // Nach E-Mail filtern
            users = users.filter(user => 
              (user.email?.toLowerCase() || '').includes(value.toLowerCase())
            );
            break;
            
          case 'role':
            // Nach Rolle filtern
            users = users.filter(user => user.role === value);
            break;
            
          case 'team':
            // Nach Team-ID filtern
            users = users.filter(user => {
              // Teams des Benutzers abrufen
              const teams = TeamAssignment.getTeamsByMember(user.id);
              return teams.some(team => team.id === value);
            });
            break;
            
          case 'isTeamLeader':
            // Nach Teamleiter-Status filtern
            if (value === true || value === 'true') {
              users = users.filter(user => {
                const teams = TeamAssignment.getTeamsByLeader(user.id);
                return teams.length > 0;
              });
            }
            break;
        }
      });
    }
    
    return users;
  }
  
  /**
   * Rendert eine kompakte Benutzerauswahlkomponente
   * @param {string} containerId - ID des Containers
   * @param {string[]} selectedUserIds - IDs der bereits ausgewählten Benutzer
   * @param {Function} onSelectionChange - Callback-Funktion bei Änderung der Auswahl
   * @param {Object} options - Zusätzliche Optionen für die Benutzerauswahl
   */
  function renderUserSelector(containerId, selectedUserIds = [], onSelectionChange = null, options = {}) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Standard-Optionen
    const defaultOptions = {
      multiple: true,           // Mehrfachauswahl erlauben
      showSearch: true,         // Suchfeld anzeigen
      showAvatar: true,         // Avatare anzeigen
      placeholder: 'Benutzer auswählen...',  // Platzhaltertext
      roleFilter: null,         // Nach Rolle filtern (null = alle Rollen)
      excludeUserIds: []        // Benutzer-IDs, die ausgeschlossen werden sollen
    };
    
    // Optionen zusammenführen
    const selectorOptions = { ...defaultOptions, ...options };
    
    // Benutzerliste abrufen und filtern
    let users = UserManagement.getAllUsers();
    
    // Nach Rolle filtern, wenn angegeben
    if (selectorOptions.roleFilter) {
      users = users.filter(user => user.role === selectorOptions.roleFilter);
    }
    
    // Auszuschließende Benutzer entfernen
    if (selectorOptions.excludeUserIds && selectorOptions.excludeUserIds.length > 0) {
      users = users.filter(user => !selectorOptions.excludeUserIds.includes(user.id));
    }
    
    // HTML für die Benutzerauswahl erstellen
    let html = `
      <div class="user-selector">
    `;
    
    // Suchfeld hinzufügen, wenn aktiviert
    if (selectorOptions.showSearch) {
      html += `
        <div class="selector-search">
          <input type="text" class="selector-search-input form-control" placeholder="Benutzer suchen...">
        </div>
      `;
    }
    
    // Container für die ausgewählten Benutzer
    html += `
        <div class="selected-users-container">
    `;
    
    // Ausgewählte Benutzer anzeigen
    if (selectedUserIds.length > 0) {
      selectedUserIds.forEach(userId => {
        const user = users.find(u => u.id === userId);
        if (user) {
          // Avatar-URL abrufen
          const avatarSrc = typeof AvatarManagement !== 'undefined' && AvatarManagement.getUserAvatar
                          ? AvatarManagement.getUserAvatar(user.id)
                          : (user.avatar || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2U0ZTRlNCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiNhYWEiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iI2FhYSIvPjwvc3ZnPg==');
          
          html += `
            <div class="selected-user" data-user-id="${user.id}">
          `;
          
          // Avatar anzeigen, wenn aktiviert
          if (selectorOptions.showAvatar) {
            html += `
              <div class="selected-user-avatar">
                <img src="${avatarSrc}" alt="Avatar" class="avatar-small">
              </div>
            `;
          }
          
          html += `
              <div class="selected-user-name">${user.firstName} ${user.lastName}</div>
              <button class="remove-selected-user" title="Benutzer entfernen">&times;</button>
            </div>
          `;
        }
      });
    }
    
    html += `
        </div>
        
        <div class="user-dropdown-container">
          <div class="user-dropdown-placeholder" id="user-dropdown-placeholder">
            ${selectedUserIds.length > 0 ? `${selectedUserIds.length} Benutzer ausgewählt` : selectorOptions.placeholder}
          </div>
          <div class="user-dropdown">
    `;
    
    // Benutzerliste hinzufügen
    users.forEach(user => {
      const isSelected = selectedUserIds.includes(user.id);
      
      // Avatar-URL abrufen
      const avatarSrc = typeof AvatarManagement !== 'undefined' && AvatarManagement.getUserAvatar
                      ? AvatarManagement.getUserAvatar(user.id)
                      : (user.avatar || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2U0ZTRlNCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiNhYWEiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iI2FhYSIvPjwvc3ZnPg==');
      
      html += `
        <div class="user-option ${isSelected ? 'selected' : ''}" data-user-id="${user.id}">
      `;
      
      // Checkbox für Mehrfachauswahl
      if (selectorOptions.multiple) {
        html += `
          <input type="checkbox" class="user-option-checkbox" ${isSelected ? 'checked' : ''}>
        `;
      }
      
      // Avatar anzeigen, wenn aktiviert
      if (selectorOptions.showAvatar) {
        html += `
          <div class="user-option-avatar">
            <img src="${avatarSrc}" alt="Avatar" class="avatar-small">
          </div>
        `;
      }
      
      html += `
          <div class="user-option-info">
            <div class="user-option-name">${user.firstName} ${user.lastName}</div>
            <div class="user-option-username">${user.username}</div>
          </div>
        </div>
      `;
    });
    
    html += `
          </div>
        </div>
        
        <input type="hidden" id="${containerId}-selected-users" name="${containerId}-selected-users" value="${selectedUserIds.join(',')}">
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addUserSelectorEventListeners(container, selectorOptions, onSelectionChange);
  }
  
  /**
   * Fügt Event-Listener für die Benutzerauswahl hinzu
   * @param {HTMLElement} container - Container mit der Benutzerauswahl
   * @param {Object} options - Optionen für die Benutzerauswahl
   * @param {Function} onSelectionChange - Callback-Funktion bei Änderung der Auswahl
   */
  function addUserSelectorEventListeners(container, options, onSelectionChange) {
    // Dropdown-Platzhalter
    const placeholder = container.querySelector('#user-dropdown-placeholder');
    if (placeholder) {
      placeholder.addEventListener('click', function() {
        const dropdown = container.querySelector('.user-dropdown');
        dropdown.classList.toggle('open');
      });
    }
    
    // Event-Listener für Benutzeroptionen
    const userOptions = container.querySelectorAll('.user-option');
    userOptions.forEach(option => {
      option.addEventListener('click', function() {
        const userId = this.getAttribute('data-user-id');
        const checkbox = this.querySelector('.user-option-checkbox');
        
        // Mehrfachauswahl oder Einfachauswahl
        if (options.multiple) {
          // Checkbox umschalten
          checkbox.checked = !checkbox.checked;
          
          // Auswahl aktualisieren
          this.classList.toggle('selected', checkbox.checked);
          
          // Benutzer zur Auswahl hinzufügen oder entfernen
          updateSelectedUsers(container, userId, checkbox.checked, options, onSelectionChange);
        } else {
          // Bei Einfachauswahl alle anderen Optionen deselektieren
          userOptions.forEach(opt => {
            opt.classList.remove('selected');
            const cb = opt.querySelector('.user-option-checkbox');
            if (cb) cb.checked = false;
          });
          
          // Diese Option selektieren
          this.classList.add('selected');
          if (checkbox) checkbox.checked = true;
          
          // Auswahl aktualisieren
          updateSelectedUsers(container, userId, true, options, onSelectionChange, true);
          
          // Dropdown schließen
          const dropdown = container.querySelector('.user-dropdown');
          dropdown.classList.remove('open');
        }
      });
    });
    
    // Event-Listener für Entfernen-Buttons
    const removeButtons = container.querySelectorAll('.remove-selected-user');
    removeButtons.forEach(button => {
      button.addEventListener('click', function(event) {
        event.stopPropagation();
        
        const selectedUser = this.closest('.selected-user');
        const userId = selectedUser.getAttribute('data-user-id');
        
        // Benutzer aus der Auswahl entfernen
        updateSelectedUsers(container, userId, false, options, onSelectionChange);
        
        // Checkbox im Dropdown aktualisieren
        const userOption = container.querySelector(`.user-option[data-user-id="${userId}"]`);
        if (userOption) {
          userOption.classList.remove('selected');
          const checkbox = userOption.querySelector('.user-option-checkbox');
          if (checkbox) checkbox.checked = false;
        }
      });
    });
    
    // Event-Listener für Suchfeld
    const searchInput = container.querySelector('.selector-search-input');
    if (searchInput) {
      searchInput.addEventListener('input', function() {
        const query = this.value.trim().toLowerCase();
        
        // Benutzeroptionen filtern
        const userOptions = container.querySelectorAll('.user-option');
        userOptions.forEach(option => {
          const name = option.querySelector('.user-option-name').textContent.toLowerCase();
          const username = option.querySelector('.user-option-username').textContent.toLowerCase();
          
          const match = name.includes(query) || username.includes(query);
          option.style.display = match ? '' : 'none';
        });
      });
      
      // Suchfeld fokussieren, wenn Dropdown geöffnet wird
      placeholder.addEventListener('click', function() {
        setTimeout(() => {
          searchInput.focus();
        }, 10);
      });
    }
    
    // Klick außerhalb des Dropdowns schließt dieses
    document.addEventListener('click', function(event) {
      if (!container.contains(event.target)) {
        const dropdown = container.querySelector('.user-dropdown');
        dropdown.classList.remove('open');
      }
    });
  }
  
  /**
   * Aktualisiert die ausgewählten Benutzer
   * @param {HTMLElement} container - Container mit der Benutzerauswahl
   * @param {string} userId - ID des Benutzers
   * @param {boolean} selected - Ob der Benutzer ausgewählt ist
   * @param {Object} options - Optionen für die Benutzerauswahl
   * @param {Function} onSelectionChange - Callback-Funktion bei Änderung der Auswahl
   * @param {boolean} clearExisting - Ob bestehende Auswahlen gelöscht werden sollen
   */
  function updateSelectedUsers(container, userId, selected, options, onSelectionChange, clearExisting = false) {
    // Benutzer abrufen
    const user = UserManagement.getUserById(userId);
    if (!user) return;
    
    // Container für die ausgewählten Benutzer
    const selectedUsersContainer = container.querySelector('.selected-users-container');
    
    // Verstecktes Eingabefeld für die ausgewählten Benutzer-IDs
    const hiddenInput = container.querySelector(`#${container.id}-selected-users`);
    let selectedUserIds = hiddenInput.value ? hiddenInput.value.split(',') : [];
    
    // Bei Einfachauswahl oder wenn bestehende Auswahlen gelöscht werden sollen
    if (!options.multiple || clearExisting) {
      // Alle ausgewählten Benutzer entfernen
      selectedUsersContainer.innerHTML = '';
      selectedUserIds = [];
    }
    
    // Benutzer hinzufügen oder entfernen
    if (selected) {
      // Prüfen, ob der Benutzer bereits ausgewählt ist
      if (!selectedUserIds.includes(userId)) {
        selectedUserIds.push(userId);
        
        // HTML für den ausgewählten Benutzer erstellen
        let html = `
          <div class="selected-user" data-user-id="${user.id}">
        `;
        
        // Avatar anzeigen, wenn aktiviert
        if (options.showAvatar) {
          // Avatar-URL abrufen
          const avatarSrc = typeof AvatarManagement !== 'undefined' && AvatarManagement.getUserAvatar
                          ? AvatarManagement.getUserAvatar(user.id)
                          : (user.avatar || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTYgMjU2Ij48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2U0ZTRlNCIvPjxjaXJjbGUgY3g9IjEyOCIgY3k9IjEwMCIgcj0iNDAiIGZpbGw9IiNhYWEiLz48cGF0aCBkPSJNMjEzLjIsMjEzLjJjMC00Ny4xLTM4LjItODUuMy04NS4yLTg1LjNTNDIuOCwxNjYuMSw0Mi44LDIxMy4ySDIxMy4yeiIgZmlsbD0iI2FhYSIvPjwvc3ZnPg==');
          
          html += `
            <div class="selected-user-avatar">
              <img src="${avatarSrc}" alt="Avatar" class="avatar-small">
            </div>
          `;
        }
        
        html += `
            <div class="selected-user-name">${user.firstName} ${user.lastName}</div>
            <button class="remove-selected-user" title="Benutzer entfernen">&times;</button>
          </div>
        `;
        
        // HTML zum Container hinzufügen
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const newUserElement = tempDiv.firstChild;
        selectedUsersContainer.appendChild(newUserElement);
        
        // Event-Listener für den Entfernen-Button hinzufügen
        const removeButton = newUserElement.querySelector('.remove-selected-user');
        removeButton.addEventListener('click', function(event) {
          event.stopPropagation();
          
          // Benutzer aus der Auswahl entfernen
          updateSelectedUsers(container, userId, false, options, onSelectionChange);
          
          // Checkbox im Dropdown aktualisieren
          const userOption = container.querySelector(`.user-option[data-user-id="${userId}"]`);
          if (userOption) {
            userOption.classList.remove('selected');
            const checkbox = userOption.querySelector('.user-option-checkbox');
            if (checkbox) checkbox.checked = false;
          }
        });
      }
    } else {
      // Benutzer aus der Auswahl entfernen
      selectedUserIds = selectedUserIds.filter(id => id !== userId);
      
      // Element aus dem DOM entfernen
      const selectedUserElement = selectedUsersContainer.querySelector(`.selected-user[data-user-id="${userId}"]`);
      if (selectedUserElement) {
        selectedUsersContainer.removeChild(selectedUserElement);
      }
    }
    
    // Verstecktes Eingabefeld aktualisieren
    hiddenInput.value = selectedUserIds.join(',');
    
    // Platzhaltertext aktualisieren
    const placeholder = container.querySelector('#user-dropdown-placeholder');
    if (placeholder) {
      placeholder.textContent = selectedUserIds.length > 0 
                              ? `${selectedUserIds.length} Benutzer ausgewählt` 
                              : options.placeholder;
    }
    
    // Callback aufrufen, wenn vorhanden
    if (typeof onSelectionChange === 'function') {
      onSelectionChange(selectedUserIds);
    }
  }
  
  /**
   * Gibt die in einem Benutzerauswahl-Container ausgewählten Benutzer-IDs zurück
   * @param {string} containerId - ID des Containers
   * @returns {string[]} - Array mit den ausgewählten Benutzer-IDs
   */
  function getSelectedUserIds(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return [];
    
    const hiddenInput = container.querySelector(`#${containerId}-selected-users`);
    if (!hiddenInput) return [];
    
    return hiddenInput.value ? hiddenInput.value.split(',') : [];
  }
  
  // Öffentliche API
  return {
    searchUsers: searchUsers,
    quickSearch: quickSearch,
    advancedSearch: advancedSearch,
    renderUserSearch: renderUserSearch,
    renderUserSelector: renderUserSelector,
    getSelectedUserIds: getSelectedUserIds,
    performSearch: performSearch
  };
})();

// CSS für die Benutzersuche
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für die Benutzersuche existiert
  if (!document.getElementById('user-search-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'user-search-styles';
    styleElement.textContent = `
      /* Benutzersuche */
      .user-search {
        margin-bottom: 20px;
      }
      
      .search-form {
        margin-bottom: 15px;
      }
      
      .search-input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
      }
      
      .search-filter-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
      }
      
      .filter-tag {
        display: inline-flex;
        align-items: center;
        background-color: #e0f7f4;
        border: 1px solid #00FFD0;
        border-radius: 20px;
        padding: 5px 10px;
        font-size: 0.9em;
      }
      
      .filter-tag-text {
        margin-right: 5px;
      }
      
      .filter-tag-remove {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        line-height: 1;
        color: #666;
      }
      
      .search-results-container {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background-color: #f9f9f9;
      }
      
      .search-prompt {
        text-align: center;
        color: #777;
        font-style: italic;
      }
      
      .results-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #eee;
      }
      
      .results-table {
        width: 100%;
        border-collapse: collapse;
      }
      
      .results-table th,
      .results-table td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid #eee;
      }
      
      .results-table th {
        background-color: #f0f0f0;
        font-weight: bold;
      }
      
      .results-table tr:hover {
        background-color: #f5f5f5;
      }
      
      .user-avatar {
        display: flex;
        justify-content: center;
      }
      
      .avatar-small {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        object-fit: cover;
      }
      
      .action-buttons {
        display: flex;
        gap: 5px;
      }
      
      .no-results {
        text-align: center;
        padding: 20px;
        color: #777;
      }
      
      /* Benutzerauswahl */
      .user-selector {
        position: relative;
        width: 100%;
        margin-bottom: 15px;
      }
      
      .selector-search {
        margin-bottom: 10px;
      }
      
      .selected-users-container {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 10px;
      }
      
      .selected-user {
        display: inline-flex;
        align-items: center;
        background-color: #e0f7f4;
        border: 1px solid #00FFD0;
        border-radius: 20px;
        padding: 5px 10px;
        font-size: 0.9em;
      }
      
      .selected-user-avatar {
        margin-right: 5px;
      }
      
      .selected-user-name {
        margin-right: 5px;
      }
      
      .remove-selected-user {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        line-height: 1;
        color: #666;
      }
      
      .user-dropdown-container {
        position: relative;
      }
      
      .user-dropdown-placeholder {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        background-color: #fff;
      }
      
      .user-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        z-index: 1000;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        margin-top: 5px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      
      .user-dropdown.open {
        display: block;
      }
      
      .user-option {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      
      .user-option:last-child {
        border-bottom: none;
      }
      
      .user-option:hover {
        background-color: #f5f5f5;
      }
      
      .user-option.selected {
        background-color: #e0f7f4;
      }
      
      .user-option-checkbox {
        margin-right: 8px;
      }
      
      .user-option-avatar {
        margin-right: 8px;
      }
      
      .user-option-info {
        flex: 1;
      }
      
      .user-option-name {
        font-weight: bold;
      }
      
      .user-option-username {
        font-size: 0.9em;
        color: #666;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.1: Test-Grunddaten erfassen
 * 
 * Dieses Modul ermöglicht die Erstellung und Bearbeitung
 * der grundlegenden Testdaten wie Titel, Beschreibung,
 * Zeitlimit und Bewertungseinstellungen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const TestBasicData = (function() {
  // Private Variablen
  let tests = [];
  let currentTest = null;
  
  /**
   * Test-Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   title: string,               // Titel des Tests
   *   description: string,         // Beschreibung
   *   instructions: string,        // Anweisungen für Teilnehmer
   *   timeLimit: number,           // Zeitlimit in Minuten (0 = kein Limit)
   *   passingScore: number,        // Erforderliche Punktzahl zum Bestehen (Prozent)
   *   isActive: boolean,           // Ist der Test aktiv?
   *   allowRetake: boolean,        // Darf der Test wiederholt werden?
   *   maxAttempts: number,         // Maximale Anzahl von Versuchen (0 = unbegrenzt)
   *   randomizeQuestions: boolean, // Fragen in zufälliger Reihenfolge anzeigen?
   *   showResults: boolean,        // Ergebnisse nach Abschluss anzeigen?
   *   createdBy: string,           // Ersteller (Benutzer-ID)
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date,             // Letztes Aktualisierungsdatum
   *   validFrom: Date,             // Gültig ab (optional)
   *   validUntil: Date,            // Gültig bis (optional)
   *   targetGroups: string[],      // Zielgruppen (Team-IDs)
   *   tags: string[],              // Tags für die Kategorisierung
   *   questions: Array,            // Array mit Fragen (wird in separatem Modul verwaltet)
   *   questionCount: number        // Anzahl der Fragen (für schnelleren Zugriff)
   * }
   */
  
  /**
   * Lädt alle Tests aus dem LocalStorage
   * @returns {Array} - Array mit allen Tests
   */
  function loadTests() {
    try {
      tests = JSON.parse(localStorage.getItem('elearning_tests') || '[]');
      return tests;
    } catch (error) {
      console.error('Fehler beim Laden der Tests:', error);
      return [];
    }
  }
  
  /**
   * Speichert alle Tests im LocalStorage
   */
  function saveTests() {
    try {
      localStorage.setItem('elearning_tests', JSON.stringify(tests));
      return true;
    } catch (error) {
      console.error('Fehler beim Speichern der Tests:', error);
      return false;
    }
  }
  
  /**
   * Erstellt einen neuen Test mit Grunddaten
   * @param {Object} testData - Grunddaten des Tests
   * @returns {Object} - Das erstellte Test-Objekt
   */
  function createTest(testData) {
    // Erstellen einer eindeutigen ID
    const testId = 'test_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Aktueller Benutzer (für Ersteller)
    const currentUser = AuthManager.getCurrentUser();
    const creatorId = currentUser ? currentUser.id : 'unknown';
    
    // Neues Test-Objekt
    const newTest = {
      id: testId,
      title: testData.title || 'Neuer Test',
      description: testData.description || '',
      instructions: testData.instructions || '',
      timeLimit: testData.timeLimit !== undefined ? parseInt(testData.timeLimit) : 0,
      passingScore: testData.passingScore !== undefined ? parseInt(testData.passingScore) : 70,
      isActive: testData.isActive !== undefined ? testData.isActive : false,
      allowRetake: testData.allowRetake !== undefined ? testData.allowRetake : true,
      maxAttempts: testData.maxAttempts !== undefined ? parseInt(testData.maxAttempts) : 0,
      randomizeQuestions: testData.randomizeQuestions !== undefined ? testData.randomizeQuestions : false,
      showResults: testData.showResults !== undefined ? testData.showResults : true,
      createdBy: creatorId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      validFrom: testData.validFrom || null,
      validUntil: testData.validUntil || null,
      targetGroups: testData.targetGroups || [],
      tags: testData.tags || [],
      questions: [],
      questionCount: 0
    };
    
    // Test zum Array hinzufügen
    tests.push(newTest);
    
    // Tests speichern
    saveTests();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Test erfolgreich erstellt.');
    
    return newTest;
  }
  
  /**
   * Aktualisiert die Grunddaten eines bestehenden Tests
   * @param {string} testId - ID des zu aktualisierenden Tests
   * @param {Object} testData - Neue Grunddaten für den Test
   * @returns {Object|null} - Das aktualisierte Test-Objekt oder null bei Fehler
   */
  function updateTest(testId, testData) {
    // Test in der Liste finden
    const testIndex = tests.findIndex(test => test.id === testId);
    
    if (testIndex === -1) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Aktuelles Test-Objekt
    const currentTestData = tests[testIndex];
    
    // Test-Objekt aktualisieren
    const updatedTest = {
      ...currentTestData,
      title: testData.title !== undefined ? testData.title : currentTestData.title,
      description: testData.description !== undefined ? testData.description : currentTestData.description,
      instructions: testData.instructions !== undefined ? testData.instructions : currentTestData.instructions,
      timeLimit: testData.timeLimit !== undefined ? parseInt(testData.timeLimit) : currentTestData.timeLimit,
      passingScore: testData.passingScore !== undefined ? parseInt(testData.passingScore) : currentTestData.passingScore,
      isActive: testData.isActive !== undefined ? testData.isActive : currentTestData.isActive,
      allowRetake: testData.allowRetake !== undefined ? testData.allowRetake : currentTestData.allowRetake,
      maxAttempts: testData.maxAttempts !== undefined ? parseInt(testData.maxAttempts) : currentTestData.maxAttempts,
      randomizeQuestions: testData.randomizeQuestions !== undefined ? testData.randomizeQuestions : currentTestData.randomizeQuestions,
      showResults: testData.showResults !== undefined ? testData.showResults : currentTestData.showResults,
      updatedAt: new Date().toISOString(),
      validFrom: testData.validFrom !== undefined ? testData.validFrom : currentTestData.validFrom,
      validUntil: testData.validUntil !== undefined ? testData.validUntil : currentTestData.validUntil
    };
    
    // Optionale Felder nur aktualisieren, wenn sie im testData enthalten sind
    if (testData.targetGroups !== undefined) {
      updatedTest.targetGroups = testData.targetGroups;
    }
    
    if (testData.tags !== undefined) {
      updatedTest.tags = testData.tags;
    }
    
    // Anzahl der Fragen aktualisieren
    if (updatedTest.questions) {
      updatedTest.questionCount = updatedTest.questions.length;
    }
    
    // Aktualisiertes Test-Objekt speichern
    tests[testIndex] = updatedTest;
    saveTests();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Test erfolgreich aktualisiert.');
    
    return updatedTest;
  }
  
  /**
   * Löscht einen Test
   * @param {string} testId - ID des zu löschenden Tests
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteTest(testId) {
    // Test-Index finden
    const testIndex = tests.findIndex(test => test.id === testId);
    
    if (testIndex === -1) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    // Test aus dem Array entfernen
    tests.splice(testIndex, 1);
    
    // Aktualisierte Tests speichern
    saveTests();
    
    // Erfolgsmeldung anzeigen
    NotificationSystem.showSuccess('Test erfolgreich gelöscht.');
    
    return true;
  }
  
  /**
   * Gibt alle Tests zurück
   * @returns {Array} - Array mit allen Tests
   */
  function getAllTests() {
    return loadTests();
  }
  
  /**
   * Gibt einen Test anhand seiner ID zurück
   * @param {string} testId - ID des Tests
   * @returns {Object|null} - Das Test-Objekt oder null, wenn nicht gefunden
   */
  function getTestById(testId) {
    const test = tests.find(t => t.id === testId);
    return test || null;
  }
  
  /**
   * Gibt Tests zurück, die für einen Benutzer verfügbar sind
   * @param {string} userId - ID des Benutzers
   * @returns {Array} - Array mit verfügbaren Tests
   */
  function getTestsForUser(userId) {
    // Benutzer abrufen
    const user = UserManagement.getUserById(userId);
    if (!user) return [];
    
    // Aktuelle Zeit für Gültigkeitsprüfung
    const now = new Date();
    
    // Teams des Benutzers abrufen, falls TeamAssignment verfügbar
    let userTeams = [];
    if (typeof TeamAssignment !== 'undefined' && TeamAssignment.getTeamsByMember) {
      userTeams = TeamAssignment.getTeamsByMember(userId);
    }
    const userTeamIds = userTeams.map(team => team.id);
    
    // Tests filtern
    return tests.filter(test => {
      // Prüfen, ob der Test aktiv ist
      if (!test.isActive) return false;
      
      // Prüfen, ob der Test zeitlich gültig ist
      if (test.validFrom && new Date(test.validFrom) > now) return false;
      if (test.validUntil && new Date(test.validUntil) < now) return false;
      
      // Prüfen, ob der Test für den Benutzer freigegeben ist (Zielgruppe)
      if (test.targetGroups && test.targetGroups.length > 0) {
        // Wenn der Benutzer Admin oder Trainer ist, immer verfügbar machen
        if (user.role === 'admin' || user.role === 'trainer') return true;
        
        // Sonst prüfen, ob der Benutzer in einer der Zielgruppen ist
        const hasAccess = test.targetGroups.some(targetGroup => 
          userTeamIds.includes(targetGroup)
        );
        
        return hasAccess;
      }
      
      // Wenn keine Zielgruppen definiert sind, für alle verfügbar
      return true;
    });
  }
  
  /**
   * Rendert das Formular zur Erfassung der Test-Grunddaten
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests (null für neuen Test)
   */
  function renderTestBasicDataForm(containerId, testId = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Tests laden, falls noch nicht geladen
    if (tests.length === 0) {
      loadTests();
    }
    
    // Bestehenden Test laden oder neuen Test vorbereiten
    currentTest = null;
    if (testId) {
      currentTest = getTestById(testId);
      if (!currentTest) {
        console.error('Test nicht gefunden:', testId);
        return;
      }
    }
    
    // Teams für Zielgruppenauswahl laden
    let teams = [];
    if (typeof TeamAssignment !== 'undefined' && TeamAssignment.getAllTeams) {
      teams = TeamAssignment.getAllTeams();
    }
    
    // Formular-HTML erstellen
    let html = `
      <form id="test-basic-data-form" class="test-form">
        <div class="form-section">
          <h3>Allgemeine Informationen</h3>
          
          <div class="form-group">
            <label for="test-title">Titel*</label>
            <input type="text" id="test-title" class="form-control" required 
                   value="${currentTest ? currentTest.title : ''}">
            <div class="form-help">Der Titel des Tests, wie er für die Teilnehmer angezeigt wird.</div>
          </div>
          
          <div class="form-group">
            <label for="test-description">Beschreibung</label>
            <textarea id="test-description" class="form-control" rows="3">${currentTest ? currentTest.description : ''}</textarea>
            <div class="form-help">Eine kurze Beschreibung des Tests und seines Zwecks.</div>
          </div>
          
          <div class="form-group">
            <label for="test-instructions">Anweisungen für Teilnehmer</label>
            <textarea id="test-instructions" class="form-control" rows="4">${currentTest ? currentTest.instructions : ''}</textarea>
            <div class="form-help">Detaillierte Anweisungen, die den Teilnehmern vor dem Test angezeigt werden.</div>
          </div>
          
          <div class="form-group">
            <label for="test-tags">Tags</label>
            <input type="text" id="test-tags" class="form-control" 
                   value="${currentTest && currentTest.tags ? currentTest.tags.join(', ') : ''}">
            <div class="form-help">Kommagetrennte Liste von Tags zur Kategorisierung des Tests.</div>
          </div>
        </div>
        
        <div class="form-section">
          <h3>Einstellungen</h3>
          
          <div class="form-group">
            <label for="test-time-limit">Zeitlimit (Minuten)</label>
            <input type="number" id="test-time-limit" class="form-control" min="0" 
                   value="${currentTest ? currentTest.timeLimit : '0'}">
            <div class="form-help">Zeitlimit für den Test in Minuten. 0 = kein Zeitlimit.</div>
          </div>
          
          <div class="form-group">
            <label for="test-passing-score">Erforderliche Punktzahl zum Bestehen (%)</label>
            <input type="number" id="test-passing-score" class="form-control" min="0" max="100" 
                   value="${currentTest ? currentTest.passingScore : '70'}">
            <div class="form-help">Prozentsatz der Punkte, die für das Bestehen des Tests erforderlich sind.</div>
          </div>
          
          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="test-randomize-questions" 
                     ${currentTest && currentTest.randomizeQuestions ? 'checked' : ''}>
              <label for="test-randomize-questions">Fragen in zufälliger Reihenfolge anzeigen</label>
            </div>
            <div class="form-help">Bei Aktivierung werden die Fragen für jeden Teilnehmer in zufälliger Reihenfolge angezeigt.</div>
          </div>
          
          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="test-show-results" 
                     ${currentTest && currentTest.showResults ? 'checked' : ''}>
              <label for="test-show-results">Ergebnisse nach Abschluss anzeigen</label>
            </div>
            <div class="form-help">Bei Aktivierung werden den Teilnehmern nach Abschluss des Tests die Ergebnisse angezeigt.</div>
          </div>
          
          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="test-allow-retake" 
                     ${currentTest && currentTest.allowRetake ? 'checked' : ''}>
              <label for="test-allow-retake">Wiederholung erlauben</label>
            </div>
            <div class="form-help">Bei Aktivierung können Teilnehmer den Test mehrfach absolvieren.</div>
          </div>
          
          <div class="form-group" id="max-attempts-group" 
              ${currentTest && !currentTest.allowRetake ? 'style="display: none;"' : ''}>
            <label for="test-max-attempts">Maximale Anzahl von Versuchen</label>
            <input type="number" id="test-max-attempts" class="form-control" min="0" 
                   value="${currentTest ? currentTest.maxAttempts : '0'}">
            <div class="form-help">Maximale Anzahl von Versuchen pro Teilnehmer. 0 = unbegrenzt.</div>
          </div>
        </div>
        
        <div class="form-section">
          <h3>Verfügbarkeit</h3>
          
          <div class="form-group">
            <div class="checkbox-group">
              <input type="checkbox" id="test-is-active" 
                     ${currentTest && currentTest.isActive ? 'checked' : ''}>
              <label for="test-is-active">Test aktiv</label>
            </div>
            <div class="form-help">Bei Aktivierung ist der Test für die Zielgruppen verfügbar.</div>
          </div>
          
          <div class="form-group">
            <label for="test-valid-from">Gültig ab</label>
            <input type="datetime-local" id="test-valid-from" class="form-control" 
                   value="${currentTest && currentTest.validFrom ? formatDateTimeForInput(currentTest.validFrom) : ''}">
            <div class="form-help">Datum und Uhrzeit, ab wann der Test verfügbar ist. Leer = sofort verfügbar.</div>
          </div>
          
          <div class="form-group">
            <label for="test-valid-until">Gültig bis</label>
            <input type="datetime-local" id="test-valid-until" class="form-control" 
                   value="${currentTest && currentTest.validUntil ? formatDateTimeForInput(currentTest.validUntil) : ''}">
            <div class="form-help">Datum und Uhrzeit, bis wann der Test verfügbar ist. Leer = unbegrenzt verfügbar.</div>
          </div>
          
          <div class="form-group">
            <label for="test-target-groups">Zielgruppen</label>
            <div id="target-groups-container" class="checkbox-list">
    `;
    
    // Teams für Zielgruppenauswahl hinzufügen
    if (teams.length === 0) {
      html += `<p class="no-data-message">Keine Teams verfügbar. Bitte erstellen Sie zuerst Teams.</p>`;
    } else {
      teams.forEach(team => {
        const isSelected = currentTest && currentTest.targetGroups && currentTest.targetGroups.includes(team.id);
        html += `
          <div class="checkbox-group">
            <input type="checkbox" id="target-group-${team.id}" value="${team.id}" 
                   ${isSelected ? 'checked' : ''}>
            <label for="target-group-${team.id}">${team.name}</label>
          </div>
        `;
      });
    }
    
    html += `
            </div>
            <div class="form-help">Wählen Sie die Teams aus, für die dieser Test verfügbar sein soll. Keine Auswahl = für alle verfügbar.</div>
          </div>
        </div>
        
        <div class="form-actions">
          <button type="button" id="cancel-test-btn" class="btn btn-secondary">Abbrechen</button>
          <button type="submit" class="btn btn-primary">Speichern</button>
        </div>
      </form>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener für das Formular hinzufügen
    addTestFormEventListeners(containerId, testId);
  }
  
  /**
   * Fügt Event-Listener für das Test-Formular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests (null für neuen Test)
   */
  function addTestFormEventListeners(containerId, testId) {
    // Formular-Event-Listener
    const form = document.getElementById('test-basic-data-form');
    if (form) {
      form.addEventListener('submit', function(event) {
        event.preventDefault();
        handleTestFormSubmit(containerId, testId);
      });
    }
    
    // Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-test-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        // Hier könnte eine Navigation zurück zur Testübersicht erfolgen
        window.history.back();
      });
    }
    
    // Event-Listener für "Wiederholung erlauben"
    const allowRetakeCheckbox = document.getElementById('test-allow-retake');
    const maxAttemptsGroup = document.getElementById('max-attempts-group');
    
    if (allowRetakeCheckbox && maxAttemptsGroup) {
      allowRetakeCheckbox.addEventListener('change', function() {
        maxAttemptsGroup.style.display = this.checked ? '' : 'none';
      });
    }
  }
  
  /**
   * Verarbeitet das Absenden des Test-Formulars
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests (null für neuen Test)
   */
  function handleTestFormSubmit(containerId, testId) {
    // Formulardaten sammeln
    const title = document.getElementById('test-title').value.trim();
    const description = document.getElementById('test-description').value.trim();
    const instructions = document.getElementById('test-instructions').value.trim();
    const tagsInput = document.getElementById('test-tags').value.trim();
    const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
    
    const timeLimit = parseInt(document.getElementById('test-time-limit').value) || 0;
    const passingScore = parseInt(document.getElementById('test-passing-score').value) || 70;
    const randomizeQuestions = document.getElementById('test-randomize-questions').checked;
    const showResults = document.getElementById('test-show-results').checked;
    const allowRetake = document.getElementById('test-allow-retake').checked;
    const maxAttempts = parseInt(document.getElementById('test-max-attempts').value) || 0;
    
    const isActive = document.getElementById('test-is-active').checked;
    const validFrom = document.getElementById('test-valid-from').value || null;
    const validUntil = document.getElementById('test-valid-until').value || null;
    
    // Zielgruppen auslesen
    const targetGroups = [];
    const targetGroupCheckboxes = document.querySelectorAll('#target-groups-container input[type="checkbox"]:checked');
    targetGroupCheckboxes.forEach(checkbox => {
      targetGroups.push(checkbox.value);
    });
    
    // Validierung
    if (!title) {
      NotificationSystem.showError('Bitte geben Sie einen Titel für den Test ein.');
      return;
    }
    
    // Test-Daten zusammenstellen
    const testData = {
      title,
      description,
      instructions,
      tags,
      timeLimit,
      passingScore,
      randomizeQuestions,
      showResults,
      allowRetake,
      maxAttempts,
      isActive,
      validFrom,
      validUntil,
      targetGroups
    };
    
    // Neuen Test erstellen oder bestehenden aktualisieren
    if (testId) {
      updateTest(testId, testData);
    } else {
      const newTest = createTest(testData);
      // Eventuell zur nächsten Seite weiterleiten (Fragenerstellung)
      if (newTest && typeof TestEditor !== 'undefined' && TestEditor.navigateToQuestions) {
        TestEditor.navigateToQuestions(newTest.id);
      }
    }
    
    // Callback oder Navigation
    if (window.TestEditor && TestEditor.onTestBasicDataSaved) {
      TestEditor.onTestBasicDataSaved(testId || (currentTest ? currentTest.id : null));
    } else {
      // Fallback: Zur Test-Übersicht zurückgehen
      window.history.back();
    }
  }
  
  /**
   * Formatiert ein Datum für input[type="datetime-local"]
   * @param {string} dateString - Datum als String oder ISO-String
   * @returns {string} - Formatiertes Datum für das Eingabefeld
   */
  function formatDateTimeForInput(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
  
  /**
   * Rendert eine Übersicht aller Tests
   * @param {string} containerId - ID des Containers
   * @param {Function} onAction - Callback-Funktion bei Aktionen (bearbeiten, löschen, usw.)
   */
  function renderTestOverview(containerId, onAction = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Tests laden
    loadTests();
    
    // HTML für die Testübersicht erstellen
    let html = `
      <div class="test-overview">
        <div class="overview-header">
          <h2>Alle Tests</h2>
          <button id="create-test-btn" class="btn btn-primary">Neuen Test erstellen</button>
        </div>
        
        <div class="test-list">
    `;
    
    // Tests auflisten
    if (tests.length === 0) {
      html += `<p class="no-data-message">Keine Tests vorhanden. Erstellen Sie einen neuen Test mit dem Button oben.</p>`;
    } else {
      html += `
        <table class="tests-table">
          <thead>
            <tr>
              <th>Titel</th>
              <th>Fragen</th>
              <th>Status</th>
              <th>Erstellt am</th>
              <th>Aktionen</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      tests.forEach(test => {
        const statusClass = test.isActive ? 'status-active' : 'status-inactive';
        const statusText = test.isActive ? 'Aktiv' : 'Inaktiv';
        
        html += `
          <tr data-test-id="${test.id}">
            <td class="test-title-cell">${test.title}</td>
            <td class="test-questions-cell">${test.questionCount || 0}</td>
            <td class="test-status-cell"><span class="status-badge ${statusClass}">${statusText}</span></td>
            <td class="test-date-cell">${formatDate(test.createdAt)}</td>
            <td class="test-actions-cell">
              <div class="action-buttons">
                <button class="btn btn-sm btn-primary view-test-btn" data-test-id="${test.id}" title="Test ansehen">
                  <i class="fas fa-eye"></i> Ansehen
                </button>
                <button class="btn btn-sm btn-edit edit-test-btn" data-test-id="${test.id}" title="Test bearbeiten">
                  <i class="fas fa-edit"></i> Bearbeiten
                </button>
                <button class="btn btn-sm btn-danger delete-test-btn" data-test-id="${test.id}" title="Test löschen">
                  <i class="fas fa-trash"></i> Löschen
                </button>
              </div>
            </td>
          </tr>
        `;
      });
      
      html += `
          </tbody>
        </table>
      `;
    }
    
    html += `
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addTestOverviewEventListeners(container, onAction);
  }
  
  /**
   * Fügt Event-Listener für die Testübersicht hinzu
   * @param {HTMLElement} container - Container mit der Testübersicht
   * @param {Function} onAction - Callback-Funktion bei Aktionen
   */
  function addTestOverviewEventListeners(container, onAction) {
    // Event-Listener für "Neuen Test erstellen"-Button
    const createTestBtn = container.querySelector('#create-test-btn');
    if (createTestBtn) {
      createTestBtn.addEventListener('click', function() {
        if (typeof onAction === 'function') {
          onAction('create');
        } else {
          // Fallback: Zur Test-Erstellungsseite navigieren
          window.location.href = '#/tests/new';
        }
      });
    }
    
    // Event-Delegation für Aktionsbuttons
    container.addEventListener('click', function(event) {
      let actionButton = null;
      let action = '';
      
      // "Ansehen"-Button
      if (event.target.classList.contains('view-test-btn') || 
          event.target.closest('.view-test-btn')) {
        actionButton = event.target.classList.contains('view-test-btn') ? 
                      event.target : 
                      event.target.closest('.view-test-btn');
        action = 'view';
      }
      
      // "Bearbeiten"-Button
      else if (event.target.classList.contains('edit-test-btn') || 
              event.target.closest('.edit-test-btn')) {
        actionButton = event.target.classList.contains('edit-test-btn') ? 
                      event.target : 
                      event.target.closest('.edit-test-btn');
        action = 'edit';
      }
      
      // "Löschen"-Button
      else if (event.target.classList.contains('delete-test-btn') || 
              event.target.closest('.delete-test-btn')) {
        actionButton = event.target.classList.contains('delete-test-btn') ? 
                      event.target : 
                      event.target.closest('.delete-test-btn');
        action = 'delete';
      }
      
      // Wenn ein Aktionsbutton geklickt wurde
      if (actionButton) {
        const testId = actionButton.getAttribute('data-test-id');
        
        if (action === 'delete') {
          // Bestätigungsdialog anzeigen
          showDeleteTestConfirmation(testId, onAction);
        } else if (typeof onAction === 'function') {
          // Callback aufrufen
          onAction(action, testId);
        } else {
          // Fallback: Navigation
          if (action === 'view') {
            window.location.href = `#/tests/view/${testId}`;
          } else if (action === 'edit') {
            window.location.href = `#/tests/edit/${testId}`;
          }
        }
      }
    });
  }
  
  /**
   * Zeigt eine Bestätigungsabfrage zum Löschen eines Tests
   * @param {string} testId - ID des zu löschenden Tests
   * @param {Function} onConfirm - Callback-Funktion nach Bestätigung
   */
  function showDeleteTestConfirmation(testId, onConfirm) {
    const test = getTestById(testId);
    if (!test) return;
    
    // Bestätigungsdialog anzeigen
    if (confirm(`Sind Sie sicher, dass Sie den Test "${test.title}" löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.`)) {
      deleteTest(testId);
      
      // Callback aufrufen, wenn vorhanden
      if (typeof onConfirm === 'function') {
        onConfirm('delete', testId, true);
      }
    }
  }
  
  /**
   * Formatiert ein Datum für die Anzeige
   * @param {string} dateString - Datum als String oder ISO-String
   * @returns {string} - Formatiertes Datum
   */
  function formatDate(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    
    return `${day}.${month}.${year}`;
  }
  
  // Initialisierung
  function init() {
    // Tests laden
    loadTests();
    
    console.log('Test-Grunddaten-Modul initialisiert');
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    createTest: createTest,
    updateTest: updateTest,
    deleteTest: deleteTest,
    getAllTests: getAllTests,
    getTestById: getTestById,
    getTestsForUser: getTestsForUser,
    renderTestBasicDataForm: renderTestBasicDataForm,
    renderTestOverview: renderTestOverview
  };
})();

// Hilfsfunktion für fehlende Module
function isModuleAvailable(moduleName) {
  return typeof window[moduleName] !== 'undefined';
}

// Wenn AuthManager noch nicht definiert ist, einen einfachen Ersatz erstellen
if (!isModuleAvailable('AuthManager')) {
  const AuthManager = {
    getCurrentUser: function() {
      // Einfache Implementierung, um den aktuellen Benutzer zu simulieren
      return { id: 'unknown', role: 'admin' };
    }
  };
  window.AuthManager = AuthManager;
}

// Wenn NotificationSystem noch nicht definiert ist
if (!isModuleAvailable('NotificationSystem')) {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}

// CSS für die Test-Verwaltung
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Tests existiert
  if (!document.getElementById('test-basic-data-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'test-basic-data-styles';
    styleElement.textContent = `
      /* Test-Formular */
      .test-form {
        max-width: 800px;
        margin: 0 auto;
      }
      
      .form-section {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      
      .form-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
        color: #333;
      }
      
      .form-group {
        margin-bottom: 15px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      
      .form-help {
        font-size: 0.85em;
        color: #666;
        margin-top: 5px;
      }
      
      .form-control {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1em;
      }
      
      .checkbox-group {
        display: flex;
        align-items: center;
      }
      
      .checkbox-group input[type="checkbox"] {
        margin-right: 8px;
      }
      
      .checkbox-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        background-color: #fff;
      }
      
      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      
      /* Test-Übersicht */
      .test-overview {
        width: 100%;
      }
      
      .overview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .overview-header h2 {
        margin: 0;
      }
      
      .tests-table {
        width: 100%;
        border-collapse: collapse;
      }
      
      .tests-table th,
      .tests-table td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #eee;
      }
      
      .tests-table th {
        background-color: #f0f0f0;
        font-weight: bold;
      }
      
      .tests-table tr:hover {
        background-color: #f5f5f5;
      }
      
      .test-title-cell {
        font-weight: bold;
      }
      
      .test-actions-cell {
        white-space: nowrap;
      }
      
      .status-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: bold;
      }
      
      .status-active {
        background-color: #e0f7f4;
        color: #00896c;
      }
      
      .status-inactive {
        background-color: #f0f0f0;
        color: #777;
      }
      
      .action-buttons {
        display: flex;
        gap: 5px;
      }
      
      .no-data-message {
        text-align: center;
        padding: 20px;
        color: #777;
        font-style: italic;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.2.1: Test-Einstellungen - Grundfunktionen
 * 
 * Dieser Teil des Moduls implementiert die grundlegenden Funktionen
 * zur Verwaltung von Testeinstellungen wie Datenstrukturen und CRUD-Operationen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const TestSettings = (function() {
  // Private Variablen
  let currentTest = null;
  
  /**
   * Testeinstellungs-Datenstruktur:
   * {
   *   questionCategories: [             // Kategorien für Fragen
   *     {
   *       id: string,                   // Eindeutige ID
   *       name: string,                 // Name der Kategorie
   *       description: string,          // Beschreibung
   *       weight: number                // Gewichtung (1-10)
   *     }
   *   ],
   *   scoringRules: {                   // Bewertungsregeln
   *     partialCredit: boolean,         // Teilpunkte erlauben?
   *     negativeScoring: boolean,       // Negative Punkte für falsche Antworten?
   *     penaltyPercentage: number,      // Prozentsatz der Strafe für falsche Antworten
   *     timeBasedScoring: boolean,      // Zeitbasierte Bewertung?
   *     timeBasedPenalty: number,       // Prozentsatz der Zeitstrafe
   *     autoGradeThreshold: number      // Schwellenwert für automatische Benotung (%)
   *   },
   *   appearance: {                     // Erscheinungsbild
   *     showProgressBar: boolean,       // Fortschrittsbalken anzeigen?
   *     showQuestionNumbers: boolean,   // Fragennummern anzeigen?
   *     showTimeRemaining: boolean,     // Verbleibende Zeit anzeigen?
   *     allowPrevious: boolean,         // Zurück-Navigation erlauben?
   *     theme: string                   // Farbthema (default, dark, custom)
   *   },
   *   feedback: {                       // Feedback-Einstellungen
   *     showCorrectAnswers: boolean,    // Richtige Antworten anzeigen?
   *     showExplanations: boolean,      // Erklärungen anzeigen?
   *     showScore: boolean,             // Punktzahl anzeigen?
   *     customFeedbackPassed: string,   // Benutzerdefiniertes Feedback bei Bestehen
   *     customFeedbackFailed: string    // Benutzerdefiniertes Feedback bei Nichtbestehen
   *   },
   *   notifications: {                  // Benachrichtigungen
   *     notifyTrainer: boolean,         // Trainer benachrichtigen?
   *     notifyTeamLeader: boolean,      // Teamleiter benachrichtigen?
   *     notifyOnCompletion: boolean,    // Bei Abschluss benachrichtigen?
   *     notifyOnFail: boolean           // Bei Nichtbestehen benachrichtigen?
   *   }
   * }
   */
  
  /**
   * Lädt die Einstellungen eines Tests
   * @param {string} testId - ID des Tests
   * @returns {Object} - Testeinstellungen-Objekt
   */
  function loadTestSettings(testId) {
    // Test aus dem TestBasicData-Modul abrufen
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Einstellungen abrufen oder Standardeinstellungen verwenden
    currentTest = test;
    
    // Wenn der Test noch keine Einstellungen hat, Standardeinstellungen erstellen
    if (!test.settings) {
      test.settings = createDefaultSettings();
    }
    
    return test.settings;
  }
  
  /**
   * Erstellt Standardeinstellungen für einen Test
   * @returns {Object} - Standardeinstellungen
   */
  function createDefaultSettings() {
    return {
      questionCategories: [],
      scoringRules: {
        partialCredit: true,
        negativeScoring: false,
        penaltyPercentage: 0,
        timeBasedScoring: false,
        timeBasedPenalty: 0,
        autoGradeThreshold: 80
      },
      appearance: {
        showProgressBar: true,
        showQuestionNumbers: true,
        showTimeRemaining: true,
        allowPrevious: true,
        theme: 'default'
      },
      feedback: {
        showCorrectAnswers: true,
        showExplanations: true,
        showScore: true,
        customFeedbackPassed: '',
        customFeedbackFailed: ''
      },
      notifications: {
        notifyTrainer: false,
        notifyTeamLeader: false,
        notifyOnCompletion: false,
        notifyOnFail: false
      }
    };
  }
  
  /**
   * Speichert die Einstellungen eines Tests
   * @param {string} testId - ID des Tests
   * @param {Object} settings - Testeinstellungen-Objekt
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function saveTestSettings(testId, settings) {
    // Test-Grunddaten laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById || !TestBasicData.updateTest) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return false;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    // Einstellungen aktualisieren
    test.settings = settings;
    
    // Test aktualisieren
    const success = TestBasicData.updateTest(testId, { settings: settings });
    
    if (success) {
      NotificationSystem.showSuccess('Testeinstellungen wurden erfolgreich gespeichert.');
      return true;
    } else {
      NotificationSystem.showError('Fehler beim Speichern der Testeinstellungen.');
      return false;
    }
  }
  
  /**
   * Fügt eine neue Fragenkategorie hinzu
   * @param {string} testId - ID des Tests
   * @param {Object} category - Kategorie-Objekt
   * @returns {Object|null} - Die hinzugefügte Kategorie oder null bei Fehler
   */
  function addQuestionCategory(testId, category) {
    const settings = loadTestSettings(testId);
    if (!settings) return null;
    
    // Kategorie-ID erstellen
    const categoryId = 'cat_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Neue Kategorie
    const newCategory = {
      id: categoryId,
      name: category.name || 'Neue Kategorie',
      description: category.description || '',
      weight: category.weight || 1
    };
    
    // Kategorie hinzufügen
    settings.questionCategories.push(newCategory);
    
    // Einstellungen speichern
    if (saveTestSettings(testId, settings)) {
      return newCategory;
    }
    
    return null;
  }
  
  /**
   * Aktualisiert eine Fragenkategorie
   * @param {string} testId - ID des Tests
   * @param {string} categoryId - ID der Kategorie
   * @param {Object} updatedCategory - Aktualisierte Kategorie-Daten
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateQuestionCategory(testId, categoryId, updatedCategory) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Kategorie finden
    const categoryIndex = settings.questionCategories.findIndex(cat => cat.id === categoryId);
    if (categoryIndex === -1) {
      console.error('Kategorie nicht gefunden:', categoryId);
      return false;
    }
    
    // Kategorie aktualisieren
    settings.questionCategories[categoryIndex] = {
      ...settings.questionCategories[categoryIndex],
      name: updatedCategory.name !== undefined ? updatedCategory.name : settings.questionCategories[categoryIndex].name,
      description: updatedCategory.description !== undefined ? updatedCategory.description : settings.questionCategories[categoryIndex].description,
      weight: updatedCategory.weight !== undefined ? updatedCategory.weight : settings.questionCategories[categoryIndex].weight
    };
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  /**
   * Löscht eine Fragenkategorie
   * @param {string} testId - ID des Tests
   * @param {string} categoryId - ID der Kategorie
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestionCategory(testId, categoryId) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Kategorie finden
    const categoryIndex = settings.questionCategories.findIndex(cat => cat.id === categoryId);
    if (categoryIndex === -1) {
      console.error('Kategorie nicht gefunden:', categoryId);
      return false;
    }
    
    // Kategorie löschen
    settings.questionCategories.splice(categoryIndex, 1);
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  /**
   * Aktualisiert die Bewertungsregeln
   * @param {string} testId - ID des Tests
   * @param {Object} scoringRules - Bewertungsregeln
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateScoringRules(testId, scoringRules) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Bewertungsregeln aktualisieren
    settings.scoringRules = {
      ...settings.scoringRules,
      ...scoringRules
    };
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  /**
   * Aktualisiert die Erscheinungseinstellungen
   * @param {string} testId - ID des Tests
   * @param {Object} appearance - Erscheinungseinstellungen
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateAppearanceSettings(testId, appearance) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Erscheinungseinstellungen aktualisieren
    settings.appearance = {
      ...settings.appearance,
      ...appearance
    };
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  /**
   * Aktualisiert die Feedback-Einstellungen
   * @param {string} testId - ID des Tests
   * @param {Object} feedback - Feedback-Einstellungen
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateFeedbackSettings(testId, feedback) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Feedback-Einstellungen aktualisieren
    settings.feedback = {
      ...settings.feedback,
      ...feedback
    };
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  /**
   * Aktualisiert die Benachrichtigungseinstellungen
   * @param {string} testId - ID des Tests
   * @param {Object} notifications - Benachrichtigungseinstellungen
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateNotificationSettings(testId, notifications) {
    const settings = loadTestSettings(testId);
    if (!settings) return false;
    
    // Benachrichtigungseinstellungen aktualisieren
    settings.notifications = {
      ...settings.notifications,
      ...notifications
    };
    
    // Einstellungen speichern
    return saveTestSettings(testId, settings);
  }
  
  // Öffentliche API
  return {
    loadTestSettings: loadTestSettings,
    createDefaultSettings: createDefaultSettings,
    saveTestSettings: saveTestSettings,
    addQuestionCategory: addQuestionCategory,
    updateQuestionCategory: updateQuestionCategory,
    deleteQuestionCategory: deleteQuestionCategory,
    updateScoringRules: updateScoringRules,
    updateAppearanceSettings: updateAppearanceSettings,
    updateFeedbackSettings: updateFeedbackSettings,
    updateNotificationSettings: updateNotificationSettings,
    
    // Diese Funktionen werden in Teil 2 implementiert und hier exportiert
    renderSettingsForm: null,
    refreshCategoryList: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.2.2: Test-Einstellungen - UI-Komponenten
 * 
 * Dieser Teil des Moduls implementiert die Benutzeroberfläche für die
 * Verwaltung von Testeinstellungen, einschließlich Formulare und Event-Handler.
 */

// Bestehende Funktionen aus Teil 1 verwenden und UI-Funktionen hinzufügen
(function() {
  // Sicherstellen, dass TestSettings existiert
  if (typeof TestSettings === 'undefined') {
    console.error('TestSettings-Modul nicht gefunden.');
    return;
  }
  
  /**
   * Rendert das Einstellungsformular
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   */
  function renderSettingsForm(containerId, testId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Einstellungen laden
    const settings = TestSettings.loadTestSettings(testId);
    if (!settings) {
      container.innerHTML = '<p class="error-message">Fehler beim Laden der Testeinstellungen.</p>';
      return;
    }
    
    // Tabs für verschiedene Einstellungsbereiche
    let html = `
      <div class="settings-container">
        <div class="settings-tabs">
          <button class="tab-button active" data-tab="scoring">Bewertung</button>
          <button class="tab-button" data-tab="categories">Kategorien</button>
          <button class="tab-button" data-tab="appearance">Erscheinungsbild</button>
          <button class="tab-button" data-tab="feedback">Feedback</button>
          <button class="tab-button" data-tab="notifications">Benachrichtigungen</button>
        </div>
        
        <div class="settings-content">
          <!-- Bewertung -->
          <div class="tab-content active" id="scoring-tab">
            <h3>Bewertungsregeln</h3>
            <form id="scoring-form" class="settings-form">
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="partial-credit" 
                         ${settings.scoringRules.partialCredit ? 'checked' : ''}>
                  <label for="partial-credit">Teilpunkte erlauben</label>
                </div>
                <div class="form-help">Bei Aktivierung können bei Multiple-Choice-Fragen Teilpunkte für teilweise richtige Antworten vergeben werden.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="negative-scoring" 
                         ${settings.scoringRules.negativeScoring ? 'checked' : ''}>
                  <label for="negative-scoring">Negative Punkte für falsche Antworten</label>
                </div>
                <div class="form-help">Bei Aktivierung werden für falsche Antworten Punkte abgezogen.</div>
              </div>
              
              <div class="form-group" id="penalty-percentage-group" 
                  ${settings.scoringRules.negativeScoring ? '' : 'style="display: none;"'}>
                <label for="penalty-percentage">Strafpunkte-Prozentsatz</label>
                <div class="range-input-group">
                  <input type="range" id="penalty-percentage" min="0" max="100" step="5" 
                         value="${settings.scoringRules.penaltyPercentage}">
                  <span id="penalty-percentage-value">${settings.scoringRules.penaltyPercentage}%</span>
                </div>
                <div class="form-help">Prozentsatz der Punkte, die für falsche Antworten abgezogen werden.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="time-based-scoring" 
                         ${settings.scoringRules.timeBasedScoring ? 'checked' : ''}>
                  <label for="time-based-scoring">Zeitbasierte Bewertung</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Punkte basierend auf der benötigten Zeit vergeben (schnellere Antworten = mehr Punkte).</div>
              </div>
              
              <div class="form-group" id="time-based-penalty-group" 
                  ${settings.scoringRules.timeBasedScoring ? '' : 'style="display: none;"'}>
                <label for="time-based-penalty">Zeitstrafe-Prozentsatz</label>
                <div class="range-input-group">
                  <input type="range" id="time-based-penalty" min="0" max="50" step="5" 
                         value="${settings.scoringRules.timeBasedPenalty}">
                  <span id="time-based-penalty-value">${settings.scoringRules.timeBasedPenalty}%</span>
                </div>
                <div class="form-help">Prozentsatz der Punkte, die pro Minute abgezogen werden.</div>
              </div>
              
              <div class="form-group">
                <label for="auto-grade-threshold">Schwellenwert für automatische Benotung (%)</label>
                <input type="number" id="auto-grade-threshold" class="form-control" min="0" max="100" 
                       value="${settings.scoringRules.autoGradeThreshold}">
                <div class="form-help">Prozentsatz der Fragen, die automatisch bewertet werden können (der Rest erfordert manuelle Bewertung).</div>
              </div>
              
              <div class="form-actions">
                <button type="submit" class="btn btn-primary">Bewertungseinstellungen speichern</button>
              </div>
            </form>
          </div>
          
          <!-- Kategorien -->
          <div class="tab-content" id="categories-tab">
            <h3>Fragenkategorien</h3>
            <div class="categories-container">
              <div class="categories-list" id="categories-list">
    `;
    
    // Vorhandene Kategorien auflisten
    if (settings.questionCategories.length === 0) {
      html += `<p class="no-data-message">Keine Kategorien vorhanden. Fügen Sie Kategorien hinzu, um Fragen zu organisieren.</p>`;
    } else {
      html += `<ul class="categories-items">`;
      
      settings.questionCategories.forEach(category => {
        html += `
          <li class="category-item" data-category-id="${category.id}">
            <div class="category-info">
              <div class="category-name">${category.name}</div>
              <div class="category-description">${category.description || '-'}</div>
              <div class="category-weight">Gewichtung: ${category.weight}</div>
            </div>
            <div class="category-actions">
              <button class="btn btn-sm btn-edit edit-category-btn" data-category-id="${category.id}">
                <i class="fas fa-edit"></i> Bearbeiten
              </button>
              <button class="btn btn-sm btn-danger delete-category-btn" data-category-id="${category.id}">
                <i class="fas fa-trash"></i> Löschen
              </button>
            </div>
          </li>
        `;
      });
      
      html += `</ul>`;
    }
    
    html += `
              </div>
              
              <div class="category-form-container" id="category-form-container">
                <h4 id="category-form-title">Neue Kategorie hinzufügen</h4>
                <form id="category-form" class="settings-form">
                  <input type="hidden" id="category-id" value="">
                  
                  <div class="form-group">
                    <label for="category-name">Kategoriename*</label>
                    <input type="text" id="category-name" class="form-control" required>
                  </div>
                  
                  <div class="form-group">
                    <label for="category-description">Beschreibung</label>
                    <textarea id="category-description" class="form-control" rows="2"></textarea>
                  </div>
                  
                  <div class="form-group">
                    <label for="category-weight">Gewichtung</label>
                    <div class="range-input-group">
                      <input type="range" id="category-weight" min="1" max="10" step="1" value="1">
                      <span id="category-weight-value">1</span>
                    </div>
                    <div class="form-help">Gewichtung der Kategorie bei der Gesamtbewertung (1 = normal, 10 = sehr wichtig).</div>
                  </div>
                  
                  <div class="form-actions">
                    <button type="button" id="cancel-category-btn" class="btn btn-secondary" style="display: none;">Abbrechen</button>
                    <button type="submit" class="btn btn-primary">Kategorie speichern</button>
                  </div>
                </form>
              </div>
            </div>
          </div>
          
          <!-- Erscheinungsbild -->
          <div class="tab-content" id="appearance-tab">
            <h3>Erscheinungsbild</h3>
            <form id="appearance-form" class="settings-form">
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-progress-bar" 
                         ${settings.appearance.showProgressBar ? 'checked' : ''}>
                  <label for="show-progress-bar">Fortschrittsbalken anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung wird ein Fortschrittsbalken angezeigt, der den Fortschritt im Test anzeigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-question-numbers" 
                         ${settings.appearance.showQuestionNumbers ? 'checked' : ''}>
                  <label for="show-question-numbers">Fragennummern anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden die Fragennummern angezeigt (z.B. "Frage 1 von 10").</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-time-remaining" 
                         ${settings.appearance.showTimeRemaining ? 'checked' : ''}>
                  <label for="show-time-remaining">Verbleibende Zeit anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung wird die verbleibende Zeit für den Test angezeigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="allow-previous" 
                         ${settings.appearance.allowPrevious ? 'checked' : ''}>
                  <label for="allow-previous">Zurück-Navigation erlauben</label>
                </div>
                <div class="form-help">Bei Aktivierung können Teilnehmer zu vorherigen Fragen zurückkehren und ihre Antworten ändern.</div>
              </div>
              
              <div class="form-group">
                <label for="theme">Farbthema</label>
                <select id="theme" class="form-control">
                  <option value="default" ${settings.appearance.theme === 'default' ? 'selected' : ''}>Standard (ImmoScout-Farben)</option>
                  <option value="dark" ${settings.appearance.theme === 'dark' ? 'selected' : ''}>Dunkel</option>
                  <option value="light" ${settings.appearance.theme === 'light' ? 'selected' : ''}>Hell</option>
                  <option value="custom" ${settings.appearance.theme === 'custom' ? 'selected' : ''}>Benutzerdefiniert</option>
                </select>
                <div class="form-help">Wählen Sie ein vordefiniertes Farbthema für den Test.</div>
              </div>
              
              <div class="form-actions">
                <button type="submit" class="btn btn-primary">Erscheinungsbild speichern</button>
              </div>
            </form>
          </div>
          
          <!-- Feedback -->
          <div class="tab-content" id="feedback-tab">
            <h3>Feedback-Einstellungen</h3>
            <form id="feedback-form" class="settings-form">
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-correct-answers" 
                         ${settings.feedback.showCorrectAnswers ? 'checked' : ''}>
                  <label for="show-correct-answers">Richtige Antworten anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden nach Abschluss des Tests die richtigen Antworten angezeigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-explanations" 
                         ${settings.feedback.showExplanations ? 'checked' : ''}>
                  <label for="show-explanations">Erklärungen anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Erklärungen zu den richtigen Antworten angezeigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="show-score" 
                         ${settings.feedback.showScore ? 'checked' : ''}>
                  <label for="show-score">Punktzahl anzeigen</label>
                </div>
                <div class="form-help">Bei Aktivierung wird die erreichte Punktzahl nach Abschluss des Tests angezeigt.</div>
              </div>
              
              <div class="form-group">
                <label for="custom-feedback-passed">Benutzerdefiniertes Feedback bei Bestehen</label>
                <textarea id="custom-feedback-passed" class="form-control" rows="3">${settings.feedback.customFeedbackPassed || ''}</textarea>
                <div class="form-help">Dieses Feedback wird angezeigt, wenn der Teilnehmer den Test bestanden hat.</div>
              </div>
              
              <div class="form-group">
                <label for="custom-feedback-failed">Benutzerdefiniertes Feedback bei Nichtbestehen</label>
                <textarea id="custom-feedback-failed" class="form-control" rows="3">${settings.feedback.customFeedbackFailed || ''}</textarea>
                <div class="form-help">Dieses Feedback wird angezeigt, wenn der Teilnehmer den Test nicht bestanden hat.</div>
              </div>
              
              <div class="form-actions">
                <button type="submit" class="btn btn-primary">Feedback-Einstellungen speichern</button>
              </div>
            </form>
          </div>
          
          <!-- Benachrichtigungen -->
          <div class="tab-content" id="notifications-tab">
            <h3>Benachrichtigungseinstellungen</h3>
            <form id="notifications-form" class="settings-form">
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="notify-trainer" 
                         ${settings.notifications.notifyTrainer ? 'checked' : ''}>
                  <label for="notify-trainer">Trainer benachrichtigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Trainer über Testergebnisse benachrichtigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="notify-team-leader" 
                         ${settings.notifications.notifyTeamLeader ? 'checked' : ''}>
                  <label for="notify-team-leader">Teamleiter benachrichtigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Teamleiter über die Ergebnisse ihrer Teammitglieder benachrichtigt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="notify-on-completion" 
                         ${settings.notifications.notifyOnCompletion ? 'checked' : ''}>
                  <label for="notify-on-completion">Bei Abschluss benachrichtigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Benachrichtigungen gesendet, wenn ein Teilnehmer den Test abschließt.</div>
              </div>
              
              <div class="form-group">
                <div class="checkbox-group">
                  <input type="checkbox" id="notify-on-fail" 
                         ${settings.notifications.notifyOnFail ? 'checked' : ''}>
                  <label for="notify-on-fail">Bei Nichtbestehen benachrichtigen</label>
                </div>
                <div class="form-help">Bei Aktivierung werden Benachrichtigungen nur gesendet, wenn ein Teilnehmer den Test nicht besteht.</div>
              </div>
              
              <div class="form-actions">
                <button type="submit" class="btn btn-primary">Benachrichtigungseinstellungen speichern</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addSettingsEventListeners(containerId, testId);
  }
  
  // Die renderSettingsForm Funktion dem TestSettings-Modul hinzufügen
  TestSettings.renderSettingsForm = renderSettingsForm;
  
  /**
   * Setzt das Kategorieformular zurück
   */
  function resetCategoryForm() {
    const categoryForm = document.getElementById('category-form');
    if (!categoryForm) return;
    
    // Formular zurücksetzen
    document.getElementById('category-id').value = '';
    document.getElementById('category-name').value = '';
    document.getElementById('category-description').value = '';
    document.getElementById('category-weight').value = '1';
    document.getElementById('category-weight-value').textContent = '1';
    
    // Formularüberschrift aktualisieren
    document.getElementById('category-form-title').textContent = 'Neue Kategorie hinzufügen';
    
    // Abbrechen-Button ausblenden
    document.getElementById('cancel-category-btn').style.display = 'none';
  }
  
  /**
   * Aktualisiert die Kategorieliste
   * @param {string} testId - ID des Tests
   */
  function refreshCategoryList(testId) {
    const settings = TestSettings.loadTestSettings(testId);
    if (!settings) return;
    
    const categoriesList = document.getElementById('categories-list');
    if (!categoriesList) return;
    
    // HTML für die Kategorieliste erstellen
    let html = '';
    
    if (settings.questionCategories.length === 0) {
      html = `<p class="no-data-message">Keine Kategorien vorhanden. Fügen Sie Kategorien hinzu, um Fragen zu organisieren.</p>`;
    } else {
      html = `<ul class="categories-items">`;
      
      settings.questionCategories.forEach(category => {
        html += `
          <li class="category-item" data-category-id="${category.id}">
            <div class="category-info">
              <div class="category-name">${category.name}</div>
              <div class="category-description">${category.description || '-'}</div>
              <div class="category-weight">Gewichtung: ${category.weight}</div>
            </div>
            <div class="category-actions">
              <button class="btn btn-sm btn-edit edit-category-btn" data-category-id="${category.id}">
                <i class="fas fa-edit"></i> Bearbeiten
              </button>
              <button class="btn btn-sm btn-danger delete-category-btn" data-category-id="${category.id}">
                <i class="fas fa-trash"></i> Löschen
              </button>
            </div>
          </li>
        `;
      });
      
      html += `</ul>`;
    }
    
    // HTML in den Container einfügen
    categoriesList.innerHTML = html;
  }
  
  // Die refreshCategoryList Funktion dem TestSettings-Modul hinzufügen
  TestSettings.refreshCategoryList = refreshCategoryList;
  
  /**
   * Lädt eine Kategorie zum Bearbeiten
   * @param {string} testId - ID des Tests
   * @param {string} categoryId - ID der Kategorie
   */
  function editCategory(testId, categoryId) {
    const settings = TestSettings.loadTestSettings(testId);
    if (!settings) return;
    
    // Kategorie finden
    const category = settings.questionCategories.find(cat => cat.id === categoryId);
    if (!category) {
      console.error('Kategorie nicht gefunden:', categoryId);
      return;
    }
    
    // Formular mit Kategorie-Daten füllen
    document.getElementById('category-id').value = category.id;
    document.getElementById('category-name').value = category.name;
    document.getElementById('category-description').value = category.description || '';
    document.getElementById('category-weight').value = category.weight;
    document.getElementById('category-weight-value').textContent = category.weight;
    
    // Formularüberschrift aktualisieren
    document.getElementById('category-form-title').textContent = 'Kategorie bearbeiten';
    
    // Abbrechen-Button anzeigen
    document.getElementById('cancel-category-btn').style.display = '';
  }
  
  /**
   * Löscht eine Kategorie nach Bestätigung
   * @param {string} testId - ID des Tests
   * @param {string} categoryId - ID der Kategorie
   */
  function deleteCategory(testId, categoryId) {
    const settings = TestSettings.loadTestSettings(testId);
    if (!settings) return;
    
    // Kategorie finden
    const category = settings.questionCategories.find(cat => cat.id === categoryId);
    if (!category) {
      console.error('Kategorie nicht gefunden:', categoryId);
      return;
    }
    
    // Bestätigungsdialog anzeigen
    if (confirm(`Sind Sie sicher, dass Sie die Kategorie "${category.name}" löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.`)) {
      // Kategorie löschen
      TestSettings.deleteQuestionCategory(testId, categoryId);
      
      // Kategorieliste aktualisieren
      refreshCategoryList(testId);
    }
  }
  
  /**
   * Fügt Event-Listener für das Einstellungsformular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   */
  function addSettingsEventListeners(containerId, testId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Tab-Navigation
    const tabButtons = container.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
      button.addEventListener('click', function() {
        // Aktiven Tab-Button setzen
        tabButtons.forEach(btn => btn.classList.remove('active'));
        this.classList.add('active');
        
        // Aktiven Tab-Inhalt setzen
        const tabId = this.getAttribute('data-tab');
        const tabContents = container.querySelectorAll('.tab-content');
        tabContents.forEach(content => content.classList.remove('active'));
        container.querySelector(`#${tabId}-tab`).classList.add('active');
      });
    });
    
    // Bewertungsformular
    const scoringForm = container.querySelector('#scoring-form');
    if (scoringForm) {
      // Event-Listener für "Negative Punkte"
      const negativeScoring = container.querySelector('#negative-scoring');
      const penaltyGroup = container.querySelector('#penalty-percentage-group');
      
      if (negativeScoring && penaltyGroup) {
        negativeScoring.addEventListener('change', function() {
          penaltyGroup.style.display = this.checked ? '' : 'none';
        });
      }
      
      // Event-Listener für "Zeitbasierte Bewertung"
      const timeBasedScoring = container.querySelector('#time-based-scoring');
      const timeBasedPenaltyGroup = container.querySelector('#time-based-penalty-group');
      
      if (timeBasedScoring && timeBasedPenaltyGroup) {
        timeBasedScoring.addEventListener('change', function() {
          timeBasedPenaltyGroup.style.display = this.checked ? '' : 'none';
        });
      }
      
      // Range-Input für Strafpunkte
      const penaltyRange = container.querySelector('#penalty-percentage');
      const penaltyValue = container.querySelector('#penalty-percentage-value');
      
      if (penaltyRange && penaltyValue) {
        penaltyRange.addEventListener('input', function() {
          penaltyValue.textContent = this.value + '%';
        });
      }
      
      // Range-Input für Zeitstrafe
      const timeBasedPenaltyRange = container.querySelector('#time-based-penalty');
      const timeBasedPenaltyValue = container.querySelector('#time-based-penalty-value');
      
      if (timeBasedPenaltyRange && timeBasedPenaltyValue) {
        timeBasedPenaltyRange.addEventListener('input', function() {
          timeBasedPenaltyValue.textContent = this.value + '%';
        });
      }
      
      // Formular absenden
      scoringForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Daten sammeln
        const scoringRules = {
          partialCredit: document.getElementById('partial-credit').checked,
          negativeScoring: document.getElementById('negative-scoring').checked,
          penaltyPercentage: parseInt(document.getElementById('penalty-percentage').value) || 0,
          timeBasedScoring: document.getElementById('time-based-scoring').checked,
          timeBasedPenalty: parseInt(document.getElementById('time-based-penalty').value) || 0,
          autoGradeThreshold: parseInt(document.getElementById('auto-grade-threshold').value) || 80
        };
        
        // Einstellungen speichern
        TestSettings.updateScoringRules(testId, scoringRules);
      });
    }
    
    // Kategorieformular
    const categoryForm = container.querySelector('#category-form');
    if (categoryForm) {
      // Range-Input für Gewichtung
      const categoryWeightRange = container.querySelector('#category-weight');
      const categoryWeightValue = container.querySelector('#category-weight-value');
      
      if (categoryWeightRange && categoryWeightValue) {
        categoryWeightRange.addEventListener('input', function() {
          categoryWeightValue.textContent = this.value;
        });
      }
      
      // Formular absenden
      categoryForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Kategorie-ID (leer bei neuer Kategorie)
        const categoryId = document.getElementById('category-id').value;
        
        // Daten sammeln
        const categoryData = {
          name: document.getElementById('category-name').value.trim(),
          description: document.getElementById('category-description').value.trim(),
          weight: parseInt(document.getElementById('category-weight').value) || 1
        };
        
        // Validierung
        if (!categoryData.name) {
          NotificationSystem.showError('Bitte geben Sie einen Namen für die Kategorie ein.');
          return;
        }
        
        // Kategorie erstellen oder aktualisieren
        if (categoryId) {
          // Bestehende Kategorie aktualisieren
          TestSettings.updateQuestionCategory(testId, categoryId, categoryData);
        } else {
          // Neue Kategorie erstellen
          TestSettings.addQuestionCategory(testId, categoryData);
        }
        
        // Formular zurücksetzen
        resetCategoryForm();
        
        // Kategorieliste aktualisieren
        refreshCategoryList(testId);
      });
      
      // Abbrechen-Button
      const cancelCategoryBtn = container.querySelector('#cancel-category-btn');
      if (cancelCategoryBtn) {
        cancelCategoryBtn.addEventListener('click', function() {
          resetCategoryForm();
        });
      }
    }
    
    // Event-Delegation für Kategorie-Aktionen
    const categoriesList = container.querySelector('#categories-list');
    if (categoriesList) {
      categoriesList.addEventListener('click', function(event) {
        // "Bearbeiten"-Button
        if (event.target.classList.contains('edit-category-btn') || 
            event.target.closest('.edit-category-btn')) {
          const button = event.target.classList.contains('edit-category-btn') ? 
                        event.target : 
                        event.target.closest('.edit-category-btn');
          
          const categoryId = button.getAttribute('data-category-id');
          editCategory(testId, categoryId);
        }
        
        // "Löschen"-Button
        if (event.target.classList.contains('delete-category-btn') || 
            event.target.closest('.delete-category-btn')) {
          const button = event.target.classList.contains('delete-category-btn') ? 
                        event.target : 
                        event.target.closest('.delete-category-btn');
          
          const categoryId = button.getAttribute('data-category-id');
          deleteCategory(testId, categoryId);
        }
      });
    }
    
    // Erscheinungsformular
    const appearanceForm = container.querySelector('#appearance-form');
    if (appearanceForm) {
      appearanceForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Daten sammeln
        const appearance = {
          showProgressBar: document.getElementById('show-progress-bar').checked,
          showQuestionNumbers: document.getElementById('show-question-numbers').checked,
          showTimeRemaining: document.getElementById('show-time-remaining').checked,
          allowPrevious: document.getElementById('allow-previous').checked,
          theme: document.getElementById('theme').value
        };
        
        // Einstellungen speichern
        TestSettings.updateAppearanceSettings(testId, appearance);
      });
    }
    
    // Feedback-Formular
    const feedbackForm = container.querySelector('#feedback-form');
    if (feedbackForm) {
      feedbackForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Daten sammeln
        const feedback = {
          showCorrectAnswers: document.getElementById('show-correct-answers').checked,
          showExplanations: document.getElementById('show-explanations').checked,
          showScore: document.getElementById('show-score').checked,
          customFeedbackPassed: document.getElementById('custom-feedback-passed').value.trim(),
          customFeedbackFailed: document.getElementById('custom-feedback-failed').value.trim()
        };
        
        // Einstellungen speichern
        TestSettings.updateFeedbackSettings(testId, feedback);
      });
    }
    
    // Benachrichtigungsformular
    const notificationsForm = container.querySelector('#notifications-form');
    if (notificationsForm) {
      notificationsForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Daten sammeln
        const notifications = {
          notifyTrainer: document.getElementById('notify-trainer').checked,
          notifyTeamLeader: document.getElementById('notify-team-leader').checked,
          notifyOnCompletion: document.getElementById('notify-on-completion').checked,
          notifyOnFail: document.getElementById('notify-on-fail').checked
        };
        
        // Einstellungen speichern
        TestSettings.updateNotificationSettings(testId, notifications);
      });
    }
  }
})();
/**
 * JS-Block 4.2.3: Test-Einstellungen - CSS-Styling
 * 
 * Dieser Teil des Moduls fügt die notwendigen CSS-Stile für die
 * Test-Einstellungsformulare hinzu.
 */

// CSS für die Test-Einstellungen
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Test-Einstellungen existiert
  if (!document.getElementById('test-settings-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'test-settings-styles';
    styleElement.textContent = `
      /* Einstellungscontainer */
      .settings-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
      }
      
      /* Tabs */
      .settings-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 20px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 10px;
      }
      
      .tab-button {
        padding: 8px 15px;
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .tab-button:hover {
        background-color: #e0e0e0;
      }
      
      .tab-button.active {
        background-color: #00FFD0;
        border-color: #00D9B0;
        color: #000;
        font-weight: bold;
      }
      
      /* Tab-Inhalte */
      .tab-content {
        display: none;
        padding: 20px;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      
      .tab-content.active {
        display: block;
      }
      
      .tab-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        color: #333;
      }
      
      /* Formular */
      .settings-form {
        width: 100%;
      }
      
      .form-group {
        margin-bottom: 15px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      
      .form-help {
        font-size: 0.85em;
        color: #666;
        margin-top: 5px;
      }
      
      .form-control {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1em;
      }
      
      .checkbox-group {
        display: flex;
        align-items: center;
      }
      
      .checkbox-group input[type="checkbox"] {
        margin-right: 8px;
      }
      
      .range-input-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .range-input-group input[type="range"] {
        flex: 1;
      }
      
      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      
      /* Kategorien */
      .categories-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      
      .categories-list {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background-color: #f9f9f9;
        max-height: 400px;
        overflow-y: auto;
      }
      
      .categories-items {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .category-item {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 10px;
        border: 1px solid #eee;
        border-radius: 4px;
        margin-bottom: 10px;
        background-color: #fff;
      }
      
      .category-info {
        flex: 1;
      }
      
      .category-name {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .category-description {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
      }
      
      .category-weight {
        font-size: 0.85em;
        color: #333;
      }
      
      .category-actions {
        display: flex;
        gap: 5px;
      }
      
      .category-form-container {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background-color: #f9f9f9;
      }
      
      .category-form-container h4 {
        margin-top: 0;
        margin-bottom: 15px;
      }
      
      .error-message {
        color: #d9534f;
        font-weight: bold;
        padding: 10px;
        background-color: #ffeaea;
        border: 1px solid #d9534f;
        border-radius: 4px;
      }
      
      .no-data-message {
        padding: 15px;
        text-align: center;
        color: #666;
        font-style: italic;
      }
      
      /* Responsive Anpassungen */
      @media (max-width: 768px) {
        .categories-container {
          grid-template-columns: 1fr;
        }
        
        .settings-tabs {
          flex-direction: column;
        }
      }
      
      /* Buttons */
      .btn {
        display: inline-block;
        padding: 8px 16px;
        border: 1px solid transparent;
        border-radius: 4px;
        font-size: 1em;
        cursor: pointer;
        text-align: center;
        transition: all 0.2s;
      }
      
      .btn-primary {
        background-color: #00FFD0;
        border-color: #00D9B0;
        color: #000;
      }
      
      .btn-primary:hover {
        background-color: #00E0B0;
      }
      
      .btn-secondary {
        background-color: #f0f0f0;
        border-color: #ddd;
        color: #333;
      }
      
      .btn-secondary:hover {
        background-color: #e0e0e0;
      }
      
      .btn-danger {
        background-color: #ff6b6b;
        border-color: #ff5252;
        color: #fff;
      }
      
      .btn-danger:hover {
        background-color: #ff5252;
      }
      
      .btn-sm {
        padding: 5px 10px;
        font-size: 0.85em;
      }
      
      .btn-edit {
        background-color: #f0f0f0;
        border-color: #ddd;
        color: #333;
      }
      
      .btn-edit:hover {
        background-color: #e0e0e0;
      }
      
      /* Zusätzliche Stile für bessere Benutzerfreundlichkeit */
      input[type="range"]:focus,
      input[type="checkbox"]:focus,
      select:focus,
      textarea:focus,
      input[type="text"]:focus,
      input[type="number"]:focus {
        outline: 2px solid #00FFD0;
      }
      
      .tab-button:focus {
        outline: 2px solid #00FFD0;
        outline-offset: 2px;
      }
      
      /* Animations */
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .tab-content.active {
        animation: fadeIn 0.3s ease-in-out;
      }
      
      /* Tooltip */
      .form-help {
        position: relative;
      }
      
      .form-help:hover::after {
        content: "";
        position: absolute;
        left: -5px;
        top: 0;
        width: 3px;
        height: 100%;
        background-color: #00FFD0;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.3.1: Multiple-Choice-Fragen erstellen - Datenstruktur und Operationen
 * 
 * Dieses Modul implementiert die Grundfunktionen und Datenstrukturen
 * zum Erstellen und Verwalten von Multiple-Choice-Fragen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const MultipleChoiceQuestions = (function() {
  // Private Variablen
  let currentTest = null;
  let currentQuestion = null;
  
  /**
   * Multiple-Choice-Frage Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   type: 'multiple_choice',     // Fragentyp
   *   text: string,                // Fragentext
   *   description: string,         // Zusätzliche Beschreibung (optional)
   *   categoryId: string,          // Kategorie-ID (optional)
   *   difficulty: number,          // Schwierigkeitsgrad (1-5)
   *   points: number,              // Punkte für diese Frage
   *   options: [                  // Antwortoptionen
   *     {
   *       id: string,              // Eindeutige ID der Option
   *       text: string,            // Text der Antwortoption
   *       isCorrect: boolean       // Ist diese Option korrekt?
   *     }
   *   ],
   *   allowMultiple: boolean,      // Mehrere Antworten erlaubt?
   *   randomizeOptions: boolean,   // Optionen in zufälliger Reihenfolge anzeigen?
   *   explanation: string,         // Erklärung der richtigen Antwort
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date              // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Erstellt eine neue Multiple-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {Object} questionData - Daten der Frage
   * @returns {Object|null} - Die erstellte Frage oder null bei Fehler
   */
  function createQuestion(testId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Fragen-Array erstellen, falls nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Eindeutige ID für die Frage
    const questionId = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Sicherstellen, dass options ein Array ist
    const options = questionData.options || [];
    
    // Sicherstellen, dass jede Option eine ID hat
    const processedOptions = options.map(option => {
      if (!option.id) {
        option.id = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
      }
      return option;
    });
    
    // Neue Frage erstellen
    const newQuestion = {
      id: questionId,
      type: 'multiple_choice',
      text: questionData.text || 'Neue Frage',
      description: questionData.description || '',
      categoryId: questionData.categoryId || null,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : 3,
      points: questionData.points !== undefined ? questionData.points : 1,
      options: processedOptions,
      allowMultiple: questionData.allowMultiple !== undefined ? questionData.allowMultiple : false,
      randomizeOptions: questionData.randomizeOptions !== undefined ? questionData.randomizeOptions : false,
      explanation: questionData.explanation || '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Frage zum Test hinzufügen
    test.questions.push(newQuestion);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich erstellt.');
        return newQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Aktualisiert eine vorhandene Multiple-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} questionData - Neue Fragendaten
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateQuestion(testId, questionId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Aktuelles Fragen-Objekt
    const currentQuestionData = test.questions[questionIndex];
    
    // Optionen verarbeiten
    let updatedOptions = currentQuestionData.options;
    if (questionData.options !== undefined) {
      updatedOptions = questionData.options.map(option => {
        if (!option.id) {
          option.id = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
        }
        return option;
      });
    }
    
    // Frage aktualisieren
    const updatedQuestion = {
      ...currentQuestionData,
      text: questionData.text !== undefined ? questionData.text : currentQuestionData.text,
      description: questionData.description !== undefined ? questionData.description : currentQuestionData.description,
      categoryId: questionData.categoryId !== undefined ? questionData.categoryId : currentQuestionData.categoryId,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : currentQuestionData.difficulty,
      points: questionData.points !== undefined ? questionData.points : currentQuestionData.points,
      options: updatedOptions,
      allowMultiple: questionData.allowMultiple !== undefined ? questionData.allowMultiple : currentQuestionData.allowMultiple,
      randomizeOptions: questionData.randomizeOptions !== undefined ? questionData.randomizeOptions : currentQuestionData.randomizeOptions,
      explanation: questionData.explanation !== undefined ? questionData.explanation : currentQuestionData.explanation,
      updatedAt: new Date().toISOString()
    };
    
    // Aktualisierte Frage speichern
    test.questions[questionIndex] = updatedQuestion;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich aktualisiert.');
        return updatedQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Multiple-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestion(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return false;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return false;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return false;
    }
    
    // Frage entfernen
    test.questions.splice(questionIndex, 1);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich gelöscht.');
        return true;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Frage.');
        return false;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return false;
    }
  }
  
  /**
   * Fügt eine Antwortoption zu einer Frage hinzu
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} optionData - Daten der Antwortoption
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function addOption(testId, questionId, optionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Neue Antwortoption erstellen
    const optionId = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    const newOption = {
      id: optionId,
      text: optionData.text || 'Neue Antwortoption',
      isCorrect: optionData.isCorrect !== undefined ? optionData.isCorrect : false
    };
    
    // Option zur Frage hinzufügen
    if (!question.options) {
      question.options = [];
    }
    
    question.options.push(newOption);
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Aktualisiert eine Antwortoption
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @param {Object} optionData - Neue Daten für die Option
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateOption(testId, questionId, optionId, optionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden
    if (!question.options) {
      console.error('Keine Optionen in der Frage vorhanden');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Option aktualisieren
    question.options[optionIndex] = {
      ...question.options[optionIndex],
      text: optionData.text !== undefined ? optionData.text : question.options[optionIndex].text,
      isCorrect: optionData.isCorrect !== undefined ? optionData.isCorrect : question.options[optionIndex].isCorrect
    };
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Antwortoption
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function deleteOption(testId, questionId, optionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden und entfernen
    if (!question.options) {
      console.error('Keine Optionen in der Frage vorhanden');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Option entfernen
    question.options.splice(optionIndex, 1);
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Ändert die Reihenfolge der Antwortoptionen
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @param {string} direction - Richtung ('up' oder 'down')
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function reorderOption(testId, questionId, optionId, direction) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden
    if (!question.options || question.options.length < 2) {
      console.error('Zu wenige Optionen für eine Neuordnung');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Neue Position berechnen
    let newIndex = optionIndex;
    if (direction === 'up' && optionIndex > 0) {
      newIndex = optionIndex - 1;
    } else if (direction === 'down' && optionIndex < question.options.length - 1) {
      newIndex = optionIndex + 1;
    } else {
      // Keine Änderung nötig
      return question;
    }
    
    // Elemente tauschen
    const temp = question.options[optionIndex];
    question.options[optionIndex] = question.options[newIndex];
    question.options[newIndex] = temp;
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Neuordnen der Antwortoptionen.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Gibt eine Multiple-Choice-Frage anhand ihrer ID zurück
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {Object|null} - Die Frage oder null, wenn nicht gefunden
   */
  function getQuestionById(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    return question || null;
  }
  
  /**
   * Gibt alle Multiple-Choice-Fragen eines Tests zurück
   * @param {string} testId - ID des Tests
   * @returns {Array} - Array mit Fragen
   */
  function getQuestions(testId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return [];
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return [];
    }
    
    // Multiple-Choice-Fragen filtern
    if (!test.questions) {
      return [];
    }
    
    return test.questions.filter(q => q.type === 'multiple_choice');
  }
  
  /**
   * Validiert eine Multiple-Choice-Frage
   * @param {Object} question - Die zu validierende Frage
   * @returns {Object} - Objekt mit den Eigenschaften isValid und errors
   */
  function validateQuestion(question) {
    const errors = [];
    
    // Pflichtfelder überprüfen
    if (!question.text || question.text.trim() === '') {
      errors.push('Der Fragentext darf nicht leer sein.');
    }
    
    // Antwortoptionen überprüfen
    if (!question.options || question.options.length < 2) {
      errors.push('Die Frage muss mindestens zwei Antwortoptionen haben.');
    } else {
      // Prüfen, ob mindestens eine korrekte Option existiert
      const hasCorrectOption = question.options.some(option => option.isCorrect);
      if (!hasCorrectOption) {
        errors.push('Es muss mindestens eine korrekte Antwortoption geben.');
      }
      
      // Prüfen, ob jede Option Text hat
      const emptyOptions = question.options.some(option => !option.text || option.text.trim() === '');
      if (emptyOptions) {
        errors.push('Alle Antwortoptionen müssen einen Text haben.');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }
  
  /**
   * Erstellt eine neue leere Multiple-Choice-Frage mit Standardwerten
   * @returns {Object} - Neue Frage
   */
  function createEmptyQuestion() {
    return {
      id: '',
      type: 'multiple_choice',
      text: '',
      description: '',
      categoryId: null,
      difficulty: 3,
      points: 1,
      options: [
        {
          id: 'opt_' + Date.now() + '_1',
          text: '',
          isCorrect: false
        },
        {
          id: 'opt_' + Date.now() + '_2',
          text: '',
          isCorrect: false
        }
      ],
      allowMultiple: false,
      randomizeOptions: false,
      explanation: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  }
  
  // Öffentliche API
  return {
    createQuestion: createQuestion,
    updateQuestion: updateQuestion,
    deleteQuestion: deleteQuestion,
    addOption: addOption,
    updateOption: updateOption,
    deleteOption: deleteOption,
    reorderOption: reorderOption,
    getQuestionById: getQuestionById,
    getQuestions: getQuestions,
    validateQuestion: validateQuestion,
    createEmptyQuestion: createEmptyQuestion,
    
    // Diese Funktionen werden in Teil 2 implementiert
    renderQuestionForm: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.3.2: Multiple-Choice-Fragen erstellen - UI-Komponenten
 * 
 * Dieser Teil des Moduls implementiert die Benutzeroberfläche für
 * das Erstellen und Bearbeiten von Multiple-Choice-Fragen.
 */

// Bestehende Funktionen aus Teil 1 verwenden und UI-Funktionen hinzufügen
(function() {
  // Sicherstellen, dass MultipleChoiceQuestions existiert
  if (typeof MultipleChoiceQuestions === 'undefined') {
    console.error('MultipleChoiceQuestions-Modul nicht gefunden.');
    return;
  }
  
  /**
   * Rendert ein Formular zum Erstellen oder Bearbeiten einer Multiple-Choice-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function renderQuestionForm(containerId, testId, questionId = null, onSave = null, onCancel = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return;
    }
    
    // Frage laden oder erstellen
    let question = null;
    
    if (questionId) {
      question = MultipleChoiceQuestions.getQuestionById(testId, questionId);
      if (!question) {
        console.error('Frage nicht gefunden:', questionId);
        return;
      }
    } else {
      question = MultipleChoiceQuestions.createEmptyQuestion();
    }
    
    // Kategorien aus den Testeinstellungen laden
    let categories = [];
    if (test.settings && test.settings.questionCategories) {
      categories = test.settings.questionCategories;
    }
    
    // HTML für das Formular erstellen
    let html = `
      <div class="question-form multiple-choice-form">
        <form id="multiple-choice-form">
          <div class="form-section">
            <h3>${questionId ? 'Multiple-Choice-Frage bearbeiten' : 'Neue Multiple-Choice-Frage erstellen'}</h3>
            
            <div class="form-group">
              <label for="question-text">Fragentext*</label>
              <textarea id="question-text" class="form-control" rows="3" required>${question.text || ''}</textarea>
              <div class="form-help">Der Haupttext der Frage. Formulieren Sie die Frage klar und präzise.</div>
            </div>
            
            <div class="form-group">
              <label for="question-description">Beschreibung</label>
              <textarea id="question-description" class="form-control" rows="2">${question.description || ''}</textarea>
              <div class="form-help">Zusätzliche Informationen zur Frage (optional).</div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-category">Kategorie</label>
                <select id="question-category" class="form-control">
                  <option value="">-- Keine Kategorie --</option>
    `;
    
    // Kategorien hinzufügen
    categories.forEach(category => {
      const selected = question.categoryId === category.id ? 'selected' : '';
      html += `<option value="${category.id}" ${selected}>${category.name}</option>`;
    });
    
    html += `
                </select>
                <div class="form-help">Kategorisieren Sie die Frage für eine bessere Organisation.</div>
              </div>
              
              <div class="form-group half-width">
                <label for="question-difficulty">Schwierigkeitsgrad</label>
                <div class="range-input-group">
                  <input type="range" id="question-difficulty" min="1" max="5" step="1" value="${question.difficulty || 3}">
                  <span id="difficulty-value">${question.difficulty || 3}</span>
                </div>
                <div class="form-help">Schwierigkeitsgrad der Frage (1 = sehr leicht, 5 = sehr schwer).</div>
              </div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-points">Punkte</label>
                <input type="number" id="question-points" class="form-control" min="1" max="100" value="${question.points || 1}">
                <div class="form-help">Anzahl der Punkte, die für eine korrekte Antwort vergeben werden.</div>
              </div>
              
              <div class="form-group half-width checkbox-container">
                <div class="checkbox-group">
                  <input type="checkbox" id="allow-multiple" ${question.allowMultiple ? 'checked' : ''}>
                  <label for="allow-multiple">Mehrere Antworten erlauben</label>
                </div>
                <div class="checkbox-group">
                  <input type="checkbox" id="randomize-options" ${question.randomizeOptions ? 'checked' : ''}>
                  <label for="randomize-options">Optionen in zufälliger Reihenfolge</label>
                </div>
              </div>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Antwortoptionen</h3>
            <p class="section-help">Fügen Sie Antwortoptionen hinzu und markieren Sie die richtigen Antworten.</p>
            
            <div id="options-container" class="options-container">
    `;
    
    // Antwortoptionen hinzufügen
    if (question.options && question.options.length > 0) {
      question.options.forEach((option, index) => {
        html += createOptionHtml(option, index + 1);
      });
    } else {
      // Standardmäßig zwei leere Optionen
      html += createOptionHtml({ id: 'new_1', text: '', isCorrect: false }, 1);
      html += createOptionHtml({ id: 'new_2', text: '', isCorrect: false }, 2);
    }
    
    html += `
            </div>
            
            <div class="form-actions options-actions">
              <button type="button" id="add-option-btn" class="btn btn-secondary">
                <i class="fas fa-plus"></i> Option hinzufügen
              </button>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Erklärung</h3>
            
            <div class="form-group">
              <label for="question-explanation">Erklärung zur richtigen Antwort</label>
              <textarea id="question-explanation" class="form-control" rows="3">${question.explanation || ''}</textarea>
              <div class="form-help">Eine Erklärung, warum die markierten Antworten richtig sind. Diese wird den Teilnehmern nach dem Test angezeigt.</div>
            </div>
          </div>
          
          <div class="form-actions">
            <button type="button" id="cancel-question-btn" class="btn btn-secondary">Abbrechen</button>
            <button type="submit" class="btn btn-primary">Frage speichern</button>
          </div>
        </form>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel);
  }
  
  /**
   * Erstellt HTML für eine Antwortoption
   * @param {Object} option - Die Antwortoption
   * @param {number} index - Index der Option
   * @returns {string} - HTML für die Option
   */
  function createOptionHtml(option, index) {
    return `
      <div class="option-item" data-option-id="${option.id}">
        <div class="option-header">
          <div class="option-number">Option ${index}</div>
          <div class="option-actions">
            <button type="button" class="btn btn-sm btn-icon move-up-btn" title="Nach oben verschieben">
              <i class="fas fa-arrow-up"></i>
            </button>
            <button type="button" class="btn btn-sm btn-icon move-down-btn" title="Nach unten verschieben">
              <i class="fas fa-arrow-down"></i>
            </button>
            <button type="button" class="btn btn-sm btn-icon delete-option-btn" title="Option löschen">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>
        <div class="option-content">
          <div class="option-input-group">
            <textarea class="form-control option-text" placeholder="Antworttext eingeben">${option.text || ''}</textarea>
            <div class="option-correct">
              <input type="checkbox" class="option-correct-checkbox" id="option-correct-${option.id}" ${option.isCorrect ? 'checked' : ''}>
              <label for="option-correct-${option.id}">Korrekt</label>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  
  /**
   * Fügt Event-Listener für das Fragenformular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel) {
    // Schwierigkeitsgrad-Slider
    const difficultySlider = document.getElementById('question-difficulty');
    const difficultyValue = document.getElementById('difficulty-value');
    
    if (difficultySlider && difficultyValue) {
      difficultySlider.addEventListener('input', function() {
        difficultyValue.textContent = this.value;
      });
    }
    
    // "Option hinzufügen"-Button
    const addOptionBtn = document.getElementById('add-option-btn');
    if (addOptionBtn) {
      addOptionBtn.addEventListener('click', function() {
        addNewOption();
      });
    }
    
    // Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-question-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        if (typeof onCancel === 'function') {
          onCancel();
        }
      });
    }
    
    // Event-Delegation für Options-Aktionen
    const optionsContainer = document.getElementById('options-container');
    if (optionsContainer) {
      optionsContainer.addEventListener('click', function(event) {
        // Option löschen
        if (event.target.classList.contains('delete-option-btn') || 
            event.target.closest('.delete-option-btn')) {
          const button = event.target.classList.contains('delete-option-btn') ? 
                        event.target : 
                        event.target.closest('.delete-option-btn');
          
          const optionItem = button.closest('.option-item');
          if (optionsContainer.children.length > 2) {
            optionsContainer.removeChild(optionItem);
            updateOptionNumbers();
          } else {
            NotificationSystem.showError('Eine Frage muss mindestens zwei Antwortoptionen haben.');
          }
        }
        
        // Option nach oben verschieben
        if (event.target.classList.contains('move-up-btn') || 
            event.target.closest('.move-up-btn')) {
          const button = event.target.classList.contains('move-up-btn') ? 
                        event.target : 
                        event.target.closest('.move-up-btn');
          
          const optionItem = button.closest('.option-item');
          const prevOption = optionItem.previousElementSibling;
          
          if (prevOption) {
            optionsContainer.insertBefore(optionItem, prevOption);
            updateOptionNumbers();
          }
        }
        
        // Option nach unten verschieben
        if (event.target.classList.contains('move-down-btn') || 
            event.target.closest('.move-down-btn')) {
          const button = event.target.classList.contains('move-down-btn') ? 
                        event.target : 
                        event.target.closest('.move-down-btn');
          
          const optionItem = button.closest('.option-item');
          const nextOption = optionItem.nextElementSibling;
          
          if (nextOption) {
            optionsContainer.insertBefore(nextOption, optionItem);
            updateOptionNumbers();
          }
        }
      });
    }
    
    // Multiple-Choice-Formular
    const form = document.getElementById('multiple-choice-form');
    if (form) {
      form.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Formulardaten sammeln
        const formData = collectFormData();
        
        // Validierung
        const validation = MultipleChoiceQuestions.validateQuestion(formData);
        if (!validation.isValid) {
          NotificationSystem.showError(validation.errors.join(' '));
          return;
        }
        
        // Frage speichern
        let savedQuestion = null;
        
        if (questionId) {
          // Bestehende Frage aktualisieren
          savedQuestion = MultipleChoiceQuestions.updateQuestion(testId, questionId, formData);
        } else {
          // Neue Frage erstellen
          savedQuestion = MultipleChoiceQuestions.createQuestion(testId, formData);
        }
        
        if (savedQuestion) {
          // Callback aufrufen
          if (typeof onSave === 'function') {
            onSave(savedQuestion);
          }
        }
      });
    }
  }
  
  /**
   * Sammelt die Daten aus dem Fragenformular
   * @returns {Object} - Gesammelte Daten
   */
  function collectFormData() {
    const formData = {
      text: document.getElementById('question-text').value.trim(),
      description: document.getElementById('question-description').value.trim(),
      categoryId: document.getElementById('question-category').value || null,
      difficulty: parseInt(document.getElementById('question-difficulty').value) || 3,
      points: parseInt(document.getElementById('question-points').value) || 1,
      allowMultiple: document.getElementById('allow-multiple').checked,
      randomizeOptions: document.getElementById('randomize-options').checked,
      explanation: document.getElementById('question-explanation').value.trim(),
      options: []
    };
    
    // Antwortoptionen sammeln
    const optionItems = document.querySelectorAll('.option-item');
    optionItems.forEach(item => {
      const optionId = item.getAttribute('data-option-id');
      const text = item.querySelector('.option-text').value.trim();
      const isCorrect = item.querySelector('.option-correct-checkbox').checked;
      
      formData.options.push({
        id: optionId,
        text: text,
        isCorrect: isCorrect
      });
    });
    
    return formData;
  }
  
  /**
   * Fügt eine neue leere Antwortoption hinzu
   */
  function addNewOption() {
    const optionsContainer = document.getElementById('options-container');
    if (!optionsContainer) return;
    
    // Neue Option-ID erstellen
    const optionId = 'new_' + Date.now();
    
    // Aktuelle Anzahl der Optionen
    const optionCount = optionsContainer.children.length;
    
    // Neue Option erstellen
    const newOption = {
      id: optionId,
      text: '',
      isCorrect: false
    };
    
    // HTML für die neue Option erstellen
    const optionHtml = createOptionHtml(newOption, optionCount + 1);
    
    // Option zum Container hinzufügen
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = optionHtml;
    optionsContainer.appendChild(tempDiv.firstElementChild);
    
    // Auf die neue Option scrollen
    const newOptionElement = optionsContainer.lastElementChild;
    newOptionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Fokus auf das Textfeld setzen
    setTimeout(() => {
      const textArea = newOptionElement.querySelector('.option-text');
      if (textArea) {
        textArea.focus();
      }
    }, 100);
  }
  
  /**
   * Aktualisiert die Nummerierung der Antwortoptionen
   */
  function updateOptionNumbers() {
    const optionItems = document.querySelectorAll('.option-item');
    optionItems.forEach((item, index) => {
      const numberElement = item.querySelector('.option-number');
      if (numberElement) {
        numberElement.textContent = `Option ${index + 1}`;
      }
    });
  }
  
  // Die renderQuestionForm Funktion dem MultipleChoiceQuestions-Modul hinzufügen
  MultipleChoiceQuestions.renderQuestionForm = renderQuestionForm;
  
  /**
   * Rendert eine Liste aller Multiple-Choice-Fragen eines Tests
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen (bearbeiten, löschen, usw.)
   */
  function renderQuestionsList(containerId, testId, onAction = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Fragen laden
    const questions = MultipleChoiceQuestions.getQuestions(testId);
    
    // HTML für die Fragenliste erstellen
    let html = `
      <div class="questions-list">
        <div class="list-header">
          <h3>Multiple-Choice-Fragen</h3>
          <button id="add-question-btn" class="btn btn-primary">
            <i class="fas fa-plus"></i> Neue Frage erstellen
          </button>
        </div>
    `;
    
    if (questions.length === 0) {
      html += `
        <div class="no-items-message">
          <p>Keine Multiple-Choice-Fragen vorhanden.</p>
          <p>Klicken Sie auf "Neue Frage erstellen", um Ihre erste Frage hinzuzufügen.</p>
        </div>
      `;
    } else {
      html += `
        <div class="items-list">
      `;
      
      questions.forEach((question, index) => {
        // Anzahl der richtigen Antworten ermitteln
        const correctCount = question.options ? 
                            question.options.filter(opt => opt.isCorrect).length : 
                            0;
        
        // Maximal 100 Zeichen des Fragentexts anzeigen
        const truncatedText = question.text.length > 100 ? 
                             question.text.substring(0, 100) + '...' : 
                             question.text;
        
        html += `
          <div class="question-list-item" data-question-id="${question.id}">
            <div class="question-info">
              <div class="question-number">${index + 1}</div>
              <div class="question-content">
                <div class="question-title">${truncatedText}</div>
                <div class="question-meta">
                  <span class="question-type">Multiple-Choice</span>
                  <span class="question-options">${question.options ? question.options.length : 0} Optionen</span>
                  <span class="question-correct">${correctCount} korrekte Antwort${correctCount !== 1 ? 'en' : ''}</span>
                  <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
                </div>
              </div>
            </div>
            <div class="question-actions">
              <button class="btn btn-sm btn-primary preview-question-btn" data-question-id="${question.id}" title="Vorschau">
                <i class="fas fa-eye"></i>
              </button>
              <button class="btn btn-sm btn-edit edit-question-btn" data-question-id="${question.id}" title="Bearbeiten">
                <i class="fas fa-edit"></i>
              </button>
              <button class="btn btn-sm btn-danger delete-question-btn" data-question-id="${question.id}" title="Löschen">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      });
      
      html += `
        </div>
      `;
    }
    
    html += `
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionsListEventListeners(containerId, testId, onAction);
  }
  
  /**
   * Fügt Event-Listener für die Fragenliste hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen
   */
  function addQuestionsListEventListeners(containerId, testId, onAction) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // "Neue Frage erstellen"-Button
    const addQuestionBtn = container.querySelector('#add-question-btn');
    if (addQuestionBtn) {
      addQuestionBtn.addEventListener('click', function() {
        if (typeof onAction === 'function') {
          onAction('create', null);
        }
      });
    }
    
    // Event-Delegation für Fragen-Aktionen
    container.addEventListener('click', function(event) {
      // Vorschau-Button
      if (event.target.classList.contains('preview-question-btn') || 
          event.target.closest('.preview-question-btn')) {
        const button = event.target.classList.contains('preview-question-btn') ? 
                      event.target : 
                      event.target.closest('.preview-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('preview', questionId);
        }
      }
      
      // Bearbeiten-Button
      if (event.target.classList.contains('edit-question-btn') || 
          event.target.closest('.edit-question-btn')) {
        const button = event.target.classList.contains('edit-question-btn') ? 
                      event.target : 
                      event.target.closest('.edit-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('edit', questionId);
        }
      }
      
      // Löschen-Button
      if (event.target.classList.contains('delete-question-btn') || 
          event.target.closest('.delete-question-btn')) {
        const button = event.target.classList.contains('delete-question-btn') ? 
                      event.target : 
                      event.target.closest('.delete-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        // Bestätigungsdialog anzeigen
        if (confirm('Sind Sie sicher, dass Sie diese Frage löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.')) {
          const deleted = MultipleChoiceQuestions.deleteQuestion(testId, questionId);
          
          if (deleted) {
            // Fragenliste aktualisieren
            renderQuestionsList(containerId, testId, onAction);
          }
        }
      }
    });
  }
  
  /**
   * Rendert eine Vorschau einer Multiple-Choice-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Function} onClose - Callback-Funktion beim Schließen
   */
  function renderQuestionPreview(containerId, testId, questionId, onClose = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Frage laden
    const question = MultipleChoiceQuestions.getQuestionById(testId, questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return;
    }
    
    // HTML für die Fragenvorschau erstellen
    let html = `
      <div class="question-preview">
        <div class="preview-header">
          <h3>Fragenvorschau</h3>
          <button id="close-preview-btn" class="btn btn-icon">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="preview-content">
          <div class="question-display">
            <div class="question-text">${question.text}</div>
            ${question.description ? `<div class="question-description">${question.description}</div>` : ''}
            
            <div class="question-meta">
              <span class="question-difficulty">Schwierigkeit: ${question.difficulty}/5</span>
              <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
              ${question.allowMultiple ? '<span class="question-multiple">Mehrfachauswahl</span>' : '<span class="question-single">Einfachauswahl</span>'}
            </div>
          </div>
          
          <div class="options-display">
    `;
    
    // Antwortoptionen anzeigen
    if (question.options && question.options.length > 0) {
      html += `<div class="preview-label">${question.allowMultiple ? 'Wählen Sie alle zutreffenden Antworten:' : 'Wählen Sie die richtige Antwort:'}</div>`;
      
      question.options.forEach((option, index) => {
        const inputType = question.allowMultiple ? 'checkbox' : 'radio';
        const inputName = question.allowMultiple ? `option-${option.id}` : 'answer';
        
        html += `
          <div class="option-display">
            <label class="option-label">
              <input type="${inputType}" name="${inputName}" value="${option.id}" disabled>
              <span class="option-text">${option.text}</span>
              ${option.isCorrect ? '<span class="option-correct-marker">✓</span>' : ''}
            </label>
          </div>
        `;
      });
    }
    
    html += `
          </div>
          
          ${question.explanation ? `
          <div class="explanation-display">
            <div class="preview-label">Erklärung:</div>
            <div class="explanation-text">${question.explanation}</div>
          </div>
          ` : ''}
        </div>
        
        <div class="preview-footer">
          <button id="edit-from-preview-btn" class="btn btn-primary">Frage bearbeiten</button>
          <button id="close-preview-btn-footer" class="btn btn-secondary">Schließen</button>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    // Schließen-Buttons
    const closeButtons = container.querySelectorAll('#close-preview-btn, #close-preview-btn-footer');
    closeButtons.forEach(button => {
      button.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose();
        }
      });
    });
    
    // Bearbeiten-Button
    const editButton = container.querySelector('#edit-from-preview-btn');
    if (editButton) {
      editButton.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose('edit');
        }
      });
    }
  }
  
  // Öffentliche Funktionen dem MultipleChoiceQuestions-Modul hinzufügen
  MultipleChoiceQuestions.renderQuestionsList = renderQuestionsList;
  MultipleChoiceQuestions.renderQuestionPreview = renderQuestionPreview;
})();

// CSS für die Multiple-Choice-Fragen
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Multiple-Choice-Fragen existiert
  if (!document.getElementById('multiple-choice-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'multiple-choice-styles';
    styleElement.textContent = `
      /* Fragenformular */
      .question-form {
        max-width: 800px;
        margin: 0 auto;
      }
      
      .form-section {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      
      .form-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
        color: #333;
      }
      
      .section-help {
        font-size: 0.9em;
        color: #666;
        margin-top: -10px;
        margin-bottom: 15px;
      }
      
      .form-row {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
      }
      
      .half-width {
        flex: 1;
      }
      
      .checkbox-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      /* Antwortoptionen */
      .options-container {
        margin-bottom: 15px;
      }
      
      .option-item {
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
      }
      
      .option-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #f0f0f0;
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
      }
      
      .option-number {
        font-weight: bold;
      }
      
      .option-actions {
        display: flex;
        gap: 5px;
      }
      
      .option-content {
        padding: 10px;
      }
      
      .option-input-group {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }
      
      .option-input-group .form-control {
        flex: 1;
      }
      
      .option-correct {
        display: flex;
        align-items: center;
        white-space: nowrap;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .option-correct input {
        margin-right: 5px;
      }
      
      .options-actions {
        justify-content: flex-start;
      }
      
      /* Fragenliste */
      .questions-list {
        width: 100%;
      }
      
      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .question-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .question-info {
        display: flex;
        flex: 1;
      }
      
      .question-number {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 50%;
        background-color: #00FFD0;
        color: #000;
        font-weight: bold;
      }
      
      .question-content {
        flex: 1;
      }
      
      .question-title {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .question-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 0.85em;
        color: #666;
      }
      
      .question-actions {
        display: flex;
        gap: 5px;
      }
      
      .no-items-message {
        text-align: center;
        padding: 20px;
        background-color: #f0f0f0;
        border-radius: 4px;
        color: #666;
      }
      
      /* Fragenvorschau */
      .question-preview {
        max-width: 700px;
        margin: 0 auto;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      
      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-bottom: 1px solid #ddd;
      }
      
      .preview-header h3 {
        margin: 0;
      }
      
      .preview-content {
        padding: 20px;
      }
      
      .question-display {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .question-text {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .question-description {
        margin-bottom: 10px;
        color: #666;
      }
      
      .options-display {
        margin-bottom: 20px;
      }
      
      .preview-label {
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .option-display {
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .option-label {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .option-correct-marker {
        color: #28a745;
        font-weight: bold;
      }
      
      .explanation-display {
        padding: 15px;
        background-color: #f0f7ff;
        border-radius: 4px;
        margin-bottom: 20px;
      }
      
      .explanation-text {
        color: #0056b3;
      }
      
      .preview-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        padding: 15px;
        border-top: 1px solid #ddd;
      }
      
      /* Buttons */
      .btn-icon {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        width: 30px;
        height: 30px;
        padding: 0;
        border-radius: 50%;
        background-color: transparent;
        border: none;
        cursor: pointer;
        color: #666;
      }
      
      .btn-icon:hover {
        background-color: #f0f0f0;
        color: #333;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.4.1: Single-Choice-Fragen erstellen - Datenstruktur und Operationen
 * 
 * Dieses Modul implementiert die Grundfunktionen und Datenstrukturen
 * zum Erstellen und Verwalten von Single-Choice-Fragen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const SingleChoiceQuestions = (function() {
  // Private Variablen
  let currentTest = null;
  let currentQuestion = null;
  
  /**
   * Single-Choice-Frage Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   type: 'single_choice',       // Fragentyp
   *   text: string,                // Fragentext
   *   description: string,         // Zusätzliche Beschreibung (optional)
   *   categoryId: string,          // Kategorie-ID (optional)
   *   difficulty: number,          // Schwierigkeitsgrad (1-5)
   *   points: number,              // Punkte für diese Frage
   *   options: [                   // Antwortoptionen
   *     {
   *       id: string,              // Eindeutige ID der Option
   *       text: string,            // Text der Antwortoption
   *       isCorrect: boolean       // Ist diese Option korrekt?
   *     }
   *   ],
   *   randomizeOptions: boolean,   // Optionen in zufälliger Reihenfolge anzeigen?
   *   explanation: string,         // Erklärung der richtigen Antwort
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date              // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Erstellt eine neue Single-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {Object} questionData - Daten der Frage
   * @returns {Object|null} - Die erstellte Frage oder null bei Fehler
   */
  function createQuestion(testId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Fragen-Array erstellen, falls nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Eindeutige ID für die Frage
    const questionId = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Sicherstellen, dass options ein Array ist
    const options = questionData.options || [];
    
    // Sicherstellen, dass jede Option eine ID hat
    const processedOptions = options.map(option => {
      if (!option.id) {
        option.id = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
      }
      return option;
    });
    
    // Bei Single-Choice darf nur eine Option korrekt sein
    ensureSingleCorrectOption(processedOptions);
    
    // Neue Frage erstellen
    const newQuestion = {
      id: questionId,
      type: 'single_choice',
      text: questionData.text || 'Neue Frage',
      description: questionData.description || '',
      categoryId: questionData.categoryId || null,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : 3,
      points: questionData.points !== undefined ? questionData.points : 1,
      options: processedOptions,
      randomizeOptions: questionData.randomizeOptions !== undefined ? questionData.randomizeOptions : false,
      explanation: questionData.explanation || '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Frage zum Test hinzufügen
    test.questions.push(newQuestion);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich erstellt.');
        return newQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Stellt sicher, dass nur eine Option als korrekt markiert ist
   * @param {Array} options - Array von Antwortoptionen
   */
  function ensureSingleCorrectOption(options) {
    // Prüfen, ob mehr als eine Option korrekt ist
    const correctOptions = options.filter(opt => opt.isCorrect);
    
    if (correctOptions.length > 1) {
      // Alle Optionen auf falsch setzen
      options.forEach(opt => opt.isCorrect = false);
      
      // Erste Option aus correctOptions auf korrekt setzen
      if (correctOptions.length > 0) {
        const firstCorrectId = correctOptions[0].id;
        const optionToMakeCorrect = options.find(opt => opt.id === firstCorrectId);
        if (optionToMakeCorrect) {
          optionToMakeCorrect.isCorrect = true;
        }
      }
    } else if (correctOptions.length === 0 && options.length > 0) {
      // Wenn keine Option korrekt ist, erste Option auf korrekt setzen
      options[0].isCorrect = true;
    }
  }
  
  /**
   * Aktualisiert eine vorhandene Single-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} questionData - Neue Fragendaten
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateQuestion(testId, questionId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Aktuelles Fragen-Objekt
    const currentQuestionData = test.questions[questionIndex];
    
    // Optionen verarbeiten
    let updatedOptions = currentQuestionData.options;
    if (questionData.options !== undefined) {
      updatedOptions = questionData.options.map(option => {
        if (!option.id) {
          option.id = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
        }
        return option;
      });
      
      // Sicherstellen, dass nur eine Option korrekt ist
      ensureSingleCorrectOption(updatedOptions);
    }
    
    // Frage aktualisieren
    const updatedQuestion = {
      ...currentQuestionData,
      text: questionData.text !== undefined ? questionData.text : currentQuestionData.text,
      description: questionData.description !== undefined ? questionData.description : currentQuestionData.description,
      categoryId: questionData.categoryId !== undefined ? questionData.categoryId : currentQuestionData.categoryId,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : currentQuestionData.difficulty,
      points: questionData.points !== undefined ? questionData.points : currentQuestionData.points,
      options: updatedOptions,
      randomizeOptions: questionData.randomizeOptions !== undefined ? questionData.randomizeOptions : currentQuestionData.randomizeOptions,
      explanation: questionData.explanation !== undefined ? questionData.explanation : currentQuestionData.explanation,
      updatedAt: new Date().toISOString()
    };
    
    // Aktualisierte Frage speichern
    test.questions[questionIndex] = updatedQuestion;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich aktualisiert.');
        return updatedQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Single-Choice-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestion(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return false;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return false;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return false;
    }
    
    // Frage entfernen
    test.questions.splice(questionIndex, 1);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich gelöscht.');
        return true;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Frage.');
        return false;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return false;
    }
  }
  
  /**
   * Fügt eine Antwortoption zu einer Frage hinzu
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} optionData - Daten der Antwortoption
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function addOption(testId, questionId, optionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Neue Antwortoption erstellen
    const optionId = 'opt_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    const newOption = {
      id: optionId,
      text: optionData.text || 'Neue Antwortoption',
      isCorrect: optionData.isCorrect !== undefined ? optionData.isCorrect : false
    };
    
    // Option zur Frage hinzufügen
    if (!question.options) {
      question.options = [];
    }
    
    question.options.push(newOption);
    
    // Sicherstellen, dass nur eine Option korrekt ist
    ensureSingleCorrectOption(question.options);
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Aktualisiert eine Antwortoption
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @param {Object} optionData - Neue Daten für die Option
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateOption(testId, questionId, optionId, optionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden
    if (!question.options) {
      console.error('Keine Optionen in der Frage vorhanden');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Option aktualisieren
    question.options[optionIndex] = {
      ...question.options[optionIndex],
      text: optionData.text !== undefined ? optionData.text : question.options[optionIndex].text,
      isCorrect: optionData.isCorrect !== undefined ? optionData.isCorrect : question.options[optionIndex].isCorrect
    };
    
    // Sicherstellen, dass nur eine Option korrekt ist
    if (optionData.isCorrect) {
      question.options.forEach(opt => {
        if (opt.id !== optionId) {
          opt.isCorrect = false;
        }
      });
    }
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Antwortoption
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function deleteOption(testId, questionId, optionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden und entfernen
    if (!question.options) {
      console.error('Keine Optionen in der Frage vorhanden');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Prüfen, ob die Option korrekt ist
    const wasCorrect = question.options[optionIndex].isCorrect;
    
    // Option entfernen
    question.options.splice(optionIndex, 1);
    
    // Wenn die entfernte Option korrekt war, eine andere Option auf korrekt setzen
    if (wasCorrect && question.options.length > 0) {
      question.options[0].isCorrect = true;
    }
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Antwortoption.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Ändert die Reihenfolge der Antwortoptionen
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {string} optionId - ID der Option
   * @param {string} direction - Richtung ('up' oder 'down')
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function reorderOption(testId, questionId, optionId, direction) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Option finden
    if (!question.options || question.options.length < 2) {
      console.error('Zu wenige Optionen für eine Neuordnung');
      return null;
    }
    
    const optionIndex = question.options.findIndex(o => o.id === optionId);
    if (optionIndex === -1) {
      console.error('Option nicht gefunden:', optionId);
      return null;
    }
    
    // Neue Position berechnen
    let newIndex = optionIndex;
    if (direction === 'up' && optionIndex > 0) {
      newIndex = optionIndex - 1;
    } else if (direction === 'down' && optionIndex < question.options.length - 1) {
      newIndex = optionIndex + 1;
    } else {
      // Keine Änderung nötig
      return question;
    }
    
    // Elemente tauschen
    const temp = question.options[optionIndex];
    question.options[optionIndex] = question.options[newIndex];
    question.options[newIndex] = temp;
    
    question.updatedAt = new Date().toISOString();
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        return question;
      } else {
        NotificationSystem.showError('Fehler beim Neuordnen der Antwortoptionen.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Gibt eine Single-Choice-Frage anhand ihrer ID zurück
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {Object|null} - Die Frage oder null, wenn nicht gefunden
   */
  function getQuestionById(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    return question || null;
  }
  
  /**
   * Gibt alle Single-Choice-Fragen eines Tests zurück
   * @param {string} testId - ID des Tests
   * @returns {Array} - Array mit Fragen
   */
  function getQuestions(testId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return [];
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return [];
    }
    
    // Single-Choice-Fragen filtern
    if (!test.questions) {
      return [];
    }
    
    return test.questions.filter(q => q.type === 'single_choice');
  }
  
  /**
   * Validiert eine Single-Choice-Frage
   * @param {Object} question - Die zu validierende Frage
   * @returns {Object} - Objekt mit den Eigenschaften isValid und errors
   */
  function validateQuestion(question) {
    const errors = [];
    
    // Pflichtfelder überprüfen
    if (!question.text || question.text.trim() === '') {
      errors.push('Der Fragentext darf nicht leer sein.');
    }
    
    // Antwortoptionen überprüfen
    if (!question.options || question.options.length < 2) {
      errors.push('Die Frage muss mindestens zwei Antwortoptionen haben.');
    } else {
      // Prüfen, ob genau eine korrekte Option existiert
      const correctOptions = question.options.filter(option => option.isCorrect);
      if (correctOptions.length !== 1) {
        errors.push('Bei einer Single-Choice-Frage muss genau eine Antwortoption korrekt sein.');
      }
      
      // Prüfen, ob jede Option Text hat
      const emptyOptions = question.options.some(option => !option.text || option.text.trim() === '');
      if (emptyOptions) {
        errors.push('Alle Antwortoptionen müssen einen Text haben.');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }
  
  /**
   * Erstellt eine neue leere Single-Choice-Frage mit Standardwerten
   * @returns {Object} - Neue Frage
   */
  function createEmptyQuestion() {
    return {
      id: '',
      type: 'single_choice',
      text: '',
      description: '',
      categoryId: null,
      difficulty: 3,
      points: 1,
      options: [
        {
          id: 'opt_' + Date.now() + '_1',
          text: '',
          isCorrect: true
        },
        {
          id: 'opt_' + Date.now() + '_2',
          text: '',
          isCorrect: false
        }
      ],
      randomizeOptions: false,
      explanation: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  }
  
  // Öffentliche API
  return {
    createQuestion: createQuestion,
    updateQuestion: updateQuestion,
    deleteQuestion: deleteQuestion,
    addOption: addOption,
    updateOption: updateOption,
    deleteOption: deleteOption,
    reorderOption: reorderOption,
    getQuestionById: getQuestionById,
    getQuestions: getQuestions,
    validateQuestion: validateQuestion,
    createEmptyQuestion: createEmptyQuestion,
    ensureSingleCorrectOption: ensureSingleCorrectOption,
    
    // Diese Funktionen werden in Teil 2 implementiert
    renderQuestionForm: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.4.2: Single-Choice-Fragen erstellen - UI-Komponenten
 * 
 * Dieser Teil des Moduls implementiert die Benutzeroberfläche für
 * das Erstellen und Bearbeiten von Single-Choice-Fragen.
 */

// Bestehende Funktionen aus Teil 1 verwenden und UI-Funktionen hinzufügen
(function() {
  // Sicherstellen, dass SingleChoiceQuestions existiert
  if (typeof SingleChoiceQuestions === 'undefined') {
    console.error('SingleChoiceQuestions-Modul nicht gefunden.');
    return;
  }
  
  /**
   * Rendert ein Formular zum Erstellen oder Bearbeiten einer Single-Choice-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function renderQuestionForm(containerId, testId, questionId = null, onSave = null, onCancel = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return;
    }
    
    // Frage laden oder erstellen
    let question = null;
    
    if (questionId) {
      question = SingleChoiceQuestions.getQuestionById(testId, questionId);
      if (!question) {
        console.error('Frage nicht gefunden:', questionId);
        return;
      }
    } else {
      question = SingleChoiceQuestions.createEmptyQuestion();
    }
    
    // Kategorien aus den Testeinstellungen laden
    let categories = [];
    if (test.settings && test.settings.questionCategories) {
      categories = test.settings.questionCategories;
    }
    
    // HTML für das Formular erstellen
    let html = `
      <div class="question-form single-choice-form">
        <form id="single-choice-form">
          <div class="form-section">
            <h3>${questionId ? 'Single-Choice-Frage bearbeiten' : 'Neue Single-Choice-Frage erstellen'}</h3>
            
            <div class="form-group">
              <label for="question-text">Fragentext*</label>
              <textarea id="question-text" class="form-control" rows="3" required>${question.text || ''}</textarea>
              <div class="form-help">Der Haupttext der Frage. Formulieren Sie die Frage klar und präzise.</div>
            </div>
            
            <div class="form-group">
              <label for="question-description">Beschreibung</label>
              <textarea id="question-description" class="form-control" rows="2">${question.description || ''}</textarea>
              <div class="form-help">Zusätzliche Informationen zur Frage (optional).</div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-category">Kategorie</label>
                <select id="question-category" class="form-control">
                  <option value="">-- Keine Kategorie --</option>
    `;
    
    // Kategorien hinzufügen
    categories.forEach(category => {
      const selected = question.categoryId === category.id ? 'selected' : '';
      html += `<option value="${category.id}" ${selected}>${category.name}</option>`;
    });
    
    html += `
                </select>
                <div class="form-help">Kategorisieren Sie die Frage für eine bessere Organisation.</div>
              </div>
              
              <div class="form-group half-width">
                <label for="question-difficulty">Schwierigkeitsgrad</label>
                <div class="range-input-group">
                  <input type="range" id="question-difficulty" min="1" max="5" step="1" value="${question.difficulty || 3}">
                  <span id="difficulty-value">${question.difficulty || 3}</span>
                </div>
                <div class="form-help">Schwierigkeitsgrad der Frage (1 = sehr leicht, 5 = sehr schwer).</div>
              </div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-points">Punkte</label>
                <input type="number" id="question-points" class="form-control" min="1" max="100" value="${question.points || 1}">
                <div class="form-help">Anzahl der Punkte, die für eine korrekte Antwort vergeben werden.</div>
              </div>
              
              <div class="form-group half-width">
                <div class="checkbox-group">
                  <input type="checkbox" id="randomize-options" ${question.randomizeOptions ? 'checked' : ''}>
                  <label for="randomize-options">Optionen in zufälliger Reihenfolge</label>
                </div>
                <div class="form-help">Bei Aktivierung werden die Antwortoptionen in zufälliger Reihenfolge angezeigt.</div>
              </div>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Antwortoptionen</h3>
            <p class="section-help">Fügen Sie Antwortoptionen hinzu und markieren Sie die richtige Antwort.</p>
            <div class="info-box">
              <i class="fas fa-info-circle"></i>
              <span>Bei Single-Choice kann nur eine Option als richtig markiert werden.</span>
            </div>
            
            <div id="options-container" class="options-container">
    `;
    
    // Antwortoptionen hinzufügen
    if (question.options && question.options.length > 0) {
      question.options.forEach((option, index) => {
        html += createOptionHtml(option, index + 1);
      });
    } else {
      // Standardmäßig zwei leere Optionen
      html += createOptionHtml({ id: 'new_1', text: '', isCorrect: true }, 1);
      html += createOptionHtml({ id: 'new_2', text: '', isCorrect: false }, 2);
    }
    
    html += `
            </div>
            
            <div class="form-actions options-actions">
              <button type="button" id="add-option-btn" class="btn btn-secondary">
                <i class="fas fa-plus"></i> Option hinzufügen
              </button>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Erklärung</h3>
            
            <div class="form-group">
              <label for="question-explanation">Erklärung zur richtigen Antwort</label>
              <textarea id="question-explanation" class="form-control" rows="3">${question.explanation || ''}</textarea>
              <div class="form-help">Eine Erklärung, warum die markierte Antwort richtig ist. Diese wird den Teilnehmern nach dem Test angezeigt.</div>
            </div>
          </div>
          
          <div class="form-actions">
            <button type="button" id="cancel-question-btn" class="btn btn-secondary">Abbrechen</button>
            <button type="submit" class="btn btn-primary">Frage speichern</button>
          </div>
        </form>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel);
  }
  
  /**
   * Erstellt HTML für eine Antwortoption
   * @param {Object} option - Die Antwortoption
   * @param {number} index - Index der Option
   * @returns {string} - HTML für die Option
   */
  function createOptionHtml(option, index) {
    return `
      <div class="option-item" data-option-id="${option.id}">
        <div class="option-header">
          <div class="option-number">Option ${index}</div>
          <div class="option-actions">
            <button type="button" class="btn btn-sm btn-icon move-up-btn" title="Nach oben verschieben">
              <i class="fas fa-arrow-up"></i>
            </button>
            <button type="button" class="btn btn-sm btn-icon move-down-btn" title="Nach unten verschieben">
              <i class="fas fa-arrow-down"></i>
            </button>
            <button type="button" class="btn btn-sm btn-icon delete-option-btn" title="Option löschen">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>
        <div class="option-content">
          <div class="option-input-group">
            <textarea class="form-control option-text" placeholder="Antworttext eingeben">${option.text || ''}</textarea>
            <div class="option-correct">
              <input type="radio" class="option-correct-radio" name="correct-option" id="option-correct-${option.id}" ${option.isCorrect ? 'checked' : ''}>
              <label for="option-correct-${option.id}">Korrekt</label>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  
  /**
   * Fügt Event-Listener für das Fragenformular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel) {
    // Schwierigkeitsgrad-Slider
    const difficultySlider = document.getElementById('question-difficulty');
    const difficultyValue = document.getElementById('difficulty-value');
    
    if (difficultySlider && difficultyValue) {
      difficultySlider.addEventListener('input', function() {
        difficultyValue.textContent = this.value;
      });
    }
    
    // "Option hinzufügen"-Button
    const addOptionBtn = document.getElementById('add-option-btn');
    if (addOptionBtn) {
      addOptionBtn.addEventListener('click', function() {
        addNewOption();
      });
    }
    
    // Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-question-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        if (typeof onCancel === 'function') {
          onCancel();
        }
      });
    }
    
    // Event-Delegation für Options-Aktionen
    const optionsContainer = document.getElementById('options-container');
    if (optionsContainer) {
      optionsContainer.addEventListener('click', function(event) {
        // Option löschen
        if (event.target.classList.contains('delete-option-btn') || 
            event.target.closest('.delete-option-btn')) {
          const button = event.target.classList.contains('delete-option-btn') ? 
                        event.target : 
                        event.target.closest('.delete-option-btn');
          
          const optionItem = button.closest('.option-item');
          if (optionsContainer.children.length > 2) {
            // Prüfen, ob die zu löschende Option als korrekt markiert ist
            const isCorrect = optionItem.querySelector('.option-correct-radio').checked;
            
            // Option entfernen
            optionsContainer.removeChild(optionItem);
            updateOptionNumbers();
            
            // Wenn die entfernte Option korrekt war, erste Option als korrekt markieren
            if (isCorrect && optionsContainer.children.length > 0) {
              const firstOption = optionsContainer.children[0];
              if (firstOption) {
                const radio = firstOption.querySelector('.option-correct-radio');
                if (radio) {
                  radio.checked = true;
                }
              }
            }
          } else {
            NotificationSystem.showError('Eine Frage muss mindestens zwei Antwortoptionen haben.');
          }
        }
        
        // Option nach oben verschieben
        if (event.target.classList.contains('move-up-btn') || 
            event.target.closest('.move-up-btn')) {
          const button = event.target.classList.contains('move-up-btn') ? 
                        event.target : 
                        event.target.closest('.move-up-btn');
          
          const optionItem = button.closest('.option-item');
          const prevOption = optionItem.previousElementSibling;
          
          if (prevOption) {
            optionsContainer.insertBefore(optionItem, prevOption);
            updateOptionNumbers();
          }
        }
        
        // Option nach unten verschieben
        if (event.target.classList.contains('move-down-btn') || 
            event.target.closest('.move-down-btn')) {
          const button = event.target.classList.contains('move-down-btn') ? 
                        event.target : 
                        event.target.closest('.move-down-btn');
          
          const optionItem = button.closest('.option-item');
          const nextOption = optionItem.nextElementSibling;
          
          if (nextOption) {
            optionsContainer.insertBefore(nextOption, optionItem);
            updateOptionNumbers();
          }
        }
      });
    }
    
    // Single-Choice-Formular
    const form = document.getElementById('single-choice-form');
    if (form) {
      form.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Formulardaten sammeln
        const formData = collectFormData();
        
        // Validierung
        const validation = SingleChoiceQuestions.validateQuestion(formData);
        if (!validation.isValid) {
          NotificationSystem.showError(validation.errors.join(' '));
          return;
        }
        
        // Frage speichern
        let savedQuestion = null;
        
        if (questionId) {
          // Bestehende Frage aktualisieren
          savedQuestion = SingleChoiceQuestions.updateQuestion(testId, questionId, formData);
        } else {
          // Neue Frage erstellen
          savedQuestion = SingleChoiceQuestions.createQuestion(testId, formData);
        }
        
        if (savedQuestion) {
          // Callback aufrufen
          if (typeof onSave === 'function') {
            onSave(savedQuestion);
          }
        }
      });
    }
  }
  
  /**
   * Sammelt die Daten aus dem Fragenformular
   * @returns {Object} - Gesammelte Daten
   */
  function collectFormData() {
    const formData = {
      text: document.getElementById('question-text').value.trim(),
      description: document.getElementById('question-description').value.trim(),
      categoryId: document.getElementById('question-category').value || null,
      difficulty: parseInt(document.getElementById('question-difficulty').value) || 3,
      points: parseInt(document.getElementById('question-points').value) || 1,
      randomizeOptions: document.getElementById('randomize-options').checked,
      explanation: document.getElementById('question-explanation').value.trim(),
      options: []
    };
    
    // Antwortoptionen sammeln
    const optionItems = document.querySelectorAll('.option-item');
    optionItems.forEach(item => {
      const optionId = item.getAttribute('data-option-id');
      const text = item.querySelector('.option-text').value.trim();
      const isCorrect = item.querySelector('.option-correct-radio').checked;
      
      formData.options.push({
        id: optionId,
        text: text,
        isCorrect: isCorrect
      });
    });
    
    return formData;
  }
  
  /**
   * Fügt eine neue leere Antwortoption hinzu
   */
  function addNewOption() {
    const optionsContainer = document.getElementById('options-container');
    if (!optionsContainer) return;
    
    // Neue Option-ID erstellen
    const optionId = 'new_' + Date.now();
    
    // Aktuelle Anzahl der Optionen
    const optionCount = optionsContainer.children.length;
    
    // Neue Option erstellen
    const newOption = {
      id: optionId,
      text: '',
      isCorrect: false
    };
    
    // HTML für die neue Option erstellen
    const optionHtml = createOptionHtml(newOption, optionCount + 1);
    
    // Option zum Container hinzufügen
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = optionHtml;
    optionsContainer.appendChild(tempDiv.firstElementChild);
    
    // Auf die neue Option scrollen
    const newOptionElement = optionsContainer.lastElementChild;
    newOptionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Fokus auf das Textfeld setzen
    setTimeout(() => {
      const textArea = newOptionElement.querySelector('.option-text');
      if (textArea) {
        textArea.focus();
      }
    }, 100);
  }
  
  /**
   * Aktualisiert die Nummerierung der Antwortoptionen
   */
  function updateOptionNumbers() {
    const optionItems = document.querySelectorAll('.option-item');
    optionItems.forEach((item, index) => {
      const numberElement = item.querySelector('.option-number');
      if (numberElement) {
        numberElement.textContent = `Option ${index + 1}`;
      }
    });
  }
  
  // Die renderQuestionForm Funktion dem SingleChoiceQuestions-Modul hinzufügen
  SingleChoiceQuestions.renderQuestionForm = renderQuestionForm;
  
  /**
   * Rendert eine Liste aller Single-Choice-Fragen eines Tests
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen (bearbeiten, löschen, usw.)
   */
  function renderQuestionsList(containerId, testId, onAction = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Fragen laden
    const questions = SingleChoiceQuestions.getQuestions(testId);
    
    // HTML für die Fragenliste erstellen
    let html = `
      <div class="questions-list">
        <div class="list-header">
          <h3>Single-Choice-Fragen</h3>
          <button id="add-question-btn" class="btn btn-primary">
            <i class="fas fa-plus"></i> Neue Frage erstellen
          </button>
        </div>
    `;
    
    if (questions.length === 0) {
      html += `
        <div class="no-items-message">
          <p>Keine Single-Choice-Fragen vorhanden.</p>
          <p>Klicken Sie auf "Neue Frage erstellen", um Ihre erste Frage hinzuzufügen.</p>
        </div>
      `;
    } else {
      html += `
        <div class="items-list">
      `;
      
      questions.forEach((question, index) => {
        // Korrekte Antwort finden
        const correctOption = question.options ? 
                            question.options.find(opt => opt.isCorrect) : 
                            null;
        
        // Maximal 100 Zeichen des Fragentexts anzeigen
        const truncatedText = question.text.length > 100 ? 
                             question.text.substring(0, 100) + '...' : 
                             question.text;
        
        html += `
          <div class="question-list-item" data-question-id="${question.id}">
            <div class="question-info">
              <div class="question-number">${index + 1}</div>
              <div class="question-content">
                <div class="question-title">${truncatedText}</div>
                <div class="question-meta">
                  <span class="question-type">Single-Choice</span>
                  <span class="question-options">${question.options ? question.options.length : 0} Optionen</span>
                  <span class="question-correct">Richtige Antwort: ${correctOption ? correctOption.text.substring(0, 30) : 'Keine'}</span>
                  <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
                </div>
              </div>
            </div>
            <div class="question-actions">
              <button class="btn btn-sm btn-primary preview-question-btn" data-question-id="${question.id}" title="Vorschau">
                <i class="fas fa-eye"></i>
              </button>
              <button class="btn btn-sm btn-edit edit-question-btn" data-question-id="${question.id}" title="Bearbeiten">
                <i class="fas fa-edit"></i>
              </button>
              <button class="btn btn-sm btn-danger delete-question-btn" data-question-id="${question.id}" title="Löschen">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      });
      
      html += `
        </div>
      `;
    }
    
    html += `
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionsListEventListeners(containerId, testId, onAction);
  }
  
  /**
   * Fügt Event-Listener für die Fragenliste hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen
   */
  function addQuestionsListEventListeners(containerId, testId, onAction) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // "Neue Frage erstellen"-Button
    const addQuestionBtn = container.querySelector('#add-question-btn');
    if (addQuestionBtn) {
      addQuestionBtn.addEventListener('click', function() {
        if (typeof onAction === 'function') {
          onAction('create', null);
        }
      });
    }
    
    // Event-Delegation für Fragen-Aktionen
    container.addEventListener('click', function(event) {
      // Vorschau-Button
      if (event.target.classList.contains('preview-question-btn') || 
          event.target.closest('.preview-question-btn')) {
        const button = event.target.classList.contains('preview-question-btn') ? 
                      event.target : 
                      event.target.closest('.preview-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('preview', questionId);
        }
      }
      
      // Bearbeiten-Button
      if (event.target.classList.contains('edit-question-btn') || 
          event.target.closest('.edit-question-btn')) {
        const button = event.target.classList.contains('edit-question-btn') ? 
                      event.target : 
                      event.target.closest('.edit-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('edit', questionId);
        }
      }
      
      // Löschen-Button
      if (event.target.classList.contains('delete-question-btn') || 
          event.target.closest('.delete-question-btn')) {
        const button = event.target.classList.contains('delete-question-btn') ? 
                      event.target : 
                      event.target.closest('.delete-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        // Bestätigungsdialog anzeigen
        if (confirm('Sind Sie sicher, dass Sie diese Frage löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.')) {
          const deleted = SingleChoiceQuestions.deleteQuestion(testId, questionId);
          
          if (deleted) {
            // Fragenliste aktualisieren
            renderQuestionsList(containerId, testId, onAction);
          }
        }
      }
    });
  }
  
  /**
   * Rendert eine Vorschau einer Single-Choice-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Function} onClose - Callback-Funktion beim Schließen
   */
  function renderQuestionPreview(containerId, testId, questionId, onClose = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Frage laden
    const question = SingleChoiceQuestions.getQuestionById(testId, questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return;
    }
    
    // HTML für die Fragenvorschau erstellen
    let html = `
      <div class="question-preview">
        <div class="preview-header">
          <h3>Fragenvorschau</h3>
          <button id="close-preview-btn" class="btn btn-icon">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="preview-content">
          <div class="question-display">
            <div class="question-text">${question.text}</div>
            ${question.description ? `<div class="question-description">${question.description}</div>` : ''}
            
            <div class="question-meta">
              <span class="question-difficulty">Schwierigkeit: ${question.difficulty}/5</span>
              <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
              <span class="question-type">Single-Choice</span>
            </div>
          </div>
          
          <div class="options-display">
    `;
    
    // Antwortoptionen anzeigen
    if (question.options && question.options.length > 0) {
      html += `<div class="preview-label">Wählen Sie die richtige Antwort:</div>`;
      
      question.options.forEach((option, index) => {
        html += `
          <div class="option-display">
            <label class="option-label">
              <input type="radio" name="answer" value="${option.id}" disabled>
              <span class="option-text">${option.text}</span>
              ${option.isCorrect ? '<span class="option-correct-marker">✓</span>' : ''}
            </label>
          </div>
        `;
      });
    }
    
    html += `
          </div>
          
          ${question.explanation ? `
          <div class="explanation-display">
            <div class="preview-label">Erklärung:</div>
            <div class="explanation-text">${question.explanation}</div>
          </div>
          ` : ''}
        </div>
        
        <div class="preview-footer">
          <button id="edit-from-preview-btn" class="btn btn-primary">Frage bearbeiten</button>
          <button id="close-preview-btn-footer" class="btn btn-secondary">Schließen</button>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    // Schließen-Buttons
    const closeButtons = container.querySelectorAll('#close-preview-btn, #close-preview-btn-footer');
    closeButtons.forEach(button => {
      button.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose();
        }
      });
    });
    
    // Bearbeiten-Button
    const editButton = container.querySelector('#edit-from-preview-btn');
    if (editButton) {
      editButton.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose('edit');
        }
      });
    }
  }
  
  // Öffentliche Funktionen dem SingleChoiceQuestions-Modul hinzufügen
  SingleChoiceQuestions.renderQuestionsList = renderQuestionsList;
  SingleChoiceQuestions.renderQuestionPreview = renderQuestionPreview;
})();

// CSS für die Single-Choice-Fragen
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Single-Choice-Fragen existiert
  if (!document.getElementById('single-choice-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'single-choice-styles';
    styleElement.textContent = `
      /* Single-Choice-spezifisches Styling */
      .option-correct input[type="radio"] {
        width: 18px;
        height: 18px;
        margin-right: 5px;
      }
      
      .info-box {
        margin-bottom: 15px;
        padding: 10px;
        background-color: #f0f7ff;
        border-left: 4px solid #0056b3;
        border-radius: 4px;
      }
      
      .info-box i {
        color: #0056b3;
        margin-right: 5px;
      }
      
      /* Allgemeines Fragenstyling - wird mit Multiple-Choice geteilt */
      .question-form {
        max-width: 800px;
        margin: 0 auto;
      }
      
      .form-section {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      
      .form-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
        color: #333;
      }
      
      .section-help {
        font-size: 0.9em;
        color: #666;
        margin-top: -10px;
        margin-bottom: 15px;
      }
      
      .form-row {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
      }
      
      .half-width {
        flex: 1;
      }
      
      /* Antwortoptionen */
      .options-container {
        margin-bottom: 15px;
      }
      
      .option-item {
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
      }
      
      .option-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #f0f0f0;
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
      }
      
      .option-number {
        font-weight: bold;
      }
      
      .option-actions {
        display: flex;
        gap: 5px;
      }
      
      .option-content {
        padding: 10px;
      }
      
      .option-input-group {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }
      
      .option-input-group .form-control {
        flex: 1;
      }
      
      .option-correct {
        display: flex;
        align-items: center;
        white-space: nowrap;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .options-actions {
        justify-content: flex-start;
      }
      
      /* Fragenliste */
      .questions-list {
        width: 100%;
      }
      
      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .question-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .question-info {
        display: flex;
        flex: 1;
      }
      
      .question-number {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 50%;
        background-color: #00FFD0;
        color: #000;
        font-weight: bold;
      }
      
      .question-content {
        flex: 1;
      }
      
      .question-title {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .question-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 0.85em;
        color: #666;
      }
      
      .question-actions {
        display: flex;
        gap: 5px;
      }
      
      .no-items-message {
        text-align: center;
        padding: 20px;
        background-color: #f0f0f0;
        border-radius: 4px;
        color: #666;
      }
      
      /* Fragenvorschau */
      .question-preview {
        max-width: 700px;
        margin: 0 auto;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      
      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-bottom: 1px solid #ddd;
      }
      
      .preview-header h3 {
        margin: 0;
      }
      
      .preview-content {
        padding: 20px;
      }
      
      .question-display {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .question-text {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .question-description {
        margin-bottom: 10px;
        color: #666;
      }
      
      .options-display {
        margin-bottom: 20px;
      }
      
      .preview-label {
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .option-display {
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .option-label {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .option-correct-marker {
        color: #28a745;
        font-weight: bold;
      }
      
      .explanation-display {
        padding: 15px;
        background-color: #f0f7ff;
        border-radius: 4px;
        margin-bottom: 20px;
      }
      
      .explanation-text {
        color: #0056b3;
      }
      
      .preview-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        padding: 15px;
        border-top: 1px solid #ddd;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.5.1: Wahr/Falsch-Fragen erstellen - Datenstruktur und Operationen
 * 
 * Dieses Modul implementiert die Grundfunktionen und Datenstrukturen
 * zum Erstellen und Verwalten von Wahr/Falsch-Fragen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const TrueFalseQuestions = (function() {
  // Private Variablen
  let currentTest = null;
  let currentQuestion = null;
  
  /**
   * Wahr/Falsch-Frage Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   type: 'true_false',          // Fragentyp
   *   text: string,                // Fragentext
   *   description: string,         // Zusätzliche Beschreibung (optional)
   *   categoryId: string,          // Kategorie-ID (optional)
   *   difficulty: number,          // Schwierigkeitsgrad (1-5)
   *   points: number,              // Punkte für diese Frage
   *   isTrue: boolean,             // Ist die Aussage wahr? (true/false)
   *   correctStatement: string,    // Korrekte Formulierung (optional)
   *   explanation: string,         // Erklärung der richtigen Antwort
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date              // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Erstellt eine neue Wahr/Falsch-Frage
   * @param {string} testId - ID des Tests
   * @param {Object} questionData - Daten der Frage
   * @returns {Object|null} - Die erstellte Frage oder null bei Fehler
   */
  function createQuestion(testId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Fragen-Array erstellen, falls nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Eindeutige ID für die Frage
    const questionId = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Neue Frage erstellen
    const newQuestion = {
      id: questionId,
      type: 'true_false',
      text: questionData.text || 'Neue Wahr/Falsch-Frage',
      description: questionData.description || '',
      categoryId: questionData.categoryId || null,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : 3,
      points: questionData.points !== undefined ? questionData.points : 1,
      isTrue: questionData.isTrue !== undefined ? questionData.isTrue : false,
      correctStatement: questionData.correctStatement || '',
      explanation: questionData.explanation || '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Frage zum Test hinzufügen
    test.questions.push(newQuestion);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich erstellt.');
        return newQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Aktualisiert eine vorhandene Wahr/Falsch-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} questionData - Neue Fragendaten
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateQuestion(testId, questionId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Aktuelles Fragen-Objekt
    const currentQuestionData = test.questions[questionIndex];
    
    // Frage aktualisieren
    const updatedQuestion = {
      ...currentQuestionData,
      text: questionData.text !== undefined ? questionData.text : currentQuestionData.text,
      description: questionData.description !== undefined ? questionData.description : currentQuestionData.description,
      categoryId: questionData.categoryId !== undefined ? questionData.categoryId : currentQuestionData.categoryId,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : currentQuestionData.difficulty,
      points: questionData.points !== undefined ? questionData.points : currentQuestionData.points,
      isTrue: questionData.isTrue !== undefined ? questionData.isTrue : currentQuestionData.isTrue,
      correctStatement: questionData.correctStatement !== undefined ? questionData.correctStatement : currentQuestionData.correctStatement,
      explanation: questionData.explanation !== undefined ? questionData.explanation : currentQuestionData.explanation,
      updatedAt: new Date().toISOString()
    };
    
    // Aktualisierte Frage speichern
    test.questions[questionIndex] = updatedQuestion;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich aktualisiert.');
        return updatedQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Wahr/Falsch-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestion(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return false;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return false;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return false;
    }
    
    // Frage entfernen
    test.questions.splice(questionIndex, 1);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich gelöscht.');
        return true;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Frage.');
        return false;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return false;
    }
  }
  
  /**
   * Gibt eine Wahr/Falsch-Frage anhand ihrer ID zurück
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {Object|null} - Die Frage oder null, wenn nicht gefunden
   */
  function getQuestionById(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    return question || null;
  }
  
  /**
   * Gibt alle Wahr/Falsch-Fragen eines Tests zurück
   * @param {string} testId - ID des Tests
   * @returns {Array} - Array mit Fragen
   */
  function getQuestions(testId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return [];
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return [];
    }
    
    // Wahr/Falsch-Fragen filtern
    if (!test.questions) {
      return [];
    }
    
    return test.questions.filter(q => q.type === 'true_false');
  }
  
  /**
   * Validiert eine Wahr/Falsch-Frage
   * @param {Object} question - Die zu validierende Frage
   * @returns {Object} - Objekt mit den Eigenschaften isValid und errors
   */
  function validateQuestion(question) {
    const errors = [];
    
    // Pflichtfelder überprüfen
    if (!question.text || question.text.trim() === '') {
      errors.push('Der Fragentext darf nicht leer sein.');
    }
    
    // Die isTrue-Eigenschaft muss ein Boolean sein
    if (typeof question.isTrue !== 'boolean') {
      errors.push('Es muss festgelegt werden, ob die Aussage wahr oder falsch ist.');
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }
  
  /**
   * Erstellt eine neue leere Wahr/Falsch-Frage mit Standardwerten
   * @returns {Object} - Neue Frage
   */
  function createEmptyQuestion() {
    return {
      id: '',
      type: 'true_false',
      text: '',
      description: '',
      categoryId: null,
      difficulty: 3,
      points: 1,
      isTrue: false,
      correctStatement: '',
      explanation: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  }
  
  /**
   * Überprüft, ob eine bestimmte Antwort für eine Wahr/Falsch-Frage korrekt ist
   * @param {Object} question - Die Frage
   * @param {boolean} answer - Die gegebene Antwort (true oder false)
   * @returns {boolean} - true, wenn die Antwort korrekt ist, sonst false
   */
  function checkAnswer(question, answer) {
    return answer === question.isTrue;
  }
  
  // Öffentliche API
  return {
    createQuestion: createQuestion,
    updateQuestion: updateQuestion,
    deleteQuestion: deleteQuestion,
    getQuestionById: getQuestionById,
    getQuestions: getQuestions,
    validateQuestion: validateQuestion,
    createEmptyQuestion: createEmptyQuestion,
    checkAnswer: checkAnswer,
    
    // Diese Funktionen werden in Teil 2 implementiert
    renderQuestionForm: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.5.2: Wahr/Falsch-Fragen erstellen - UI-Komponenten
 * 
 * Dieser Teil des Moduls implementiert die Benutzeroberfläche für
 * das Erstellen und Bearbeiten von Wahr/Falsch-Fragen.
 */

// Bestehende Funktionen aus Teil 1 verwenden und UI-Funktionen hinzufügen
(function() {
  // Sicherstellen, dass TrueFalseQuestions existiert
  if (typeof TrueFalseQuestions === 'undefined') {
    console.error('TrueFalseQuestions-Modul nicht gefunden.');
    return;
  }
  
  /**
   * Rendert ein Formular zum Erstellen oder Bearbeiten einer Wahr/Falsch-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function renderQuestionForm(containerId, testId, questionId = null, onSave = null, onCancel = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return;
    }
    
    // Frage laden oder erstellen
    let question = null;
    
    if (questionId) {
      question = TrueFalseQuestions.getQuestionById(testId, questionId);
      if (!question) {
        console.error('Frage nicht gefunden:', questionId);
        return;
      }
    } else {
      question = TrueFalseQuestions.createEmptyQuestion();
    }
    
    // Kategorien aus den Testeinstellungen laden
    let categories = [];
    if (test.settings && test.settings.questionCategories) {
      categories = test.settings.questionCategories;
    }
    
    // HTML für das Formular erstellen
    let html = `
      <div class="question-form true-false-form">
        <form id="true-false-form">
          <div class="form-section">
            <h3>${questionId ? 'Wahr/Falsch-Frage bearbeiten' : 'Neue Wahr/Falsch-Frage erstellen'}</h3>
            
            <div class="form-group">
              <label for="question-text">Aussage/Behauptung*</label>
              <textarea id="question-text" class="form-control" rows="3" required>${question.text || ''}</textarea>
              <div class="form-help">Formulieren Sie eine klare Aussage, die entweder wahr oder falsch ist.</div>
            </div>
            
            <div class="form-group">
              <label for="question-description">Beschreibung oder Kontext</label>
              <textarea id="question-description" class="form-control" rows="2">${question.description || ''}</textarea>
              <div class="form-help">Zusätzliche Informationen oder Kontext zur Aussage (optional).</div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-category">Kategorie</label>
                <select id="question-category" class="form-control">
                  <option value="">-- Keine Kategorie --</option>
    `;
    
    // Kategorien hinzufügen
    categories.forEach(category => {
      const selected = question.categoryId === category.id ? 'selected' : '';
      html += `<option value="${category.id}" ${selected}>${category.name}</option>`;
    });
    
    html += `
                </select>
                <div class="form-help">Kategorisieren Sie die Frage für eine bessere Organisation.</div>
              </div>
              
              <div class="form-group half-width">
                <label for="question-difficulty">Schwierigkeitsgrad</label>
                <div class="range-input-group">
                  <input type="range" id="question-difficulty" min="1" max="5" step="1" value="${question.difficulty || 3}">
                  <span id="difficulty-value">${question.difficulty || 3}</span>
                </div>
                <div class="form-help">Schwierigkeitsgrad der Frage (1 = sehr leicht, 5 = sehr schwer).</div>
              </div>
            </div>
            
            <div class="form-group">
              <label for="question-points">Punkte</label>
              <input type="number" id="question-points" class="form-control" min="1" max="100" value="${question.points || 1}">
              <div class="form-help">Anzahl der Punkte, die für eine korrekte Antwort vergeben werden.</div>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Antwort und Erklärung</h3>
            
            <div class="form-group true-false-toggle">
              <label>Ist die obige Aussage wahr oder falsch?</label>
              <div class="true-false-buttons">
                <button type="button" id="true-btn" class="btn ${question.isTrue ? 'btn-true active' : 'btn-outline'}">
                  <i class="fas fa-check"></i> Wahr
                </button>
                <button type="button" id="false-btn" class="btn ${!question.isTrue ? 'btn-false active' : 'btn-outline'}">
                  <i class="fas fa-times"></i> Falsch
                </button>
              </div>
              <input type="hidden" id="is-true-input" value="${question.isTrue ? 'true' : 'false'}">
            </div>
            
            <div class="form-group" id="correct-statement-group" ${!question.isTrue ? '' : 'style="display: none;"'}>
              <label for="correct-statement">Korrekte Formulierung (falls falsch)</label>
              <textarea id="correct-statement" class="form-control" rows="3">${question.correctStatement || ''}</textarea>
              <div class="form-help">Wenn die obige Aussage falsch ist, geben Sie hier die korrekte Formulierung an (optional).</div>
            </div>
            
            <div class="form-group">
              <label for="question-explanation">Erklärung</label>
              <textarea id="question-explanation" class="form-control" rows="3">${question.explanation || ''}</textarea>
              <div class="form-help">Eine Erklärung, warum die Aussage wahr oder falsch ist. Diese wird den Teilnehmern nach dem Test angezeigt.</div>
            </div>
          </div>
          
          <div class="form-actions">
            <button type="button" id="cancel-question-btn" class="btn btn-secondary">Abbrechen</button>
            <button type="submit" class="btn btn-primary">Frage speichern</button>
          </div>
        </form>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel);
  }
  
  /**
   * Fügt Event-Listener für das Fragenformular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel) {
    // Schwierigkeitsgrad-Slider
    const difficultySlider = document.getElementById('question-difficulty');
    const difficultyValue = document.getElementById('difficulty-value');
    
    if (difficultySlider && difficultyValue) {
      difficultySlider.addEventListener('input', function() {
        difficultyValue.textContent = this.value;
      });
    }
    
    // Wahr/Falsch-Buttons
    const trueBtn = document.getElementById('true-btn');
    const falseBtn = document.getElementById('false-btn');
    const isTrueInput = document.getElementById('is-true-input');
    const correctStatementGroup = document.getElementById('correct-statement-group');
    
    if (trueBtn && falseBtn && isTrueInput) {
      trueBtn.addEventListener('click', function() {
        trueBtn.classList.add('active');
        falseBtn.classList.remove('active');
        isTrueInput.value = 'true';
        
        // Korrekte Formulierung ausblenden, wenn die Aussage wahr ist
        if (correctStatementGroup) {
          correctStatementGroup.style.display = 'none';
        }
      });
      
      falseBtn.addEventListener('click', function() {
        falseBtn.classList.add('active');
        trueBtn.classList.remove('active');
        isTrueInput.value = 'false';
        
        // Korrekte Formulierung anzeigen, wenn die Aussage falsch ist
        if (correctStatementGroup) {
          correctStatementGroup.style.display = '';
        }
      });
    }
    
    // Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-question-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        if (typeof onCancel === 'function') {
          onCancel();
        }
      });
    }
    
    // Formular-Submit
    const form = document.getElementById('true-false-form');
    if (form) {
      form.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Formulardaten sammeln
        const formData = collectFormData();
        
        // Validierung
        const validation = TrueFalseQuestions.validateQuestion(formData);
        if (!validation.isValid) {
          NotificationSystem.showError(validation.errors.join(' '));
          return;
        }
        
        // Frage speichern
        let savedQuestion = null;
        
        if (questionId) {
          // Bestehende Frage aktualisieren
          savedQuestion = TrueFalseQuestions.updateQuestion(testId, questionId, formData);
        } else {
          // Neue Frage erstellen
          savedQuestion = TrueFalseQuestions.createQuestion(testId, formData);
        }
        
        if (savedQuestion) {
          // Callback aufrufen
          if (typeof onSave === 'function') {
            onSave(savedQuestion);
          }
        }
      });
    }
  }
  
  /**
   * Sammelt die Daten aus dem Fragenformular
   * @returns {Object} - Gesammelte Daten
   */
  function collectFormData() {
    const formData = {
      text: document.getElementById('question-text').value.trim(),
      description: document.getElementById('question-description').value.trim(),
      categoryId: document.getElementById('question-category').value || null,
      difficulty: parseInt(document.getElementById('question-difficulty').value) || 3,
      points: parseInt(document.getElementById('question-points').value) || 1,
      isTrue: document.getElementById('is-true-input').value === 'true',
      correctStatement: document.getElementById('correct-statement').value.trim(),
      explanation: document.getElementById('question-explanation').value.trim()
    };
    
    return formData;
  }
  
  // Die renderQuestionForm Funktion dem TrueFalseQuestions-Modul hinzufügen
  TrueFalseQuestions.renderQuestionForm = renderQuestionForm;
  
  /**
   * Rendert eine Liste aller Wahr/Falsch-Fragen eines Tests
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen (bearbeiten, löschen, usw.)
   */
  function renderQuestionsList(containerId, testId, onAction = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Fragen laden
    const questions = TrueFalseQuestions.getQuestions(testId);
    
    // HTML für die Fragenliste erstellen
    let html = `
      <div class="questions-list">
        <div class="list-header">
          <h3>Wahr/Falsch-Fragen</h3>
          <button id="add-question-btn" class="btn btn-primary">
            <i class="fas fa-plus"></i> Neue Frage erstellen
          </button>
        </div>
    `;
    
    if (questions.length === 0) {
      html += `
        <div class="no-items-message">
          <p>Keine Wahr/Falsch-Fragen vorhanden.</p>
          <p>Klicken Sie auf "Neue Frage erstellen", um Ihre erste Frage hinzuzufügen.</p>
        </div>
      `;
    } else {
      html += `
        <div class="items-list">
      `;
      
      questions.forEach((question, index) => {
        // Maximal 100 Zeichen des Fragentexts anzeigen
        const truncatedText = question.text.length > 100 ? 
                             question.text.substring(0, 100) + '...' : 
                             question.text;
        
        html += `
          <div class="question-list-item" data-question-id="${question.id}">
            <div class="question-info">
              <div class="question-number">${index + 1}</div>
              <div class="question-content">
                <div class="question-title">${truncatedText}</div>
                <div class="question-meta">
                  <span class="question-type">Wahr/Falsch</span>
                  <span class="question-answer ${question.isTrue ? 'true-answer' : 'false-answer'}">
                    ${question.isTrue ? '<i class="fas fa-check"></i> Wahr' : '<i class="fas fa-times"></i> Falsch'}
                  </span>
                  <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
                </div>
              </div>
            </div>
            <div class="question-actions">
              <button class="btn btn-sm btn-primary preview-question-btn" data-question-id="${question.id}" title="Vorschau">
                <i class="fas fa-eye"></i>
              </button>
              <button class="btn btn-sm btn-edit edit-question-btn" data-question-id="${question.id}" title="Bearbeiten">
                <i class="fas fa-edit"></i>
              </button>
              <button class="btn btn-sm btn-danger delete-question-btn" data-question-id="${question.id}" title="Löschen">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      });
      
      html += `
        </div>
      `;
    }
    
    html += `
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionsListEventListeners(containerId, testId, onAction);
  }
  
  /**
   * Fügt Event-Listener für die Fragenliste hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen
   */
  function addQuestionsListEventListeners(containerId, testId, onAction) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // "Neue Frage erstellen"-Button
    const addQuestionBtn = container.querySelector('#add-question-btn');
    if (addQuestionBtn) {
      addQuestionBtn.addEventListener('click', function() {
        if (typeof onAction === 'function') {
          onAction('create', null);
        }
      });
    }
    
    // Event-Delegation für Fragen-Aktionen
    container.addEventListener('click', function(event) {
      // Vorschau-Button
      if (event.target.classList.contains('preview-question-btn') || 
          event.target.closest('.preview-question-btn')) {
        const button = event.target.classList.contains('preview-question-btn') ? 
                      event.target : 
                      event.target.closest('.preview-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('preview', questionId);
        }
      }
      
      // Bearbeiten-Button
      if (event.target.classList.contains('edit-question-btn') || 
          event.target.closest('.edit-question-btn')) {
        const button = event.target.classList.contains('edit-question-btn') ? 
                      event.target : 
                      event.target.closest('.edit-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('edit', questionId);
        }
      }
      
      // Löschen-Button
      if (event.target.classList.contains('delete-question-btn') || 
          event.target.closest('.delete-question-btn')) {
        const button = event.target.classList.contains('delete-question-btn') ? 
                      event.target : 
                      event.target.closest('.delete-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        // Bestätigungsdialog anzeigen
        if (confirm('Sind Sie sicher, dass Sie diese Frage löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.')) {
          const deleted = TrueFalseQuestions.deleteQuestion(testId, questionId);
          
          if (deleted) {
            // Fragenliste aktualisieren
            renderQuestionsList(containerId, testId, onAction);
          }
        }
      }
    });
  }
  
  /**
   * Rendert eine Vorschau einer Wahr/Falsch-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Function} onClose - Callback-Funktion beim Schließen
   */
  function renderQuestionPreview(containerId, testId, questionId, onClose = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Frage laden
    const question = TrueFalseQuestions.getQuestionById(testId, questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return;
    }
    
    // HTML für die Fragenvorschau erstellen
    let html = `
      <div class="question-preview">
        <div class="preview-header">
          <h3>Fragenvorschau</h3>
          <button id="close-preview-btn" class="btn btn-icon">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="preview-content">
          <div class="question-display">
            <div class="question-text">${question.text}</div>
            ${question.description ? `<div class="question-description">${question.description}</div>` : ''}
            
            <div class="question-meta">
              <span class="question-difficulty">Schwierigkeit: ${question.difficulty}/5</span>
              <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
              <span class="question-type">Wahr/Falsch</span>
            </div>
          </div>
          
          <div class="true-false-display">
            <div class="preview-label">Bitte geben Sie an, ob die Aussage wahr oder falsch ist:</div>
            
            <div class="true-false-options">
              <div class="option-display">
                <label class="option-label">
                  <input type="radio" name="tf-answer" value="true" disabled>
                  <span class="option-text">Wahr</span>
                  ${question.isTrue ? '<span class="option-correct-marker">✓</span>' : ''}
                </label>
              </div>
              
              <div class="option-display">
                <label class="option-label">
                  <input type="radio" name="tf-answer" value="false" disabled>
                  <span class="option-text">Falsch</span>
                  ${!question.isTrue ? '<span class="option-correct-marker">✓</span>' : ''}
                </label>
              </div>
            </div>
          </div>
          
          ${question.correctStatement && !question.isTrue ? `
          <div class="correct-statement-display">
            <div class="preview-label">Korrekte Formulierung:</div>
            <div class="correct-statement-text">${question.correctStatement}</div>
          </div>
          ` : ''}
          
          ${question.explanation ? `
          <div class="explanation-display">
            <div class="preview-label">Erklärung:</div>
            <div class="explanation-text">${question.explanation}</div>
          </div>
          ` : ''}
        </div>
        
        <div class="preview-footer">
          <button id="edit-from-preview-btn" class="btn btn-primary">Frage bearbeiten</button>
          <button id="close-preview-btn-footer" class="btn btn-secondary">Schließen</button>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    // Schließen-Buttons
    const closeButtons = container.querySelectorAll('#close-preview-btn, #close-preview-btn-footer');
    closeButtons.forEach(button => {
      button.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose();
        }
      });
    });
    
    // Bearbeiten-Button
    const editButton = container.querySelector('#edit-from-preview-btn');
    if (editButton) {
      editButton.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose('edit');
        }
      });
    }
  }
  
  // Öffentliche Funktionen dem TrueFalseQuestions-Modul hinzufügen
  TrueFalseQuestions.renderQuestionsList = renderQuestionsList;
  TrueFalseQuestions.renderQuestionPreview = renderQuestionPreview;
})();

// CSS für die Wahr/Falsch-Fragen
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Wahr/Falsch-Fragen existiert
  if (!document.getElementById('true-false-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'true-false-styles';
    styleElement.textContent = `
      /* Wahr/Falsch-spezifisches Styling */
      .true-false-toggle {
        margin-bottom: 20px;
      }
      
      .true-false-buttons {
        display: flex;
        gap: 15px;
        margin-top: 10px;
      }
      
      .btn-true.active {
        background-color: #28a745;
        border-color: #28a745;
        color: white;
      }
      
      .btn-false.active {
        background-color: #dc3545;
        border-color: #dc3545;
        color: white;
      }
      
      .btn-outline {
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        color: #333;
      }
      
      .true-answer {
        color: #28a745;
        font-weight: bold;
      }
      
      .false-answer {
        color: #dc3545;
        font-weight: bold;
      }
      
      .true-false-options {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }
      
      .correct-statement-display {
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid #28a745;
      }
      
      .correct-statement-text {
        color: #28a745;
        font-weight: bold;
      }
      
      /* Allgemeines Fragenstyling */
      .question-form {
        max-width: 800px;
        margin: 0 auto;
      }
      
      .form-section {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      
      .form-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
        color: #333;
      }
      
      .form-row {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
      }
      
      .half-width {
        flex: 1;
      }
      
      /* Fragenliste */
      .questions-list {
        width: 100%;
      }
      
      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .question-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .question-info {
        display: flex;
        flex: 1;
      }
      
      .question-number {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 50%;
        background-color: #00FFD0;
        color: #000;
        font-weight: bold;
      }
      
      .question-content {
        flex: 1;
      }
      
      .question-title {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .question-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 0.85em;
        color: #666;
      }
      
      .question-actions {
        display: flex;
        gap: 5px;
      }
      
      .no-items-message {
        text-align: center;
        padding: 20px;
        background-color: #f0f0f0;
        border-radius: 4px;
        color: #666;
      }
      
      /* Fragenvorschau */
      .question-preview {
        max-width: 700px;
        margin: 0 auto;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      
      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-bottom: 1px solid #ddd;
      }
      
      .preview-header h3 {
        margin: 0;
      }
      
      .preview-content {
        padding: 20px;
      }
      
      .question-display {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .question-text {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .question-description {
        margin-bottom: 10px;
        color: #666;
      }
      
      .preview-label {
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .option-display {
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .option-label {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .option-correct-marker {
        color: #28a745;
        font-weight: bold;
      }
      
      .explanation-display {
        padding: 15px;
        background-color: #f0f7ff;
        border-radius: 4px;
        margin-bottom: 20px;
      }
      
      .explanation-text {
        color: #0056b3;
      }
      
      .preview-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        padding: 15px;
        border-top: 1px solid #ddd;
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.6.1: Freitext-Fragen erstellen - Datenstruktur und Operationen
 * 
 * Dieses Modul implementiert die Grundfunktionen und Datenstrukturen
 * zum Erstellen und Verwalten von Freitext-Fragen.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const TextQuestions = (function() {
  // Private Variablen
  let currentTest = null;
  let currentQuestion = null;
  
  /**
   * Freitext-Frage Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   type: 'text',                // Fragentyp
   *   text: string,                // Fragentext
   *   description: string,         // Zusätzliche Beschreibung (optional)
   *   categoryId: string,          // Kategorie-ID (optional)
   *   difficulty: number,          // Schwierigkeitsgrad (1-5)
   *   points: number,              // Punkte für diese Frage
   *   minWords: number,            // Minimale Wortanzahl (0 = keine Einschränkung)
   *   maxWords: number,            // Maximale Wortanzahl (0 = keine Einschränkung)
   *   expectedAnswer: string,      // Erwartete Antwort/Musterantwort
   *   keywords: string[],          // Schlüsselwörter oder Phrasen, die in der Antwort vorkommen sollten
   *   caseSensitive: boolean,      // Groß-/Kleinschreibung bei Schlüsselwörtern beachten?
   *   autoGrade: boolean,          // Automatische Bewertung möglich?
   *   explanation: string,         // Erklärung zur erwarteten Antwort
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date              // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Erstellt eine neue Freitext-Frage
   * @param {string} testId - ID des Tests
   * @param {Object} questionData - Daten der Frage
   * @returns {Object|null} - Die erstellte Frage oder null bei Fehler
   */
  function createQuestion(testId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Fragen-Array erstellen, falls nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Eindeutige ID für die Frage
    const questionId = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Schlüsselwörter verarbeiten
    let keywords = [];
    if (questionData.keywords) {
      if (Array.isArray(questionData.keywords)) {
        keywords = questionData.keywords;
      } else if (typeof questionData.keywords === 'string') {
        // Kommagetrennte Schlüsselwörter in Array umwandeln
        keywords = questionData.keywords.split(',')
          .map(kw => kw.trim())
          .filter(kw => kw.length > 0);
      }
    }
    
    // Neue Frage erstellen
    const newQuestion = {
      id: questionId,
      type: 'text',
      text: questionData.text || 'Neue Freitext-Frage',
      description: questionData.description || '',
      categoryId: questionData.categoryId || null,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : 3,
      points: questionData.points !== undefined ? questionData.points : 1,
      minWords: questionData.minWords !== undefined ? questionData.minWords : 0,
      maxWords: questionData.maxWords !== undefined ? questionData.maxWords : 0,
      expectedAnswer: questionData.expectedAnswer || '',
      keywords: keywords,
      caseSensitive: questionData.caseSensitive !== undefined ? questionData.caseSensitive : false,
      autoGrade: questionData.autoGrade !== undefined ? questionData.autoGrade : false,
      explanation: questionData.explanation || '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Frage zum Test hinzufügen
    test.questions.push(newQuestion);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich erstellt.');
        return newQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Aktualisiert eine vorhandene Freitext-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Object} questionData - Neue Fragendaten
   * @returns {Object|null} - Die aktualisierte Frage oder null bei Fehler
   */
  function updateQuestion(testId, questionId, questionData) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return null;
    }
    
    // Aktuelles Fragen-Objekt
    const currentQuestionData = test.questions[questionIndex];
    
    // Schlüsselwörter verarbeiten
    let keywords = currentQuestionData.keywords || [];
    if (questionData.keywords !== undefined) {
      if (Array.isArray(questionData.keywords)) {
        keywords = questionData.keywords;
      } else if (typeof questionData.keywords === 'string') {
        // Kommagetrennte Schlüsselwörter in Array umwandeln
        keywords = questionData.keywords.split(',')
          .map(kw => kw.trim())
          .filter(kw => kw.length > 0);
      }
    }
    
    // Frage aktualisieren
    const updatedQuestion = {
      ...currentQuestionData,
      text: questionData.text !== undefined ? questionData.text : currentQuestionData.text,
      description: questionData.description !== undefined ? questionData.description : currentQuestionData.description,
      categoryId: questionData.categoryId !== undefined ? questionData.categoryId : currentQuestionData.categoryId,
      difficulty: questionData.difficulty !== undefined ? questionData.difficulty : currentQuestionData.difficulty,
      points: questionData.points !== undefined ? questionData.points : currentQuestionData.points,
      minWords: questionData.minWords !== undefined ? questionData.minWords : currentQuestionData.minWords,
      maxWords: questionData.maxWords !== undefined ? questionData.maxWords : currentQuestionData.maxWords,
      expectedAnswer: questionData.expectedAnswer !== undefined ? questionData.expectedAnswer : currentQuestionData.expectedAnswer,
      keywords: keywords,
      caseSensitive: questionData.caseSensitive !== undefined ? questionData.caseSensitive : currentQuestionData.caseSensitive,
      autoGrade: questionData.autoGrade !== undefined ? questionData.autoGrade : currentQuestionData.autoGrade,
      explanation: questionData.explanation !== undefined ? questionData.explanation : currentQuestionData.explanation,
      updatedAt: new Date().toISOString()
    };
    
    // Aktualisierte Frage speichern
    test.questions[questionIndex] = updatedQuestion;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich aktualisiert.');
        return updatedQuestion;
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Frage.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Löscht eine Freitext-Frage
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestion(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return false;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    currentTest = test;
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return false;
    }
    
    const questionIndex = test.questions.findIndex(q => q.id === questionId);
    if (questionIndex === -1) {
      console.error('Frage nicht gefunden:', questionId);
      return false;
    }
    
    // Frage entfernen
    test.questions.splice(questionIndex, 1);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        NotificationSystem.showSuccess('Frage erfolgreich gelöscht.');
        return true;
      } else {
        NotificationSystem.showError('Fehler beim Löschen der Frage.');
        return false;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return false;
    }
  }
  
  /**
   * Gibt eine Freitext-Frage anhand ihrer ID zurück
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @returns {Object|null} - Die Frage oder null, wenn nicht gefunden
   */
  function getQuestionById(testId, questionId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Frage finden
    if (!test.questions) {
      console.error('Keine Fragen im Test vorhanden');
      return null;
    }
    
    const question = test.questions.find(q => q.id === questionId);
    return question || null;
  }
  
  /**
   * Gibt alle Freitext-Fragen eines Tests zurück
   * @param {string} testId - ID des Tests
   * @returns {Array} - Array mit Fragen
   */
  function getQuestions(testId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return [];
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return [];
    }
    
    // Freitext-Fragen filtern
    if (!test.questions) {
      return [];
    }
    
    return test.questions.filter(q => q.type === 'text');
  }
  
  /**
   * Validiert eine Freitext-Frage
   * @param {Object} question - Die zu validierende Frage
   * @returns {Object} - Objekt mit den Eigenschaften isValid und errors
   */
  function validateQuestion(question) {
    const errors = [];
    
    // Pflichtfelder überprüfen
    if (!question.text || question.text.trim() === '') {
      errors.push('Der Fragentext darf nicht leer sein.');
    }
    
    // Min/Max-Wortanzahl überprüfen
    if (question.minWords !== undefined && question.maxWords !== undefined) {
      if (question.minWords > question.maxWords && question.maxWords > 0) {
        errors.push('Die minimale Wortanzahl darf nicht größer sein als die maximale Wortanzahl.');
      }
    }
    
    // Wenn automatische Bewertung aktiviert ist, müssen Keywords vorhanden sein
    if (question.autoGrade && (!question.keywords || question.keywords.length === 0)) {
      errors.push('Für die automatische Bewertung müssen Schlüsselwörter angegeben werden.');
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }
  
  /**
   * Erstellt eine neue leere Freitext-Frage mit Standardwerten
   * @returns {Object} - Neue Frage
   */
  function createEmptyQuestion() {
    return {
      id: '',
      type: 'text',
      text: '',
      description: '',
      categoryId: null,
      difficulty: 3,
      points: 1,
      minWords: 0,
      maxWords: 0,
      expectedAnswer: '',
      keywords: [],
      caseSensitive: false,
      autoGrade: false,
      explanation: '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  }
  
  /**
   * Automatische Bewertung einer Freitext-Antwort
   * @param {Object} question - Die Frage
   * @param {string} answer - Die gegebene Antwort
   * @returns {Object} - Bewertungsergebnis mit Punktzahl und Feedback
   */
  function evaluateAnswer(question, answer) {
    // Überprüfen, ob automatische Bewertung möglich ist
    if (!question.autoGrade || !question.keywords || question.keywords.length === 0) {
      return {
        autoGraded: false,
        score: 0,
        maxScore: question.points,
        feedback: 'Diese Antwort erfordert eine manuelle Bewertung.',
        requiresManualGrading: true
      };
    }
    
    // Wortanzahl prüfen
    const words = countWords(answer);
    let feedback = [];
    
    // Minimale Wortanzahl prüfen
    if (question.minWords > 0 && words < question.minWords) {
      feedback.push(`Die Antwort enthält zu wenige Wörter (${words}/${question.minWords}).`);
      
      return {
        autoGraded: true,
        score: 0,
        maxScore: question.points,
        feedback: feedback.join(' '),
        requiresManualGrading: false,
        words: words
      };
    }
    
    // Maximale Wortanzahl prüfen
    if (question.maxWords > 0 && words > question.maxWords) {
      feedback.push(`Die Antwort überschreitet die maximale Wortanzahl (${words}/${question.maxWords}).`);
    }
    
    // Schlüsselwörter zählen
    const keywordResults = checkKeywords(answer, question.keywords, question.caseSensitive);
    const keywordsFound = keywordResults.found;
    const keywordsNotFound = keywordResults.notFound;
    
    // Punktzahl berechnen
    let score = 0;
    if (keywordsFound.length > 0) {
      // Punkte proportional zur Anzahl der gefundenen Schlüsselwörter
      score = Math.round((keywordsFound.length / question.keywords.length) * question.points);
    }
    
    // Feedback generieren
    if (keywordsFound.length === question.keywords.length) {
      feedback.push('Alle erwarteten Schlüsselwörter wurden gefunden.');
    } else {
      feedback.push(`${keywordsFound.length} von ${question.keywords.length} erwarteten Schlüsselwörtern gefunden.`);
      
      if (keywordsNotFound.length > 0) {
        feedback.push(`Fehlende Schlüsselwörter: ${keywordsNotFound.join(', ')}.`);
      }
    }
    
    return {
      autoGraded: true,
      score: score,
      maxScore: question.points,
      feedback: feedback.join(' '),
      requiresManualGrading: false,
      keywordsFound: keywordsFound,
      keywordsNotFound: keywordsNotFound,
      words: words
    };
  }
  
  /**
   * Zählt die Wörter in einem Text
   * @param {string} text - Der Text
   * @returns {number} - Anzahl der Wörter
   */
  function countWords(text) {
    if (!text) return 0;
    
    // Leerzeichen normalisieren und am Anfang/Ende entfernen
    const trimmedText = text.trim();
    if (trimmedText === '') return 0;
    
    // Wörter zählen (durch Leerzeichen getrennt)
    return trimmedText.split(/\s+/).length;
  }
  
  /**
   * Überprüft, ob Schlüsselwörter in einem Text vorkommen
   * @param {string} text - Der zu prüfende Text
   * @param {string[]} keywords - Die zu suchenden Schlüsselwörter
   * @param {boolean} caseSensitive - Groß-/Kleinschreibung beachten?
   * @returns {Object} - Objekt mit gefundenen und nicht gefundenen Schlüsselwörtern
   */
  function checkKeywords(text, keywords, caseSensitive = false) {
    const found = [];
    const notFound = [];
    
    // Text vorbereiten
    const processedText = caseSensitive ? text : text.toLowerCase();
    
    // Jedes Schlüsselwort prüfen
    keywords.forEach(keyword => {
      const processedKeyword = caseSensitive ? keyword : keyword.toLowerCase();
      
      if (processedText.includes(processedKeyword)) {
        found.push(keyword);
      } else {
        notFound.push(keyword);
      }
    });
    
    return {
      found: found,
      notFound: notFound
    };
  }
  
  // Öffentliche API
  return {
    createQuestion: createQuestion,
    updateQuestion: updateQuestion,
    deleteQuestion: deleteQuestion,
    getQuestionById: getQuestionById,
    getQuestions: getQuestions,
    validateQuestion: validateQuestion,
    createEmptyQuestion: createEmptyQuestion,
    evaluateAnswer: evaluateAnswer,
    countWords: countWords,
    checkKeywords: checkKeywords,
    
    // Diese Funktionen werden in Teil 2 implementiert
    renderQuestionForm: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.6.2: Freitext-Fragen erstellen - UI-Komponenten
 * 
 * Dieser Teil des Moduls implementiert die Benutzeroberfläche für
 * das Erstellen und Bearbeiten von Freitext-Fragen.
 */

// Bestehende Funktionen aus Teil 1 verwenden und UI-Funktionen hinzufügen
(function() {
  // Sicherstellen, dass TextQuestions existiert
  if (typeof TextQuestions === 'undefined') {
    console.error('TextQuestions-Modul nicht gefunden.');
    return;
  }
  
  /**
   * Rendert ein Formular zum Erstellen oder Bearbeiten einer Freitext-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function renderQuestionForm(containerId, testId, questionId = null, onSave = null, onCancel = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return;
    }
    
    // Frage laden oder erstellen
    let question = null;
    
    if (questionId) {
      question = TextQuestions.getQuestionById(testId, questionId);
      if (!question) {
        console.error('Frage nicht gefunden:', questionId);
        return;
      }
    } else {
      question = TextQuestions.createEmptyQuestion();
    }
    
    // Kategorien aus den Testeinstellungen laden
    let categories = [];
    if (test.settings && test.settings.questionCategories) {
      categories = test.settings.questionCategories;
    }
    
    // Schlüsselwörter als kommagetrennten String formatieren
    const keywordsString = question.keywords && Array.isArray(question.keywords) ? 
                          question.keywords.join(', ') : '';
    
    // HTML für das Formular erstellen
    let html = `
      <div class="question-form text-question-form">
        <form id="text-question-form">
          <div class="form-section">
            <h3>${questionId ? 'Freitext-Frage bearbeiten' : 'Neue Freitext-Frage erstellen'}</h3>
            
            <div class="form-group">
              <label for="question-text">Fragentext/Aufgabenstellung*</label>
              <textarea id="question-text" class="form-control" rows="3" required>${question.text || ''}</textarea>
              <div class="form-help">Formulieren Sie die Frage oder Aufgabenstellung klar und präzise.</div>
            </div>
            
            <div class="form-group">
              <label for="question-description">Beschreibung oder zusätzliche Informationen</label>
              <textarea id="question-description" class="form-control" rows="2">${question.description || ''}</textarea>
              <div class="form-help">Zusätzliche Informationen oder Kontext zur Frage (optional).</div>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="question-category">Kategorie</label>
                <select id="question-category" class="form-control">
                  <option value="">-- Keine Kategorie --</option>
    `;
    
    // Kategorien hinzufügen
    categories.forEach(category => {
      const selected = question.categoryId === category.id ? 'selected' : '';
      html += `<option value="${category.id}" ${selected}>${category.name}</option>`;
    });
    
    html += `
                </select>
                <div class="form-help">Kategorisieren Sie die Frage für eine bessere Organisation.</div>
              </div>
              
              <div class="form-group half-width">
                <label for="question-difficulty">Schwierigkeitsgrad</label>
                <div class="range-input-group">
                  <input type="range" id="question-difficulty" min="1" max="5" step="1" value="${question.difficulty || 3}">
                  <span id="difficulty-value">${question.difficulty || 3}</span>
                </div>
                <div class="form-help">Schwierigkeitsgrad der Frage (1 = sehr leicht, 5 = sehr schwer).</div>
              </div>
            </div>
            
            <div class="form-group">
              <label for="question-points">Punkte</label>
              <input type="number" id="question-points" class="form-control" min="1" max="100" value="${question.points || 1}">
              <div class="form-help">Anzahl der Punkte, die für eine korrekte Antwort vergeben werden.</div>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Antwortparameter</h3>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label for="min-words">Minimale Wortanzahl</label>
                <input type="number" id="min-words" class="form-control" min="0" value="${question.minWords || 0}">
                <div class="form-help">Minimale Anzahl von Wörtern, die die Antwort enthalten muss (0 = keine Einschränkung).</div>
              </div>
              
              <div class="form-group half-width">
                <label for="max-words">Maximale Wortanzahl</label>
                <input type="number" id="max-words" class="form-control" min="0" value="${question.maxWords || 0}">
                <div class="form-help">Maximale Anzahl von Wörtern für die Antwort (0 = keine Einschränkung).</div>
              </div>
            </div>
          </div>
          
          <div class="form-section">
            <h3>Bewertungskriterien und Musterantwort</h3>
            
            <div class="form-group">
              <label for="expected-answer">Erwartete Antwort / Musterantwort</label>
              <textarea id="expected-answer" class="form-control" rows="5">${question.expectedAnswer || ''}</textarea>
              <div class="form-help">Geben Sie eine Beispielantwort an, die als Grundlage für die Bewertung dienen kann.</div>
            </div>
            
            <div class="form-group">
              <label for="keywords">Schlüsselwörter oder Phrasen</label>
              <textarea id="keywords" class="form-control" rows="2">${keywordsString}</textarea>
              <div class="form-help">Kommagetrennte Liste von Schlüsselwörtern oder Phrasen, die in der Antwort vorkommen sollten.</div>
            </div>
            
            <div class="form-group checkbox-container">
              <div class="checkbox-group">
                <input type="checkbox" id="case-sensitive" ${question.caseSensitive ? 'checked' : ''}>
                <label for="case-sensitive">Groß-/Kleinschreibung bei Schlüsselwörtern beachten</label>
              </div>
              
              <div class="checkbox-group">
                <input type="checkbox" id="auto-grade" ${question.autoGrade ? 'checked' : ''}>
                <label for="auto-grade">Automatische Bewertung aktivieren</label>
              </div>
              <div class="form-help">Die automatische Bewertung erfolgt auf Basis der angegebenen Schlüsselwörter und Wortanzahl, ist aber weniger präzise als eine manuelle Bewertung.</div>
            </div>
            
            <div class="form-group">
              <label for="question-explanation">Erklärung / Bewertungshinweise</label>
              <textarea id="question-explanation" class="form-control" rows="3">${question.explanation || ''}</textarea>
              <div class="form-help">Eine Erklärung oder Hinweise zur Bewertung der Antwort. Dies kann zur Information für Prüfer oder für die Teilnehmer nach dem Test dienen.</div>
            </div>
          </div>
          
          <div class="form-actions">
            <button type="button" id="cancel-question-btn" class="btn btn-secondary">Abbrechen</button>
            <button type="submit" class="btn btn-primary">Frage speichern</button>
          </div>
        </form>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel);
  }
  
  /**
   * Fügt Event-Listener für das Fragenformular hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage (null für neue Frage)
   * @param {Function} onSave - Callback-Funktion nach dem Speichern
   * @param {Function} onCancel - Callback-Funktion bei Abbruch
   */
  function addQuestionFormEventListeners(containerId, testId, questionId, onSave, onCancel) {
    // Schwierigkeitsgrad-Slider
    const difficultySlider = document.getElementById('question-difficulty');
    const difficultyValue = document.getElementById('difficulty-value');
    
    if (difficultySlider && difficultyValue) {
      difficultySlider.addEventListener('input', function() {
        difficultyValue.textContent = this.value;
      });
    }
    
    // Validierungshelfer für Wortbegrenzungen
    const minWordsInput = document.getElementById('min-words');
    const maxWordsInput = document.getElementById('max-words');
    
    if (minWordsInput && maxWordsInput) {
      minWordsInput.addEventListener('change', function() {
        validateWordLimits(minWordsInput, maxWordsInput);
      });
      
      maxWordsInput.addEventListener('change', function() {
        validateWordLimits(minWordsInput, maxWordsInput);
      });
    }
    
    // Event-Listener für "Automatische Bewertung"
    const autoGradeCheckbox = document.getElementById('auto-grade');
    const keywordsTextarea = document.getElementById('keywords');
    
    if (autoGradeCheckbox && keywordsTextarea) {
      autoGradeCheckbox.addEventListener('change', function() {
        if (this.checked && keywordsTextarea.value.trim() === '') {
          NotificationSystem.showInfo('Für die automatische Bewertung werden Schlüsselwörter benötigt. Bitte geben Sie einige Schlüsselwörter an.');
        }
      });
    }
    
    // Abbrechen-Button
    const cancelBtn = document.getElementById('cancel-question-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        if (typeof onCancel === 'function') {
          onCancel();
        }
      });
    }
    
    // Formular-Submit
    const form = document.getElementById('text-question-form');
    if (form) {
      form.addEventListener('submit', function(event) {
        event.preventDefault();
        
        // Formulardaten sammeln
        const formData = collectFormData();
        
        // Validierung
        const validation = TextQuestions.validateQuestion(formData);
        if (!validation.isValid) {
          NotificationSystem.showError(validation.errors.join(' '));
          return;
        }
        
        // Frage speichern
        let savedQuestion = null;
        
        if (questionId) {
          // Bestehende Frage aktualisieren
          savedQuestion = TextQuestions.updateQuestion(testId, questionId, formData);
        } else {
          // Neue Frage erstellen
          savedQuestion = TextQuestions.createQuestion(testId, formData);
        }
        
        if (savedQuestion) {
          // Callback aufrufen
          if (typeof onSave === 'function') {
            onSave(savedQuestion);
          }
        }
      });
    }
  }
  
  /**
   * Validiert die Eingaben für minimale und maximale Wortanzahl
   * @param {HTMLElement} minInput - Input-Element für minimale Wortanzahl
   * @param {HTMLElement} maxInput - Input-Element für maximale Wortanzahl
   */
  function validateWordLimits(minInput, maxInput) {
    const minWords = parseInt(minInput.value) || 0;
    const maxWords = parseInt(maxInput.value) || 0;
    
    // Wenn maxWords > 0 und minWords > maxWords, maxWords auf minWords setzen
    if (maxWords > 0 && minWords > maxWords) {
      maxInput.value = minWords;
      NotificationSystem.showInfo('Die maximale Wortanzahl wurde angepasst, da sie kleiner als die minimale Wortanzahl war.');
    }
  }
  
  /**
   * Sammelt die Daten aus dem Fragenformular
   * @returns {Object} - Gesammelte Daten
   */
  function collectFormData() {
    const formData = {
      text: document.getElementById('question-text').value.trim(),
      description: document.getElementById('question-description').value.trim(),
      categoryId: document.getElementById('question-category').value || null,
      difficulty: parseInt(document.getElementById('question-difficulty').value) || 3,
      points: parseInt(document.getElementById('question-points').value) || 1,
      minWords: parseInt(document.getElementById('min-words').value) || 0,
      maxWords: parseInt(document.getElementById('max-words').value) || 0,
      expectedAnswer: document.getElementById('expected-answer').value.trim(),
      keywords: document.getElementById('keywords').value.trim(),
      caseSensitive: document.getElementById('case-sensitive').checked,
      autoGrade: document.getElementById('auto-grade').checked,
      explanation: document.getElementById('question-explanation').value.trim()
    };
    
    return formData;
  }
  
  // Die renderQuestionForm Funktion dem TextQuestions-Modul hinzufügen
  TextQuestions.renderQuestionForm = renderQuestionForm;
  
  /**
   * Rendert eine Liste aller Freitext-Fragen eines Tests
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen (bearbeiten, löschen, usw.)
   */
  function renderQuestionsList(containerId, testId, onAction = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Fragen laden
    const questions = TextQuestions.getQuestions(testId);
    
    // HTML für die Fragenliste erstellen
    let html = `
      <div class="questions-list">
        <div class="list-header">
          <h3>Freitext-Fragen</h3>
          <button id="add-question-btn" class="btn btn-primary">
            <i class="fas fa-plus"></i> Neue Frage erstellen
          </button>
        </div>
    `;
    
    if (questions.length === 0) {
      html += `
        <div class="no-items-message">
          <p>Keine Freitext-Fragen vorhanden.</p>
          <p>Klicken Sie auf "Neue Frage erstellen", um Ihre erste Frage hinzuzufügen.</p>
        </div>
      `;
    } else {
      html += `
        <div class="items-list">
      `;
      
      questions.forEach((question, index) => {
        // Maximal 100 Zeichen des Fragentexts anzeigen
        const truncatedText = question.text.length > 100 ? 
                             question.text.substring(0, 100) + '...' : 
                             question.text;
        
        // Formatierte Wortbegrenzungen
        let wordLimits = [];
        if (question.minWords > 0) wordLimits.push(`Min: ${question.minWords} Wörter`);
        if (question.maxWords > 0) wordLimits.push(`Max: ${question.maxWords} Wörter`);
        const wordLimitsText = wordLimits.length > 0 ? wordLimits.join(', ') : 'Keine Wortbegrenzung';
        
        // Schlüsselwörter zählen
        const keywordCount = question.keywords && Array.isArray(question.keywords) ? 
                           question.keywords.length : 0;
        
        html += `
          <div class="question-list-item" data-question-id="${question.id}">
            <div class="question-info">
              <div class="question-number">${index + 1}</div>
              <div class="question-content">
                <div class="question-title">${truncatedText}</div>
                <div class="question-meta">
                  <span class="question-type">Freitext</span>
                  <span class="question-words">${wordLimitsText}</span>
                  <span class="question-keywords">${keywordCount} Schlüsselwörter</span>
                  <span class="question-grading">${question.autoGrade ? 'Auto-Bewertung' : 'Manuelle Bewertung'}</span>
                  <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
                </div>
              </div>
            </div>
            <div class="question-actions">
              <button class="btn btn-sm btn-primary preview-question-btn" data-question-id="${question.id}" title="Vorschau">
                <i class="fas fa-eye"></i>
              </button>
              <button class="btn btn-sm btn-edit edit-question-btn" data-question-id="${question.id}" title="Bearbeiten">
                <i class="fas fa-edit"></i>
              </button>
              <button class="btn btn-sm btn-danger delete-question-btn" data-question-id="${question.id}" title="Löschen">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      });
      
      html += `
        </div>
      `;
    }
    
    html += `
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    addQuestionsListEventListeners(containerId, testId, onAction);
  }
  
  /**
   * Fügt Event-Listener für die Fragenliste hinzu
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {Function} onAction - Callback-Funktion bei Aktionen
   */
  function addQuestionsListEventListeners(containerId, testId, onAction) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // "Neue Frage erstellen"-Button
    const addQuestionBtn = container.querySelector('#add-question-btn');
    if (addQuestionBtn) {
      addQuestionBtn.addEventListener('click', function() {
        if (typeof onAction === 'function') {
          onAction('create', null);
        }
      });
    }
    
    // Event-Delegation für Fragen-Aktionen
    container.addEventListener('click', function(event) {
      // Vorschau-Button
      if (event.target.classList.contains('preview-question-btn') || 
          event.target.closest('.preview-question-btn')) {
        const button = event.target.classList.contains('preview-question-btn') ? 
                      event.target : 
                      event.target.closest('.preview-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('preview', questionId);
        }
      }
      
      // Bearbeiten-Button
      if (event.target.classList.contains('edit-question-btn') || 
          event.target.closest('.edit-question-btn')) {
        const button = event.target.classList.contains('edit-question-btn') ? 
                      event.target : 
                      event.target.closest('.edit-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        if (typeof onAction === 'function') {
          onAction('edit', questionId);
        }
      }
      
      // Löschen-Button
      if (event.target.classList.contains('delete-question-btn') || 
          event.target.closest('.delete-question-btn')) {
        const button = event.target.classList.contains('delete-question-btn') ? 
                      event.target : 
                      event.target.closest('.delete-question-btn');
        
        const questionId = button.getAttribute('data-question-id');
        
        // Bestätigungsdialog anzeigen
        if (confirm('Sind Sie sicher, dass Sie diese Frage löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.')) {
          const deleted = TextQuestions.deleteQuestion(testId, questionId);
          
          if (deleted) {
            // Fragenliste aktualisieren
            renderQuestionsList(containerId, testId, onAction);
          }
        }
      }
    });
  }
  
  /**
   * Rendert eine Vorschau einer Freitext-Frage
   * @param {string} containerId - ID des Containers
   * @param {string} testId - ID des Tests
   * @param {string} questionId - ID der Frage
   * @param {Function} onClose - Callback-Funktion beim Schließen
   */
  function renderQuestionPreview(containerId, testId, questionId, onClose = null) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Frage laden
    const question = TextQuestions.getQuestionById(testId, questionId);
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return;
    }
    
    // Formatierte Wortbegrenzungen
    let wordLimits = [];
    if (question.minWords > 0) wordLimits.push(`Mindestens ${question.minWords} Wörter`);
    if (question.maxWords > 0) wordLimits.push(`Höchstens ${question.maxWords} Wörter`);
    const wordLimitsText = wordLimits.join(', ');
    
    // HTML für die Fragenvorschau erstellen
    let html = `
      <div class="question-preview">
        <div class="preview-header">
          <h3>Fragenvorschau</h3>
          <button id="close-preview-btn" class="btn btn-icon">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="preview-content">
          <div class="question-display">
            <div class="question-text">${question.text}</div>
            ${question.description ? `<div class="question-description">${question.description}</div>` : ''}
            
            <div class="question-meta">
              <span class="question-difficulty">Schwierigkeit: ${question.difficulty}/5</span>
              <span class="question-points">${question.points} Punkt${question.points !== 1 ? 'e' : ''}</span>
              <span class="question-type">Freitext</span>
            </div>
          </div>
          
          <div class="text-answer-display">
            <div class="preview-label">Bitte geben Sie Ihre Antwort im Textfeld ein:</div>
            ${wordLimitsText ? `<div class="word-limits">${wordLimitsText}</div>` : ''}
            
            <textarea class="form-control answer-textarea" rows="6" placeholder="Hier Antwort eingeben..." disabled></textarea>
    `;
    
    // Anzeige der Wortanzahl
    html += `
            <div class="word-counter">
              <span id="word-count">0</span> Wörter
            </div>
          </div>
          
          <div class="preview-section">
            <h4>Bewertungsinformationen (nur für Ersteller sichtbar)</h4>
    `;
    
    // Erwartete Antwort anzeigen, wenn vorhanden
    if (question.expectedAnswer) {
      html += `
            <div class="expected-answer-display">
              <div class="preview-label">Erwartete Antwort / Musterantwort:</div>
              <div class="expected-answer-text">${question.expectedAnswer}</div>
            </div>
      `;
    }
    
    // Schlüsselwörter anzeigen, wenn vorhanden
    if (question.keywords && question.keywords.length > 0) {
      html += `
            <div class="keywords-display">
              <div class="preview-label">Schlüsselwörter/Phrasen:</div>
              <div class="keywords-list">
      `;
      
      question.keywords.forEach(keyword => {
        html += `<span class="keyword-tag">${keyword}</span>`;
      });
      
      html += `
              </div>
              ${question.caseSensitive ? '<div class="case-sensitive-note">Groß-/Kleinschreibung wird beachtet</div>' : ''}
            </div>
      `;
    }
    
    // Bewertungsmethode anzeigen
    html += `
            <div class="grading-method-display">
              <div class="preview-label">Bewertungsmethode:</div>
              <div class="grading-method">${question.autoGrade ? 'Automatische Bewertung' : 'Manuelle Bewertung'}</div>
            </div>
    `;
    
    // Erklärung anzeigen, wenn vorhanden
    if (question.explanation) {
      html += `
            <div class="explanation-display">
              <div class="preview-label">Erklärung / Bewertungshinweise:</div>
              <div class="explanation-text">${question.explanation}</div>
            </div>
      `;
    }
    
    html += `
          </div>
        </div>
        
        <div class="preview-footer">
          <button id="edit-from-preview-btn" class="btn btn-primary">Frage bearbeiten</button>
          <button id="close-preview-btn-footer" class="btn btn-secondary">Schließen</button>
        </div>
      </div>
    `;
    
    // HTML in den Container einfügen
    container.innerHTML = html;
    
    // Event-Listener hinzufügen
    // Schließen-Buttons
    const closeButtons = container.querySelectorAll('#close-preview-btn, #close-preview-btn-footer');
    closeButtons.forEach(button => {
      button.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose();
        }
      });
    });
    
    // Bearbeiten-Button
    const editButton = container.querySelector('#edit-from-preview-btn');
    if (editButton) {
      editButton.addEventListener('click', function() {
        if (typeof onClose === 'function') {
          onClose('edit');
        }
      });
    }
    
    // Texteingabefeld für Wortanzahl-Demonstration
    const answerTextarea = container.querySelector('.answer-textarea');
    const wordCount = container.querySelector('#word-count');
    
    if (answerTextarea && wordCount) {
      answerTextarea.addEventListener('input', function() {
        const count = TextQuestions.countWords(this.value);
        wordCount.textContent = count;
        
        // Visuelles Feedback bei Wortbegrenzungen
        if ((question.minWords > 0 && count < question.minWords) || 
            (question.maxWords > 0 && count > question.maxWords)) {
          wordCount.classList.add('word-count-error');
        } else {
          wordCount.classList.remove('word-count-error');
        }
      });
    }
  }
  
  // Öffentliche Funktionen dem TextQuestions-Modul hinzufügen
  TextQuestions.renderQuestionsList = renderQuestionsList;
  TextQuestions.renderQuestionPreview = renderQuestionPreview;
})();

// CSS für die Freitext-Fragen
document.addEventListener('DOMContentLoaded', function() {
  // Überprüfen, ob bereits ein Style-Element für Freitext-Fragen existiert
  if (!document.getElementById('text-questions-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'text-questions-styles';
    styleElement.textContent = `
      /* Freitext-spezifisches Styling */
      .text-answer-display {
        margin-bottom: 20px;
      }
      
      .answer-textarea {
        width: 100%;
        resize: vertical;
        margin: 10px 0;
      }
      
      .word-counter {
        text-align: right;
        font-size: 0.85em;
        color: #666;
      }
      
      .word-count-error {
        color: #dc3545;
        font-weight: bold;
      }
      
      .word-limits {
        font-size: 0.9em;
        color: #666;
        margin: 5px 0;
        font-style: italic;
      }
      
      .preview-section {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      
      .preview-section h4 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.1em;
        color: #495057;
      }
      
      .expected-answer-display,
      .keywords-display,
      .grading-method-display {
        margin-bottom: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .expected-answer-text {
        background-color: #f0f7ff;
        padding: 10px;
        border-radius: 4px;
        border-left: 4px solid #0056b3;
      }
      
      .keywords-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin: 5px 0;
      }
      
      .keyword-tag {
        background-color: #e0f7f4;
        color: #00a38a;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }
      
      .case-sensitive-note {
        font-size: 0.85em;
        color: #666;
        margin-top: 5px;
        font-style: italic;
      }
      
      .grading-method {
        font-weight: bold;
        color: #333;
      }
      
      /* Allgemeines Fragenstyling */
      .question-form {
        max-width: 800px;
        margin: 0 auto;
      }
      
      .form-section {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      
      .form-section h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.2em;
        color: #333;
      }
      
      .form-row {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
      }
      
      .half-width {
        flex: 1;
      }
      
      .checkbox-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      /* Fragenliste */
      .questions-list {
        width: 100%;
      }
      
      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .question-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .question-info {
        display: flex;
        flex: 1;
      }
      
      .question-number {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 50%;
        background-color: #00FFD0;
        color: #000;
        font-weight: bold;
      }
      
      .question-content {
        flex: 1;
      }
      
      .question-title {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .question-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 0.85em;
        color: #666;
      }
      
      .question-actions {
        display: flex;
        gap: 5px;
      }
      
      .no-items-message {
        text-align: center;
        padding: 20px;
        background-color: #f0f0f0;
        border-radius: 4px;
        color: #666;
      }
      
      /* Fragenvorschau */
      .question-preview {
        max-width: 700px;
        margin: 0 auto;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      
      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-bottom: 1px solid #ddd;
      }
      
      .preview-header h3 {
        margin: 0;
      }
      
      .preview-content {
        padding: 20px;
      }
      
      .question-display {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      
      .question-text {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 10px;
      }
      
      .question-description {
        margin-bottom: 10px;
        color: #666;
      }
      
      .preview-label {
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      .explanation-display {
        padding: 15px;
        background-color: #f0f7ff;
        border-radius: 4px;
        margin-bottom: 15px;
      }
      
      .explanation-text {
        color: #0056b3;
      }
      
      .preview-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        padding: 15px;
        border-top: 1px solid #ddd;
      }
      
      /* Responsive Anpassungen */
      @media (max-width: 768px) {
        .form-row {
          flex-direction: column;
          gap: 10px;
        }
      }
    `;
    
    // Styles zum Dokument hinzufügen
    document.head.appendChild(styleElement);
  }
});
/**
 * JS-Block 4.7.1: Fragenpool-Verwaltung - Datenstruktur und Operationen
 * 
 * Dieses Modul implementiert die Funktionen zur Verwaltung eines Fragenpools,
 * aus dem Fragen für Tests wiederverwendet werden können.
 */

// Modul als IIFE (Immediately Invoked Function Expression)
const QuestionPool = (function() {
  // Private Variablen
  let poolQuestions = [];
  
  /**
   * Fragenpool-Eintrag Datenstruktur:
   * {
   *   id: string,                  // Eindeutige ID
   *   question: Object,            // Die Fragedaten (wie in den anderen Modulen)
   *   tags: string[],              // Tags zur Kategorisierung
   *   source: string,              // Herkunft der Frage (z.B. Testname)
   *   useCount: number,            // Wie oft wurde die Frage verwendet
   *   createdBy: string,           // Ersteller (Benutzer-ID)
   *   createdAt: Date,             // Erstellungsdatum
   *   updatedAt: Date              // Letztes Aktualisierungsdatum
   * }
   */
  
  /**
   * Lädt den Fragenpool aus dem LocalStorage
   * @returns {Array} - Array mit Fragenpool-Einträgen
   */
  function loadQuestionPool() {
    try {
      poolQuestions = JSON.parse(localStorage.getItem('elearning_question_pool') || '[]');
      return poolQuestions;
    } catch (error) {
      console.error('Fehler beim Laden des Fragenpools:', error);
      return [];
    }
  }
  
  /**
   * Speichert den Fragenpool im LocalStorage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function saveQuestionPool() {
    try {
      localStorage.setItem('elearning_question_pool', JSON.stringify(poolQuestions));
      return true;
    } catch (error) {
      console.error('Fehler beim Speichern des Fragenpools:', error);
      return false;
    }
  }
  
  /**
   * Fügt eine Frage zum Fragenpool hinzu
   * @param {Object} question - Die Fragedaten
   * @param {string} source - Herkunft der Frage
   * @param {string[]} tags - Tags zur Kategorisierung
   * @returns {Object|null} - Der erstellte Fragenpool-Eintrag oder null bei Fehler
   */
  function addToPool(question, source = '', tags = []) {
    // Eindeutige ID für den Fragenpool-Eintrag
    const poolEntryId = 'pool_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Aktueller Benutzer (für Ersteller)
    const currentUser = typeof AuthManager !== 'undefined' && AuthManager.getCurrentUser ? 
                      AuthManager.getCurrentUser() : { id: 'unknown' };
    const creatorId = currentUser.id || 'unknown';
    
    // Prüfen, ob die Frage bereits im Pool existiert
    const existingEntry = poolQuestions.find(entry => 
      entry.question.id === question.id && entry.question.type === question.type
    );
    
    if (existingEntry) {
      // Eintrag aktualisieren
      existingEntry.question = { ...question };
      existingEntry.tags = [...new Set([...existingEntry.tags, ...tags])]; // Doppelte Tags entfernen
      existingEntry.updatedAt = new Date().toISOString();
      
      if (source && !existingEntry.source.includes(source)) {
        existingEntry.source += (existingEntry.source ? ', ' : '') + source;
      }
      
      saveQuestionPool();
      
      NotificationSystem.showInfo('Frage im Fragenpool aktualisiert.');
      return existingEntry;
    }
    
    // Neuen Fragenpool-Eintrag erstellen
    const newPoolEntry = {
      id: poolEntryId,
      question: { ...question }, // Kopie der Frage erstellen
      tags: tags,
      source: source,
      useCount: 0,
      createdBy: creatorId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Zum Fragenpool hinzufügen
    poolQuestions.push(newPoolEntry);
    
    // Fragenpool speichern
    if (saveQuestionPool()) {
      NotificationSystem.showSuccess('Frage erfolgreich zum Fragenpool hinzugefügt.');
      return newPoolEntry;
    } else {
      NotificationSystem.showError('Fehler beim Hinzufügen der Frage zum Fragenpool.');
      return null;
    }
  }
  
  /**
   * Aktualisiert einen Fragenpool-Eintrag
   * @param {string} poolEntryId - ID des Fragenpool-Eintrags
   * @param {Object} updateData - Die zu aktualisierenden Daten
   * @returns {Object|null} - Der aktualisierte Fragenpool-Eintrag oder null bei Fehler
   */
  function updatePoolEntry(poolEntryId, updateData) {
    // Fragenpool-Eintrag finden
    const entryIndex = poolQuestions.findIndex(entry => entry.id === poolEntryId);
    
    if (entryIndex === -1) {
      console.error('Fragenpool-Eintrag nicht gefunden:', poolEntryId);
      return null;
    }
    
    // Aktuelles Eintragsobjekt
    const currentEntry = poolQuestions[entryIndex];
    
    // Tags aktualisieren, wenn vorhanden
    let updatedTags = currentEntry.tags;
    if (updateData.tags !== undefined) {
      // Wenn Tags als String übergeben wurden, in Array umwandeln
      if (typeof updateData.tags === 'string') {
        updatedTags = updateData.tags.split(',')
          .map(tag => tag.trim())
          .filter(tag => tag.length > 0);
      } else if (Array.isArray(updateData.tags)) {
        updatedTags = updateData.tags;
      }
    }
    
    // Eintrag aktualisieren
    const updatedEntry = {
      ...currentEntry,
      question: updateData.question !== undefined ? { ...updateData.question } : currentEntry.question,
      tags: updatedTags,
      source: updateData.source !== undefined ? updateData.source : currentEntry.source,
      useCount: updateData.useCount !== undefined ? updateData.useCount : currentEntry.useCount,
      updatedAt: new Date().toISOString()
    };
    
    // Aktualisierter Eintrag speichern
    poolQuestions[entryIndex] = updatedEntry;
    
    // Fragenpool speichern
    if (saveQuestionPool()) {
      NotificationSystem.showSuccess('Fragenpool-Eintrag erfolgreich aktualisiert.');
      return updatedEntry;
    } else {
      NotificationSystem.showError('Fehler beim Aktualisieren des Fragenpool-Eintrags.');
      return null;
    }
  }
  
  /**
   * Löscht einen Fragenpool-Eintrag
   * @param {string} poolEntryId - ID des Fragenpool-Eintrags
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deletePoolEntry(poolEntryId) {
    // Fragenpool-Eintrag finden
    const entryIndex = poolQuestions.findIndex(entry => entry.id === poolEntryId);
    
    if (entryIndex === -1) {
      console.error('Fragenpool-Eintrag nicht gefunden:', poolEntryId);
      return false;
    }
    
    // Eintrag entfernen
    poolQuestions.splice(entryIndex, 1);
    
    // Fragenpool speichern
    if (saveQuestionPool()) {
      NotificationSystem.showSuccess('Fragenpool-Eintrag erfolgreich gelöscht.');
      return true;
    } else {
      NotificationSystem.showError('Fehler beim Löschen des Fragenpool-Eintrags.');
      return false;
    }
  }
  
  /**
   * Gibt einen Fragenpool-Eintrag anhand seiner ID zurück
   * @param {string} poolEntryId - ID des Fragenpool-Eintrags
   * @returns {Object|null} - Der Fragenpool-Eintrag oder null, wenn nicht gefunden
   */
  function getPoolEntryById(poolEntryId) {
    // Sicherstellen, dass der Fragenpool geladen ist
    if (poolQuestions.length === 0) {
      loadQuestionPool();
    }
    
    return poolQuestions.find(entry => entry.id === poolEntryId) || null;
  }
  
  /**
   * Gibt alle Fragenpool-Einträge zurück
   * @returns {Array} - Array mit allen Fragenpool-Einträgen
   */
  function getAllPoolEntries() {
    return loadQuestionPool();
  }
  
  /**
   * Sucht Fragenpool-Einträge anhand von Kriterien
   * @param {Object} criteria - Suchkriterien
   * @returns {Array} - Array mit passenden Fragenpool-Einträgen
   */
  function searchPoolEntries(criteria = {}) {
    // Sicherstellen, dass der Fragenpool geladen ist
    if (poolQuestions.length === 0) {
      loadQuestionPool();
    }
    
    // Wenn keine Kriterien angegeben, alle Einträge zurückgeben
    if (!criteria || Object.keys(criteria).length === 0) {
      return poolQuestions;
    }
    
    // Einträge filtern
    return poolQuestions.filter(entry => {
      // Nach Fragetext suchen
      if (criteria.text && entry.question.text) {
        const searchText = criteria.text.toLowerCase();
        const questionText = entry.question.text.toLowerCase();
        
        if (!questionText.includes(searchText)) {
          return false;
        }
      }
      
      // Nach Typ filtern
      if (criteria.type && entry.question.type !== criteria.type) {
        return false;
      }
      
      // Nach Tags filtern
      if (criteria.tags && Array.isArray(criteria.tags) && criteria.tags.length > 0) {
        // Prüfen, ob mindestens ein Tag übereinstimmt
        const hasMatchingTag = criteria.tags.some(tag => 
          entry.tags.includes(tag)
        );
        
        if (!hasMatchingTag) {
          return false;
        }
      }
      
      // Nach Quelle filtern
      if (criteria.source && entry.source) {
        const searchSource = criteria.source.toLowerCase();
        const entrySource = entry.source.toLowerCase();
        
        if (!entrySource.includes(searchSource)) {
          return false;
        }
      }
      
      // Nach Ersteller filtern
      if (criteria.createdBy && entry.createdBy !== criteria.createdBy) {
        return false;
      }
      
      // Nach Erstellungsdatum filtern (nach einem bestimmten Datum)
      if (criteria.createdAfter && entry.createdAt) {
        const createdAfter = new Date(criteria.createdAfter);
        const createdAt = new Date(entry.createdAt);
        
        if (createdAt < createdAfter) {
          return false;
        }
      }
      
      // Nach Erstellungsdatum filtern (vor einem bestimmten Datum)
      if (criteria.createdBefore && entry.createdAt) {
        const createdBefore = new Date(criteria.createdBefore);
        const createdAt = new Date(entry.createdAt);
        
        if (createdAt > createdBefore) {
          return false;
        }
      }
      
      // Nach Verwendungshäufigkeit filtern
      if (criteria.minUseCount !== undefined && entry.useCount < criteria.minUseCount) {
        return false;
      }
      
      if (criteria.maxUseCount !== undefined && entry.useCount > criteria.maxUseCount) {
        return false;
      }
      
      // Alle Kriterien erfüllt
      return true;
    });
  }
  
  /**
   * Erhöht den Verwendungszähler eines Fragenpool-Eintrags
   * @param {string} poolEntryId - ID des Fragenpool-Eintrags
   * @returns {Object|null} - Der aktualisierte Fragenpool-Eintrag oder null bei Fehler
   */
  function incrementUseCount(poolEntryId) {
    // Fragenpool-Eintrag finden
    const entry = getPoolEntryById(poolEntryId);
    
    if (!entry) {
      console.error('Fragenpool-Eintrag nicht gefunden:', poolEntryId);
      return null;
    }
    
    // Verwendungszähler erhöhen
    return updatePoolEntry(poolEntryId, { useCount: entry.useCount + 1 });
  }
  
  /**
   * Fügt eine Frage aus dem Fragenpool zu einem Test hinzu
   * @param {string} poolEntryId - ID des Fragenpool-Eintrags
   * @param {string} testId - ID des Tests
   * @returns {Object|null} - Die hinzugefügte Frage oder null bei Fehler
   */
  function addPoolQuestionToTest(poolEntryId, testId) {
    // Fragenpool-Eintrag finden
    const poolEntry = getPoolEntryById(poolEntryId);
    
    if (!poolEntry) {
      console.error('Fragenpool-Eintrag nicht gefunden:', poolEntryId);
      return null;
    }
    
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return null;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return null;
    }
    
    // Fragen-Array erstellen, falls nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Kopie der Frage erstellen mit neuer ID
    const questionCopy = { ...poolEntry.question };
    questionCopy.id = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    questionCopy.updatedAt = new Date().toISOString();
    
    // Frage zum Test hinzufügen
    test.questions.push(questionCopy);
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Test speichern
    if (typeof TestBasicData !== 'undefined' && TestBasicData.updateTest) {
      const success = TestBasicData.updateTest(testId, { questions: test.questions, questionCount: test.questionCount });
      
      if (success) {
        // Verwendungszähler erhöhen
        incrementUseCount(poolEntryId);
        
        NotificationSystem.showSuccess('Frage erfolgreich zum Test hinzugefügt.');
        return questionCopy;
      } else {
        NotificationSystem.showError('Fehler beim Hinzufügen der Frage zum Test.');
        return null;
      }
    } else {
      console.error('TestBasicData.updateTest nicht verfügbar');
      return null;
    }
  }
  
  /**
   * Importiert alle Fragen eines Tests in den Fragenpool
   * @param {string} testId - ID des Tests
   * @returns {number} - Anzahl der importierten Fragen
   */
  function importQuestionsFromTest(testId) {
    // Test laden
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar');
      return 0;
    }
    
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return 0;
    }
    
    // Keine Fragen vorhanden
    if (!test.questions || test.questions.length === 0) {
      NotificationSystem.showInfo('Der Test enthält keine Fragen.');
      return 0;
    }
    
    // Zähler für importierte Fragen
    let importCount = 0;
    
    // Jede Frage importieren
    test.questions.forEach(question => {
      const result = addToPool(question, test.title, []);
      if (result) {
        importCount++;
      }
    });
    
    if (importCount > 0) {
      NotificationSystem.showSuccess(`${importCount} Fragen wurden erfolgreich in den Fragenpool importiert.`);
    } else {
      NotificationSystem.showInfo('Es wurden keine neuen Fragen in den Fragenpool importiert.');
    }
    
    return importCount;
  }
  
  /**
   * Gibt alle eindeutigen Tags im Fragenpool zurück
   * @returns {string[]} - Array mit allen eindeutigen Tags
   */
  function getAllTags() {
    // Sicherstellen, dass der Fragenpool geladen ist
    if (poolQuestions.length === 0) {
      loadQuestionPool();
    }
    
    // Alle Tags sammeln und Duplikate entfernen
    const allTags = [];
    
    poolQuestions.forEach(entry => {
      if (entry.tags && Array.isArray(entry.tags)) {
        entry.tags.forEach(tag => {
          if (!allTags.includes(tag)) {
            allTags.push(tag);
          }
        });
      }
    });
    
    return allTags.sort();
  }
  
  /**
   * Gibt die Anzahl der Fragen pro Typ zurück
   * @returns {Object} - Objekt mit Typen als Schlüssel und Anzahl als Wert
   */
  function getQuestionCountByType() {
    // Sicherstellen, dass der Fragenpool geladen ist
    if (poolQuestions.length === 0) {
      loadQuestionPool();
    }
    
    const counts = {
      multiple_choice: 0,
      single_choice: 0,
      true_false: 0,
      text: 0,
      other: 0
    };
    
    poolQuestions.forEach(entry => {
      const type = entry.question.type;
      
      if (counts[type] !== undefined) {
        counts[type]++;
      } else {
        counts.other++;
      }
    });
    
    return counts;
  }
  
  // Initialisierung
  function init() {
    // Fragenpool laden
    loadQuestionPool();
    
    console.log('Fragenpool-Modul initialisiert');
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    loadQuestionPool: loadQuestionPool,
    addToPool: addToPool,
    updatePoolEntry: updatePoolEntry,
    deletePoolEntry: deletePoolEntry,
    getPoolEntryById: getPoolEntryById,
    getAllPoolEntries: getAllPoolEntries,
    searchPoolEntries: searchPoolEntries,
    incrementUseCount: incrementUseCount,
    addPoolQuestionToTest: addPoolQuestionToTest,
    importQuestionsFromTest: importQuestionsFromTest,
    getAllTags: getAllTags,
    getQuestionCountByType: getQuestionCountByType,
    
    // Diese Funktionen werden in Teil 2 implementiert
    renderPoolView: null
  };
})();

// Wenn NotificationSystem noch nicht definiert ist
if (typeof NotificationSystem === 'undefined') {
  const NotificationSystem = {
    showSuccess: function(message) {
      alert('Erfolg: ' + message);
    },
    showError: function(message) {
      alert('Fehler: ' + message);
    },
    showInfo: function(message) {
      alert('Info: ' + message);
    }
  };
  window.NotificationSystem = NotificationSystem;
}
/**
 * JS-Block 4.7.2: Fragenpool-Verwaltung UI - Grundfunktionen
 * 
 * Dieses Modul implementiert die Benutzeroberflächenfunktionen für den Fragenpool.
 * Teil 1 enthält die grundlegende Renderingfunktionen sowie Filterung und Sortierung.
 */

// Fragenpool-UI als Erweiterung des bestehenden QuestionPool-Moduls
(function() {
  // Referenz auf das existierende QuestionPool-Modul
  const qpModule = window.QuestionPool;
  
  if (!qpModule) {
    console.error('QuestionPool-Modul nicht gefunden. Bitte zuerst JS-Block 4.7.1 laden.');
    return;
  }
  
  // DOM-Selektoren
  const selectors = {
    poolContainer: '#question-pool-container',
    poolList: '#question-pool-list',
    filterForm: '#question-pool-filter',
    searchInput: '#pool-search-input',
    typeFilter: '#pool-type-filter',
    tagFilter: '#pool-tag-filter',
    sortSelect: '#pool-sort-select',
    entriesCount: '#pool-entries-count',
    addToTestModal: '#add-to-test-modal',
    addToTestSelect: '#add-to-test-select',
    addToTestButton: '#add-to-test-confirm'
  };
  
  // Aktuelle UI-Zustände
  const uiState = {
    selectedEntry: null,
    visibleEntries: [],
    currentFilter: {
      text: '',
      type: '',
      tags: [],
      source: ''
    },
    currentSort: {
      field: 'updatedAt',
      direction: 'desc'
    }
  };
  
  /**
   * Initialisiert die Fragenpool-UI
   * @param {string} containerId - Die ID des Container-Elements
   */
  function initPoolUI(containerId = 'question-pool-container') {
    // Container-Element erstellen, falls noch nicht vorhanden
    let container = document.getElementById(containerId);
    
    if (!container) {
      container = document.createElement('div');
      container.id = containerId;
      document.body.appendChild(container);
    }
    
    // Grundlegende UI-Struktur erstellen
    container.innerHTML = `
      <div class="pool-header">
        <h2>Fragenpool</h2>
        <div class="pool-stats">
          <span id="pool-entries-count">0 Fragen im Pool</span>
        </div>
      </div>
      
      <div class="pool-controls">
        <form id="question-pool-filter" class="pool-filter-form">
          <div class="form-group">
            <input type="text" id="pool-search-input" placeholder="Suchen..." class="form-control">
          </div>
          
          <div class="form-group">
            <label for="pool-type-filter">Fragetyp:</label>
            <select id="pool-type-filter" class="form-control">
              <option value="">Alle Typen</option>
              <option value="multiple_choice">Multiple Choice</option>
              <option value="single_choice">Single Choice</option>
              <option value="true_false">Wahr/Falsch</option>
              <option value="text">Freitext</option>
            </select>
          </div>
          
          <div class="form-group">
            <label for="pool-tag-filter">Tags:</label>
            <select id="pool-tag-filter" class="form-control" multiple>
              <!-- Tags werden dynamisch eingefügt -->
            </select>
          </div>
          
          <div class="form-group">
            <button type="button" id="pool-filter-reset" class="btn btn-outline">Filter zurücksetzen</button>
          </div>
        </form>
        
        <div class="pool-actions">
          <div class="form-group">
            <label for="pool-sort-select">Sortieren nach:</label>
            <select id="pool-sort-select" class="form-control">
              <option value="updatedAt:desc">Zuletzt aktualisiert</option>
              <option value="createdAt:desc">Neueste zuerst</option>
              <option value="createdAt:asc">Älteste zuerst</option>
              <option value="useCount:desc">Häufig verwendet</option>
              <option value="useCount:asc">Selten verwendet</option>
            </select>
          </div>
          
          <button id="pool-refresh-button" class="btn btn-outline" title="Aktualisieren">
            <i class="icon-refresh"></i>
          </button>
        </div>
      </div>
      
      <div id="question-pool-list" class="pool-list">
        <!-- Fragenpool-Einträge werden hier eingefügt -->
      </div>
      
      <!-- Modaler Dialog für "Zum Test hinzufügen" -->
      <div id="add-to-test-modal" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Frage zum Test hinzufügen</h3>
            <button class="close-button">&times;</button>
          </div>
          <div class="modal-body">
            <p>Wählen Sie einen Test, zu dem die Frage hinzugefügt werden soll:</p>
            <select id="add-to-test-select" class="form-control">
              <!-- Test-Optionen werden dynamisch eingefügt -->
            </select>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary modal-cancel">Abbrechen</button>
            <button id="add-to-test-confirm" class="btn btn-primary">Hinzufügen</button>
          </div>
        </div>
      </div>
    `;
    
    // Event-Listener registrieren
    registerPoolUIEvents();
    
    // Daten laden und anzeigen
    refreshPoolView();
  }
  
  /**
   * Registriert Event-Listener für die Fragenpool-UI
   */
  function registerPoolUIEvents() {
    const container = document.querySelector(selectors.poolContainer);
    if (!container) return;
    
    // Such-Input
    const searchInput = container.querySelector(selectors.searchInput);
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        uiState.currentFilter.text = searchInput.value;
        applyFiltersAndSort();
      });
    }
    
    // Typ-Filter
    const typeFilter = container.querySelector(selectors.typeFilter);
    if (typeFilter) {
      typeFilter.addEventListener('change', () => {
        uiState.currentFilter.type = typeFilter.value;
        applyFiltersAndSort();
      });
    }
    
    // Tag-Filter
    const tagFilter = container.querySelector(selectors.tagFilter);
    if (tagFilter) {
      tagFilter.addEventListener('change', () => {
        const selectedOptions = Array.from(tagFilter.selectedOptions);
        uiState.currentFilter.tags = selectedOptions.map(option => option.value);
        applyFiltersAndSort();
      });
    }
    
    // Sortierung
    const sortSelect = container.querySelector(selectors.sortSelect);
    if (sortSelect) {
      sortSelect.addEventListener('change', () => {
        const [field, direction] = sortSelect.value.split(':');
        uiState.currentSort.field = field;
        uiState.currentSort.direction = direction;
        applyFiltersAndSort();
      });
    }
    
    // Filter zurücksetzen
    const resetButton = container.querySelector('#pool-filter-reset');
    if (resetButton) {
      resetButton.addEventListener('click', resetFilters);
    }
    
    // Aktualisieren-Button
    const refreshButton = container.querySelector('#pool-refresh-button');
    if (refreshButton) {
      refreshButton.addEventListener('click', refreshPoolView);
    }
    
    // Modaler Dialog "Zum Test hinzufügen" - Schließen
    const modalCloseButtons = container.querySelectorAll('#add-to-test-modal .close-button, #add-to-test-modal .modal-cancel');
    modalCloseButtons.forEach(button => {
      button.addEventListener('click', () => {
        const modal = document.querySelector(selectors.addToTestModal);
        if (modal) modal.style.display = 'none';
      });
    });
    
    // Modaler Dialog "Zum Test hinzufügen" - Bestätigen
    const addToTestButton = container.querySelector(selectors.addToTestButton);
    if (addToTestButton) {
      addToTestButton.addEventListener('click', () => {
        const testSelect = document.querySelector(selectors.addToTestSelect);
        if (testSelect && uiState.selectedEntry) {
          const testId = testSelect.value;
          qpModule.addPoolQuestionToTest(uiState.selectedEntry, testId);
          
          // Modal schließen
          const modal = document.querySelector(selectors.addToTestModal);
          if (modal) modal.style.display = 'none';
        }
      });
    }
  }
  
  /**
   * Aktualisiert die Fragenpool-Ansicht
   */
  function refreshPoolView() {
    // Tags laden und Dropdown aktualisieren
    const allTags = qpModule.getAllTags();
    updateTagFilterOptions(allTags);
    
    // Alle Einträge laden und anzeigen
    const allEntries = qpModule.getAllPoolEntries();
    uiState.visibleEntries = allEntries;
    
    // Anzahl der Einträge anzeigen
    updateEntriesCount();
    
    // Filter und Sortierung anwenden
    applyFiltersAndSort();
  }
  
  /**
   * Aktualisiert die Tag-Filter-Optionen
   * @param {string[]} tags - Array mit allen verfügbaren Tags
   */
  function updateTagFilterOptions(tags) {
    const tagFilter = document.querySelector(selectors.tagFilter);
    if (!tagFilter) return;
    
    // Aktuelle Auswahl speichern
    const selectedTags = Array.from(tagFilter.selectedOptions).map(option => option.value);
    
    // Optionen leeren und neu befüllen
    tagFilter.innerHTML = '';
    
    tags.forEach(tag => {
      const option = document.createElement('option');
      option.value = tag;
      option.textContent = tag;
      option.selected = selectedTags.includes(tag);
      tagFilter.appendChild(option);
    });
  }
  
  /**
   * Aktualisiert die Anzahl der angezeigten Einträge
   */
  function updateEntriesCount() {
    const countElement = document.querySelector(selectors.entriesCount);
    if (!countElement) return;
    
    const totalCount = qpModule.getAllPoolEntries().length;
    const visibleCount = uiState.visibleEntries.length;
    
    if (totalCount === visibleCount) {
      countElement.textContent = `${totalCount} Fragen im Pool`;
    } else {
      countElement.textContent = `${visibleCount} von ${totalCount} Fragen werden angezeigt`;
    }
  }
  
  /**
   * Setzt alle Filter zurück
   */
  function resetFilters() {
    const searchInput = document.querySelector(selectors.searchInput);
    if (searchInput) searchInput.value = '';
    
    const typeFilter = document.querySelector(selectors.typeFilter);
    if (typeFilter) typeFilter.value = '';
    
    const tagFilter = document.querySelector(selectors.tagFilter);
    if (tagFilter) {
      Array.from(tagFilter.options).forEach(option => {
        option.selected = false;
      });
    }
    
    // UI-Zustand zurücksetzen
    uiState.currentFilter = {
      text: '',
      type: '',
      tags: [],
      source: ''
    };
    
    // Filter anwenden
    applyFiltersAndSort();
  }
  
  /**
   * Wendet die aktuellen Filter und Sortierungen an
   */
  function applyFiltersAndSort() {
    // Filter anwenden
    let filteredEntries = filterEntries(qpModule.getAllPoolEntries(), uiState.currentFilter);
    
    // Sortierung anwenden
    filteredEntries = sortEntries(filteredEntries, uiState.currentSort);
    
    // Ergebnisse speichern
    uiState.visibleEntries = filteredEntries;
    
    // Anzahl der angezeigten Einträge aktualisieren
    updateEntriesCount();
    
    // Einträge rendern
    renderPoolEntries(filteredEntries);
  }
  
  /**
   * Filtert Einträge nach den angegebenen Kriterien
   * @param {Array} entries - Die zu filternden Einträge
   * @param {Object} filter - Filterobjekt mit Kriterien
   * @returns {Array} - Gefilterte Einträge
   */
  function filterEntries(entries, filter) {
    return entries.filter(entry => {
      // Nach Fragetext filtern
      if (filter.text && entry.question.text) {
        const searchText = filter.text.toLowerCase();
        const questionText = entry.question.text.toLowerCase();
        
        if (!questionText.includes(searchText)) {
          return false;
        }
      }
      
      // Nach Typ filtern
      if (filter.type && entry.question.type !== filter.type) {
        return false;
      }
      
      // Nach Tags filtern
      if (filter.tags && filter.tags.length > 0) {
        // Prüfen, ob mindestens ein Tag übereinstimmt
        const hasMatchingTag = filter.tags.some(tag => 
          entry.tags.includes(tag)
        );
        
        if (!hasMatchingTag) {
          return false;
        }
      }
      
      // Nach Quelle filtern
      if (filter.source && entry.source) {
        const searchSource = filter.source.toLowerCase();
        const entrySource = entry.source.toLowerCase();
        
        if (!entrySource.includes(searchSource)) {
          return false;
        }
      }
      
      // Alle Kriterien erfüllt
      return true;
    });
  }
  
  /**
   * Sortiert Einträge nach den angegebenen Kriterien
   * @param {Array} entries - Die zu sortierenden Einträge
   * @param {Object} sort - Sortierobjekt mit field und direction
   * @returns {Array} - Sortierte Einträge
   */
  function sortEntries(entries, sort) {
    const { field, direction } = sort;
    
    return [...entries].sort((a, b) => {
      let valueA, valueB;
      
      // Je nach Feld unterschiedlich vergleichen
      switch (field) {
        case 'createdAt':
        case 'updatedAt':
          valueA = new Date(a[field]).getTime();
          valueB = new Date(b[field]).getTime();
          break;
        case 'useCount':
          valueA = a[field] || 0;
          valueB = b[field] || 0;
          break;
        default:
          valueA = a[field] || '';
          valueB = b[field] || '';
          if (typeof valueA === 'string') valueA = valueA.toLowerCase();
          if (typeof valueB === 'string') valueB = valueB.toLowerCase();
      }
      
      // Sortierrichtung berücksichtigen
      return direction === 'asc' ? valueA - valueB : valueB - valueA;
    });
  }
  
  // Modul erweitern
  qpModule.initPoolUI = initPoolUI;
  qpModule.refreshPoolView = refreshPoolView;
  qpModule.applyFiltersAndSort = applyFiltersAndSort;
  qpModule.resetFilters = resetFilters;
  
  // Wenn das Modul als Teil einer größeren Anwendung geladen wird,
  // kann hier die UI automatisch initialisiert werden
  if (document.readyState === 'complete') {
    setTimeout(() => {
      if (document.getElementById('question-pool-container')) {
        initPoolUI();
      }
    }, 0);
  } else {
    window.addEventListener('DOMContentLoaded', () => {
      if (document.getElementById('question-pool-container')) {
        initPoolUI();
      }
    });
  }
})();
/**
 * JS-Block 4.7.2: Fragenpool-Verwaltung UI - Eintragsdarstellung und Interaktion
 * 
 * Dieses Modul erweitert den UI-Teil des Fragenpools um die Darstellung
 * einzelner Einträge und deren Interaktionslogik.
 */

// Fragenpool-UI Erweiterung - Teil 2
(function() {
  // Referenz auf das existierende QuestionPool-Modul
  const qpModule = window.QuestionPool;
  
  if (!qpModule) {
    console.error('QuestionPool-Modul nicht gefunden. Bitte zuerst JS-Block 4.7.1 laden.');
    return;
  }
  
  /**
   * Rendert die Fragenpool-Einträge in die Liste
   * @param {Array} entries - Die anzuzeigenden Einträge
   */
  function renderPoolEntries(entries) {
    const listContainer = document.querySelector('#question-pool-list');
    if (!listContainer) return;
    
    // Liste leeren
    listContainer.innerHTML = '';
    
    // Meldung anzeigen, wenn keine Einträge vorhanden sind
    if (entries.length === 0) {
      listContainer.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">📚</div>
          <h3>Keine Fragen gefunden</h3>
          <p>Fügen Sie Fragen zum Fragenpool hinzu oder ändern Sie Ihre Filter.</p>
        </div>
      `;
      return;
    }
    
    // Einträge rendern
    entries.forEach(entry => {
      const entryElement = document.createElement('div');
      entryElement.className = 'pool-entry';
      entryElement.dataset.entryId = entry.id;
      
      // Fragetyp ermitteln und als CSS-Klasse hinzufügen
      const questionType = entry.question.type || 'unknown';
      entryElement.classList.add(`type-${questionType}`);
      
      // Anzeigename für den Fragetyp
      const typeDisplayNames = {
        multiple_choice: 'Multiple Choice',
        single_choice: 'Single Choice',
        true_false: 'Wahr/Falsch',
        text: 'Freitext',
        unknown: 'Unbekannt'
      };
      
      const typeDisplayName = typeDisplayNames[questionType] || 'Unbekannt';
      
      // HTML-Inhalt erstellen
      entryElement.innerHTML = `
        <div class="entry-header">
          <div class="entry-type" title="Fragetyp: ${typeDisplayName}">
            <span class="type-indicator ${questionType}"></span>
            ${typeDisplayName}
          </div>
          <div class="entry-stats">
            <span class="use-count" title="Verwendungshäufigkeit">
              <i class="icon-use"></i> ${entry.useCount || 0}x verwendet
            </span>
          </div>
        </div>
        
        <div class="entry-content">
          <div class="entry-question">${formatQuestionText(entry.question.text)}</div>
          
          <div class="entry-details">
            <div class="entry-source" title="Quelle">
              <i class="icon-source"></i> Quelle: ${entry.source || 'Keine Angabe'}
            </div>
            
            <div class="entry-date" title="Zuletzt aktualisiert am ${formatDate(entry.updatedAt)}">
              <i class="icon-date"></i> ${getRelativeTimeString(entry.updatedAt)}
            </div>
          </div>
          
          <div class="entry-tags">
            ${renderTags(entry.tags)}
          </div>
        </div>
        
        <div class="entry-actions">
          <button class="btn btn-icon view-question" title="Frage anzeigen">
            <i class="icon-view"></i>
          </button>
          <button class="btn btn-icon edit-question" title="Frage bearbeiten">
            <i class="icon-edit"></i>
          </button>
          <button class="btn btn-icon add-to-test" title="Zum Test hinzufügen">
            <i class="icon-add"></i>
          </button>
          <button class="btn btn-icon delete-question" title="Frage löschen">
            <i class="icon-delete"></i>
          </button>
        </div>
      `;
      
      // Event-Listener für die Aktionsbuttons hinzufügen
      addEntryEventListeners(entryElement, entry);
      
      // Element zur Liste hinzufügen
      listContainer.appendChild(entryElement);
    });
  }
  
  /**
   * Fügt Event-Listener zu einem Eintragselement hinzu
   * @param {HTMLElement} entryElement - Das DOM-Element des Eintrags
   * @param {Object} entry - Die Daten des Eintrags
   */
  function addEntryEventListeners(entryElement, entry) {
    // Frage anzeigen
    const viewButton = entryElement.querySelector('.view-question');
    if (viewButton) {
      viewButton.addEventListener('click', () => {
        showQuestionDetailModal(entry);
      });
    }
    
    // Frage bearbeiten
    const editButton = entryElement.querySelector('.edit-question');
    if (editButton) {
      editButton.addEventListener('click', () => {
        openQuestionEditor(entry);
      });
    }
    
    // Zum Test hinzufügen
    const addToTestButton = entryElement.querySelector('.add-to-test');
    if (addToTestButton) {
      addToTestButton.addEventListener('click', () => {
        openAddToTestModal(entry.id);
      });
    }
    
    // Frage löschen
    const deleteButton = entryElement.querySelector('.delete-question');
    if (deleteButton) {
      deleteButton.addEventListener('click', () => {
        confirmDeleteQuestion(entry);
      });
    }
    
    // Klick auf den gesamten Eintrag (für Details)
    entryElement.addEventListener('click', (event) => {
      // Nur reagieren, wenn nicht auf einen Button geklickt wurde
      if (!event.target.closest('.btn')) {
        showQuestionDetailModal(entry);
      }
    });
  }
  
  /**
   * Formatiert den Fragetext für die Anzeige
   * @param {string} text - Der zu formatierende Text
   * @returns {string} - Formatierter HTML-Text
   */
  function formatQuestionText(text) {
    if (!text) return 'Keine Fragestellung';
    
    // Text kürzen, wenn er zu lang ist
    let formattedText = text;
    if (formattedText.length > 150) {
      formattedText = formattedText.substring(0, 147) + '...';
    }
    
    // Einfache HTML-Formatierung (Text-Escaping)
    formattedText = formattedText
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
    
    return formattedText;
  }
  
  /**
   * Rendert Tags als HTML
   * @param {string[]} tags - Array mit Tag-Strings
   * @returns {string} - HTML für die Tag-Darstellung
   */
  function renderTags(tags) {
    if (!tags || !Array.isArray(tags) || tags.length === 0) {
      return '<span class="no-tags">Keine Tags</span>';
    }
    
    return tags.map(tag => `
      <span class="tag" data-tag="${tag}">
        ${tag}
      </span>
    `).join('');
  }
  
  /**
   * Formatiert ein Datum als lesbaren String
   * @param {string|Date} dateInput - Das zu formatierende Datum
   * @returns {string} - Formatierter Datums-String
   */
  function formatDate(dateInput) {
    if (!dateInput) return 'Unbekannt';
    
    try {
      const date = new Date(dateInput);
      
      return date.toLocaleDateString('de-DE', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (error) {
      console.error('Fehler beim Formatieren des Datums:', error);
      return 'Ungültiges Datum';
    }
  }
  
  /**
   * Gibt einen relativen Zeitstring zurück (z.B. "vor 3 Tagen")
   * @param {string|Date} dateInput - Das zu formatierende Datum
   * @returns {string} - Relativer Zeitstring
   */
  function getRelativeTimeString(dateInput) {
    if (!dateInput) return 'Unbekannt';
    
    try {
      const date = new Date(dateInput);
      const now = new Date();
      const diffTime = now - date;
      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) {
        const diffHours = Math.floor(diffTime / (1000 * 60 * 60));
        if (diffHours === 0) {
          const diffMinutes = Math.floor(diffTime / (1000 * 60));
          if (diffMinutes === 0) {
            return 'Gerade eben';
          }
          return `Vor ${diffMinutes} Minute${diffMinutes !== 1 ? 'n' : ''}`;
        }
        return `Vor ${diffHours} Stunde${diffHours !== 1 ? 'n' : ''}`;
      } else if (diffDays < 30) {
        return `Vor ${diffDays} Tag${diffDays !== 1 ? 'en' : ''}`;
      } else {
        return formatDate(date);
      }
    } catch (error) {
      console.error('Fehler beim Berechnen der relativen Zeit:', error);
      return 'Unbekannt';
    }
  }
  
  /**
   * Öffnet einen modalen Dialog mit den Details einer Frage
   * @param {Object} entry - Der anzuzeigende Fragenpool-Eintrag
   */
  function showQuestionDetailModal(entry) {
    // Vorhandenen Modal-Dialog schließen
    const existingModal = document.getElementById('question-detail-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Fragetyp ermitteln
    const questionType = entry.question.type || 'unknown';
    const typeDisplayNames = {
      multiple_choice: 'Multiple Choice',
      single_choice: 'Single Choice',
      true_false: 'Wahr/Falsch',
      text: 'Freitext',
      unknown: 'Unbekannt'
    };
    
    const typeDisplayName = typeDisplayNames[questionType] || 'Unbekannt';
    
    // Modal-Dialog erstellen
    const modal = document.createElement('div');
    modal.id = 'question-detail-modal';
    modal.className = 'modal';
    
    // Antwortoptionen rendern (abhängig vom Fragetyp)
    let optionsHtml = '';
    if (questionType === 'multiple_choice' || questionType === 'single_choice') {
      optionsHtml = '<div class="question-options"><h4>Antwortoptionen:</h4><ul>';
      
      if (entry.question.options && Array.isArray(entry.question.options)) {
        entry.question.options.forEach(option => {
          const isCorrect = option.isCorrect || false;
          optionsHtml += `
            <li class="${isCorrect ? 'correct-option' : 'incorrect-option'}">
              <span class="option-indicator ${isCorrect ? 'correct' : 'incorrect'}"></span>
              ${option.text || 'Keine Antworttext'}
            </li>
          `;
        });
      }
      
      optionsHtml += '</ul></div>';
    } else if (questionType === 'true_false') {
      const correctAnswer = entry.question.correctAnswer;
      optionsHtml = `
        <div class="question-options">
          <h4>Richtige Antwort:</h4>
          <div class="true-false-answer">
            ${correctAnswer === true ? 'Wahr' : (correctAnswer === false ? 'Falsch' : 'Nicht definiert')}
          </div>
        </div>
      `;
    }
    
    // Modal-Inhalt erstellen
    modal.innerHTML = `
      <div class="modal-content question-detail-modal">
        <div class="modal-header">
          <div class="question-type-header">
            <span class="type-indicator ${questionType}"></span>
            <h3>${typeDisplayName}-Frage</h3>
          </div>
          <button class="close-button">&times;</button>
        </div>
        
        <div class="modal-body">
          <div class="question-text">
            ${entry.question.text || 'Keine Fragestellung'}
          </div>
          
          ${optionsHtml}
          
          <div class="question-metadata">
            <div class="metadata-group">
              <label>Quelle:</label>
              <div>${entry.source || 'Keine Angabe'}</div>
            </div>
            
            <div class="metadata-group">
              <label>Erstellt:</label>
              <div>${formatDate(entry.createdAt)}</div>
            </div>
            
            <div class="metadata-group">
              <label>Letzte Aktualisierung:</label>
              <div>${formatDate(entry.updatedAt)}</div>
            </div>
            
            <div class="metadata-group">
              <label>Verwendungshäufigkeit:</label>
              <div>${entry.useCount || 0}x verwendet</div>
            </div>
            
            <div class="metadata-group">
              <label>Tags:</label>
              <div class="detail-tags">
                ${renderTags(entry.tags)}
              </div>
            </div>
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn btn-secondary" id="detail-close-button">Schließen</button>
          <button class="btn btn-primary" id="detail-edit-button">Bearbeiten</button>
          <button class="btn btn-success" id="detail-add-to-test-button">Zum Test hinzufügen</button>
        </div>
      </div>
    `;
    
    // Modal zum DOM hinzufügen
    document.body.appendChild(modal);
    
    // Event-Listener für die Buttons hinzufügen
    const closeButtons = modal.querySelectorAll('.close-button, #detail-close-button');
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        modal.remove();
      });
    });
    
    const editButton = modal.querySelector('#detail-edit-button');
    if (editButton) {
      editButton.addEventListener('click', () => {
        modal.remove();
        openQuestionEditor(entry);
      });
    }
    
    const addToTestButton = modal.querySelector('#detail-add-to-test-button');
    if (addToTestButton) {
      addToTestButton.addEventListener('click', () => {
        modal.remove();
        openAddToTestModal(entry.id);
      });
    }
    
    // Modal anzeigen (mit Animation)
    setTimeout(() => {
      modal.style.display = 'block';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
    }, 0);
  }
  
  /**
   * Öffnet einen modalen Dialog zum Hinzufügen einer Frage zu einem Test
   * @param {string} entryId - Die ID des Fragenpool-Eintrags
   */
  function openAddToTestModal(entryId) {
    // Eintrag in UI-Zustand speichern
    window.QuestionPool.uiState = window.QuestionPool.uiState || {};
    window.QuestionPool.uiState.selectedEntry = entryId;
    
    // Test-Liste laden
    let tests = [];
    if (typeof TestBasicData !== 'undefined' && TestBasicData.getAllTests) {
      tests = TestBasicData.getAllTests();
    }
    
    // Select-Element aktualisieren
    const testSelect = document.querySelector('#add-to-test-select');
    if (testSelect) {
      testSelect.innerHTML = '';
      
      if (tests.length === 0) {
        const option = document.createElement('option');
        option.textContent = 'Keine Tests verfügbar';
        option.disabled = true;
        testSelect.appendChild(option);
      } else {
        tests.forEach(test => {
          const option = document.createElement('option');
          option.value = test.id;
          option.textContent = test.title || `Test ${test.id}`;
          testSelect.appendChild(option);
        });
      }
    }
    
    // Modal anzeigen
    const modal = document.querySelector('#add-to-test-modal');
    if (modal) {
      modal.style.display = 'block';
    }
  }
  
  /**
   * Öffnet den Frageneditor für einen Eintrag
   * @param {Object} entry - Der zu bearbeitende Fragenpool-Eintrag
   */
  function openQuestionEditor(entry) {
    // Wenn ein Frageneditor-Modul existiert, dieses aufrufen
    if (typeof QuestionEditor !== 'undefined' && QuestionEditor.openEditor) {
      QuestionEditor.openEditor(entry.question, entry.id, 'pool');
      return;
    }
    
    // Ansonsten einfachen Editor öffnen
    showSimpleQuestionEditor(entry);
  }
  
  /**
   * Zeigt einen einfachen Editor für Fragenpool-Einträge an
   * @param {Object} entry - Der zu bearbeitende Fragenpool-Eintrag
   */
  function showSimpleQuestionEditor(entry) {
    // Vorhandenen Modal-Dialog schließen
    const existingModal = document.getElementById('question-editor-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Modal-Dialog erstellen
    const modal = document.createElement('div');
    modal.id = 'question-editor-modal';
    modal.className = 'modal';
    
    // Modal-Inhalt basierend auf Fragetyp erstellen
    const questionType = entry.question.type || 'unknown';
    let optionsHtml = '';
    
    // Je nach Fragetyp unterschiedliche Bearbeitungsfelder anzeigen
    if (questionType === 'multiple_choice' || questionType === 'single_choice') {
      optionsHtml = `
        <div class="form-group">
          <label>Antwortoptionen:</label>
          <div id="options-container">
            ${(entry.question.options || []).map((option, index) => `
              <div class="option-row" data-index="${index}">
                <input type="checkbox" class="option-correct" ${option.isCorrect ? 'checked' : ''}>
                <input type="text" class="form-control option-text" value="${option.text || ''}">
                <button type="button" class="btn btn-icon remove-option" title="Option entfernen">
                  <i class="icon-delete"></i>
                </button>
              </div>
            `).join('')}
          </div>
          <button type="button" class="btn btn-outline" id="add-option-button">Option hinzufügen</button>
          ${questionType === 'single_choice' ? 
            '<p class="form-hint">Bei Single-Choice-Fragen sollte nur eine Option als korrekt markiert werden.</p>' : ''}
        </div>
      `;
    } else if (questionType === 'true_false') {
      const correctAnswer = entry.question.correctAnswer;
      optionsHtml = `
        <div class="form-group">
          <label>Richtige Antwort:</label>
          <div class="true-false-selection">
            <label>
              <input type="radio" name="correct-answer" value="true" ${correctAnswer === true ? 'checked' : ''}>
              Wahr
            </label>
            <label>
              <input type="radio" name="correct-answer" value="false" ${correctAnswer === false ? 'checked' : ''}>
              Falsch
            </label>
          </div>
        </div>
      `;
    }
    
    // Modal-Inhalt erstellen
    modal.innerHTML = `
      <div class="modal-content question-editor-modal">
        <div class="modal-header">
          <h3>Frage bearbeiten</h3>
          <button class="close-button">&times;</button>
        </div>
        
        <div class="modal-body">
          <form id="question-editor-form">
            <div class="form-group">
              <label for="question-text">Fragestellung:</label>
              <textarea id="question-text" class="form-control" rows="4" required>${entry.question.text || ''}</textarea>
            </div>
            
            <div class="form-group">
              <label for="question-type">Fragetyp:</label>
              <select id="question-type" class="form-control" disabled>
                <option value="multiple_choice" ${questionType === 'multiple_choice' ? 'selected' : ''}>Multiple Choice</option>
                <option value="single_choice" ${questionType === 'single_choice' ? 'selected' : ''}>Single Choice</option>
                <option value="true_false" ${questionType === 'true_false' ? 'selected' : ''}>Wahr/Falsch</option>
                <option value="text" ${questionType === 'text' ? 'selected' : ''}>Freitext</option>
              </select>
              <p class="form-hint">Der Fragetyp kann nicht geändert werden.</p>
            </div>
            
            ${optionsHtml}
            
            <div class="form-group">
              <label for="question-tags">Tags (durch Komma getrennt):</label>
              <input type="text" id="question-tags" class="form-control" value="${(entry.tags || []).join(', ')}">
            </div>
            
            <div class="form-group">
              <label for="question-source">Quelle:</label>
              <input type="text" id="question-source" class="form-control" value="${entry.source || ''}">
            </div>
          </form>
        </div>
        
        <div class="modal-footer">
          <button class="btn btn-secondary" id="editor-cancel-button">Abbrechen</button>
          <button class="btn btn-primary" id="editor-save-button">Speichern</button>
        </div>
      </div>
    `;
    
    // Modal zum DOM hinzufügen
    document.body.appendChild(modal);
    
    // Event-Listener für die Buttons hinzufügen
    const closeButtons = modal.querySelectorAll('.close-button, #editor-cancel-button');
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        modal.remove();
      });
    });
    
    // Option hinzufügen (für Multiple/Single Choice)
    const addOptionButton = modal.querySelector('#add-option-button');
    if (addOptionButton) {
      addOptionButton.addEventListener('click', () => {
        const optionsContainer = modal.querySelector('#options-container');
        if (optionsContainer) {
          const optionCount = optionsContainer.querySelectorAll('.option-row').length;
          
          const newOption = document.createElement('div');
          newOption.className = 'option-row';
          newOption.dataset.index = optionCount;
          
          newOption.innerHTML = `
            <input type="checkbox" class="option-correct">
            <input type="text" class="form-control option-text" value="">
            <button type="button" class="btn btn-icon remove-option" title="Option entfernen">
              <i class="icon-delete"></i>
            </button>
          `;
          
          optionsContainer.appendChild(newOption);
          
          // Event-Listener für "Option entfernen" hinzufügen
          const removeButton = newOption.querySelector('.remove-option');
          if (removeButton) {
            removeButton.addEventListener('click', (event) => {
              event.preventDefault();
              newOption.remove();
            });
          }
        }
      });
    }
    
    // Event-Listener für vorhandene "Option entfernen" Buttons
    const removeOptionButtons = modal.querySelectorAll('.remove-option');
    removeOptionButtons.forEach(button => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        const optionRow = button.closest('.option-row');
        if (optionRow) {
          optionRow.remove();
        }
      });
    });
    
    // Speichern-Button
    const saveButton = modal.querySelector('#editor-save-button');
    if (saveButton) {
      saveButton.addEventListener('click', () => {
        // Formulardaten sammeln
        const formData = {
          question: {
            ...entry.question,
            text: modal.querySelector('#question-text').value
          },
          tags: modal.querySelector('#question-tags').value.split(',')
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0),
          source: modal.querySelector('#question-source').value
        };
        
        // Optionen je nach Fragetyp sammeln
        if (questionType === 'multiple_choice' || questionType === 'single_choice') {
          const optionRows = modal.querySelectorAll('.option-row');
          formData.question.options = Array.from(optionRows).map(row => ({
            text: row.querySelector('.option-text').value,
            isCorrect: row.querySelector('.option-correct').checked
          }));
        } else if (questionType === 'true_false') {
          const trueRadio = modal.querySelector('input[name="correct-answer"][value="true"]');
          const falseRadio = modal.querySelector('input[name="correct-answer"][value="false"]');
          
          formData.question.correctAnswer = trueRadio.checked;
        }
        
        // Eintrag aktualisieren
        const success = qpModule.updatePoolEntry(entry.id, formData);
        
        if (success) {
          modal.remove();
          qpModule.refreshPoolView();
        }
      });
    }
    
    // Modal anzeigen (mit Animation)
    setTimeout(() => {
      modal.style.display = 'block';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
    }, 0);
  }
  
  /**
   * Zeigt einen Bestätigungsdialog zum Löschen einer Frage
   * @param {Object} entry - Der zu löschende Fragenpool-Eintrag
   */
  function confirmDeleteQuestion(entry) {
    if (confirm(`Möchten Sie die Frage "${entry.question.text.substring(0, 50)}${entry.question.text.length > 50 ? '...' : ''}" wirklich aus dem Fragenpool löschen?`)) {
      const success = qpModule.deletePoolEntry(entry.id);
      
      if (success) {
        qpModule.refreshPoolView();
      }
    }
  }
  
  // Modul erweitern
  qpModule.renderPoolEntries = renderPoolEntries;
  qpModule.showQuestionDetailModal = showQuestionDetailModal;
  qpModule.openQuestionEditor = openQuestionEditor;
  qpModule.openAddToTestModal = openAddToTestModal;
  
  // UI-Zustand initialisieren
  qpModule.uiState = qpModule.uiState || {};
})();
/**
 * JS-Block 4.7.2: Fragenpool-Verwaltung UI - Erweiterte Funktionen
 * 
 * Dieser Teil erweitert den Fragenpool um zusätzliche Features wie:
 * - Dashboard-Widgets für den Fragenpool
 * - Import-/Export-Funktionen
 * - Fragenpool-Statistiken
 */

// Fragenpool-UI Erweiterung - Teil 3
(function() {
  // Referenz auf das existierende QuestionPool-Modul
  const qpModule = window.QuestionPool;
  
  if (!qpModule) {
    console.error('QuestionPool-Modul nicht gefunden. Bitte zuerst JS-Block 4.7.1 laden.');
    return;
  }
  
  /**
   * Rendert ein Dashboard-Widget für den Fragenpool
   * @param {string} containerId - ID des Container-Elements
   */
  function renderPoolWidget(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Statistiken berechnen
    const allEntries = qpModule.getAllPoolEntries();
    const countByType = qpModule.getQuestionCountByType();
    const tags = qpModule.getAllTags();
    const totalEntries = allEntries.length;
    
    // Datum des neuesten Eintrags finden
    let newestEntry = null;
    if (totalEntries > 0) {
      newestEntry = allEntries.reduce((newest, current) => {
        const currentDate = new Date(current.updatedAt || current.createdAt);
        const newestDate = new Date(newest.updatedAt || newest.createdAt);
        return currentDate > newestDate ? current : newest;
      }, allEntries[0]);
    }
    
    // Widget-HTML erstellen
    container.innerHTML = `
      <div class="dashboard-widget question-pool-widget">
        <div class="widget-header">
          <h3>Fragenpool</h3>
          <div class="widget-actions">
            <button class="btn btn-icon" id="refresh-pool-widget" title="Aktualisieren">
              <i class="icon-refresh"></i>
            </button>
          </div>
        </div>
        
        <div class="widget-content">
          <div class="widget-stats">
            <div class="stat-item">
              <div class="stat-value">${totalEntries}</div>
              <div class="stat-label">Fragen gesamt</div>
            </div>
            
            <div class="stat-item">
              <div class="stat-value">${countByType.multiple_choice}</div>
              <div class="stat-label">Multiple Choice</div>
            </div>
            
            <div class="stat-item">
              <div class="stat-value">${countByType.single_choice}</div>
              <div class="stat-label">Single Choice</div>
            </div>
            
            <div class="stat-item">
              <div class="stat-value">${countByType.true_false}</div>
              <div class="stat-label">Wahr/Falsch</div>
            </div>
            
            <div class="stat-item">
              <div class="stat-value">${countByType.text}</div>
              <div class="stat-label">Freitext</div>
            </div>
          </div>
          
          <div class="widget-section">
            <h4>Häufig verwendete Tags</h4>
            <div class="widget-tags">
              ${tags.slice(0, 5).map(tag => `<span class="tag">${tag}</span>`).join('') || 
                '<span class="no-tags">Keine Tags vorhanden</span>'}
            </div>
          </div>
          
          ${newestEntry ? `
            <div class="widget-section">
              <h4>Neueste Frage</h4>
              <div class="newest-question">
                <div class="question-preview">${newestEntry.question.text.substring(0, 80)}${newestEntry.question.text.length > 80 ? '...' : ''}</div>
                <div class="question-meta">
                  <span class="question-type">${getTypeDisplayName(newestEntry.question.type)}</span>
                  <span class="question-date">${formatDateRelative(newestEntry.updatedAt || newestEntry.createdAt)}</span>
                </div>
              </div>
            </div>
          ` : ''}
        </div>
        
        <div class="widget-footer">
          <a href="#" id="open-pool-view" class="btn btn-text">Zum Fragenpool</a>
          <a href="#" id="import-questions" class="btn btn-text">Fragen importieren</a>
        </div>
      </div>
    `;
    
    // Event-Listener hinzufügen
    const refreshButton = container.querySelector('#refresh-pool-widget');
    if (refreshButton) {
      refreshButton.addEventListener('click', () => {
        renderPoolWidget(containerId);
      });
    }
    
    const openPoolButton = container.querySelector('#open-pool-view');
    if (openPoolButton) {
      openPoolButton.addEventListener('click', (event) => {
        event.preventDefault();
        showPoolView();
      });
    }
    
    const importButton = container.querySelector('#import-questions');
    if (importButton) {
      importButton.addEventListener('click', (event) => {
        event.preventDefault();
        showImportQuestionsDialog();
      });
    }
  }
  
  /**
   * Gibt den anzuzeigenden Namen für einen Fragetyp zurück
   * @param {string} type - Der Fragetyp
   * @returns {string} - Anzeigename
   */
  function getTypeDisplayName(type) {
    const typeDisplayNames = {
      multiple_choice: 'Multiple Choice',
      single_choice: 'Single Choice',
      true_false: 'Wahr/Falsch',
      text: 'Freitext'
    };
    
    return typeDisplayNames[type] || 'Unbekannt';
  }
  
  /**
   * Formatiert ein Datum als relativen Zeitstring
   * @param {string|Date} dateInput - Das zu formatierende Datum
   * @returns {string} - Formatierter String
   */
  function formatDateRelative(dateInput) {
    if (!dateInput) return 'Unbekannt';
    
    try {
      const date = new Date(dateInput);
      const now = new Date();
      const diffTime = now - date;
      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) {
        return 'Heute';
      } else if (diffDays === 1) {
        return 'Gestern';
      } else if (diffDays < 7) {
        return `Vor ${diffDays} Tagen`;
      } else if (diffDays < 30) {
        const diffWeeks = Math.floor(diffDays / 7);
        return `Vor ${diffWeeks} Woche${diffWeeks !== 1 ? 'n' : ''}`;
      } else {
        const diffMonths = Math.floor(diffDays / 30);
        return `Vor ${diffMonths} Monat${diffMonths !== 1 ? 'en' : ''}`;
      }
    } catch (error) {
      console.error('Fehler beim Formatieren des relativen Datums:', error);
      return 'Unbekannt';
    }
  }
  
  /**
   * Öffnet die Fragenpool-Ansicht
   */
  function showPoolView() {
    // Navigations-Handler aufrufen, falls verfügbar
    if (typeof Navigation !== 'undefined' && Navigation.navigateTo) {
      Navigation.navigateTo('question-pool');
      return;
    }
    
    // Wenn kein Navigations-Modul verfügbar ist, einfache Umleitung
    const mainContent = document.querySelector('#main-content, #app-content, main');
    if (mainContent) {
      // Bestehenden Inhalt löschen
      mainContent.innerHTML = '';
      
      // Fragenpool-Container erstellen
      const poolContainer = document.createElement('div');
      poolContainer.id = 'question-pool-container';
      mainContent.appendChild(poolContainer);
      
      // Fragenpool-UI initialisieren
      qpModule.initPoolUI('question-pool-container');
    }
  }
  
  /**
   * Zeigt einen Dialog zum Importieren von Fragen aus Tests
   */
  function showImportQuestionsDialog() {
    // Vorhandenen Modal-Dialog schließen
    const existingModal = document.getElementById('import-questions-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Tests laden
    let tests = [];
    if (typeof TestBasicData !== 'undefined' && TestBasicData.getAllTests) {
      tests = TestBasicData.getAllTests();
    }
    
    // Modal-Dialog erstellen
    const modal = document.createElement('div');
    modal.id = 'import-questions-modal';
    modal.className = 'modal';
    
    // Test-Optionen erstellen
    let testOptionsHtml = '';
    if (tests.length === 0) {
      testOptionsHtml = '<option disabled>Keine Tests verfügbar</option>';
    } else {
      testOptionsHtml = tests.map(test => `
        <option value="${test.id}">
          ${test.title || `Test ${test.id}`} (${test.questionCount || 0} Fragen)
        </option>
      `).join('');
    }
    
    // Modal-Inhalt erstellen
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h3>Fragen aus Test importieren</h3>
          <button class="close-button">&times;</button>
        </div>
        
        <div class="modal-body">
          <p>
            Wählen Sie einen Test aus, dessen Fragen in den Fragenpool importiert werden sollen.
            Alle Fragen des Tests werden in den Fragenpool aufgenommen.
          </p>
          
          <div class="form-group">
            <label for="import-test-select">Test auswählen:</label>
            <select id="import-test-select" class="form-control">
              ${testOptionsHtml}
            </select>
          </div>
        </div>
        
        <div class="modal-footer">
          <button class="btn btn-secondary" id="import-cancel-button">Abbrechen</button>
          <button class="btn btn-primary" id="import-confirm-button" ${tests.length === 0 ? 'disabled' : ''}>
            Fragen importieren
          </button>
        </div>
      </div>
    `;
    
    // Modal zum DOM hinzufügen
    document.body.appendChild(modal);
    
    // Event-Listener hinzufügen
    const closeButtons = modal.querySelectorAll('.close-button, #import-cancel-button');
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        modal.remove();
      });
    });
    
    const importButton = modal.querySelector('#import-confirm-button');
    if (importButton) {
      importButton.addEventListener('click', () => {
        const testSelect = modal.querySelector('#import-test-select');
        
        if (testSelect && testSelect.value) {
          const testId = testSelect.value;
          const importCount = qpModule.importQuestionsFromTest(testId);
          
          // Dialog schließen
          modal.remove();
          
          // Fragenpool-Ansicht aktualisieren, falls vorhanden
          if (qpModule.refreshPoolView) {
            qpModule.refreshPoolView();
          }
        }
      });
    }
    
    // Modal anzeigen (mit Animation)
    setTimeout(() => {
      modal.style.display = 'block';
      setTimeout(() => {
        modal.classList.add('show');
      }, 10);
    }, 0);
  }
  
  /**
   * Zeigt eine statistische Übersicht für den Fragenpool
   * @param {string} containerId - ID des Container-Elements
   */
  function renderPoolStats(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Statistiken sammeln
    const allEntries = qpModule.getAllPoolEntries();
    const countByType = qpModule.getQuestionCountByType();
    const totalCount = allEntries.length;
    
    // Verwendet/Unverwendet zählen
    const usedCount = allEntries.filter(entry => entry.useCount > 0).length;
    const unusedCount = totalCount - usedCount;
    
    // Durchschnittliche Verwendung berechnen
    const totalUseCount = allEntries.reduce((sum, entry) => sum + (entry.useCount || 0), 0);
    const avgUseCount = totalCount > 0 ? (totalUseCount / totalCount).toFixed(1) : '0.0';
    
    // Tags analysieren
    const allTags = [];
    allEntries.forEach(entry => {
      if (entry.tags && Array.isArray(entry.tags)) {
        entry.tags.forEach(tag => {
          allTags.push(tag);
        });
      }
    });
    
    // Tag-Häufigkeit zählen
    const tagCounts = {};
    allTags.forEach(tag => {
      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    });
    
    // Top-Tags ermitteln
    const topTags = Object.entries(tagCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);
    
    // Quellen analysieren
    const sources = {};
    allEntries.forEach(entry => {
      if (entry.source) {
        sources[entry.source] = (sources[entry.source] || 0) + 1;
      }
    });
    
    // Top-Quellen ermitteln
    const topSources = Object.entries(sources)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    // HTML erstellen
    container.innerHTML = `
      <div class="pool-stats-container">
        <h2>Fragenpool-Statistiken</h2>
        
        <div class="stats-section">
          <h3>Allgemeine Übersicht</h3>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value">${totalCount}</div>
              <div class="stat-label">Fragen gesamt</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-value">${usedCount}</div>
              <div class="stat-label">Verwendete Fragen</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-value">${unusedCount}</div>
              <div class="stat-label">Unverwendete Fragen</div>
            </div>
            
            <div class="stat-card">
              <div class="stat-value">${avgUseCount}</div>
              <div class="stat-label">Ø Verwendung pro Frage</div>
            </div>
          </div>
        </div>
        
        <div class="stats-section">
          <h3>Verteilung nach Fragetyp</h3>
          
          <div class="stats-grid">
            <div class="stat-card type-card multiple_choice">
              <div class="stat-value">${countByType.multiple_choice}</div>
              <div class="stat-label">Multiple Choice</div>
              <div class="stat-percentage">${totalCount > 0 ? Math.round(countByType.multiple_choice / totalCount * 100) : 0}%</div>
            </div>
            
            <div class="stat-card type-card single_choice">
              <div class="stat-value">${countByType.single_choice}</div>
              <div class="stat-label">Single Choice</div>
              <div class="stat-percentage">${totalCount > 0 ? Math.round(countByType.single_choice / totalCount * 100) : 0}%</div>
            </div>
            
            <div class="stat-card type-card true_false">
              <div class="stat-value">${countByType.true_false}</div>
              <div class="stat-label">Wahr/Falsch</div>
              <div class="stat-percentage">${totalCount > 0 ? Math.round(countByType.true_false / totalCount * 100) : 0}%</div>
            </div>
            
            <div class="stat-card type-card text">
              <div class="stat-value">${countByType.text}</div>
              <div class="stat-label">Freitext</div>
              <div class="stat-percentage">${totalCount > 0 ? Math.round(countByType.text / totalCount * 100) : 0}%</div>
            </div>
          </div>
        </div>
        
        <div class="stats-flex-container">
          <div class="stats-section tags-section">
            <h3>Häufigste Tags</h3>
            
            ${topTags.length > 0 ? `
              <ul class="tag-stats-list">
                ${topTags.map(([tag, count]) => `
                  <li>
                    <span class="tag">${tag}</span>
                    <span class="tag-count">${count}</span>
                  </li>
                `).join('')}
              </ul>
            ` : '<p class="empty-state">Keine Tags vorhanden</p>'}
          </div>
          
          <div class="stats-section sources-section">
            <h3>Häufigste Quellen</h3>
            
            ${topSources.length > 0 ? `
              <ul class="source-stats-list">
                ${topSources.map(([source, count]) => `
                  <li>
                    <span class="source-name">${source}</span>
                    <span class="source-count">${count} Frage${count !== 1 ? 'n' : ''}</span>
                  </li>
                `).join('')}
              </ul>
            ` : '<p class="empty-state">Keine Quellen angegeben</p>'}
          </div>
        </div>
        
        <div class="stats-actions">
          <button class="btn btn-primary" id="export-pool-button">Fragenpool exportieren</button>
          <button class="btn btn-secondary" id="back-to-pool-button">Zurück zum Fragenpool</button>
        </div>
      </div>
    `;
    
    // Event-Listener hinzufügen
    const exportButton = container.querySelector('#export-pool-button');
    if (exportButton) {
      exportButton.addEventListener('click', exportQuestionPool);
    }
    
    const backButton = container.querySelector('#back-to-pool-button');
    if (backButton) {
      backButton.addEventListener('click', showPoolView);
    }
  }
  
  /**
   * Exportiert den Fragenpool als JSON-Datei
   */
  function exportQuestionPool() {
    const allEntries = qpModule.getAllPoolEntries();
    
    // Datum für Dateinamen
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0]; // YYYY-MM-DD
    
    // JSON erstellen
    const exportData = {
      exportDate: today.toISOString(),
      version: '1.0',
      entries: allEntries
    };
    
    const jsonStr = JSON.stringify(exportData, null, 2);
    
    // Download-Link erstellen
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `fragenpool_export_${dateStr}.json`;
    
    // Link klicken und entfernen
    document.body.appendChild(a);
    a.click();
    
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
    
    NotificationSystem.showSuccess('Fragenpool wurde erfolgreich exportiert.');
  }
  
  /**
   * Importiert den Fragenpool aus einer JSON-Datei
   */
  function importQuestionPool() {
    // Datei-Input-Element erstellen
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const importData = JSON.parse(e.target.result);
          
          // Validieren
          if (!importData.entries || !Array.isArray(importData.entries)) {
            NotificationSystem.showError('Ungültiges Dateiformat: Keine Einträge gefunden.');
            return;
          }
          
          // Bestätigung einholen
          if (confirm(`${importData.entries.length} Fragen aus der Datei importieren? Bestehende Fragen werden aktualisiert, wenn sie die gleiche ID haben.`)) {
            // Jede Frage importieren
            let importedCount = 0;
            let updatedCount = 0;
            
            importData.entries.forEach(entry => {
              // Prüfen, ob Eintrag bereits existiert
              const existingEntry = qpModule.getPoolEntryById(entry.id);
              
              if (existingEntry) {
                // Eintrag aktualisieren
                const success = qpModule.updatePoolEntry(entry.id, entry);
                if (success) updatedCount++;
              } else {
                // Zum Pool hinzufügen
                const source = entry.source || 'Import';
                const tags = entry.tags || [];
                const result = qpModule.addToPool(entry.question, source, tags);
                if (result) importedCount++;
              }
            });
            
            NotificationSystem.showSuccess(`Import abgeschlossen: ${importedCount} Fragen importiert, ${updatedCount} Fragen aktualisiert.`);
            
            // Fragenpool-Ansicht aktualisieren, falls vorhanden
            if (qpModule.refreshPoolView) {
              qpModule.refreshPoolView();
            }
          }
        } catch (error) {
          console.error('Fehler beim Importieren:', error);
          NotificationSystem.showError('Fehler beim Importieren: ' + error.message);
        }
      };
      
      reader.readAsText(file);
    });
    
    // Datei-Input aktivieren
    fileInput.click();
  }
  
  // Modul erweitern
  qpModule.renderPoolWidget = renderPoolWidget;
  qpModule.renderPoolStats = renderPoolStats;
  qpModule.showPoolView = showPoolView;
  qpModule.showImportQuestionsDialog = showImportQuestionsDialog;
  qpModule.exportQuestionPool = exportQuestionPool;
  qpModule.importQuestionPool = importQuestionPool;
  
  // Wenn ein Dashboard existiert, Fragenpool-Widget hinzufügen
  if (document.getElementById('dashboard-widgets')) {
    // Widget-Container erstellen, falls noch nicht vorhanden
    let poolWidgetContainer = document.getElementById('pool-widget-container');
    
    if (!poolWidgetContainer) {
      poolWidgetContainer = document.createElement('div');
      poolWidgetContainer.id = 'pool-widget-container';
      document.getElementById('dashboard-widgets').appendChild(poolWidgetContainer);
    }
    
    // Widget initialisieren
    renderPoolWidget('pool-widget-container');
  }
})();

// Stylesheet für den Fragenpool hinzufügen
(function() {
  const style = document.createElement('style');
  style.id = 'question-pool-styles';
  style.textContent = `
    /* Fragenpool-Container */
    #question-pool-container {
      padding: 1rem;
    }
    
    /* Pool-Header */
    .pool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .pool-header h2 {
      margin: 0;
    }
    
    .pool-stats {
      font-size: 0.9rem;
      color: #666;
    }
    
    /* Pool-Controls */
    .pool-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background-color: #f5f5f5;
      border-radius: 4px;
    }
    
    .pool-filter-form {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      flex: 1;
    }
    
    .form-group {
      margin-bottom: 0.5rem;
    }
    
    .pool-actions {
      display: flex;
      align-items: flex-end;
      gap: 0.5rem;
    }
    
    /* Pool-Liste */
    .pool-list {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    }
    
    /* Pool-Eintrag */
    .pool-entry {
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
      transition: box-shadow 0.2s, transform 0.2s;
      background-color: #fff;
      cursor: pointer;
    }
    
    .pool-entry:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }
    
    .entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
    }
    
    .entry-type {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      font-weight: bold;
    }
    
    .type-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .type-indicator.multiple_choice { background-color: #3498db; }
    .type-indicator.single_choice { background-color: #2ecc71; }
    .type-indicator.true_false { background-color: #e74c3c; }
    .type-indicator.text { background-color: #f39c12; }
    
    .entry-stats {
      font-size: 0.75rem;
      color: #666;
    }
    
    .entry-content {
      padding: 1rem;
    }
    
    .entry-question {
      margin-bottom: 1rem;
      font-size: 0.95rem;
    }
    
    .entry-details {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 0.5rem;
    }
    
    .entry-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      margin-top: 0.5rem;
    }
    
    .tag {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      background-color: #e0f7fa;
      color: #00796b;
      border-radius: 4px;
      font-size: 0.75rem;
    }
    
    .no-tags {
      font-size: 0.75rem;
      color: #999;
      font-style: italic;
    }
    
    .entry-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      padding: 0.5rem;
      border-top: 1px solid #eee;
      background-color: #fafafa;
    }
    
    /* Leerer Zustand */
    .empty-state {
      text-align: center;
      padding: 2rem;
      grid-column: 1 / -1;
    }
    
    .empty-state-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
    
    /* Modal-Dialog */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .modal.show {
      opacity: 1;
    }
    
    .modal-content {
      background-color: #fff;
      margin: 10% auto;
      padding: 0;
      border-radius: 4px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      width: 80%;
      max-width: 700px;
      position: relative;
      transition: transform 0.3s;
      transform: scale(0.9);
    }
    
    .modal.show .modal-content {
      transform: scale(1);
    }
    
    .modal-header {
      padding: 1rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .modal-header h3 {
      margin: 0;
    }
    
    .close-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
    }
    
    .close-button:hover {
      color: #000;
    }
    
    .modal-body {
      padding: 1rem;
      max-height: 60vh;
      overflow-y: auto;
    }
    
    .modal-footer {
      padding: 1rem;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }
    
    /* Frage-Details-Modal */
    .question-detail-modal .question-type-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .question-text {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background-color: #f9f9f9;
      border-radius: 4px;
      border-left: 4px solid #00FFD0;
    }
    
    .question-options {
      margin-bottom: 1.5rem;
    }
    
    .question-options ul {
      list-style: none;
      padding: 0;
    }
    
    .question-options li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      border-radius: 4px;
    }
    
    .correct-option {
      background-color: rgba(46, 204, 113, 0.1);
    }
    
    .incorrect-option {
      background-color: rgba(231, 76, 60, 0.05);
    }
    
    .option-indicator {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .option-indicator.correct {
      background-color: #2ecc71;
    }
    
    .option-indicator.incorrect {
      background-color: #e74c3c;
    }
    
    .true-false-answer {
      font-weight: bold;
      padding: 0.5rem;
      background-color: rgba(46, 204, 113, 0.1);
      border-radius: 4px;
      display: inline-block;
    }
    
    .question-metadata {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }
    
    .metadata-group label {
      display: block;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 0.3rem;
    }
    
    /* Editor-Modal */
    .question-editor-modal textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    .option-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
    }
    
    .option-text {
      flex: 1;
    }
    
    .form-hint {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.3rem;
    }
    
    .true-false-selection {
      display: flex;
      gap: 1rem;
    }
    
    /* Dashboard-Widget */
    .question-pool-widget {
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
      background-color: #fff;
    }
    
    .widget-header {
      padding: 0.8rem;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .widget-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    
    .widget-content {
      padding: 1rem;
    }
    
    .widget-stats {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1.5rem;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #00FFD0;
    }
    
    .stat-label {
      font-size: 0.75rem;
      color: #666;
    }
    
    .widget-section {
      margin-bottom: 1rem;
    }
    
    .widget-section h4 {
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
      color: #333;
    }
    
    .widget-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
    }
    
    .newest-question {
      background-color: #f9f9f9;
      padding: 0.8rem;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    
    .question-preview {
      margin-bottom: 0.5rem;
    }
    
    .question-meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #666;
    }
    
    .widget-footer {
      padding: 0.8rem;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }
    
    /* Statistik-Ansicht */
    .pool-stats-container {
      padding: 1rem;
    }
    
    .stats-section {
      margin-bottom: 2rem;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
    }
    
    .stat-card {
      padding: 1rem;
      border-radius: 4px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      text-align: center;
    }
    
    .type-card {
      border-top: 3px solid #ccc;
    }
    
    .type-card.multiple_choice { border-top-color: #3498db; }
    .type-card.single_choice { border-top-color: #2ecc71; }
    .type-card.true_false { border-top-color: #e74c3c; }
    .type-card.text { border-top-color: #f39c12; }
    
    .stat-percentage {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.3rem;
    }
    
    .stats-flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .tags-section, .sources-section {
      flex: 1;
      min-width: 300px;
    }
    
    .tag-stats-list, .source-stats-list {
      list-style: none;
      padding: 0;
    }
    
    .tag-stats-list li, .source-stats-list li {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    
    .tag-count, .source-count {
      color: #666;
      font-size: 0.85rem;
    }
    
    .stats-actions {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }
  `;
  
  document.head.appendChild(style);
})();
/**
 * JS-Block 4.8.1: Word-Import - Grundstruktur und Datei-Parsing
 * 
 * Dieses Modul implementiert die grundlegende Funktionalität zum Importieren von Tests
 * und Fragen aus Word-Dokumenten. Es enthält Funktionen zum Einlesen und Parsen
 * von DOCX-Dateien, die Extraktion der XML-Inhalte und die grundlegende Struktur
 * für die weitere Verarbeitung.
 */

// Word-Import-Modul als IIFE (Immediately Invoked Function Expression)
const WordImport = (function() {
  // Private Variablen
  let currentDocument = null;
  let currentDocumentName = '';
  let extractedContent = null;
  let parsedQuestions = [];
  let importSettings = {
    questionDelimiter: 'Frage',
    answerDelimiter: 'Antwort',
    correctAnswerMarker: '[x]',
    incorrectAnswerMarker: '[ ]',
    autoDetect: true,
    createNewTest: true,
    targetTestId: null,
    questionType: 'auto'
  };
  
  /**
   * Initialisiert das Word-Import-Modul
   */
  function init() {
    console.log('Word-Import-Modul initialisiert');
  }
  
  /**
   * Liest eine Word-Datei ein und extrahiert den Inhalt
   * @param {File} file - Die hochgeladene Word-Datei
   * @returns {Promise} - Promise, das den extrahierten Inhalt zurückgibt
   */
  function readWordFile(file) {
    return new Promise((resolve, reject) => {
      // Prüfen, ob es sich um eine Word-Datei handelt
      if (!file || (!file.name.endsWith('.docx') && !file.name.endsWith('.doc'))) {
        reject(new Error('Bitte wählen Sie eine gültige Word-Datei (.docx oder .doc) aus.'));
        return;
      }
      
      // .doc-Dateien werden nicht unterstützt
      if (file.name.endsWith('.doc')) {
        reject(new Error('Das alte .doc-Format wird nicht unterstützt. Bitte speichern Sie die Datei im .docx-Format.'));
        return;
      }
      
      // Dateiinformationen speichern
      currentDocumentName = file.name;
      
      // FileReader zum Lesen der Datei
      const reader = new FileReader();
      
      // Event-Handler für abgeschlossenes Lesen
      reader.onload = function(e) {
        try {
          // ArrayBuffer für JSZip
          const arrayBuffer = e.target.result;
          
          // JSZip für das Entpacken der DOCX-Datei (ein DOCX ist ein ZIP-Archiv)
          loadJSZip()
            .then(() => {
              // JSZip verwenden, um die DOCX-Datei zu entpacken
              return JSZip.loadAsync(arrayBuffer);
            })
            .then(zip => {
              // Zugriff auf document.xml, das den Haupttext enthält
              if (!zip.files['word/document.xml']) {
                throw new Error('Die Datei scheint keine gültige DOCX-Datei zu sein (document.xml nicht gefunden).');
              }
              
              // Dokument-Objekt speichern
              currentDocument = zip;
              
              // XML-Inhalt extrahieren
              return zip.files['word/document.xml'].async('text');
            })
            .then(xmlContent => {
              // XML parsen
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
              
              // Extrahierten Inhalt speichern
              extractedContent = xmlDoc;
              
              // Textinhalt extrahieren
              const plainText = extractPlainText(xmlDoc);
              
              // Erfolgreich
              resolve({
                filename: file.name,
                xmlDocument: xmlDoc,
                plainText: plainText
              });
            })
            .catch(error => {
              console.error('Fehler beim Verarbeiten der DOCX-Datei:', error);
              reject(new Error('Fehler beim Verarbeiten der Datei: ' + error.message));
            });
        } catch (error) {
          console.error('Fehler beim Lesen der Datei:', error);
          reject(new Error('Fehler beim Lesen der Datei: ' + error.message));
        }
      };
      
      // Event-Handler für Fehler
      reader.onerror = function(e) {
        console.error('Fehler beim Lesen der Datei:', e);
        reject(new Error('Fehler beim Lesen der Datei.'));
      };
      
      // Datei als ArrayBuffer lesen
      reader.readAsArrayBuffer(file);
    });
  }
  
  /**
   * Lädt JSZip, falls es noch nicht geladen ist
   * @returns {Promise} - Promise, das gelöst wird, wenn JSZip verfügbar ist
   */
  function loadJSZip() {
    return new Promise((resolve, reject) => {
      // Prüfen, ob JSZip bereits geladen ist
      if (typeof JSZip !== 'undefined') {
        resolve();
        return;
      }
      
      // JSZip über CDN laden
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
      script.integrity = 'sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg==';
      script.crossOrigin = 'anonymous';
      script.referrerPolicy = 'no-referrer';
      
      script.onload = function() {
        console.log('JSZip erfolgreich geladen');
        resolve();
      };
      
      script.onerror = function(e) {
        console.error('Fehler beim Laden von JSZip:', e);
        reject(new Error('Fehler beim Laden der benötigten Bibliothek (JSZip).'));
      };
      
      document.head.appendChild(script);
    });
  }
  
  /**
   * Extrahiert Plaintext aus dem XML-Dokument
   * @param {Document} xmlDoc - Das XML-Dokument
   * @returns {string} - Der extrahierte Plaintext
   */
  function extractPlainText(xmlDoc) {
    // Namespace für OOXML (Office Open XML)
    const ns = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
    
    // Text-Elemente auswählen
    const textElements = xmlDoc.getElementsByTagNameNS(ns, 't');
    let plainText = '';
    
    // Text aus allen Textelementen extrahieren
    for (let i = 0; i < textElements.length; i++) {
      // Text zum Ergebnis hinzufügen, mit Leerzeichen zwischen Elementen
      plainText += textElements[i].textContent;
      
      // Prüfen, ob ein Zeilenumbruch folgen sollte
      const parent = textElements[i].parentNode; // <w:r>
      if (parent && parent.parentNode) { // <w:p>
        const runParent = parent.parentNode;
        const nextRun = parent.nextSibling;
        
        // Wenn kein nächstes Run-Element im selben Absatz vorhanden ist,
        // oder wenn dieser Absatz endet, einen Zeilenumbruch hinzufügen
        if (!nextRun || nextRun.nodeName !== parent.nodeName) {
          const nextParagraph = runParent.nextSibling;
          if (nextParagraph && nextParagraph.nodeName === runParent.nodeName) {
            plainText += '\n';
          }
        } else {
          // Innerhalb eines Absatzes ein Leerzeichen hinzufügen
          plainText += ' ';
        }
      }
    }
    
    // Mehrfache Leerzeichen und Zeilenumbrüche entfernen
    plainText = plainText.replace(/\s+/g, ' ');
    plainText = plainText.replace(/\n\s+/g, '\n');
    
    return plainText;
  }
  
  /**
   * Extrahiert strukturierte Inhalte aus dem XML-Dokument
   * @param {Document} xmlDoc - Das XML-Dokument
   * @returns {Array} - Array mit strukturierten Inhaltselementen
   */
  function extractStructuredContent(xmlDoc) {
    // Namespace für OOXML
    const ns = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
    
    // Absätze auswählen
    const paragraphs = xmlDoc.getElementsByTagNameNS(ns, 'p');
    const structuredContent = [];
    
    // Jeden Absatz verarbeiten
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i];
      
      // Textinhalt des Absatzes extrahieren
      const textElements = paragraph.getElementsByTagNameNS(ns, 't');
      let paragraphText = '';
      
      for (let j = 0; j < textElements.length; j++) {
        paragraphText += textElements[j].textContent;
        
        // Leerzeichen zwischen Textelementen hinzufügen
        if (j < textElements.length - 1) {
          paragraphText += ' ';
        }
      }
      
      // Stilinformationen extrahieren
      const styles = extractParagraphStyles(paragraph, ns);
      
      // Strukturiertes Element erstellen
      structuredContent.push({
        type: 'paragraph',
        text: paragraphText.trim(),
        styles: styles
      });
    }
    
    return structuredContent;
  }
  
  /**
   * Extrahiert Stilinformationen aus einem Absatz
   * @param {Element} paragraph - Das Absatz-Element
   * @param {string} ns - Der XML-Namespace
   * @returns {Object} - Objekt mit Stilinformationen
   */
  function extractParagraphStyles(paragraph, ns) {
    const styles = {
      isBold: false,
      isItalic: false,
      isUnderlined: false,
      isHeading: false,
      headingLevel: 0,
      isList: false,
      listType: null,
      alignment: 'left'
    };
    
    // Absatzformatierung prüfen
    const pPr = paragraph.getElementsByTagNameNS(ns, 'pPr')[0];
    if (pPr) {
      // Überschriftenstil prüfen
      const pStyle = pPr.getElementsByTagNameNS(ns, 'pStyle')[0];
      if (pStyle && pStyle.getAttributeNS(ns, 'val')) {
        const styleVal = pStyle.getAttributeNS(ns, 'val');
        
        // Überschriften erkennen
        if (styleVal.startsWith('Heading') || styleVal.startsWith('heading')) {
          styles.isHeading = true;
          
          // Überschriftenebene extrahieren
          const level = styleVal.match(/\d+$/);
          if (level) {
            styles.headingLevel = parseInt(level[0], 10);
          }
        }
      }
      
      // Listenformatierung prüfen
      const numPr = pPr.getElementsByTagNameNS(ns, 'numPr')[0];
      if (numPr) {
        styles.isList = true;
        
        // Nummerierungstyp ermitteln (nur begrenzt möglich ohne Zugriff auf alle Stildefinitionen)
        // Hier vereinfacht auf nummerierte und ungeordnete Listen
        const ilvl = numPr.getElementsByTagNameNS(ns, 'ilvl')[0];
        if (ilvl) {
          const level = ilvl.getAttributeNS(ns, 'val');
          styles.listType = level === '0' ? 'bullet' : 'number';
        }
      }
      
      // Textausrichtung prüfen
      const jc = pPr.getElementsByTagNameNS(ns, 'jc')[0];
      if (jc && jc.getAttributeNS(ns, 'val')) {
        styles.alignment = jc.getAttributeNS(ns, 'val');
      }
    }
    
    // Run-Formatierungen prüfen
    const runs = paragraph.getElementsByTagNameNS(ns, 'r');
    for (let i = 0; i < runs.length; i++) {
      const run = runs[i];
      const rPr = run.getElementsByTagNameNS(ns, 'rPr')[0];
      
      if (rPr) {
        // Fett prüfen
        if (rPr.getElementsByTagNameNS(ns, 'b').length > 0) {
          styles.isBold = true;
        }
        
        // Kursiv prüfen
        if (rPr.getElementsByTagNameNS(ns, 'i').length > 0) {
          styles.isItalic = true;
        }
        
        // Unterstrichen prüfen
        if (rPr.getElementsByTagNameNS(ns, 'u').length > 0) {
          styles.isUnderlined = true;
        }
      }
    }
    
    return styles;
  }
  
  /**
   * Setzt die Import-Einstellungen
   * @param {Object} settings - Die neuen Einstellungen
   */
  function setImportSettings(settings) {
    // Einstellungen mit Standardwerten zusammenführen
    importSettings = {
      ...importSettings,
      ...settings
    };
    
    console.log('Import-Einstellungen aktualisiert:', importSettings);
  }
  
  /**
   * Gibt die aktuellen Import-Einstellungen zurück
   * @returns {Object} - Die aktuellen Einstellungen
   */
  function getImportSettings() {
    return { ...importSettings };
  }
  
  /**
   * Prüft, ob ein Word-Dokument geladen wurde
   * @returns {boolean} - true, wenn ein Dokument geladen wurde
   */
  function hasLoadedDocument() {
    return !!currentDocument && !!extractedContent;
  }
  
  /**
   * Gibt Informationen über das geladene Dokument zurück
   * @returns {Object|null} - Informationen über das Dokument oder null
   */
  function getDocumentInfo() {
    if (!hasLoadedDocument()) {
      return null;
    }
    
    return {
      filename: currentDocumentName,
      contentAvailable: !!extractedContent,
      parseStatus: parsedQuestions.length > 0 ? 'parsed' : 'notParsed',
      questionCount: parsedQuestions.length
    };
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    readWordFile: readWordFile,
    extractPlainText: extractPlainText,
    extractStructuredContent: extractStructuredContent,
    setImportSettings: setImportSettings,
    getImportSettings: getImportSettings,
    hasLoadedDocument: hasLoadedDocument,
    getDocumentInfo: getDocumentInfo
  };
})();
/**
 * JS-Block 4.8.2: Word-Import - Fragenerkennung und -extraktion
 * 
 * Dieses Modul erweitert das Word-Import-Modul um Funktionen zur Erkennung
 * und Extraktion von Fragen und Antworten aus dem Word-Dokument.
 */

// Word-Import-Modul erweitern
(function() {
  // Referenz auf das existierende WordImport-Modul
  const wordImport = window.WordImport;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.1 laden.');
    return;
  }
  
  /**
   * Analysiert den Dokumentinhalt, um potenzielle Fragestrukturen zu erkennen
   * @param {Document} xmlDoc - Das XML-Dokument
   * @returns {Object} - Erkannte Strukturen und Muster
   */
  function analyzeDocumentStructure(xmlDoc) {
    // Strukturierten Inhalt extrahieren
    const structuredContent = wordImport.extractStructuredContent(xmlDoc);
    
    // Muster für mögliche Fragestrukturen
    const patterns = {
      questionMarkers: [],
      answerMarkers: [],
      choiceMarkers: [],
      numberedQuestions: false,
      numberedAnswers: false,
      // Potenzielle Fragetypen
      multipleChoicePattern: false,
      singleChoicePattern: false,
      trueFalsePattern: false,
      textPattern: false
    };
    
    // Reguläre Ausdrücke für potenzielle Marker
    const questionRegexes = [
      /^frage\s*\d+[\.:]/i,
      /^f\d+[\.:]/i,
      /^\d+\.\s*frage/i,
      /^q(uestion)?\s*\d+[\.:]/i
    ];
    
    const answerRegexes = [
      /^antwort\s*\d*[\.:]/i,
      /^a\d+[\.:]/i,
      /^lösung[\.:]/i,
      /^a(nswer)?\s*\d*[\.:]/i
    ];
    
    const choiceRegexes = [
      /^\[\s*\]/,      // [ ]
      /^\[\s*x\s*\]/i, // [x]
      /^\(\s*\)/,      // ( )
      /^\(\s*x\s*\)/i, // (x)
      /^[a-z]\)\s+/i,  // a) oder A)
      /^[a-z]\.\s+/i   // a. oder A.
    ];
    
    // Jedes Element analysieren
    structuredContent.forEach((item, index) => {
      const text = item.text.trim();
      
      // Frage-Marker erkennen
      questionRegexes.forEach(regex => {
        if (regex.test(text) && !patterns.questionMarkers.includes(regex.source)) {
          patterns.questionMarkers.push(regex.source);
        }
      });
      
      // Antwort-Marker erkennen
      answerRegexes.forEach(regex => {
        if (regex.test(text) && !patterns.answerMarkers.includes(regex.source)) {
          patterns.answerMarkers.push(regex.source);
        }
      });
      
      // Auswahloptionen erkennen
      choiceRegexes.forEach(regex => {
        if (regex.test(text) && !patterns.choiceMarkers.includes(regex.source)) {
          patterns.choiceMarkers.push(regex.source);
        }
      });
      
      // Nummerierte Fragen erkennen
      if (/^\d+\.\s+/.test(text) && 
          (text.toLowerCase().includes('frage') || 
           text.length > 20 && !text.toLowerCase().includes('antwort'))) {
        patterns.numberedQuestions = true;
      }
      
      // Nummerierte Antworten erkennen
      if (/^\d+\.\s+/.test(text) && 
          (text.toLowerCase().includes('antwort') || 
           (index > 0 && structuredContent[index-1].text.toLowerCase().includes('frage')))) {
        patterns.numberedAnswers = true;
      }
      
      // Multiple-Choice-Muster erkennen
      if ((/^\[\s*x\s*\]/i.test(text) || /^\(\s*x\s*\)/i.test(text)) && 
          (/^\[\s*\]/.test(text) || /^\(\s*\)/.test(text))) {
        patterns.multipleChoicePattern = true;
      }
      
      // Single-Choice-Muster erkennen (a), b), c) Format oder ähnlich)
      if (/^[a-z][\)\.]/.test(text)) {
        patterns.singleChoicePattern = true;
      }
      
      // Wahr/Falsch-Muster erkennen
      if (text.toLowerCase().includes('wahr') && text.toLowerCase().includes('falsch')) {
        patterns.trueFalsePattern = true;
      }
    });
    
    // Empfohlene Fragetyp-Einstellung basierend auf erkannten Mustern
    let recommendedType = 'auto';
    
    if (patterns.multipleChoicePattern) {
      recommendedType = 'multiple_choice';
    } else if (patterns.singleChoicePattern) {
      recommendedType = 'single_choice';
    } else if (patterns.trueFalsePattern) {
      recommendedType = 'true_false';
    } else if (patterns.questionMarkers.length > 0 && patterns.choiceMarkers.length === 0) {
      recommendedType = 'text';
    }
    
    // Empfohlene Einstellungen für den Import
    const recommendedSettings = {
      questionDelimiter: patterns.questionMarkers.length > 0 ? patterns.questionMarkers[0] : 'Frage',
      answerDelimiter: patterns.answerMarkers.length > 0 ? patterns.answerMarkers[0] : 'Antwort',
      correctAnswerMarker: '[x]',
      incorrectAnswerMarker: '[ ]',
      questionType: recommendedType
    };
    
    return {
      patterns: patterns,
      recommendedSettings: recommendedSettings
    };
  }
  
  /**
   * Extrahiert Fragen und Antworten aus dem strukturierten Inhalt
   * @param {Document} xmlDoc - Das XML-Dokument
   * @param {Object} settings - Die Import-Einstellungen
   * @returns {Array} - Array mit extrahierten Fragen
   */
  function extractQuestions(xmlDoc, settings) {
    // Standardeinstellungen verwenden, falls keine übergeben wurden
    const currentSettings = settings || wordImport.getImportSettings();
    
    // Strukturierten Inhalt extrahieren
    const structuredContent = wordImport.extractStructuredContent(xmlDoc);
    
    // Fragen-Array
    const questions = [];
    
    // Aktuelle Frage
    let currentQuestion = null;
    
    // Modus (Frage oder Antwort)
    let mode = 'none';
    
    // Hilfsregex für die Erkennung von Fragen und Antworten
    const questionRegex = new RegExp(`^${currentSettings.questionDelimiter}\\s*\\d*[\\.:]*`, 'i');
    const answerRegex = new RegExp(`^${currentSettings.answerDelimiter}\\s*\\d*[\\.:]*`, 'i');
    
    // Regex für Antwortoptionen
    const correctAnswerRegex = new RegExp(`^\\s*${escapeRegExp(currentSettings.correctAnswerMarker)}\\s*`, 'i');
    const incorrectAnswerRegex = new RegExp(`^\\s*${escapeRegExp(currentSettings.incorrectAnswerMarker)}\\s*`, 'i');
    
    // Optionen für die aktuelle Frage
    let currentOptions = [];
    
    // Nummerierte Fragen erkennen
    const numberedQuestionRegex = /^(\d+)[\.\)]\s+(.+)/;
    
    // Jeden Absatz durchgehen
    for (let i = 0; i < structuredContent.length; i++) {
      const item = structuredContent[i];
      let text = item.text.trim();
      
      // Leere Absätze überspringen
      if (!text) continue;
      
      // Frage-Marker erkennen
      if (questionRegex.test(text) || (currentSettings.autoDetect && numberedQuestionRegex.test(text) && mode !== 'answer')) {
        // Vorherige Frage abschließen, falls vorhanden
        if (currentQuestion) {
          // Wenn Optionen für die vorherige Frage vorhanden sind, diese hinzufügen
          if (currentOptions.length > 0) {
            currentQuestion.options = currentOptions;
            
            // Fragetyp bestimmen
            if (currentSettings.questionType === 'auto') {
              if (currentOptions.some(opt => opt.isCorrect) && currentOptions.some(opt => !opt.isCorrect)) {
                currentQuestion.type = 'multiple_choice';
              } else if (currentOptions.length > 0) {
                // Wenn genau eine Option korrekt ist, Single Choice
                const correctCount = currentOptions.filter(opt => opt.isCorrect).length;
                currentQuestion.type = correctCount === 1 ? 'single_choice' : 'multiple_choice';
              }
            } else {
              currentQuestion.type = currentSettings.questionType;
            }
          } else {
            // Ohne Optionen ist es eine Freitext-Frage
            currentQuestion.type = 'text';
          }
          
          // Frage zum Array hinzufügen
          questions.push(currentQuestion);
        }
        
        // Text von Fragenmarkern bereinigen
        if (questionRegex.test(text)) {
          text = text.replace(questionRegex, '').trim();
        } else if (numberedQuestionRegex.test(text)) {
          const match = text.match(numberedQuestionRegex);
          text = match[2].trim();
        }
        
        // Neue Frage erstellen
        currentQuestion = {
          id: 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
          text: text,
          type: currentSettings.questionType === 'auto' ? 'text' : currentSettings.questionType,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        // Optionen zurücksetzen
        currentOptions = [];
        
        // Modus auf Frage setzen
        mode = 'question';
        continue;
      }
      
      // Antwort-Marker erkennen
      if (answerRegex.test(text)) {
        // Text von Antwortmarkern bereinigen
        text = text.replace(answerRegex, '').trim();
        
        // Wenn eine Frage vorhanden ist, den Antworttext hinzufügen
        if (currentQuestion) {
          if (!currentQuestion.answerText) {
            currentQuestion.answerText = text;
          } else {
            currentQuestion.answerText += "\n" + text;
          }
        }
        
        // Modus auf Antwort setzen
        mode = 'answer';
        continue;
      }
      
      // Korrekte Multiple-Choice-Option erkennen
      if (correctAnswerRegex.test(text)) {
        // Text von Markern bereinigen
        text = text.replace(correctAnswerRegex, '').trim();
        
        // Option hinzufügen
        currentOptions.push({
          text: text,
          isCorrect: true
        });
        
        // Modus auf Antwort setzen
        mode = 'answer';
        continue;
      }
      
      // Inkorrekte Multiple-Choice-Option erkennen
      if (incorrectAnswerRegex.test(text)) {
        // Text von Markern bereinigen
        text = text.replace(incorrectAnswerRegex, '').trim();
        
        // Option hinzufügen
        currentOptions.push({
          text: text,
          isCorrect: false
        });
        
        // Modus auf Antwort setzen
        mode = 'answer';
        continue;
      }
      
      // Alphabetische oder nummerierte Antwortoptionen erkennen (a), b), 1., 2., usw.)
      const alphaOptionRegex = /^([a-z][\.\)])\s+(.+)/i;
      const numberedOptionRegex = /^(\d+[\.\)])\s+(.+)/;
      
      if (mode === 'answer' && (alphaOptionRegex.test(text) || numberedOptionRegex.test(text))) {
        let optionText = '';
        
        if (alphaOptionRegex.test(text)) {
          const match = text.match(alphaOptionRegex);
          optionText = match[2].trim();
        } else if (numberedOptionRegex.test(text)) {
          const match = text.match(numberedOptionRegex);
          optionText = match[2].trim();
        }
        
        // Prüfen, ob die Option als korrekt markiert ist
        const isCorrect = optionText.includes('(richtig)') || 
                           optionText.includes('(korrekt)') || 
                           optionText.includes('(correct)');
        
        // Marker aus dem Text entfernen
        optionText = optionText.replace(/\(richtig\)|\(korrekt\)|\(correct\)/gi, '').trim();
        
        // Option hinzufügen
        currentOptions.push({
          text: optionText,
          isCorrect: isCorrect
        });
        
        continue;
      }
      
      // Falls keine spezifischen Marker erkannt wurden, aber wir im Frage- oder Antwortmodus sind
      if (mode === 'question' && currentQuestion) {
        // Text zur aktuellen Frage hinzufügen
        currentQuestion.text += "\n" + text;
      } else if (mode === 'answer' && currentQuestion) {
        // Text zur aktuellen Antwort hinzufügen oder als Option behandeln
        if (currentOptions.length > 0 && text.length < 100) {
          // Könnte eine weitere Option sein
          currentOptions.push({
            text: text,
            isCorrect: false // Standardmäßig als falsch markieren
          });
        } else {
          // Als Antworttext behandeln
          if (!currentQuestion.answerText) {
            currentQuestion.answerText = text;
          } else {
            currentQuestion.answerText += "\n" + text;
          }
        }
      }
    }
    
    // Letzte Frage hinzufügen, falls vorhanden
    if (currentQuestion) {
      // Wenn Optionen für die letzte Frage vorhanden sind, diese hinzufügen
      if (currentOptions.length > 0) {
        currentQuestion.options = currentOptions;
        
        // Fragetyp bestimmen
        if (currentSettings.questionType === 'auto') {
          if (currentOptions.some(opt => opt.isCorrect) && currentOptions.some(opt => !opt.isCorrect)) {
            currentQuestion.type = 'multiple_choice';
          } else {
            // Wenn genau eine Option korrekt ist, Single Choice
            const correctCount = currentOptions.filter(opt => opt.isCorrect).length;
            currentQuestion.type = correctCount === 1 ? 'single_choice' : 'multiple_choice';
          }
        } else {
          currentQuestion.type = currentSettings.questionType;
        }
      } else {
        // Ohne Optionen ist es eine Freitext-Frage
        currentQuestion.type = 'text';
      }
      
      // Frage zum Array hinzufügen
      questions.push(currentQuestion);
    }
    
    // Fragen nachbearbeiten
    questions.forEach(question => {
      // Wahr/Falsch-Fragen erkennen und konvertieren
      if (question.type === 'auto' || question.type === 'true_false') {
        if (question.text.toLowerCase().includes('wahr oder falsch') || 
            question.text.toLowerCase().includes('richtig oder falsch')) {
          question.type = 'true_false';
          
          // Korrekte Antwort aus den Optionen oder dem Antworttext ermitteln
          if (question.options && question.options.length > 0) {
            // Option mit "wahr", "richtig" oder "true" ist korrekt
            const trueOption = question.options.find(opt => 
              opt.text.toLowerCase().includes('wahr') || 
              opt.text.toLowerCase().includes('richtig') || 
              opt.text.toLowerCase().includes('true')
            );
            
            question.correctAnswer = !!trueOption && trueOption.isCorrect;
          } else if (question.answerText) {
            // Antworttext analysieren
            question.correctAnswer = 
              question.answerText.toLowerCase().includes('wahr') || 
              question.answerText.toLowerCase().includes('richtig') || 
              question.answerText.toLowerCase().includes('true');
          }
          
          // Optionen entfernen, da nicht benötigt für Wahr/Falsch
          delete question.options;
        }
      }
    });
    
    return questions;
  }
  
  /**
   * Hilfsfunktion zum Escapen von Sonderzeichen in regulären Ausdrücken
   * @param {string} string - Der zu escapende String
   * @returns {string} - Escapeter String
   */
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  /**
   * Führt den Extraktionsprozess für das aktuelle Dokument durch
   * @param {Object} settings - Optionale Import-Einstellungen
   * @returns {Promise} - Promise, das die extrahierten Fragen zurückgibt
   */
  function processDocument(settings) {
    return new Promise((resolve, reject) => {
      // Prüfen, ob ein Dokument geladen wurde
      if (!wordImport.hasLoadedDocument()) {
        reject(new Error('Kein Dokument geladen. Bitte laden Sie zuerst ein Word-Dokument.'));
        return;
      }
      
      try {
        // Einstellungen aktualisieren, falls vorhanden
        if (settings) {
          wordImport.setImportSettings(settings);
        }
        
        // Aktuellen Dokument-Content holen
        const documentInfo = wordImport.getDocumentInfo();
        const extractedContent = window.extractedContent; // Globale Variable aus dem ersten Teil
        
        if (!extractedContent) {
          reject(new Error('Kein Inhalt extrahiert. Die Datei scheint leer oder ungültig zu sein.'));
          return;
        }
        
        // Fragen extrahieren
        const questions = extractQuestions(extractedContent, wordImport.getImportSettings());
        
        // Gefundene Fragen speichern
        window.parsedQuestions = questions;
        
        // Erfolgreiche Extraktion
        resolve({
          filename: documentInfo.filename,
          questionCount: questions.length,
          questions: questions
        });
      } catch (error) {
        console.error('Fehler bei der Extraktion von Fragen:', error);
        reject(new Error('Fehler bei der Extraktion von Fragen: ' + error.message));
      }
    });
  }
  
  /**
   * Empfiehlt Einstellungen basierend auf der Dokumentstruktur
   * @returns {Promise} - Promise, das die empfohlenen Einstellungen zurückgibt
   */
  function recommendSettings() {
    return new Promise((resolve, reject) => {
      // Prüfen, ob ein Dokument geladen wurde
      if (!wordImport.hasLoadedDocument()) {
        reject(new Error('Kein Dokument geladen. Bitte laden Sie zuerst ein Word-Dokument.'));
        return;
      }
      
      try {
        // Dokument-Struktur analysieren
        const results = analyzeDocumentStructure(window.extractedContent);
        
        // Empfohlene Einstellungen zurückgeben
        resolve(results.recommendedSettings);
      } catch (error) {
        console.error('Fehler bei der Analyse der Dokumentstruktur:', error);
        reject(new Error('Fehler bei der Analyse der Dokumentstruktur: ' + error.message));
      }
    });
  }
  
  // Modul um neue Funktionen erweitern
  wordImport.analyzeDocumentStructure = analyzeDocumentStructure;
  wordImport.extractQuestions = extractQuestions;
  wordImport.processDocument = processDocument;
  wordImport.recommendSettings = recommendSettings;
})();
/**
 * JS-Block 4.8.3: Word-Import UI Teil 1 - Grundstruktur und Upload
 * 
 * Dieser Teil implementiert die grundlegende Benutzeroberfläche für den Word-Import
 * und den ersten Schritt des Import-Prozesses (Datei-Upload).
 */

// Word-Import-UI-Modul - Teil 1
(function() {
  // Referenz auf das existierende WordImport-Modul
  const wordImport = window.WordImport;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.1 und 4.8.2 laden.');
    return;
  }
  
  // Status des Import-Prozesses
  const importStatus = {
    step: 'upload', // 'upload', 'settings', 'preview', 'import'
    file: null,
    parsedQuestions: [],
    selectedQuestions: [],
    targetTest: null
  };
  
  /**
   * Initialisiert die Word-Import-UI
   * @param {string} containerId - ID des Container-Elements
   */
  function initImportUI(containerId = 'word-import-container') {
    // Container-Element erstellen, falls noch nicht vorhanden
    let container = document.getElementById(containerId);
    
    if (!container) {
      container = document.createElement('div');
      container.id = containerId;
      document.body.appendChild(container);
    }
    
    // Grundlegende UI-Struktur erstellen
    container.innerHTML = `
      <div class="import-container">
        <div class="import-header">
          <h2>Word-Import: Fragen aus Word-Dokumenten importieren</h2>
        </div>
        
        <div class="import-progress-bar">
          <div class="progress-step ${importStatus.step === 'upload' ? 'active' : ''}" data-step="upload">
            <div class="step-number">1</div>
            <div class="step-label">Datei hochladen</div>
          </div>
          <div class="progress-step ${importStatus.step === 'settings' ? 'active' : ''}" data-step="settings">
            <div class="step-number">2</div>
            <div class="step-label">Einstellungen</div>
          </div>
          <div class="progress-step ${importStatus.step === 'preview' ? 'active' : ''}" data-step="preview">
            <div class="step-number">3</div>
            <div class="step-label">Vorschau</div>
          </div>
          <div class="progress-step ${importStatus.step === 'import' ? 'active' : ''}" data-step="import">
            <div class="step-number">4</div>
            <div class="step-label">Import</div>
          </div>
        </div>
        
        <div class="import-content">
          <!-- Inhalt wird dynamisch geladen -->
        </div>
      </div>
    `;
    
    // Ersten Schritt anzeigen
    showUploadStep();
  }
  
  /**
   * Zeigt den Upload-Schritt an
   */
  function showUploadStep() {
    // Importstatus aktualisieren
    importStatus.step = 'upload';
    updateProgressBar();
    
    // Container finden
    const container = document.querySelector('.import-content');
    if (!container) return;
    
    // Upload-UI anzeigen
    container.innerHTML = `
      <div class="upload-step">
        <div class="upload-instructions">
          <h3>Word-Dokument hochladen</h3>
          <p>
            Laden Sie ein Word-Dokument (.docx) hoch, das Fragen und Antworten enthält.
            Das System wird versuchen, die Fragen und Antworten automatisch zu erkennen.
          </p>
          <div class="file-format-info">
            <h4>Unterstützte Formate:</h4>
            <ul>
              <li>Fragen mit "Frage X:" oder ähnlichen Markierungen</li>
              <li>Multiple-Choice-Fragen mit [x] für richtige und [ ] für falsche Antworten</li>
              <li>Nummerierte oder mit Buchstaben versehene Antwortoptionen</li>
              <li>Wahr/Falsch-Fragen</li>
            </ul>
          </div>
        </div>
        
        <div class="upload-area">
          <div class="file-drop-zone" id="file-drop-zone">
            <div class="drop-zone-content">
              <div class="upload-icon">📄</div>
              <p>Ziehen Sie eine .docx-Datei hierher oder</p>
              <label for="file-input" class="btn btn-primary file-select-button">Datei auswählen</label>
              <input type="file" id="file-input" accept=".docx" style="display: none;">
            </div>
          </div>
          
          <div id="upload-status" class="upload-status" style="display: none;">
            <div class="loader"></div>
            <p>Datei wird verarbeitet...</p>
          </div>
        </div>
        
        <div class="upload-actions">
          <button id="upload-cancel" class="btn btn-secondary">Abbrechen</button>
          <button id="upload-next" class="btn btn-primary" disabled>Weiter</button>
        </div>
      </div>
    `;
    
    // Event-Listener registrieren
    registerUploadEventListeners();
  }
  
  /**
   * Registriert Event-Listener für den Upload-Schritt
   */
  function registerUploadEventListeners() {
    // Datei-Input
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
      fileInput.addEventListener('change', handleFileSelection);
    }
    
    // Drop-Zone
    const dropZone = document.getElementById('file-drop-zone');
    if (dropZone) {
      // Drag-Events
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add('drag-over');
      });
      
      dropZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('drag-over');
      });
      
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('drag-over');
        
        // Datei aus dem Drop-Event extrahieren
        if (e.dataTransfer.files.length > 0) {
          const file = e.dataTransfer.files[0];
          processUploadedFile(file);
        }
      });
    }
    
    // Weiter-Button
    const nextButton = document.getElementById('upload-next');
    if (nextButton) {
      nextButton.addEventListener('click', () => {
        if (importStatus.file) {
          showSettingsStep();
        }
      });
    }
    
    // Abbrechen-Button
    const cancelButton = document.getElementById('upload-cancel');
    if (cancelButton) {
      cancelButton.addEventListener('click', () => {
        // Bestätigung einholen
        if (confirm('Möchten Sie den Import-Vorgang wirklich abbrechen?')) {
          // Zurück zum Dashboard oder zur vorherigen Seite
          navigateBack();
        }
      });
    }
  }
  
  /**
   * Handler für die Dateiauswahl
   * @param {Event} event - Das Change-Event
   */
  function handleFileSelection(event) {
    const file = event.target.files[0];
    if (file) {
      processUploadedFile(file);
    }
  }
  
  /**
   * Verarbeitet eine hochgeladene Datei
   * @param {File} file - Die hochgeladene Datei
   */
  function processUploadedFile(file) {
    // Prüfen, ob es sich um eine DOCX-Datei handelt
    if (!file.name.endsWith('.docx')) {
      NotificationSystem.showError('Bitte wählen Sie eine gültige Word-Datei (.docx) aus.');
      return;
    }
    
    // Upload-Status anzeigen
    const uploadStatus = document.getElementById('upload-status');
    const dropZone = document.getElementById('file-drop-zone');
    
    if (uploadStatus) uploadStatus.style.display = 'flex';
    if (dropZone) dropZone.style.display = 'none';
    
    // Nächster-Button aktivieren
    const nextButton = document.getElementById('upload-next');
    if (nextButton) nextButton.disabled = true;
    
    // Datei in das WordImport-Modul laden
    wordImport.readWordFile(file)
      .then(result => {
        // Datei-Informationen im Status speichern
        importStatus.file = file;
        
        // Upload-Status aktualisieren
        if (uploadStatus) {
          uploadStatus.innerHTML = `
            <div class="success-icon">✓</div>
            <p>Datei "${file.name}" erfolgreich geladen</p>
          `;
        }
        
        // Nächster-Button aktivieren
        if (nextButton) nextButton.disabled = false;
      })
      .catch(error => {
        console.error('Fehler beim Laden der Datei:', error);
        
        // Fehlermeldung anzeigen
        if (uploadStatus) {
          uploadStatus.innerHTML = `
            <div class="error-icon">❌</div>
            <p>Fehler: ${error.message}</p>
          `;
        }
        
        // Drop-Zone wieder anzeigen
        if (dropZone) dropZone.style.display = 'block';
        
        // Notification anzeigen
        NotificationSystem.showError('Fehler beim Laden der Datei: ' + error.message);
      });
  }
  
  /**
   * Aktualisiert die Fortschrittsanzeige im Import-Prozess
   */
  function updateProgressBar() {
    const steps = document.querySelectorAll('.progress-step');
    
    steps.forEach(step => {
      const stepName = step.dataset.step;
      
      if (stepName === importStatus.step) {
        step.classList.add('active');
      } else {
        step.classList.remove('active');
      }
      
      // Vergangene Schritte markieren
      const stepIndex = getStepIndex(stepName);
      const currentIndex = getStepIndex(importStatus.step);
      
      if (stepIndex < currentIndex) {
        step.classList.add('completed');
      } else {
        step.classList.remove('completed');
      }
    });
  }
  
  /**
   * Gibt den Index eines Schritts zurück
   * @param {string} step - Der Name des Schritts
   * @returns {number} - Der Index des Schritts
   */
  function getStepIndex(step) {
    const steps = ['upload', 'settings', 'preview', 'import'];
    return steps.indexOf(step);
  }
  
  /**
   * Navigiert zurück zur vorherigen Seite oder zum Dashboard
   */
  function navigateBack() {
    // Navigation-Modul verwenden, falls verfügbar
    if (typeof Navigation !== 'undefined' && Navigation.goBack) {
      Navigation.goBack();
      return;
    }
    
    // Fallback: Historie verwenden
    if (window.history.length > 1) {
      window.history.back();
    } else {
      // Zum Dashboard navigieren
      window.location.href = '?page=dashboard';
    }
  }
  
  /**
   * Setzt den Import-Status zurück
   */
  function resetImportStatus() {
    // Status auf Ursprungswerte zurücksetzen
    importStatus.step = 'upload';
    importStatus.file = null;
    importStatus.parsedQuestions = [];
    importStatus.selectedQuestions = [];
    importStatus.targetTest = null;
  }
  
  // Einige Funktionen als Platzhalter deklarieren, die in späteren Teilen implementiert werden
  function showSettingsStep() {
    console.log('showSettingsStep wird in Teil 2 implementiert');
    // Diese Funktion wird in Teil 2 implementiert
    if (typeof WordImportUI !== 'undefined' && WordImportUI.showSettingsStep) {
      WordImportUI.showSettingsStep();
    }
  }
  
  // Öffentliche API
  window.WordImportUI = {
    initImportUI: initImportUI,
    showUploadStep: showUploadStep,
    resetImportStatus: resetImportStatus,
    updateProgressBar: updateProgressBar,
    importStatus: importStatus
  };
  
  // WordImport-Modul um UI-Funktionen erweitern
  wordImport.initImportUI = initImportUI;
  wordImport.resetImportStatus = resetImportStatus;
  
  // Status für die UI global verfügbar machen
  window.importStatus = importStatus;
})();
/**
 * JS-Block 4.8.3: Word-Import UI Teil 2 - Einstellungen und Vorschau
 * 
 * Dieser Teil implementiert die Einstellungs- und Vorschau-Schritte
 * des Word-Import-Prozesses.
 */

// Word-Import-UI-Modul - Teil 2
(function() {
  // Referenz auf das existierende WordImport-Modul
  const wordImport = window.WordImport;
  const wordImportUI = window.WordImportUI;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.1 und 4.8.2 laden.');
    return;
  }
  
  if (!wordImportUI) {
    console.error('WordImportUI-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.3-Teil 1 laden.');
    return;
  }
  
  // Import-Status aus Teil 1 verwenden
  const importStatus = wordImportUI.importStatus;
  
  /**
   * Zeigt den Einstellungs-Schritt an
   */
  function showSettingsStep() {
    // Importstatus aktualisieren
    importStatus.step = 'settings';
    wordImportUI.updateProgressBar();
    
    // Container finden
    const container = document.querySelector('.import-content');
    if (!container) return;
    
    // Aktuelle Einstellungen holen
    const currentSettings = wordImport.getImportSettings();
    
    // Status anzeigen
    container.innerHTML = `
      <div class="settings-step">
        <div class="settings-info">
          <h3>Import-Einstellungen</h3>
          <p>
            Passen Sie die Einstellungen für den Import an. Das System hat versucht, die
            Fragestruktur zu erkennen und optimale Einstellungen vorzuschlagen.
          </p>
        </div>
        
        <div id="settings-loading" class="settings-loading">
          <div class="loader"></div>
          <p>Dokument wird analysiert...</p>
        </div>
        
        <form id="import-settings-form" class="import-settings-form" style="display: none;">
          <div class="settings-section">
            <h4>Frage- und Antwort-Erkennung</h4>
            
            <div class="form-group">
              <label for="question-delimiter">Frage-Marker:</label>
              <input type="text" id="question-delimiter" class="form-control" 
                value="${currentSettings.questionDelimiter}">
              <p class="form-hint">
                Text, der den Beginn einer Frage markiert (z.B. "Frage", "F1", "Aufgabe").
              </p>
            </div>
            
            <div class="form-group">
              <label for="answer-delimiter">Antwort-Marker:</label>
              <input type="text" id="answer-delimiter" class="form-control" 
                value="${currentSettings.answerDelimiter}">
              <p class="form-hint">
                Text, der den Beginn einer Antwort markiert (z.B. "Antwort", "Lösung").
              </p>
            </div>
          </div>
          
          <div class="settings-section">
            <h4>Multiple-Choice-Optionen</h4>
            
            <div class="form-group">
              <label for="correct-answer-marker">Marker für richtige Antworten:</label>
              <input type="text" id="correct-answer-marker" class="form-control" 
                value="${currentSettings.correctAnswerMarker}">
              <p class="form-hint">
                Zeichen, die eine richtige Antwort markieren (z.B. "[x]", "(x)").
              </p>
            </div>
            
            <div class="form-group">
              <label for="incorrect-answer-marker">Marker für falsche Antworten:</label>
              <input type="text" id="incorrect-answer-marker" class="form-control" 
                value="${currentSettings.incorrectAnswerMarker}">
              <p class="form-hint">
                Zeichen, die eine falsche Antwort markieren (z.B. "[ ]", "( )").
              </p>
            </div>
          </div>
          
          <div class="settings-section">
            <h4>Fragetypen und Ziel</h4>
            
            <div class="form-group">
              <label for="question-type">Fragetyp:</label>
              <select id="question-type" class="form-control">
                <option value="auto" ${currentSettings.questionType === 'auto' ? 'selected' : ''}>
                  Automatisch erkennen
                </option>
                <option value="multiple_choice" ${currentSettings.questionType === 'multiple_choice' ? 'selected' : ''}>
                  Multiple Choice
                </option>
                <option value="single_choice" ${currentSettings.questionType === 'single_choice' ? 'selected' : ''}>
                  Single Choice
                </option>
                <option value="true_false" ${currentSettings.questionType === 'true_false' ? 'selected' : ''}>
                  Wahr/Falsch
                </option>
                <option value="text" ${currentSettings.questionType === 'text' ? 'selected' : ''}>
                  Freitext
                </option>
              </select>
              <p class="form-hint">
                Legen Sie fest, welcher Fragetyp verwendet werden soll.
              </p>
            </div>
            
            <div class="form-group">
              <label for="create-new-test">Ziel:</label>
              <div class="radio-group">
                <label>
                  <input type="radio" name="import-target" id="create-new-test" value="new" 
                    ${currentSettings.createNewTest ? 'checked' : ''}>
                  Neuen Test erstellen
                </label>
                <label>
                  <input type="radio" name="import-target" id="add-to-existing" value="existing" 
                    ${!currentSettings.createNewTest ? 'checked' : ''}>
                  Zu bestehendem Test hinzufügen
                </label>
              </div>
            </div>
            
            <div id="existing-test-selection" class="form-group" 
                style="${currentSettings.createNewTest ? 'display: none;' : ''}">
              <label for="target-test">Test auswählen:</label>
              <select id="target-test" class="form-control">
                <!-- Wird dynamisch befüllt -->
              </select>
            </div>
          </div>
        </form>
        
        <div class="settings-actions">
          <button id="settings-back" class="btn btn-secondary">Zurück</button>
          <button id="settings-next" class="btn btn-primary" disabled>Weiter zur Vorschau</button>
        </div>
      </div>
    `;
    
    // Event-Listener registrieren
    registerSettingsEventListeners();
    
    // Dokument analysieren und Empfehlungen generieren
    wordImport.recommendSettings()
      .then(recommendedSettings => {
        // Empfohlene Einstellungen übernehmen
        document.getElementById('question-delimiter').value = recommendedSettings.questionDelimiter;
        document.getElementById('answer-delimiter').value = recommendedSettings.answerDelimiter;
        document.getElementById('correct-answer-marker').value = recommendedSettings.correctAnswerMarker;
        document.getElementById('incorrect-answer-marker').value = recommendedSettings.incorrectAnswerMarker;
        document.getElementById('question-type').value = recommendedSettings.questionType;
        
        // Loading-Status ausblenden und Formular anzeigen
        document.getElementById('settings-loading').style.display = 'none';
        document.getElementById('import-settings-form').style.display = 'block';
        
        // Weiter-Button aktivieren
        document.getElementById('settings-next').disabled = false;
      })
      .catch(error => {
        console.error('Fehler bei der Analyse:', error);
        
        // Fehlermeldung anzeigen
        document.getElementById('settings-loading').innerHTML = `
          <div class="error-icon">❌</div>
          <p>Fehler bei der Analyse: ${error.message}</p>
        `;
        
        // Formular trotzdem anzeigen und Weiter-Button aktivieren
        document.getElementById('import-settings-form').style.display = 'block';
        document.getElementById('settings-next').disabled = false;
      });
    
    // Tests laden und im Dropdown anzeigen
    loadAvailableTests();
  }
  
  /**
   * Registriert Event-Listener für den Einstellungs-Schritt
   */
  function registerSettingsEventListeners() {
    // Zurück-Button
    const backButton = document.getElementById('settings-back');
    if (backButton) {
      backButton.addEventListener('click', wordImportUI.showUploadStep);
    }
    
    // Weiter-Button
    const nextButton = document.getElementById('settings-next');
    if (nextButton) {
      nextButton.addEventListener('click', () => {
        // Einstellungen aus dem Formular übernehmen
        const settings = {
          questionDelimiter: document.getElementById('question-delimiter').value,
          answerDelimiter: document.getElementById('answer-delimiter').value,
          correctAnswerMarker: document.getElementById('correct-answer-marker').value,
          incorrectAnswerMarker: document.getElementById('incorrect-answer-marker').value,
          questionType: document.getElementById('question-type').value,
          createNewTest: document.querySelector('input[name="import-target"]:checked').value === 'new',
          targetTestId: document.getElementById('target-test').value
        };
        
        // Einstellungen aktualisieren
        wordImport.setImportSettings(settings);
        
        // Zur Vorschau wechseln
        showPreviewStep();
      });
    }
    
    // Ziel-Optionen
    const createNewTest = document.getElementById('create-new-test');
    const addToExisting = document.getElementById('add-to-existing');
    const existingTestSelection = document.getElementById('existing-test-selection');
    
    if (createNewTest && addToExisting && existingTestSelection) {
      createNewTest.addEventListener('change', () => {
        existingTestSelection.style.display = 'none';
      });
      
      addToExisting.addEventListener('change', () => {
        existingTestSelection.style.display = 'block';
      });
    }
  }
  
  /**
   * Lädt verfügbare Tests und zeigt sie im Dropdown an
   */
  function loadAvailableTests() {
    const targetTestSelect = document.getElementById('target-test');
    if (!targetTestSelect) return;
    
    // Tests aus dem TestBasicData-Modul laden, falls verfügbar
    let tests = [];
    
    if (typeof TestBasicData !== 'undefined' && TestBasicData.getAllTests) {
      tests = TestBasicData.getAllTests();
    }
    
    // Dropdown befüllen
    targetTestSelect.innerHTML = '';
    
    if (tests.length === 0) {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'Keine Tests verfügbar';
      option.disabled = true;
      targetTestSelect.appendChild(option);
      
      // Option "Neuen Test erstellen" auswählen
      const createNewTest = document.getElementById('create-new-test');
      if (createNewTest) {
        createNewTest.checked = true;
        
        // Auswahlfeld ausblenden
        const existingTestSelection = document.getElementById('existing-test-selection');
        if (existingTestSelection) {
          existingTestSelection.style.display = 'none';
        }
      }
    } else {
      tests.forEach(test => {
        const option = document.createElement('option');
        option.value = test.id;
        option.textContent = test.title || `Test ${test.id}`;
        targetTestSelect.appendChild(option);
      });
    }
  }
  
  /**
   * Zeigt den Vorschau-Schritt an
   */
  function showPreviewStep() {
    // Importstatus aktualisieren
    importStatus.step = 'preview';
    wordImportUI.updateProgressBar();
    
    // Container finden
    const container = document.querySelector('.import-content');
    if (!container) return;
    
    // Status anzeigen
    container.innerHTML = `
      <div class="preview-step">
        <div class="preview-info">
          <h3>Vorschau der erkannten Fragen</h3>
          <p>
            Überprüfen Sie die erkannten Fragen und wählen Sie aus, welche importiert werden sollen.
          </p>
        </div>
        
        <div id="preview-loading" class="preview-loading">
          <div class="loader"></div>
          <p>Fragen werden extrahiert...</p>
        </div>
        
        <div id="questions-preview" class="questions-preview" style="display: none;">
          <div class="preview-controls">
            <div class="preview-stats">
              <span id="selected-count">0</span> von <span id="total-count">0</span> Fragen ausgewählt
            </div>
            
            <div class="preview-actions">
              <button id="select-all" class="btn btn-outline btn-sm">Alle auswählen</button>
              <button id="deselect-all" class="btn btn-outline btn-sm">Alle abwählen</button>
            </div>
          </div>
          
          <div id="questions-list" class="questions-list">
            <!-- Wird dynamisch befüllt -->
          </div>
        </div>
        
        <div class="preview-actions">
          <button id="preview-back" class="btn btn-secondary">Zurück</button>
          <button id="preview-next" class="btn btn-primary" disabled>Importieren</button>
        </div>
      </div>
    `;
    
    // Event-Listener registrieren
    registerPreviewEventListeners();
    
    // Fragen extrahieren und anzeigen
    wordImport.processDocument()
      .then(result => {
        // Fragen im Status speichern
        importStatus.parsedQuestions = result.questions;
        importStatus.selectedQuestions = [...result.questions]; // Alle standardmäßig auswählen
        
        // Vorschau anzeigen
        showQuestionsPreview(result.questions);
        
        // Loading-Status ausblenden und Vorschau anzeigen
        document.getElementById('preview-loading').style.display = 'none';
        document.getElementById('questions-preview').style.display = 'block';
        
        // Weiter-Button aktivieren
        document.getElementById('preview-next').disabled = false;
      })
      .catch(error => {
        console.error('Fehler bei der Extraktion von Fragen:', error);
        
        // Fehlermeldung anzeigen
        document.getElementById('preview-loading').innerHTML = `
          <div class="error-icon">❌</div>
          <p>Fehler bei der Extraktion von Fragen: ${error.message}</p>
        `;
      });
  }
  
  /**
   * Registriert Event-Listener für den Vorschau-Schritt
   */
  function registerPreviewEventListeners() {
    // Zurück-Button
    const backButton = document.getElementById('preview-back');
    if (backButton) {
      backButton.addEventListener('click', showSettingsStep);
    }
    
    // Weiter-Button
    const nextButton = document.getElementById('preview-next');
    if (nextButton) {
      nextButton.addEventListener('click', () => {
        // Prüfen, ob Fragen ausgewählt wurden
        if (importStatus.selectedQuestions.length === 0) {
          NotificationSystem.showError('Bitte wählen Sie mindestens eine Frage aus.');
          return;
        }
        
        // Zum Import-Schritt wechseln
        showImportStep();
      });
    }
    
    // "Alle auswählen"-Button
    const selectAllButton = document.getElementById('select-all');
    if (selectAllButton) {
      selectAllButton.addEventListener('click', () => {
        // Alle Checkboxen auswählen
        const checkboxes = document.querySelectorAll('.question-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.checked = true;
        });
        
        // Status aktualisieren
        importStatus.selectedQuestions = [...importStatus.parsedQuestions];
        updateSelectedCount();
      });
    }
    
    // "Alle abwählen"-Button
    const deselectAllButton = document.getElementById('deselect-all');
    if (deselectAllButton) {
      deselectAllButton.addEventListener('click', () => {
        // Alle Checkboxen abwählen
        const checkboxes = document.querySelectorAll('.question-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.checked = false;
        });
        
        // Status aktualisieren
        importStatus.selectedQuestions = [];
        updateSelectedCount();
      });
    }
  }
  
  /**
   * Zeigt die Vorschau der extrahierten Fragen an
   * @param {Array} questions - Die extrahierten Fragen
   */
  function showQuestionsPreview(questions) {
    const questionsList = document.getElementById('questions-list');
    const totalCount = document.getElementById('total-count');
    const selectedCount = document.getElementById('selected-count');
    
    if (!questionsList || !totalCount || !selectedCount) return;
    
    // Zähler aktualisieren
    totalCount.textContent = questions.length;
    selectedCount.textContent = importStatus.selectedQuestions.length;
    
    // Liste leeren
    questionsList.innerHTML = '';
    
    // Keine Fragen gefunden
    if (questions.length === 0) {
      questionsList.innerHTML = `
        <div class="no-questions">
          <p>Keine Fragen gefunden. Bitte überprüfen Sie die Import-Einstellungen.</p>
        </div>
      `;
      return;
    }
    
    // Jede Frage anzeigen
    questions.forEach((question, index) => {
      const questionElement = document.createElement('div');
      questionElement.className = 'preview-question';
      questionElement.dataset.questionId = question.id;
      
      // Fragetyp-Anzeige
      const typeDisplay = getQuestionTypeDisplay(question.type);
      
      // HTML für Optionen generieren (falls vorhanden)
      let optionsHtml = '';
      if (question.options && question.options.length > 0) {
        optionsHtml = `
          <div class="question-options">
            <strong>Antwortoptionen:</strong>
            <ul>
              ${question.options.map(option => `
                <li class="${option.isCorrect ? 'correct-option' : ''}">
                  ${option.isCorrect ? '✓' : '○'} ${option.text}
                </li>
              `).join('')}
            </ul>
          </div>
        `;
      } else if (question.type === 'true_false') {
        optionsHtml = `
          <div class="question-options">
            <strong>Antwort:</strong>
            <div class="true-false-answer">
              ${question.correctAnswer === true ? 'Wahr' : 'Falsch'}
            </div>
          </div>
        `;
      } else if (question.answerText) {
        optionsHtml = `
          <div class="question-answer">
            <strong>Antwort:</strong>
            <div>${question.answerText}</div>
          </div>
        `;
      }
      
      // HTML für die Frage
      questionElement.innerHTML = `
        <div class="question-header">
          <label class="question-select">
            <input type="checkbox" class="question-checkbox" data-index="${index}" checked>
            <span>Frage ${index + 1}</span>
          </label>
          <div class="question-type">${typeDisplay}</div>
        </div>
        
        <div class="question-content">
          <div class="question-text">${question.text}</div>
          ${optionsHtml}
        </div>
      `;
      
      // Event-Listener für Checkbox hinzufügen
      const checkbox = questionElement.querySelector('.question-checkbox');
      if (checkbox) {
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            // Zur Auswahl hinzufügen
            importStatus.selectedQuestions.push(question);
          } else {
            // Aus der Auswahl entfernen
            importStatus.selectedQuestions = importStatus.selectedQuestions.filter(q => q.id !== question.id);
          }
          
          // Zähler aktualisieren
          updateSelectedCount();
        });
      }
      
      // Element zur Liste hinzufügen
      questionsList.appendChild(questionElement);
    });
  }
  
  /**
   * Aktualisiert den Zähler für ausgewählte Fragen
   */
  function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    if (selectedCount) {
      selectedCount.textContent = importStatus.selectedQuestions.length;
    }
    
    // Import-Button aktivieren/deaktivieren
    const importButton = document.getElementById('preview-next');
    if (importButton) {
      importButton.disabled = importStatus.selectedQuestions.length === 0;
    }
  }
  
  /**
   * Gibt die Anzeige für einen Fragetyp zurück
   * @param {string} type - Der Fragetyp
   * @returns {string} - Die Anzeige für den Fragetyp
   */
  function getQuestionTypeDisplay(type) {
    const typeDisplays = {
      multiple_choice: 'Multiple Choice',
      single_choice: 'Single Choice',
      true_false: 'Wahr/Falsch',
      text: 'Freitext',
      auto: 'Automatisch'
    };
    
    return typeDisplays[type] || 'Unbekannt';
  }
  
  // Platzhalter für Funktionen, die in Teil 3 implementiert werden
  function showImportStep() {
    console.log('showImportStep wird in Teil 3 implementiert');
    // Diese Funktion wird in Teil 3 implementiert
    if (typeof WordImportUI !== 'undefined' && WordImportUI.showImportStep) {
      WordImportUI.showImportStep();
    }
  }
  
  // Word-Import-UI-Modul erweitern
  window.WordImportUI.showSettingsStep = showSettingsStep;
  window.WordImportUI.showPreviewStep = showPreviewStep;
})();
/**
 * JS-Block 4.8.3: Word-Import UI Teil 3 - Import-Schritt und Styling
 * 
 * Dieser Teil implementiert den finalen Import-Schritt des Word-Import-Prozesses
 * und fügt das CSS-Styling für die gesamte Benutzeroberfläche hinzu.
 */

// Word-Import-UI-Modul - Teil 3
(function() {
  // Referenz auf das existierende WordImport-Modul
  const wordImport = window.WordImport;
  const wordImportUI = window.WordImportUI;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.1 und 4.8.2 laden.');
    return;
  }
  
  if (!wordImportUI) {
    console.error('WordImportUI-Modul nicht gefunden. Bitte zuerst JS-Block 4.8.3-Teil 1 und Teil 2 laden.');
    return;
  }
  
  // Import-Status aus Teil 1 verwenden
  const importStatus = wordImportUI.importStatus;
  
  /**
   * Zeigt den Import-Schritt an
   */
  function showImportStep() {
    // Importstatus aktualisieren
    importStatus.step = 'import';
    wordImportUI.updateProgressBar();
    
    // Container finden
    const container = document.querySelector('.import-content');
    if (!container) return;
    
    // Einstellungen holen
    const settings = wordImport.getImportSettings();
    
    // Status anzeigen
    container.innerHTML = `
      <div class="import-step">
        <div class="import-info">
          <h3>Fragen importieren</h3>
          <p>
            Sie haben ${importStatus.selectedQuestions.length} Fragen ausgewählt.
            Der Import wird nun durchgeführt.
          </p>
        </div>
        
        <div id="import-summary" class="import-summary">
          <div class="summary-section">
            <h4>Ziel</h4>
            <p id="target-info">
              ${settings.createNewTest ? 
                'Die Fragen werden in einen neuen Test importiert.' : 
                'Die Fragen werden einem bestehenden Test hinzugefügt.'}
            </p>
          </div>
          
          <div class="summary-section">
            <h4>Ausgewählte Fragen</h4>
            <ul class="summary-questions">
              ${importStatus.selectedQuestions.slice(0, 5).map((question, index) => `
                <li>${question.text.substring(0, 50)}${question.text.length > 50 ? '...' : ''}</li>
              `).join('')}
              ${importStatus.selectedQuestions.length > 5 ? 
                `<li class="more-questions">+ ${importStatus.selectedQuestions.length - 5} weitere Fragen</li>` : ''}
            </ul>
          </div>
        </div>
        
        <div id="import-progress" class="import-progress">
          <div class="progress-bar">
            <div class="progress-bar-inner" style="width: 0%"></div>
          </div>
          <p id="import-status">Bereit zum Import...</p>
        </div>
        
        <div class="import-actions">
          <button id="import-back" class="btn btn-secondary">Zurück</button>
          <button id="start-import" class="btn btn-primary">Import starten</button>
        </div>
      </div>
    `;
    
    // Event-Listener registrieren
    registerImportEventListeners();
  }
  
  /**
   * Registriert Event-Listener für den Import-Schritt
   */
  function registerImportEventListeners() {
    // Zurück-Button
    const backButton = document.getElementById('import-back');
    if (backButton) {
      backButton.addEventListener('click', wordImportUI.showPreviewStep);
    }
    
    // Import-Button
    const importButton = document.getElementById('start-import');
    if (importButton) {
      importButton.addEventListener('click', () => {
        // Button deaktivieren
        importButton.disabled = true;
        
        // Zurück-Button deaktivieren
        const backButton = document.getElementById('import-back');
        if (backButton) backButton.disabled = true;
        
        // Import starten
        startImport();
      });
    }
  }
  
  /**
   * Startet den Import-Prozess
   */
  function startImport() {
    // Einstellungen holen
    const settings = wordImport.getImportSettings();
    
    // Import-Status-Element
    const importStatus = document.getElementById('import-status');
    const progressBar = document.querySelector('.progress-bar-inner');
    
    // Fortschrittsbalken initialisieren
    if (progressBar) progressBar.style.width = '0%';
    
    // Status aktualisieren
    if (importStatus) importStatus.textContent = 'Import wird vorbereitet...';
    
    // Ziel-Test vorbereiten
    let targetTestId = null;
    
    if (settings.createNewTest) {
      // Neuen Test erstellen
      if (importStatus) importStatus.textContent = 'Neuer Test wird erstellt...';
      
      if (typeof TestBasicData !== 'undefined' && TestBasicData.createTest) {
        // Dateinamen als Titel verwenden
        const fileName = window.importStatus.file.name;
        const testTitle = fileName.replace(/\.docx$/, '');
        
        // Test erstellen
        const test = {
          title: testTitle,
          description: `Importiert aus ${fileName}`,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          questions: [] // Fragen werden später hinzugefügt
        };
        
        targetTestId = TestBasicData.createTest(test);
      }
    } else {
      // Bestehenden Test verwenden
      targetTestId = settings.targetTestId;
    }
    
    // Prüfen, ob ein Ziel-Test verfügbar ist
    if (!targetTestId) {
      if (importStatus) importStatus.textContent = 'Fehler: Kein Ziel-Test verfügbar.';
      NotificationSystem.showError('Fehler beim Import: Kein Ziel-Test verfügbar.');
      enableButtons();
      return;
    }
    
    // Ausgewählte Fragen importieren
    const questions = window.importStatus.selectedQuestions;
    const totalQuestions = questions.length;
    
    if (importStatus) importStatus.textContent = `0 von ${totalQuestions} Fragen importiert...`;
    
    // Fragen einzeln importieren (asynchron)
    importQuestionsSequentially(questions, targetTestId, 0, totalQuestions)
      .then(result => {
        // Import abgeschlossen
        if (progressBar) progressBar.style.width = '100%';
        
        if (importStatus) {
          importStatus.textContent = `Import abgeschlossen: ${result.successCount} von ${totalQuestions} Fragen erfolgreich importiert.`;
        }
        
        // Erfolg melden
        NotificationSystem.showSuccess(`Import abgeschlossen: ${result.successCount} von ${totalQuestions} Fragen erfolgreich importiert.`);
        
        // Buttons wieder aktivieren
        enableButtons();
        
        // "Fertig"-Button anzeigen
        const importActions = document.querySelector('.import-actions');
        if (importActions) {
          importActions.innerHTML = `
            <button id="view-test" class="btn btn-primary">Test anzeigen</button>
            <button id="import-new" class="btn btn-outline">Neuen Import starten</button>
          `;
          
          // Event-Listener für die neuen Buttons
          const viewTestButton = document.getElementById('view-test');
          if (viewTestButton) {
            viewTestButton.addEventListener('click', () => {
              // Zum Test navigieren
              if (typeof Navigation !== 'undefined' && Navigation.navigateTo) {
                Navigation.navigateTo('edit-test', { testId: targetTestId });
              } else {
                // Fallback: Seite neu laden
                window.location.href = `?page=edit-test&testId=${targetTestId}`;
              }
            });
          }
          
          const importNewButton = document.getElementById('import-new');
          if (importNewButton) {
            importNewButton.addEventListener('click', () => {
              // Import-Status zurücksetzen und von vorne beginnen
              wordImportUI.resetImportStatus();
              wordImportUI.initImportUI();
            });
          }
        }
      })
      .catch(error => {
        console.error('Fehler beim Import:', error);
        
        // Fehlermeldung anzeigen
        if (importStatus) {
          importStatus.textContent = `Fehler beim Import: ${error.message}`;
        }
        
        // Notification anzeigen
        NotificationSystem.showError('Fehler beim Import: ' + error.message);
        
        // Buttons wieder aktivieren
        enableButtons();
      });
  }
  
  /**
   * Importiert Fragen sequentiell in einen Test
   * @param {Array} questions - Die zu importierenden Fragen
   * @param {string} testId - Die ID des Ziel-Tests
   * @param {number} startIndex - Der Startindex für den Import
   * @param {number} total - Die Gesamtzahl der Fragen
   * @returns {Promise} - Promise mit dem Ergebnis des Imports
   */
  function importQuestionsSequentially(questions, testId, startIndex, total) {
    return new Promise((resolve, reject) => {
      // Ergebnis-Objekt
      const result = {
        successCount: 0,
        errorCount: 0,
        errors: []
      };
      
      // Rekursive Funktion zum Import einer Frage nach der anderen
      function importQuestion(index) {
        // Abbruchbedingung
        if (index >= questions.length) {
          resolve(result);
          return;
        }
        
        // Aktuelle Frage
        const question = questions[index];
        
        // Fortschritt aktualisieren
        const progress = Math.round((index / total) * 100);
        const progressBar = document.querySelector('.progress-bar-inner');
        const importStatus = document.getElementById('import-status');
        
        if (progressBar) progressBar.style.width = `${progress}%`;
        if (importStatus) importStatus.textContent = `${index} von ${total} Fragen importiert...`;
        
        // Frage zum Test hinzufügen
        if (typeof TestBasicData !== 'undefined' && TestBasicData.addQuestionToTest) {
          try {
            // Frage zum Test hinzufügen
            const success = TestBasicData.addQuestionToTest(testId, question);
            
            if (success) {
              result.successCount++;
            } else {
              result.errorCount++;
              result.errors.push({
                question: question,
                error: 'Fehler beim Hinzufügen der Frage zum Test'
              });
            }
            
            // Mit der nächsten Frage fortfahren
            setTimeout(() => {
              importQuestion(index + 1);
            }, 10); // Kleine Verzögerung für die UI-Aktualisierung
          } catch (error) {
            result.errorCount++;
            result.errors.push({
              question: question,
              error: error.message
            });
            
            // Trotz Fehler mit der nächsten Frage fortfahren
            setTimeout(() => {
              importQuestion(index + 1);
            }, 10);
          }
        } else {
          // TestBasicData-Modul nicht verfügbar
          reject(new Error('TestBasicData-Modul nicht verfügbar'));
        }
      }
      
      // Import starten
      importQuestion(startIndex);
    });
  }
  
  /**
   * Aktiviert die Import-Buttons wieder
   */
  function enableButtons() {
    const backButton = document.getElementById('import-back');
    const importButton = document.getElementById('start-import');
    
    if (backButton) backButton.disabled = false;
    if (importButton) importButton.disabled = false;
  }
  
  // Word-Import-UI-Modul erweitern
  window.WordImportUI.showImportStep = showImportStep;
  window.WordImportUI.startImport = startImport;
  
  // Stylesheet für den Word-Import hinzufügen
  const style = document.createElement('style');
  style.id = 'word-import-styles';
  style.textContent = `
    /* Import-Container */
    .import-container {
      padding: 1rem;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* Import-Header */
    .import-header {
      margin-bottom: 2rem;
    }
    
    /* Fortschritts-Anzeige */
    .import-progress-bar {
      display: flex;
      margin-bottom: 2rem;
      position: relative;
    }
    
    .import-progress-bar::before {
      content: '';
      position: absolute;
      top: 12px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #e0e0e0;
      z-index: 1;
    }
    
    .progress-step {
      flex: 1;
      text-align: center;
      position: relative;
      z-index: 2;
    }
    
    .step-number {
      width: 24px;
      height: 24px;
      line-height: 24px;
      border-radius: 50%;
      background-color: #e0e0e0;
      color: #666;
      margin: 0 auto 8px;
    }
    
    .step-label {
      font-size: 0.85rem;
      color: #666;
    }
    
    .progress-step.active .step-number {
      background-color: #00FFD0;
      color: #333;
    }
    
    .progress-step.active .step-label {
      color: #333;
      font-weight: bold;
    }
    
    .progress-step.completed .step-number {
      background-color: #00FFD0;
      color: #333;
    }
    
    /* Import-Inhalt */
    .import-content {
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 1.5rem;
    }
    
    /* Upload-Schritt */
    .upload-step {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .upload-instructions {
      margin-bottom: 1rem;
    }
    
    .file-format-info {
      background-color: #f5f5f5;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
    
    .file-format-info h4 {
      margin-top: 0;
    }
    
    .upload-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
    }
    
    .file-drop-zone {
      border: 2px dashed #ccc;
      border-radius: 4px;
      padding: 2rem;
      text-align: center;
      width: 100%;
      max-width: 500px;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    
    .file-drop-zone:hover, .file-drop-zone.drag-over {
      border-color: #00FFD0;
    }
    
    .upload-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      color: #999;
    }
    
    .upload-status {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    .success-icon {
      width: 40px;
      height: 40px;
      line-height: 40px;
      text-align: center;
      border-radius: 50%;
      background-color: #2ecc71;
      color: white;
      font-size: 1.5rem;
    }
    
    .error-icon {
      width: 40px;
      height: 40px;
      line-height: 40px;
      text-align: center;
      border-radius: 50%;
      background-color: #e74c3c;
      color: white;
      font-size: 1.5rem;
    }
    
    .upload-actions, .settings-actions, .preview-actions, .import-actions {
      display: flex;
      justify-content: space-between;
      margin-top: 1.5rem;
    }
    
    /* Einstellungs-Schritt */
    .settings-step {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .settings-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem;
    }
    
    .import-settings-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
    }
    
    .settings-section {
      margin-bottom: 1.5rem;
    }
    
    .form-hint {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.3rem;
    }
    
    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    /* Vorschau-Schritt */
    .preview-step {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .preview-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem;
    }
    
    .preview-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #f5f5f5;
      border-radius: 4px;
    }
    
    .preview-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .questions-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: 60vh;
      overflow-y: auto;
      padding: 0.5rem;
    }
    
    .preview-question {
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.8rem;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
    }
    
    .question-select {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
    }
    
    .question-content {
      padding: 1rem;
    }
    
    .question-text {
      margin-bottom: 1rem;
    }
    
    .question-options ul {
      list-style: none;
      padding-left: 1rem;
    }
    
    .question-options li {
      margin-bottom: 0.5rem;
    }
    
    .correct-option {
      color: #2ecc71;
    }
    
    .true-false-answer {
      font-weight: bold;
      padding: 0.5rem;
      background-color: rgba(46, 204, 113, 0.1);
      border-radius: 4px;
      display: inline-block;
    }
    
    .question-answer {
      margin-top: 1rem;
      padding: 0.5rem;
      background-color: #f9f9f9;
      border-radius: 4px;
    }
    
    .no-questions {
      text-align: center;
      padding: 2rem;
      color: #666;
    }
    
    /* Import-Schritt */
    .import-step {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .import-summary {
      background-color: #f5f5f5;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }
    
    .summary-section {
      margin-bottom: 1rem;
    }
    
    .summary-section h4 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }
    
    .summary-questions {
      list-style: none;
      padding-left: 0;
    }
    
    .summary-questions li {
      margin-bottom: 0.5rem;
      padding-left: 1rem;
      position: relative;
    }
    
    .summary-questions li::before {
      content: '•';
      position: absolute;
      left: 0;
    }
    
    .more-questions {
      color: #666;
      font-style: italic;
    }
    
    .import-progress {
      margin: 1.5rem 0;
    }
    
    .progress-bar {
      height: 10px;
      background-color: #eee;
      border-radius: 5px;
      margin-bottom: 0.5rem;
      overflow: hidden;
    }
    
    .progress-bar-inner {
      height: 100%;
      background-color: #00FFD0;
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Loader-Animation */
    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #00FFD0;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `;
  
  document.head.appendChild(style);
})();
/**
 * JS-Block 4.9.1: Word-Import - Datenintegration Teil 1 - Grundstruktur und Datenvalidierung
 * 
 * Dieses Modul implementiert die Datenintegration für den Word-Import.
 * Teil 1 umfasst die Grundstruktur für die Datenvalidierung und -transformation.
 */

// Word-Import Datenintegration - Teil 1
(function() {
  // Referenz auf das existierende WordImport-Modul
  const wordImport = window.WordImport;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8 laden.');
    return;
  }
  
  // Modul für die Datenintegration
  const DataIntegration = {
    // Konfiguration für die Datenintegration
    config: {
      // Maximale Anzahl an Antwortoptionen
      maxOptions: 10,
      // Minimale Textlänge für Fragen
      minQuestionLength: 3,
      // Maximale Textlänge für Fragen (0 = unbegrenzt)
      maxQuestionLength: 0,
      // Validierungsstufe (strict, normal, lenient)
      validationLevel: 'normal',
      // Automatische Korrekturen
      autoCorrections: true
    },
    
    /**
     * Setzt die Konfiguration für die Datenintegration
     * @param {Object} newConfig - Neue Konfigurationseinstellungen
     */
    setConfig: function(newConfig) {
      this.config = { ...this.config, ...newConfig };
      console.log('Datenintegrations-Konfiguration aktualisiert:', this.config);
    },
    
    /**
     * Validiert einen Fragenpool vor der Integration
     * @param {Array} questions - Array mit Fragen
     * @returns {Object} - Validierungsergebnis mit gültigen und ungültigen Fragen
     */
    validateQuestions: function(questions) {
      if (!Array.isArray(questions)) {
        throw new Error('Ungültiges Datenformat: Fragen müssen als Array vorliegen.');
      }
      
      const result = {
        valid: [],
        invalid: [],
        warnings: []
      };
      
      // Jede Frage validieren
      questions.forEach((question, index) => {
        // Validierungsergebnis für diese Frage
        const validationResult = this.validateQuestion(question);
        
        if (validationResult.isValid) {
          // Frage ist gültig, aber könnte Warnungen haben
          result.valid.push({
            question: validationResult.question, // Möglicherweise korrigierte Frage
            originalIndex: index
          });
          
          // Warnungen sammeln, falls vorhanden
          if (validationResult.warnings && validationResult.warnings.length > 0) {
            result.warnings.push({
              questionIndex: index,
              warnings: validationResult.warnings
            });
          }
        } else {
          // Ungültige Frage
          result.invalid.push({
            question: question,
            originalIndex: index,
            errors: validationResult.errors
          });
        }
      });
      
      return result;
    },
    
    /**
     * Validiert eine einzelne Frage
     * @param {Object} question - Die zu validierende Frage
     * @returns {Object} - Validierungsergebnis
     */
    validateQuestion: function(question) {
      const result = {
        isValid: true,
        question: { ...question }, // Kopie der Frage (für mögliche Korrekturen)
        errors: [],
        warnings: []
      };
      
      // Grundlegende Struktur prüfen
      if (!question || typeof question !== 'object') {
        result.isValid = false;
        result.errors.push('Ungültiges Frageformat: Frage muss ein Objekt sein.');
        return result;
      }
      
      // Pflichtfelder prüfen
      if (!question.id) {
        if (this.config.autoCorrections) {
          // ID generieren
          result.question.id = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
          result.warnings.push('ID fehlte und wurde automatisch generiert.');
        } else {
          result.isValid = false;
          result.errors.push('Pflichtfeld "id" fehlt.');
        }
      }
      
      // Fragetext prüfen
      if (!question.text || typeof question.text !== 'string') {
        result.isValid = false;
        result.errors.push('Fragetext fehlt oder ist kein String.');
      } else {
        // Fragetext-Länge prüfen
        if (question.text.trim().length < this.config.minQuestionLength) {
          if (this.config.validationLevel === 'strict') {
            result.isValid = false;
            result.errors.push(`Fragetext ist zu kurz (min. ${this.config.minQuestionLength} Zeichen).`);
          } else {
            result.warnings.push(`Fragetext ist sehr kurz (${question.text.trim().length} Zeichen).`);
          }
        }
        
        if (this.config.maxQuestionLength > 0 && question.text.length > this.config.maxQuestionLength) {
          if (this.config.autoCorrections) {
            result.question.text = question.text.substring(0, this.config.maxQuestionLength);
            result.warnings.push(`Fragetext wurde auf ${this.config.maxQuestionLength} Zeichen gekürzt.`);
          } else {
            result.warnings.push(`Fragetext ist sehr lang (${question.text.length} Zeichen).`);
          }
        }
      }
      
      // Fragetyp prüfen
      if (!question.type) {
        if (this.config.autoCorrections) {
          // Standardtyp setzen
          result.question.type = 'text';
          result.warnings.push('Fragetyp fehlte und wurde auf "text" gesetzt.');
        } else {
          result.isValid = false;
          result.errors.push('Pflichtfeld "type" fehlt.');
        }
      } else if (!['multiple_choice', 'single_choice', 'true_false', 'text'].includes(question.type)) {
        if (this.config.autoCorrections) {
          // Auf gültigen Typ korrigieren
          result.question.type = 'text';
          result.warnings.push(`Ungültiger Fragetyp "${question.type}" wurde auf "text" korrigiert.`);
        } else {
          result.isValid = false;
          result.errors.push(`Ungültiger Fragetyp "${question.type}".`);
        }
      }
      
      // Typenspezifische Validierung
      if (result.isValid) {
        // Für Multiple-Choice und Single-Choice
        if (['multiple_choice', 'single_choice'].includes(result.question.type)) {
          this.validateChoiceQuestion(result);
        }
        
        // Für Wahr/Falsch
        if (result.question.type === 'true_false') {
          this.validateTrueFalseQuestion(result);
        }
        
        // Für Freitext
        if (result.question.type === 'text') {
          this.validateTextQuestion(result);
        }
      }
      
      // Zeitstempel prüfen und bei Bedarf hinzufügen
      if (!question.createdAt) {
        result.question.createdAt = new Date().toISOString();
        result.warnings.push('Erstellungsdatum fehlte und wurde auf aktuelle Zeit gesetzt.');
      }
      
      if (!question.updatedAt) {
        result.question.updatedAt = new Date().toISOString();
        result.warnings.push('Aktualisierungsdatum fehlte und wurde auf aktuelle Zeit gesetzt.');
      }
      
      return result;
    },
    
    /**
     * Validiert eine Multiple-Choice oder Single-Choice Frage
     * @param {Object} result - Validierungsergebnis-Objekt
     */
    validateChoiceQuestion: function(result) {
      const question = result.question;
      
      // Optionen prüfen
      if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
        if (this.config.autoCorrections) {
          // Standard-Optionen erstellen
          result.question.options = [
            { text: 'Option 1', isCorrect: true },
            { text: 'Option 2', isCorrect: false }
          ];
          result.warnings.push('Keine Optionen gefunden, Standard-Optionen wurden erstellt.');
        } else {
          result.isValid = false;
          result.errors.push('Keine Antwortoptionen für Choice-Frage gefunden.');
          return;
        }
      }
      
      // Zu viele Optionen prüfen
      if (question.options.length > this.config.maxOptions) {
        if (this.config.autoCorrections) {
          result.question.options = question.options.slice(0, this.config.maxOptions);
          result.warnings.push(`Zu viele Optionen, auf ${this.config.maxOptions} begrenzt.`);
        } else {
          result.warnings.push(`Ungewöhnlich viele Optionen (${question.options.length}).`);
        }
      }
      
      // Jede Option prüfen
      let hasCorrectOption = false;
      
      for (let i = 0; i < result.question.options.length; i++) {
        const option = result.question.options[i];
        
        // Option-Struktur prüfen
        if (!option || typeof option !== 'object') {
          if (this.config.autoCorrections) {
            result.question.options[i] = { text: 'Leere Option', isCorrect: false };
            result.warnings.push(`Ungültige Option an Position ${i+1} wurde korrigiert.`);
          } else {
            result.isValid = false;
            result.errors.push(`Ungültige Option an Position ${i+1}.`);
            continue;
          }
        }
        
        // Text prüfen
        if (!option.text || typeof option.text !== 'string' || option.text.trim() === '') {
          if (this.config.autoCorrections) {
            result.question.options[i].text = `Option ${i+1}`;
            result.warnings.push(`Leerer Optionstext an Position ${i+1} wurde korrigiert.`);
          } else {
            result.isValid = false;
            result.errors.push(`Leerer Optionstext an Position ${i+1}.`);
          }
        }
        
        // isCorrect-Flag prüfen
        if (typeof option.isCorrect !== 'boolean') {
          if (this.config.autoCorrections) {
            result.question.options[i].isCorrect = false;
            result.warnings.push(`Fehlendes isCorrect-Flag an Position ${i+1} wurde auf "false" gesetzt.`);
          } else {
            result.isValid = false;
            result.errors.push(`Fehlendes isCorrect-Flag an Position ${i+1}.`);
          }
        }
        
        // Zählen, wie viele korrekte Optionen es gibt
        if (result.question.options[i].isCorrect) {
          hasCorrectOption = true;
        }
      }
      
      // Prüfen, ob mindestens eine korrekte Option existiert
      if (!hasCorrectOption) {
        if (this.config.autoCorrections) {
          // Erste Option als korrekt markieren
          if (result.question.options.length > 0) {
            result.question.options[0].isCorrect = true;
            result.warnings.push('Keine korrekte Option gefunden, erste Option wurde als korrekt markiert.');
          }
        } else {
          result.isValid = false;
          result.errors.push('Keine korrekte Option für Choice-Frage gefunden.');
        }
      }
      
      // Bei Single-Choice sicherstellen, dass nur eine Option korrekt ist
      if (result.question.type === 'single_choice') {
        const correctOptions = result.question.options.filter(o => o.isCorrect);
        
        if (correctOptions.length > 1) {
          if (this.config.autoCorrections) {
            // Alle bis auf die erste korrekte Option auf falsch setzen
            let foundFirst = false;
            
            for (let i = 0; i < result.question.options.length; i++) {
              if (result.question.options[i].isCorrect) {
                if (foundFirst) {
                  result.question.options[i].isCorrect = false;
                } else {
                  foundFirst = true;
                }
              }
            }
            
            result.warnings.push('Mehrere korrekte Optionen bei Single-Choice-Frage gefunden, nur die erste wurde behalten.');
          } else {
            result.warnings.push('Single-Choice-Frage hat mehrere korrekte Antworten.');
          }
        }
      }
    },
    
    /**
     * Validiert eine Wahr/Falsch-Frage
     * @param {Object} result - Validierungsergebnis-Objekt
     */
    validateTrueFalseQuestion: function(result) {
      const question = result.question;
      
      // correctAnswer-Flag prüfen
      if (typeof question.correctAnswer !== 'boolean') {
        if (this.config.autoCorrections) {
          // Standard-Antwort setzen
          result.question.correctAnswer = true;
          result.warnings.push('correctAnswer-Flag fehlte und wurde auf "true" gesetzt.');
        } else {
          result.isValid = false;
          result.errors.push('Pflichtfeld "correctAnswer" fehlt bei Wahr/Falsch-Frage.');
        }
      }
      
      // Optionen entfernen, falls vorhanden (für Wahr/Falsch nicht benötigt)
      if (question.options) {
        delete result.question.options;
        result.warnings.push('Optionen bei Wahr/Falsch-Frage wurden entfernt.');
      }
    },
    
    /**
     * Validiert eine Freitext-Frage
     * @param {Object} result - Validierungsergebnis-Objekt
     */
    validateTextQuestion: function(result) {
      const question = result.question;
      
      // Optionen entfernen, falls vorhanden (für Freitext nicht benötigt)
      if (question.options) {
        delete result.question.options;
        result.warnings.push('Optionen bei Freitext-Frage wurden entfernt.');
      }
      
      // Antworttext prüfen (optional)
      if (question.answerText && typeof question.answerText !== 'string') {
        if (this.config.autoCorrections) {
          result.question.answerText = String(question.answerText);
          result.warnings.push('Antworttext wurde in String konvertiert.');
        } else {
          result.warnings.push('Antworttext ist kein String.');
        }
      }
    }
  };
  
  // Modul für Word-Import erweitern
  wordImport.DataIntegration = DataIntegration;
  
  // Modul auch global zugänglich machen
  window.WordImportDataIntegration = DataIntegration;
})();
/**
 * JS-Block 4.9.2: Word-Import - Datenintegration Teil 2 - Transformation und Anpassung
 * 
 * Dieses Modul erweitert die Datenintegration für den Word-Import um Funktionen
 * zur Transformation und Anpassung der importierten Daten.
 */

// Word-Import Datenintegration - Teil 2
(function() {
  // Referenz auf das existierende WordImport-Modul und DataIntegration
  const wordImport = window.WordImport;
  const dataIntegration = window.WordImportDataIntegration;
  
  if (!wordImport) {
    console.error('WordImport-Modul nicht gefunden. Bitte zuerst JS-Block 4.8 laden.');
    return;
  }
  
  if (!dataIntegration) {
    console.error('DataIntegration-Modul nicht gefunden. Bitte zuerst JS-Block 4.9.1 laden.');
    return;
  }
  
  /**
   * Bereitet einen Fragenpool für die Integration in einen Test vor
   * @param {Array} questions - Array mit Fragen
   * @param {Object} options - Optionen für die Vorbereitung
   * @returns {Object} - Ergebnis der Vorbereitung
   */
  dataIntegration.prepareQuestionsForTest = function(questions, options = {}) {
    // Optionen mit Standardwerten
    const prepOptions = {
      regenerateIds: options.regenerateIds ?? false,
      assignCategories: options.assignCategories ?? true,
      normalizeText: options.normalizeText ?? true,
      assignDifficulty: options.assignDifficulty ?? false,
      defaultCategory: options.defaultCategory || 'Importiert',
      defaultDifficulty: options.defaultDifficulty || 'mittel'
    };
    
    // Validierung durchführen
    const validation = this.validateQuestions(questions);
    
    // Aufbereitete Fragen
    const preparedQuestions = [];
    
    // Nur gültige Fragen verarbeiten
    validation.valid.forEach(item => {
      const question = { ...item.question };
      
      // IDs neu generieren, falls gewünscht
      if (prepOptions.regenerateIds) {
        question.id = 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
      }
      
      // Text normalisieren
      if (prepOptions.normalizeText) {
        question.text = this.normalizeText(question.text);
        
        // Auch Antworttexte normalisieren
        if (question.options && Array.isArray(question.options)) {
          question.options.forEach(option => {
            option.text = this.normalizeText(option.text);
          });
        }
        
        if (question.answerText) {
          question.answerText = this.normalizeText(question.answerText);
        }
      }
      
      // Kategorie zuweisen
      if (prepOptions.assignCategories && !question.category) {
        question.category = this.detectCategory(question) || prepOptions.defaultCategory;
      }
      
      // Schwierigkeitsgrad zuweisen
      if (prepOptions.assignDifficulty && !question.difficulty) {
        question.difficulty = this.estimateDifficulty(question) || prepOptions.defaultDifficulty;
      }
      
      // Weitere Standardfelder hinzufügen
      question.updatedAt = new Date().toISOString();
      question.importedFrom = 'word';
      
      // Aufbereitete Frage zum Ergebnis hinzufügen
      preparedQuestions.push(question);
    });
    
    return {
      preparedQuestions: preparedQuestions,
      invalidQuestions: validation.invalid,
      warnings: validation.warnings
    };
  };
  
  /**
   * Normalisiert einen Text (entfernt überflüssige Leerzeichen, korrigiert Zeichensetzung, etc.)
   * @param {string} text - Der zu normalisierende Text
   * @returns {string} - Der normalisierte Text
   */
  dataIntegration.normalizeText = function(text) {
    if (!text || typeof text !== 'string') {
      return text;
    }
    
    let normalized = text;
    
    // Mehrfache Leerzeichen entfernen
    normalized = normalized.replace(/\s+/g, ' ');
    
    // Führende und nachfolgende Leerzeichen entfernen
    normalized = normalized.trim();
    
    // Sicherstellen, dass der Text mit einem Großbuchstaben beginnt
    if (normalized.length > 0) {
      normalized = normalized.charAt(0).toUpperCase() + normalized.slice(1);
    }
    
    // Sicherstellen, dass der Text mit einem Satzzeichen endet
    const lastChar = normalized.charAt(normalized.length - 1);
    const endPunctuation = ['.', '?', '!'];
    
    if (!endPunctuation.includes(lastChar) && normalized.length > 0) {
      // Keine Endung hinzufügen, wenn der Text mit Anführungszeichen oder Klammern endet
      const skipChars = ['"', "'", ')', ']', '}'];
      if (!skipChars.includes(lastChar)) {
        if (normalized.endsWith('?') || normalized.includes('?') && !normalized.includes('.')) {
          normalized += '?';
        } else {
          normalized += '.';
        }
      }
    }
    
    return normalized;
  };
  
  /**
   * Erkennt die Kategorie einer Frage basierend auf dem Inhalt
   * @param {Object} question - Die Frage, deren Kategorie erkannt werden soll
   * @returns {string|null} - Die erkannte Kategorie oder null, wenn keine erkannt wurde
   */
  dataIntegration.detectCategory = function(question) {
    if (!question || !question.text) {
      return null;
    }
    
    const text = question.text.toLowerCase();
    
    // Beispielhafte Kategorie-Erkennung basierend auf Schlüsselwörtern
    const categoryPatterns = [
      { keywords: ['mathe', 'rechnen', 'formel', 'gleichung', 'zahl', 'addition', 'subtraktion', 'multiplikation', 'division'], category: 'Mathematik' },
      { keywords: ['deutsch', 'grammatik', 'rechtschreibung', 'satz', 'literatur', 'gedicht', 'wort', 'sprache'], category: 'Deutsch' },
      { keywords: ['englisch', 'vocabulary', 'grammar', 'english', 'tense', 'word', 'language'], category: 'Englisch' },
      { keywords: ['geschichte', 'historisch', 'vergangenheit', 'krieg', 'politik', 'ereignis', 'jahr'], category: 'Geschichte' },
      { keywords: ['physik', 'kraft', 'energie', 'elektrizität', 'magnetismus', 'mechanik', 'optik'], category: 'Physik' },
      { keywords: ['chemie', 'element', 'verbindung', 'reaktion', 'formel', 'molekül', 'atom'], category: 'Chemie' },
      { keywords: ['biologie', 'lebewesen', 'pflanze', 'tier', 'körper', 'organ', 'zelle'], category: 'Biologie' },
      { keywords: ['informatik', 'computer', 'programmierung', 'software', 'hardware', 'algorithmus', 'daten'], category: 'Informatik' },
      { keywords: ['wirtschaft', 'ökonomie', 'finanzen', 'markt', 'unternehmen', 'handel', 'geld'], category: 'Wirtschaft' },
      { keywords: ['geographie', 'erdkunde', 'land', 'kontinent', 'stadt', 'fluss', 'gebirge'], category: 'Geographie' },
      { keywords: ['musik', 'instrument', 'note', 'ton', 'melodie', 'rhythmus', 'komponist'], category: 'Musik' },
      { keywords: ['kunst', 'bild', 'gemälde', 'skulptur', 'farbe', 'stil', 'künstler'], category: 'Kunst' },
      { keywords: ['sport', 'spieler', 'mannschaft', 'ball', 'wettkampf', 'olympia', 'turnier'], category: 'Sport' },
      { keywords: ['immobilien', 'haus', 'wohnung', 'grundstück', 'miete', 'kauf', 'eigentum'], category: 'Immobilien' }
    ];
    
    // Text nach Schlüsselwörtern durchsuchen
    for (const pattern of categoryPatterns) {
      for (const keyword of pattern.keywords) {
        if (text.includes(keyword)) {
          return pattern.category;
        }
      }
    }
    
    // Keine passende Kategorie gefunden
    return null;
  };
  
  /**
   * Schätzt den Schwierigkeitsgrad einer Frage
   * @param {Object} question - Die Frage, deren Schwierigkeit geschätzt werden soll
   * @returns {string} - Der geschätzte Schwierigkeitsgrad ('leicht', 'mittel', 'schwer')
   */
  dataIntegration.estimateDifficulty = function(question) {
    if (!question) {
      return 'mittel';
    }
    
    // Punkteberechnung für die Schwierigkeit
    let difficultyScore = 0;
    
    // Länge des Fragetexts berücksichtigen
    if (question.text) {
      const textLength = question.text.length;
      
      if (textLength < 50) {
        difficultyScore += 1; // Kurze Fragen sind tendenziell leichter
      } else if (textLength > 150) {
        difficultyScore += 3; // Lange Fragen sind tendenziell schwerer
      } else {
        difficultyScore += 2; // Mittlere Länge
      }
      
      // Komplexität des Textes basierend auf Schlüsselwörtern
      const complexityTerms = ['analysieren', 'bewerten', 'erklären', 'begründen', 'vergleichen', 'interpretieren', 'diskutieren'];
      const complexityCount = complexityTerms.filter(term => question.text.toLowerCase().includes(term)).length;
      difficultyScore += complexityCount;
      
      // Anzahl der Fragezeichen
      const questionMarkCount = (question.text.match(/\?/g) || []).length;
      if (questionMarkCount > 1) {
        difficultyScore += 1; // Mehrere Fragezeichen deuten auf komplexere Fragen hin
      }
    }
    
    // Fragetyp berücksichtigen
    if (question.type === 'multiple_choice') {
      difficultyScore += 2; // Multiple-Choice tendenziell mittelschwer
    } else if (question.type === 'single_choice') {
      difficultyScore += 1; // Single-Choice tendenziell leichter
    } else if (question.type === 'true_false') {
      difficultyScore += 0; // Wahr/Falsch tendenziell am leichtesten
    } else if (question.type === 'text') {
      difficultyScore += 3; // Freitext tendenziell am schwersten
    }
    
    // Bei Choice-Fragen: Anzahl der Optionen berücksichtigen
    if (['multiple_choice', 'single_choice'].includes(question.type) && question.options) {
      if (question.options.length > 4) {
        difficultyScore += 1; // Mehr Optionen machen die Frage schwerer
      }
    }
    
    // Gesamtwertung in Schwierigkeitsgrad umwandeln
    if (difficultyScore <= 3) {
      return 'leicht';
    } else if (difficultyScore <= 6) {
      return 'mittel';
    } else {
      return 'schwer';
    }
  };
  
  /**
   * Erzeugt Metadaten für einen Test basierend auf importierten Fragen
   * @param {Array} questions - Array mit Fragen
   * @param {Object} baseMetadata - Basis-Metadaten für den Test
   * @returns {Object} - Die Testmetadaten
   */
  dataIntegration.generateTestMetadata = function(questions, baseMetadata = {}) {
    if (!Array.isArray(questions) || questions.length === 0) {
      return baseMetadata;
    }
    
    // Basis-Metadaten mit Standardwerten
    const metadata = {
      title: baseMetadata.title || 'Importierter Test',
      description: baseMetadata.description || 'Aus Word importierter Test',
      createdAt: baseMetadata.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      questionCount: questions.length,
      estimatedDuration: Math.max(5, Math.ceil(questions.length * 1.5)), // 1,5 Min pro Frage, mindestens 5 Min
      ...baseMetadata
    };
    
    // Kategorien aus den Fragen extrahieren
    const categories = {};
    
    questions.forEach(question => {
      if (question.category) {
        categories[question.category] = (categories[question.category] || 0) + 1;
      }
    });
    
    // Hauptkategorie bestimmen (häufigste Kategorie)
    let mainCategory = null;
    let maxCount = 0;
    
    for (const [category, count] of Object.entries(categories)) {
      if (count > maxCount) {
        maxCount = count;
        mainCategory = category;
      }
    }
    
    if (mainCategory) {
      metadata.mainCategory = mainCategory;
    }
    
    // Array mit allen Kategorien
    metadata.categories = Object.keys(categories);
    
    // Schwierigkeitsverteilung
    const difficulties = { leicht: 0, mittel: 0, schwer: 0 };
    
    questions.forEach(question => {
      if (question.difficulty && difficulties[question.difficulty] !== undefined) {
        difficulties[question.difficulty]++;
      } else {
        difficulties.mittel++; // Standardwert
      }
    });
    
    metadata.difficultyDistribution = difficulties;
    
    // Durchschnittliche Schwierigkeit
    const totalWeight = difficulties.leicht * 1 + difficulties.mittel * 2 + difficulties.schwer * 3;
    const avgDifficulty = totalWeight / questions.length;
    
    if (avgDifficulty < 1.67) {
      metadata.difficulty = 'leicht';
    } else if (avgDifficulty < 2.33) {
      metadata.difficulty = 'mittel';
    } else {
      metadata.difficulty = 'schwer';
    }
    
    // Testtypen nach Fragetypen
    const questionTypes = {};
    
    questions.forEach(question => {
      if (question.type) {
        questionTypes[question.type] = (questionTypes[question.type] || 0) + 1;
      }
    });
    
    metadata.questionTypes = questionTypes;
    
    // Dominierender Fragetyp bestimmen
    let mainType = null;
    maxCount = 0;
    
    for (const [type, count] of Object.entries(questionTypes)) {
      if (count > maxCount) {
        maxCount = count;
        mainType = type;
      }
    }
    
    metadata.mainQuestionType = mainType;
    
    // Import-Quelle vermerken
    metadata.importSource = 'word';
    
    return metadata;
  };
  
  /**
   * Erstellt einen neuen Test mit den importierten Fragen
   * @param {Array} questions - Array mit Fragen
   * @param {Object} metadata - Metadaten für den Test
   * @returns {string|null} - Die ID des erstellten Tests oder null bei Fehler
   */
  dataIntegration.createTest = function(questions, metadata = {}) {
    if (!Array.isArray(questions) || questions.length === 0) {
      console.error('Keine Fragen zum Erstellen des Tests vorhanden.');
      return null;
    }
    
    // TestBasicData-Modul prüfen
    if (typeof TestBasicData === 'undefined' || !TestBasicData.createTest) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return null;
    }
    
    // Fragen vorbereiten
    const prepResult = this.prepareQuestionsForTest(questions);
    const preparedQuestions = prepResult.preparedQuestions;
    
    if (preparedQuestions.length === 0) {
      console.error('Keine gültigen Fragen zum Erstellen des Tests vorhanden.');
      return null;
    }
    
    // Metadaten erzeugen
    const testMetadata = this.generateTestMetadata(preparedQuestions, metadata);
    
    // Test erstellen
    const testData = {
      ...testMetadata,
      questions: preparedQuestions
    };
    
    try {
      const testId = TestBasicData.createTest(testData);
      console.log(`Test mit ID ${testId} und ${preparedQuestions.length} Fragen erstellt.`);
      return testId;
    } catch (error) {
      console.error('Fehler beim Erstellen des Tests:', error);
      return null;
    }
  };
  
  /**
   * Fügt importierte Fragen zu einem bestehenden Test hinzu
   * @param {string} testId - Die ID des Tests
   * @param {Array} questions - Array mit Fragen
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  dataIntegration.addQuestionsToTest = function(testId, questions) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return false;
    }
    
    if (!Array.isArray(questions) || questions.length === 0) {
      console.error('Keine Fragen zum Hinzufügen vorhanden.');
      return false;
    }
    
    // TestBasicData-Modul prüfen
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById || !TestBasicData.updateTest) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return false;
    }
    
    // Test laden
    const test = TestBasicData.getTestById(testId);
    if (!test) {
      console.error('Test nicht gefunden:', testId);
      return false;
    }
    
    // Fragen vorbereiten
    const prepResult = this.prepareQuestionsForTest(questions);
    const preparedQuestions = prepResult.preparedQuestions;
    
    if (preparedQuestions.length === 0) {
      console.error('Keine gültigen Fragen zum Hinzufügen vorhanden.');
      return false;
    }
    
    // Bestehende Fragen-Array erstellen, falls noch nicht vorhanden
    if (!test.questions) {
      test.questions = [];
    }
    
    // Fragen hinzufügen
    test.questions = [...test.questions, ...preparedQuestions];
    
    // Anzahl der Fragen aktualisieren
    test.questionCount = test.questions.length;
    
    // Aktualisierungsdatum setzen
    test.updatedAt = new Date().toISOString();
    
    // Test aktualisieren
    try {
      const success = TestBasicData.updateTest(testId, {
        questions: test.questions,
        questionCount: test.questionCount,
        updatedAt: test.updatedAt
      });
      
      if (success) {
        console.log(`${preparedQuestions.length} Fragen zu Test ${testId} hinzugefügt.`);
      }
      
      return success;
    } catch (error) {
      console.error('Fehler beim Aktualisieren des Tests:', error);
      return false;
    }
  };
})();
/**
 * JS-Block 4.9.3: Word-Import - Datenintegration Teil 3 - Spezielle Formate und UI-Integration
 * 
 * Dieser Teil erweitert die Datenintegration um Funktionen für spezielle Formatierungen
 * und die Integration mit der Benutzeroberfläche.
 */

// Word-Import Datenintegration - Teil 3
(function() {
  // Referenz auf die existierenden Module
  const wordImport = window.WordImport;
  const wordImportUI = window.WordImportUI;
  const dataIntegration = window.WordImportDataIntegration;
  
  if (!wordImport || !dataIntegration) {
    console.error('WordImport oder DataIntegration nicht gefunden. Bitte zuerst JS-Block 4.8 und 4.9.1-2 laden.');
    return;
  }
  
  /**
   * Erkennt und konvertiert spezielle Formatierungen im Text
   * @param {string} text - Der zu konvertierende Text
   * @returns {string} - Der Text mit konvertierten Formatierungen
   */
  dataIntegration.convertSpecialFormats = function(text) {
    if (!text || typeof text !== 'string') {
      return text;
    }
    
    let converted = text;
    
    // Konvertiere Markdown-ähnliche Formatierungen in HTML
    
    // Fett: **Text** oder __Text__
    converted = converted.replace(/\*\*(.*?)\*\*|__(.*?)__/g, '<strong>$1$2</strong>');
    
    // Kursiv: *Text* oder _Text_
    converted = converted.replace(/\*(.*?)\*|_(.*?)_/g, '<em>$1$2</em>');
    
    // Unterstrichen: ++Text++
    converted = converted.replace(/\+\+(.*?)\+\+/g, '<u>$1</u>');
    
    // Durchgestrichen: ~~Text~~
    converted = converted.replace(/~~(.*?)~~/g, '<s>$1</s>');
    
    // Hervorhebungen (Highlighter): ==Text==
    converted = converted.replace(/==(.*?)==/g, '<mark>$1</mark>');
    
    // Überschriften: # Überschrift (nur am Anfang der Zeile)
    converted = converted.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
    converted = converted.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
    converted = converted.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
    
    // Listen (nur einfache Listenformate)
    // Ungeordnete Listen: - Item oder * Item
    converted = converted.replace(/^[*\-] (.*?)$/gm, '<li>$1</li>');
    
    // Nummerierte Listen: 1. Item, 2. Item usw.
    converted = converted.replace(/^\d+\. (.*?)$/gm, '<li>$1</li>');
    
    // Listen in <ul> oder <ol> zusammenfassen
    // (einfache Version, funktioniert nur für aufeinanderfolgende Listeneinträge)
    converted = converted.replace(/<li>([^<]+)<\/li>(\s*<li>[^<]+<\/li>)+/g, '<ul>$&</ul>');
    
    // Links: [Text](URL)
    converted = converted.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
    
    // Code: `code`
    converted = converted.replace(/`(.*?)`/g, '<code>$1</code>');
    
    // Blockzitat: > Text
    converted = converted.replace(/^> (.*?)$/gm, '<blockquote>$1</blockquote>');
    
    // Horizontale Linie: --- oder ***
    converted = converted.replace(/^(\-{3,}|\*{3,})$/gm, '<hr>');
    
    return converted;
  };
  
  /**
   * Erkennt und extrahiert Medienverweise aus dem Text
   * @param {string} text - Der zu analysierende Text
   * @returns {Object} - Objekt mit dem bereinigten Text und gefundenen Medienverweisen
   */
  dataIntegration.extractMediaReferences = function(text) {
    if (!text || typeof text !== 'string') {
      return { text, mediaRefs: [] };
    }
    
    const mediaRefs = [];
    let cleanedText = text;
    
    // Bildverweise erkennen: ![Beschreibung](URL)
    const imagePattern = /!\[(.*?)\]\((.*?)\)/g;
    let match;
    
    while ((match = imagePattern.exec(text)) !== null) {
      mediaRefs.push({
        type: 'image',
        description: match[1],
        url: match[2]
      });
      
      // Bildverweis im Text mit Platzhalter ersetzen
      cleanedText = cleanedText.replace(match[0], `[Bild: ${match[1]}]`);
    }
    
    // Video-/Audio-Verweise erkennen: ![Video: Titel](URL) oder ![Audio: Titel](URL)
    const mediaPattern = /!\[(Video|Audio): (.*?)\]\((.*?)\)/g;
    
    while ((match = mediaPattern.exec(text)) !== null) {
      mediaRefs.push({
        type: match[1].toLowerCase(),
        description: match[2],
        url: match[3]
      });
      
      // Medienverweis im Text mit Platzhalter ersetzen
      cleanedText = cleanedText.replace(match[0], `[${match[1]}: ${match[2]}]`);
    }
    
    return {
      text: cleanedText,
      mediaRefs
    };
  };
  
  /**
   * Extrahiert Schlüsselwörter aus einem Text
   * @param {string} text - Der zu analysierende Text
   * @param {number} maxKeywords - Maximale Anzahl an Schlüsselwörtern
   * @returns {string[]} - Array mit Schlüsselwörtern
   */
  dataIntegration.extractKeywords = function(text, maxKeywords = 5) {
    if (!text || typeof text !== 'string') {
      return [];
    }
    
    // Text in Kleinbuchstaben umwandeln und in Wörter aufteilen
    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    
    // Stopwörter (Wörter, die ignoriert werden sollen)
    const stopWords = [
      // Deutsche Stopwörter
      'der', 'die', 'das', 'den', 'dem', 'ein', 'eine', 'einer', 'eines', 'und',
      'oder', 'aber', 'wenn', 'als', 'an', 'am', 'in', 'im', 'auf', 'ist', 'sind',
      'war', 'waren', 'wird', 'werden', 'wurde', 'wurden', 'hat', 'haben', 'hatte',
      'hatten', 'kann', 'können', 'denn', 'weil', 'mit', 'zu', 'zum', 'zur', 'für',
      'von', 'vor', 'nach', 'über', 'unter', 'um', 'bei', 'bis', 'nicht', 'nur',
      'so', 'wie', 'auch', 'sehr', 'oft', 'immer', 'wieder', 'mehr', 'weniger',
      
      // Englische Stopwörter
      'the', 'a', 'an', 'and', 'or', 'but', 'if', 'as', 'at', 'in', 'on', 'is', 'are',
      'was', 'were', 'will', 'be', 'has', 'have', 'had', 'can', 'could', 'for',
      'from', 'to', 'of', 'by', 'about', 'with', 'not', 'only', 'so', 'such', 'how',
      'also', 'very', 'often', 'always', 'again', 'more', 'less'
    ];
    
    // Wörter zählen (ohne Stopwörter)
    const wordCounts = {};
    
    words.forEach(word => {
      // Mindestlänge 3 Zeichen und nicht in Stopwörtern enthalten
      if (word.length >= 3 && !stopWords.includes(word)) {
        wordCounts[word] = (wordCounts[word] || 0) + 1;
      }
    });
    
    // Nach Häufigkeit sortieren und die häufigsten Wörter zurückgeben
    return Object.entries(wordCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, maxKeywords)
      .map(entry => entry[0]);
  };
  
  /**
   * Erkennt Fragen mit Formeln und bereitet sie speziell auf
   * @param {Object} question - Die zu analysierende Frage
   * @returns {Object} - Die aufbereitete Frage
   */
  dataIntegration.processFormulas = function(question) {
    if (!question || !question.text) {
      return question;
    }
    
    const processedQuestion = { ...question };
    
    // Einfache Formel-Muster erkennen (z.B. $formel$ oder $$formel$$)
    const hasSingleFormula = question.text.match(/\$([^$]+)\$/g);
    const hasBlockFormula = question.text.match(/\$\$([^$]+)\$\$/g);
    
    if (hasSingleFormula || hasBlockFormula) {
      // Formel-Flag setzen
      processedQuestion.hasFormulas = true;
      
      // Formeln in LaTeX/MathJax-Format konvertieren
      let processedText = processedQuestion.text;
      
      // Blockformeln ($$...$$) unverändert lassen, da sie bereits im richtigen Format sind
      
      // Inline-Formeln ($...$) unverändert lassen, da sie bereits im richtigen Format sind
      
      processedQuestion.text = processedText;
      
      // Bei Antwortoptionen ebenfalls Formeln verarbeiten
      if (processedQuestion.options && Array.isArray(processedQuestion.options)) {
        processedQuestion.options.forEach(option => {
          const hasSingleFormula = option.text.match(/\$([^$]+)\$/g);
          const hasBlockFormula = option.text.match(/\$\$([^$]+)\$\$/g);
          
          if (hasSingleFormula || hasBlockFormula) {
            // Formel-Flag setzen
            option.hasFormulas = true;
          }
        });
      }
    }
    
    return processedQuestion;
  };
  
  /**
   * Erstellt Tags für eine Frage basierend auf dem Inhalt
   * @param {Object} question - Die Frage, für die Tags erstellt werden sollen
   * @param {string[]} existingTags - Bereits vorhandene Tags, falls vorhanden
   * @returns {string[]} - Array mit Tags
   */
  dataIntegration.generateTags = function(question, existingTags = []) {
    if (!question) {
      return existingTags;
    }
    
    // Set für Tags (um Duplikate zu vermeiden)
    const tagSet = new Set(existingTags);
    
    // Fragetyp als Tag
    if (question.type) {
      const typeTagMap = {
        'multiple_choice': 'Multiple-Choice',
        'single_choice': 'Single-Choice',
        'true_false': 'Wahr-Falsch',
        'text': 'Freitext'
      };
      
      if (typeTagMap[question.type]) {
        tagSet.add(typeTagMap[question.type]);
      }
    }
    
    // Kategorie als Tag
    if (question.category) {
      tagSet.add(question.category);
    }
    
    // Schwierigkeitsgrad als Tag
    if (question.difficulty) {
      tagSet.add(question.difficulty);
    }
    
    // Besondere Eigenschaften als Tags
    if (question.hasFormulas) {
      tagSet.add('Formeln');
    }
    
    if (question.mediaRefs && question.mediaRefs.length > 0) {
      tagSet.add('Medien');
      
      // Spezifische Medientypen
      question.mediaRefs.forEach(ref => {
        if (ref.type === 'image') tagSet.add('Bilder');
        if (ref.type === 'video') tagSet.add('Videos');
        if (ref.type === 'audio') tagSet.add('Audio');
      });
    }
    
    // Import-Quelle als Tag
    tagSet.add('Word-Import');
    
    // Schlüsselwörter aus dem Text extrahieren
    if (question.text) {
      const keywords = this.extractKeywords(question.text, 3);
      keywords.forEach(keyword => {
        // Ersten Buchstaben groß schreiben für bessere Lesbarkeit
        const formattedKeyword = keyword.charAt(0).toUpperCase() + keyword.slice(1);
        tagSet.add(formattedKeyword);
      });
    }
    
    // Set in Array umwandeln
    return Array.from(tagSet);
  };
  
  /**
   * Integriert die Datenverarbeitung in die Word-Import-UI
   */
  dataIntegration.integrateWithUI = function() {
    // Prüfen, ob die UI-Module vorhanden sind
    if (!wordImportUI) {
      console.error('WordImportUI-Modul nicht gefunden. UI-Integration nicht möglich.');
      return;
    }
    
    // Original-Funktionen für Import-Prozess referenzieren
    const originalStartImport = wordImportUI.startImport;
    
    // Funktion zum Starten des Imports überschreiben
    wordImportUI.startImport = function() {
      // Status-Element für Import
      const importStatus = document.getElementById('import-status');
      
      // Zusätzlichen Verarbeitungsschritt anzeigen
      if (importStatus) {
        importStatus.textContent = 'Daten werden verarbeitet und optimiert...';
      }
      
      // Ausgewählte Fragen abrufen
      const selectedQuestions = wordImportUI.importStatus.selectedQuestions;
      
      // Fragen verarbeiten
      try {
        // Verarbeitung für jede Frage durchführen
        const processedQuestions = selectedQuestions.map(question => {
          // Kopie der Frage erstellen
          let processedQuestion = { ...question };
          
          // Spezielle Formate konvertieren
          if (processedQuestion.text) {
            processedQuestion.text = dataIntegration.convertSpecialFormats(processedQuestion.text);
          }
          
          // Medienverweise extrahieren
          if (processedQuestion.text) {
            const mediaResult = dataIntegration.extractMediaReferences(processedQuestion.text);
            processedQuestion.text = mediaResult.text;
            
            if (mediaResult.mediaRefs.length > 0) {
              processedQuestion.mediaRefs = mediaResult.mediaRefs;
            }
          }
          
          // Formeln verarbeiten
          processedQuestion = dataIntegration.processFormulas(processedQuestion);
          
          // Tags generieren
          processedQuestion.tags = dataIntegration.generateTags(processedQuestion, processedQuestion.tags || []);
          
          return processedQuestion;
        });
        
        // Verarbeitete Fragen im Import-Status speichern
        wordImportUI.importStatus.selectedQuestions = processedQuestions;
        
        // Original-Import-Funktion aufrufen
        if (originalStartImport) {
          originalStartImport.call(wordImportUI);
        }
      } catch (error) {
        console.error('Fehler bei der Datenverarbeitung:', error);
        
        // Fehlermeldung anzeigen
        if (importStatus) {
          importStatus.textContent = `Fehler bei der Datenverarbeitung: ${error.message}`;
        }
        
        // Notification anzeigen
        if (typeof NotificationSystem !== 'undefined') {
          NotificationSystem.showError('Fehler bei der Datenverarbeitung: ' + error.message);
        }
      }
    };
    
    console.log('Datenintegration erfolgreich mit Word-Import-UI verknüpft.');
  };
  
  /**
   * Führt einen vollständigen Import-Prozess durch (UI-unabhängig)
   * @param {File} file - Die Word-Datei
   * @param {Object} options - Optionen für den Import
   * @returns {Promise} - Promise mit dem Ergebnis des Imports
   */
  dataIntegration.performCompleteImport = function(file, options = {}) {
    return new Promise((resolve, reject) => {
      // Optionen mit Standardwerten
      const importOptions = {
        regenerateIds: options.regenerateIds ?? true,
        normalizeText: options.normalizeText ?? true,
        assignCategories: options.assignCategories ?? true,
        assignDifficulty: options.assignDifficulty ?? true,
        processSpecialFormats: options.processSpecialFormats ?? true,
        extractMediaRefs: options.extractMediaRefs ?? true,
        processFormulas: options.processFormulas ?? true,
        generateTags: options.generateTags ?? true,
        createNewTest: options.createNewTest ?? true,
        targetTestId: options.targetTestId || null,
        testMetadata: options.testMetadata || {}
      };
      
      // 1. Datei einlesen
      wordImport.readWordFile(file)
        .then(() => {
          // 2. Empfohlene Einstellungen abrufen
          return wordImport.recommendSettings();
        })
        .then(recommendedSettings => {
          // 3. Einstellungen übernehmen
          wordImport.setImportSettings(recommendedSettings);
          
          // 4. Fragen extrahieren
          return wordImport.processDocument();
        })
        .then(result => {
          const extractedQuestions = result.questions;
          
          // 5. Fragen weiterverarbeiten
          let processedQuestions = extractedQuestions;
          
          if (importOptions.processSpecialFormats) {
            processedQuestions = processedQuestions.map(q => {
              const processed = { ...q };
              
              if (processed.text) {
                processed.text = dataIntegration.convertSpecialFormats(processed.text);
              }
              
              return processed;
            });
          }
          
          if (importOptions.extractMediaRefs) {
            processedQuestions = processedQuestions.map(q => {
              const processed = { ...q };
              
              if (processed.text) {
                const mediaResult = dataIntegration.extractMediaReferences(processed.text);
                processed.text = mediaResult.text;
                
                if (mediaResult.mediaRefs.length > 0) {
                  processed.mediaRefs = mediaResult.mediaRefs;
                }
              }
              
              return processed;
            });
          }
          
          if (importOptions.processFormulas) {
            processedQuestions = processedQuestions.map(q => dataIntegration.processFormulas(q));
          }
          
          if (importOptions.generateTags) {
            processedQuestions = processedQuestions.map(q => {
              const processed = { ...q };
              processed.tags = dataIntegration.generateTags(processed, processed.tags || []);
              return processed;
            });
          }
          
          // 6. Fragen für Test vorbereiten
          const prepareOptions = {
            regenerateIds: importOptions.regenerateIds,
            normalizeText: importOptions.normalizeText,
            assignCategories: importOptions.assignCategories,
            assignDifficulty: importOptions.assignDifficulty
          };
          
          const prepResult = dataIntegration.prepareQuestionsForTest(processedQuestions, prepareOptions);
          
          // 7. Test erstellen oder Fragen hinzufügen
          if (importOptions.createNewTest) {
            // Dateinamen als Titel verwenden, falls nicht anders angegeben
            if (!importOptions.testMetadata.title) {
              importOptions.testMetadata.title = file.name.replace(/\.docx$/, '');
            }
            
            // Test erstellen
            const testId = dataIntegration.createTest(prepResult.preparedQuestions, importOptions.testMetadata);
            
            if (testId) {
              resolve({
                success: true,
                testId: testId,
                questionCount: prepResult.preparedQuestions.length,
                warnings: prepResult.warnings,
                invalidCount: prepResult.invalidQuestions.length
              });
            } else {
              reject(new Error('Fehler beim Erstellen des Tests.'));
            }
          } else {
            // Fragen zu bestehendem Test hinzufügen
            if (!importOptions.targetTestId) {
              reject(new Error('Keine Ziel-Test-ID angegeben.'));
              return;
            }
            
            const success = dataIntegration.addQuestionsToTest(importOptions.targetTestId, prepResult.preparedQuestions);
            
            if (success) {
              resolve({
                success: true,
                testId: importOptions.targetTestId,
                questionCount: prepResult.preparedQuestions.length,
                warnings: prepResult.warnings,
                invalidCount: prepResult.invalidQuestions.length
              });
            } else {
              reject(new Error('Fehler beim Hinzufügen der Fragen zum Test.'));
            }
          }
        })
        .catch(error => {
          console.error('Fehler beim Import:', error);
          reject(error);
        });
    });
  };
  
  // Datenintegration mit UI verknüpfen
  if (wordImportUI) {
    dataIntegration.integrateWithUI();
  }
})();
/**
 * JS-Block 4.10.1: Test-Speichern - Grundfunktionalität
 * 
 * Dieses Modul implementiert die grundlegende Funktionalität zum Speichern
 * von Tests, einschließlich Validierung, Versionierung und Sicherungskopien.
 */

// Test-Speicher-Modul als IIFE (Immediately Invoked Function Expression)
const TestStorage = (function() {
  // Private Variablen
  const LOCAL_STORAGE_KEY = 'elearning_tests';
  const BACKUP_KEY = 'elearning_tests_backup';
  const VERSION = '1.0';
  
  // Cache für geladene Tests
  let testsCache = null;
  
  // Zeitstempel der letzten Änderung
  let lastModified = null;
  
  /**
   * Initialisiert das Test-Speicher-Modul
   */
  function init() {
    console.log('Test-Speicher-Modul initialisiert (Version ' + VERSION + ')');
    
    // Prüfen, ob LocalStorage verfügbar ist
    if (!isLocalStorageAvailable()) {
      console.error('LocalStorage ist nicht verfügbar. Test-Speicherung wird nicht funktionieren.');
      NotificationSystem.showError('Ihr Browser unterstützt keine lokale Speicherung. Die Test-Daten können nicht gespeichert werden.');
    }
  }
  
  /**
   * Prüft, ob LocalStorage verfügbar ist
   * @returns {boolean} - true, wenn LocalStorage verfügbar ist
   */
  function isLocalStorageAvailable() {
    try {
      const test = 'test';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (e) {
      return false;
    }
  }
  
  /**
   * Lädt alle Tests aus dem LocalStorage
   * @param {boolean} forceReload - Erzwingt das Neuladen aus dem LocalStorage (ignoriert Cache)
   * @returns {Array} - Array mit allen Tests
   */
  function loadAllTests(forceReload = false) {
    // Cache verwenden, wenn verfügbar und kein Neuladen erzwungen wird
    if (testsCache !== null && !forceReload) {
      return testsCache;
    }
    
    try {
      // Aus LocalStorage laden
      const testsJson = localStorage.getItem(LOCAL_STORAGE_KEY);
      
      if (!testsJson) {
        // Keine Tests gefunden, leeres Array zurückgeben
        testsCache = [];
        return testsCache;
      }
      
      // Tests parsen
      const tests = JSON.parse(testsJson);
      
      // Prüfen, ob es sich um ein Array handelt
      if (!Array.isArray(tests)) {
        console.error('Ungültiges Format für Tests in LocalStorage. Array erwartet.');
        testsCache = [];
        return testsCache;
      }
      
      // Tests im Cache speichern
      testsCache = tests;
      
      // Zeitstempel aktualisieren
      lastModified = new Date();
      
      return testsCache;
    } catch (error) {
      console.error('Fehler beim Laden der Tests aus LocalStorage:', error);
      
      // Sicherungskopie wiederherstellen, falls verfügbar
      const backup = localStorage.getItem(BACKUP_KEY);
      
      if (backup) {
        try {
          const backupTests = JSON.parse(backup);
          
          if (Array.isArray(backupTests)) {
            console.log('Tests aus Sicherungskopie wiederhergestellt.');
            NotificationSystem.showInfo('Die Tests wurden aus einer Sicherungskopie wiederhergestellt.');
            
            // Sicherungskopie als Hauptdaten speichern
            localStorage.setItem(LOCAL_STORAGE_KEY, backup);
            
            testsCache = backupTests;
            return testsCache;
          }
        } catch (backupError) {
          console.error('Fehler beim Wiederherstellen der Sicherungskopie:', backupError);
        }
      }
      
      // Wenn keine Wiederherstellung möglich ist, leeres Array zurückgeben
      NotificationSystem.showError('Fehler beim Laden der Tests. Es wurde ein neuer Datenbestand angelegt.');
      testsCache = [];
      return testsCache;
    }
  }
  
  /**
   * Speichert alle Tests im LocalStorage
   * @param {Array} tests - Array mit Tests
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function saveAllTests(tests) {
    if (!Array.isArray(tests)) {
      console.error('Ungültiges Format für Tests. Array erwartet.');
      return false;
    }
    
    try {
      // Vor dem Speichern eine Sicherungskopie der aktuellen Daten erstellen
      const currentData = localStorage.getItem(LOCAL_STORAGE_KEY);
      
      if (currentData) {
        localStorage.setItem(BACKUP_KEY, currentData);
      }
      
      // Neue Daten speichern
      const testsJson = JSON.stringify(tests);
      localStorage.setItem(LOCAL_STORAGE_KEY, testsJson);
      
      // Cache aktualisieren
      testsCache = tests;
      
      // Zeitstempel aktualisieren
      lastModified = new Date();
      
      return true;
    } catch (error) {
      console.error('Fehler beim Speichern der Tests in LocalStorage:', error);
      
      // Speicherlimit-Fehler behandeln
      if (error.name === 'QuotaExceededError' || error.code === 22) {
        NotificationSystem.showError(
          'Speicherlimit überschritten. Bitte löschen Sie nicht benötigte Tests, um Platz zu schaffen.'
        );
      } else {
        NotificationSystem.showError('Fehler beim Speichern der Tests: ' + error.message);
      }
      
      return false;
    }
  }
  
  /**
   * Erstellt eine Sicherungskopie aller Tests
   * @returns {string|null} - JSON-String mit der Sicherungskopie oder null bei Fehler
   */
  function createBackup() {
    try {
      // Alle Tests laden
      const tests = loadAllTests();
      
      // Tests als JSON-String
      const testsJson = JSON.stringify(tests);
      
      // Zeitstempel für den Dateinamen
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      
      // JSON-String zurückgeben
      return {
        data: testsJson,
        filename: `elearning_tests_backup_${timestamp}.json`,
        timestamp: new Date().toISOString(),
        count: tests.length
      };
    } catch (error) {
      console.error('Fehler beim Erstellen der Sicherungskopie:', error);
      return null;
    }
  }
  
  /**
   * Stellt Tests aus einer Sicherungskopie wieder her
   * @param {string} backupData - JSON-String mit der Sicherungskopie
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function restoreFromBackup(backupData) {
    try {
      // Backup-Daten parsen
      const tests = JSON.parse(backupData);
      
      // Prüfen, ob es sich um ein Array handelt
      if (!Array.isArray(tests)) {
        console.error('Ungültiges Format für Backup-Daten. Array erwartet.');
        return false;
      }
      
      // Vor der Wiederherstellung eine Sicherungskopie der aktuellen Daten erstellen
      const currentData = localStorage.getItem(LOCAL_STORAGE_KEY);
      
      if (currentData) {
        // Spezielle Backup-Kopie für Wiederherstellungen
        localStorage.setItem(BACKUP_KEY + '_restore', currentData);
      }
      
      // Tests validieren
      const validationResult = validateTests(tests);
      
      if (!validationResult.isValid) {
        console.error('Ungültige Tests in Backup-Daten:', validationResult.errors);
        NotificationSystem.showError(
          `Fehler in den Backup-Daten: ${validationResult.errors.join(', ')}`
        );
        return false;
      }
      
      // Tests speichern
      const success = saveAllTests(tests);
      
      if (success) {
        NotificationSystem.showSuccess(`${tests.length} Tests erfolgreich wiederhergestellt.`);
      }
      
      return success;
    } catch (error) {
      console.error('Fehler beim Wiederherstellen der Sicherungskopie:', error);
      NotificationSystem.showError('Fehler beim Wiederherstellen der Sicherungskopie: ' + error.message);
      return false;
    }
  }
  
  /**
   * Validiert ein Array von Tests
   * @param {Array} tests - Array mit Tests
   * @returns {Object} - Validierungsergebnis {isValid, errors}
   */
  function validateTests(tests) {
    const result = {
      isValid: true,
      errors: []
    };
    
    // Prüfen, ob es sich um ein Array handelt
    if (!Array.isArray(tests)) {
      result.isValid = false;
      result.errors.push('Keine gültigen Test-Daten (kein Array)');
      return result;
    }
    
    // Jeden Test validieren
    tests.forEach((test, index) => {
      try {
        // Test validieren
        const testValidation = validateTest(test);
        
        if (!testValidation.isValid) {
          result.isValid = false;
          result.errors.push(`Test ${index + 1} (${test.title || 'Unbenannt'}): ${testValidation.errors.join(', ')}`);
        }
      } catch (error) {
        result.isValid = false;
        result.errors.push(`Test ${index + 1}: Unbekannter Fehler`);
      }
    });
    
    return result;
  }
  
  /**
   * Validiert einen einzelnen Test
   * @param {Object} test - Der zu validierende Test
   * @returns {Object} - Validierungsergebnis {isValid, errors}
   */
  function validateTest(test) {
    const result = {
      isValid: true,
      errors: []
    };
    
    // Grundlegende Struktur prüfen
    if (!test || typeof test !== 'object') {
      result.isValid = false;
      result.errors.push('Ungültiges Test-Format (kein Objekt)');
      return result;
    }
    
    // Pflichtfelder prüfen
    if (!test.id) {
      result.isValid = false;
      result.errors.push('Test-ID fehlt');
    }
    
    if (!test.title) {
      result.isValid = false;
      result.errors.push('Titel fehlt');
    }
    
    // Fragen prüfen
    if (!test.questions || !Array.isArray(test.questions)) {
      result.isValid = false;
      result.errors.push('Keine gültigen Fragen (kein Array)');
    } else {
      // Jede Frage validieren
      test.questions.forEach((question, index) => {
        // Grundlegende Struktur prüfen
        if (!question || typeof question !== 'object') {
          result.isValid = false;
          result.errors.push(`Frage ${index + 1}: Ungültiges Format (kein Objekt)`);
          return;
        }
        
        // Pflichtfelder prüfen
        if (!question.id) {
          result.isValid = false;
          result.errors.push(`Frage ${index + 1}: ID fehlt`);
        }
        
        if (!question.text) {
          result.isValid = false;
          result.errors.push(`Frage ${index + 1}: Text fehlt`);
        }
        
        if (!question.type) {
          result.isValid = false;
          result.errors.push(`Frage ${index + 1}: Typ fehlt`);
        } else {
          // Typ-spezifische Validierung
          if (['multiple_choice', 'single_choice'].includes(question.type)) {
            // Antwortoptionen prüfen
            if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
              result.isValid = false;
              result.errors.push(`Frage ${index + 1}: Keine Antwortoptionen`);
            } else {
              // Mindestens eine korrekte Antwort bei Multiple-Choice
              if (question.type === 'multiple_choice' && !question.options.some(opt => opt.isCorrect)) {
                result.isValid = false;
                result.errors.push(`Frage ${index + 1}: Keine korrekte Antwortoption`);
              }
              
              // Genau eine korrekte Antwort bei Single-Choice
              if (question.type === 'single_choice') {
                const correctCount = question.options.filter(opt => opt.isCorrect).length;
                if (correctCount !== 1) {
                  result.isValid = false;
                  result.errors.push(`Frage ${index + 1}: Single-Choice-Frage muss genau eine korrekte Antwort haben`);
                }
              }
            }
          } else if (question.type === 'true_false') {
            // Wahr/Falsch-Flag prüfen
            if (typeof question.correctAnswer !== 'boolean') {
              result.isValid = false;
              result.errors.push(`Frage ${index + 1}: Korrekte Antwort fehlt`);
            }
          }
          // Bei Freitext-Fragen keine besonderen Prüfungen
        }
      });
    }
    
    return result;
  }
  
  /**
   * Erzeugt eine eindeutige ID für einen Test
   * @returns {string} - Eindeutige ID
   */
  function generateTestId() {
    return 'test_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  /**
   * Erzeugt eine eindeutige ID für eine Frage
   * @returns {string} - Eindeutige ID
   */
  function generateQuestionId() {
    return 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  /**
   * Erstellt einen neuen Test
   * @param {Object} testData - Daten für den neuen Test
   * @returns {string|null} - ID des erstellten Tests oder null bei Fehler
   */
  function createTest(testData) {
    if (!testData || typeof testData !== 'object') {
      console.error('Ungültige Test-Daten.');
      return null;
    }
    
    try {
      // Alle Tests laden
      const tests = loadAllTests();
      
      // Standardwerte für fehlende Felder
      const newTest = {
        id: generateTestId(),
        title: testData.title || 'Neuer Test',
        description: testData.description || '',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        questions: Array.isArray(testData.questions) ? testData.questions : [],
        questionCount: Array.isArray(testData.questions) ? testData.questions.length : 0,
        ...testData
      };
      
      // Test validieren
      const validation = validateTest(newTest);
      
      if (!validation.isValid) {
        console.error('Ungültiger Test:', validation.errors);
        NotificationSystem.showError(`Fehler beim Erstellen des Tests: ${validation.errors.join(', ')}`);
        return null;
      }
      
      // Test hinzufügen
      tests.push(newTest);
      
      // Tests speichern
      const success = saveAllTests(tests);
      
      if (success) {
        NotificationSystem.showSuccess(`Test "${newTest.title}" erfolgreich erstellt.`);
        return newTest.id;
      } else {
        return null;
      }
    } catch (error) {
      console.error('Fehler beim Erstellen des Tests:', error);
      NotificationSystem.showError('Fehler beim Erstellen des Tests: ' + error.message);
      return null;
    }
  }
  
  /**
   * Lädt einen Test anhand seiner ID
   * @param {string} testId - ID des Tests
   * @returns {Object|null} - Der Test oder null, wenn nicht gefunden
   */
  function getTestById(testId) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return null;
    }
    
    try {
      // Alle Tests laden
      const tests = loadAllTests();
      
      // Test suchen
      const test = tests.find(t => t.id === testId);
      
      if (!test) {
        console.error('Test nicht gefunden:', testId);
        return null;
      }
      
      return test;
    } catch (error) {
      console.error('Fehler beim Laden des Tests:', error);
      return null;
    }
  }
  
  /**
   * Aktualisiert einen Test
   * @param {string} testId - ID des Tests
   * @param {Object} updateData - Zu aktualisierende Daten
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateTest(testId, updateData) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return false;
    }
    
    if (!updateData || typeof updateData !== 'object') {
      console.error('Ungültige Update-Daten.');
      return false;
    }
    
    try {
      // Alle Tests laden
      const tests = loadAllTests();
      
      // Test-Index finden
      const testIndex = tests.findIndex(t => t.id === testId);
      
      if (testIndex === -1) {
        console.error('Test nicht gefunden:', testId);
        NotificationSystem.showError('Der zu aktualisierende Test wurde nicht gefunden.');
        return false;
      }
      
      // Aktuellen Test kopieren
      const currentTest = tests[testIndex];
      
      // Aktualisiertes Objekt erstellen
      const updatedTest = {
        ...currentTest,
        ...updateData,
        updatedAt: new Date().toISOString()
      };
      
      // Fragen-Anzahl aktualisieren, falls Fragen aktualisiert wurden
      if (updateData.questions) {
        updatedTest.questionCount = updateData.questions.length;
      }
      
      // Test validieren
      const validation = validateTest(updatedTest);
      
      if (!validation.isValid) {
        console.error('Ungültiger Test nach Update:', validation.errors);
        NotificationSystem.showError(`Fehler beim Aktualisieren des Tests: ${validation.errors.join(', ')}`);
        return false;
      }
      
      // Test aktualisieren
      tests[testIndex] = updatedTest;
      
      // Tests speichern
      const success = saveAllTests(tests);
      
      if (success) {
        NotificationSystem.showSuccess(`Test "${updatedTest.title}" erfolgreich aktualisiert.`);
      }
      
      return success;
    } catch (error) {
      console.error('Fehler beim Aktualisieren des Tests:', error);
      NotificationSystem.showError('Fehler beim Aktualisieren des Tests: ' + error.message);
      return false;
    }
  }
  
  /**
   * Löscht einen Test
   * @param {string} testId - ID des Tests
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteTest(testId) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return false;
    }
    
    try {
      // Alle Tests laden
      const tests = loadAllTests();
      
      // Test-Index finden
      const testIndex = tests.findIndex(t => t.id === testId);
      
      if (testIndex === -1) {
        console.error('Test nicht gefunden:', testId);
        return false;
      }
      
      // Testname für Erfolgsmeldung speichern
      const testTitle = tests[testIndex].title;
      
      // Test entfernen
      tests.splice(testIndex, 1);
      
      // Tests speichern
      const success = saveAllTests(tests);
      
      if (success) {
        NotificationSystem.showSuccess(`Test "${testTitle}" erfolgreich gelöscht.`);
      }
      
      return success;
    } catch (error) {
      console.error('Fehler beim Löschen des Tests:', error);
      NotificationSystem.showError('Fehler beim Löschen des Tests: ' + error.message);
      return false;
    }
  }
  
  /**
   * Fügt eine Frage zu einem Test hinzu
   * @param {string} testId - ID des Tests
   * @param {Object} questionData - Daten für die neue Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function addQuestionToTest(testId, questionData) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return false;
    }
    
    if (!questionData || typeof questionData !== 'object') {
      console.error('Ungültige Frage-Daten.');
      return false;
    }
    
    try {
      // Test laden
      const test = getTestById(testId);
      
      if (!test) {
        console.error('Test nicht gefunden:', testId);
        return false;
      }
      
      // Fragen-Array erstellen, falls noch nicht vorhanden
      if (!test.questions) {
        test.questions = [];
      }
      
      // Frage vorbereiten
      const newQuestion = {
        id: questionData.id || generateQuestionId(),
        text: questionData.text || '',
        type: questionData.type || 'text',
        createdAt: questionData.createdAt || new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        ...questionData
      };
      
      // Frage hinzufügen
      test.questions.push(newQuestion);
      
      // Anzahl der Fragen aktualisieren
      test.questionCount = test.questions.length;
      
      // Test aktualisieren
      return updateTest(testId, {
        questions: test.questions,
        questionCount: test.questionCount,
        updatedAt: new Date().toISOString()
      });
    } catch (error) {
      console.error('Fehler beim Hinzufügen der Frage:', error);
      NotificationSystem.showError('Fehler beim Hinzufügen der Frage: ' + error.message);
      return false;
    }
  }
  
  // Modul initialisieren
  init();
  
  // Öffentliche API
  return {
    loadAllTests: loadAllTests,
    createTest: createTest,
    getTestById: getTestById,
    updateTest: updateTest,
    deleteTest: deleteTest,
    addQuestionToTest: addQuestionToTest,
    createBackup: createBackup,
    restoreFromBackup: restoreFromBackup,
    validateTest: validateTest,
    generateTestId: generateTestId,
    generateQuestionId: generateQuestionId
  };
})();

// Wenn TestBasicData bereits existiert, erweitern
if (typeof TestBasicData !== 'undefined') {
  // Funktionen von TestStorage übernehmen
  Object.assign(TestBasicData, TestStorage);
  console.log('TestBasicData-Modul um Speicherfunktionen erweitert.');
} else {
  // TestBasicData neu erstellen
  window.TestBasicData = TestStorage;
  console.log('TestBasicData-Modul erstellt.');
}
/**
 * JS-Block 4.10.2: Test-Bearbeiten - Grundfunktionen
 * 
 * Dieses Modul implementiert die grundlegenden Funktionen zum Bearbeiten von Tests,
 * einschließlich Grunddaten, Einstellungen und Änderungshistorie.
 */

// Test-Bearbeiten-Modul als IIFE (Immediately Invoked Function Expression)
const TestEditor = (function() {
  // Private Variablen
  let currentTest = null;
  let changeHistory = [];
  const MAX_HISTORY_SIZE = 20;
  
  // Status für Bearbeitung
  const editingStatus = {
    isDirty: false,
    lastSaved: null,
    currentSection: null,
    autoSaveTimer: null,
    AUTO_SAVE_INTERVAL: 60000 // 1 Minute
  };
  
  /**
   * Initialisiert das Test-Bearbeiten-Modul
   */
  function init() {
    console.log('Test-Bearbeiten-Modul initialisiert');
    
    // Auto-Save-Timer starten, falls nicht bereits gestartet
    if (!editingStatus.autoSaveTimer && typeof window !== 'undefined') {
      startAutoSave();
    }
  }
  
  /**
   * Startet den Auto-Save-Timer
   */
  function startAutoSave() {
    // Bestehenden Timer beenden, falls vorhanden
    if (editingStatus.autoSaveTimer) {
      clearInterval(editingStatus.autoSaveTimer);
    }
    
    // Neuen Timer starten
    editingStatus.autoSaveTimer = setInterval(() => {
      // Nur speichern, wenn Änderungen vorliegen
      if (editingStatus.isDirty && currentTest) {
        console.log('Auto-Save wird durchgeführt...');
        saveCurrentTest();
      }
    }, editingStatus.AUTO_SAVE_INTERVAL);
  }
  
  /**
   * Lädt einen Test zur Bearbeitung
   * @param {string} testId - ID des Tests
   * @returns {Object|null} - Der geladene Test oder null bei Fehler
   */
  function loadTest(testId) {
    // Prüfen, ob TestBasicData verfügbar ist
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return null;
    }
    
    try {
      // Test laden
      const test = TestBasicData.getTestById(testId);
      
      if (!test) {
        console.error('Test nicht gefunden:', testId);
        return null;
      }
      
      // Aktuellen Test setzen
      currentTest = JSON.parse(JSON.stringify(test)); // Tiefe Kopie erstellen
      
      // Status zurücksetzen
      editingStatus.isDirty = false;
      editingStatus.lastSaved = new Date();
      
      // Änderungshistorie zurücksetzen
      changeHistory = [];
      
      // Event auslösen
      triggerEvent('testLoaded', { test: currentTest });
      
      return currentTest;
    } catch (error) {
      console.error('Fehler beim Laden des Tests:', error);
      return null;
    }
  }
  
  /**
   * Speichert den aktuellen Test
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function saveCurrentTest() {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    // Prüfen, ob TestBasicData verfügbar ist
    if (typeof TestBasicData === 'undefined' || !TestBasicData.updateTest) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return false;
    }
    
    try {
      // Test aktualisieren
      const success = TestBasicData.updateTest(currentTest.id, currentTest);
      
      if (success) {
        // Status aktualisieren
        editingStatus.isDirty = false;
        editingStatus.lastSaved = new Date();
        
        // Event auslösen
        triggerEvent('testSaved', { test: currentTest });
        
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.error('Fehler beim Speichern des Tests:', error);
      return false;
    }
  }
  
  /**
   * Erstellt einen neuen Test
   * @param {Object} testData - Grunddaten für den neuen Test
   * @returns {Object|null} - Der erstellte Test oder null bei Fehler
   */
  function createNewTest(testData = {}) {
    // Prüfen, ob TestBasicData verfügbar ist
    if (typeof TestBasicData === 'undefined' || !TestBasicData.createTest) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return null;
    }
    
    try {
      // Standardwerte für den Test
      const newTestData = {
        title: testData.title || 'Neuer Test',
        description: testData.description || '',
        questions: testData.questions || [],
        ...testData
      };
      
      // Test erstellen
      const testId = TestBasicData.createTest(newTestData);
      
      if (!testId) {
        console.error('Fehler beim Erstellen des Tests.');
        return null;
      }
      
      // Erstellten Test laden
      return loadTest(testId);
    } catch (error) {
      console.error('Fehler beim Erstellen des Tests:', error);
      return null;
    }
  }
  
  /**
   * Aktualisiert die Grunddaten eines Tests
   * @param {Object} basicData - Grunddaten für den Test
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateBasicData(basicData) {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Änderungen anwenden
      if (basicData.title !== undefined) currentTest.title = basicData.title;
      if (basicData.description !== undefined) currentTest.description = basicData.description;
      if (basicData.category !== undefined) currentTest.category = basicData.category;
      if (basicData.tags !== undefined) currentTest.tags = basicData.tags;
      if (basicData.difficulty !== undefined) currentTest.difficulty = basicData.difficulty;
      if (basicData.duration !== undefined) currentTest.duration = basicData.duration;
      if (basicData.passingScore !== undefined) currentTest.passingScore = basicData.passingScore;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      addToHistory('updateBasicData', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editingStatus.isDirty = true;
      
      // Event auslösen
      triggerEvent('testChanged', { 
        changeType: 'basicData', 
        test: currentTest 
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Grunddaten:', error);
      return false;
    }
  }
  
  /**
   * Aktualisiert die Testeinstellungen
   * @param {Object} settings - Einstellungen für den Test
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateSettings(settings) {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Einstellungen-Objekt erstellen oder aktualisieren
      if (!currentTest.settings) {
        currentTest.settings = {};
      }
      
      // Einstellungen aktualisieren
      currentTest.settings = {
        ...currentTest.settings,
        ...settings
      };
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      addToHistory('updateSettings', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editingStatus.isDirty = true;
      
      // Event auslösen
      triggerEvent('testChanged', { 
        changeType: 'settings', 
        test: currentTest 
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Testeinstellungen:', error);
      return false;
    }
  }
  
  /**
   * Fügt einen Eintrag zur Änderungshistorie hinzu
   * @param {string} action - Die durchgeführte Aktion
   * @param {Object} prevState - Vorheriger Zustand
   * @param {Object} newState - Neuer Zustand
   */
  function addToHistory(action, prevState, newState) {
    // Eintrag erstellen
    const historyEntry = {
      action,
      timestamp: new Date().toISOString(),
      prevState,
      newState
    };
    
    // Zur Historie hinzufügen
    changeHistory.push(historyEntry);
    
    // Historie auf maximale Größe begrenzen
    if (changeHistory.length > MAX_HISTORY_SIZE) {
      changeHistory.shift(); // Ältesten Eintrag entfernen
    }
  }
  
  /**
   * Macht die letzte Änderung rückgängig
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function undo() {
    // Prüfen, ob Einträge in der Historie vorhanden sind
    if (changeHistory.length === 0) {
      console.log('Keine Änderungen zum Rückgängigmachen vorhanden.');
      return false;
    }
    
    try {
      // Letzten Eintrag aus der Historie holen
      const lastEntry = changeHistory.pop();
      
      // Vorherigen Zustand wiederherstellen
      currentTest = JSON.parse(JSON.stringify(lastEntry.prevState));
      
      // Status aktualisieren
      editingStatus.isDirty = true;
      
      // Event auslösen
      triggerEvent('testChanged', { 
        changeType: 'undo', 
        test: currentTest 
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Rückgängigmachen der letzten Änderung:', error);
      return false;
    }
  }
  
  /**
   * Dupliziert den aktuellen Test
   * @param {string} newTitle - Titel für den duplizierten Test (optional)
   * @returns {Object|null} - Der duplizierte Test oder null bei Fehler
   */
  function duplicateTest(newTitle = null) {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return null;
    }
    
    try {
      // Kopie des aktuellen Tests erstellen
      const duplicatedTest = JSON.parse(JSON.stringify(currentTest));
      
      // ID entfernen, damit eine neue generiert wird
      delete duplicatedTest.id;
      
      // Titel anpassen, falls angegeben
      if (newTitle) {
        duplicatedTest.title = newTitle;
      } else {
        duplicatedTest.title = `${currentTest.title} (Kopie)`;
      }
      
      // Erstellungs- und Aktualisierungsdatum aktualisieren
      duplicatedTest.createdAt = new Date().toISOString();
      duplicatedTest.updatedAt = new Date().toISOString();
      
      // Duplizierten Test erstellen
      const testId = TestBasicData.createTest(duplicatedTest);
      
      if (!testId) {
        console.error('Fehler beim Duplizieren des Tests.');
        return null;
      }
      
      NotificationSystem.showSuccess(`Test "${duplicatedTest.title}" erfolgreich erstellt.`);
      
      // Neuen Test laden
      return loadTest(testId);
    } catch (error) {
      console.error('Fehler beim Duplizieren des Tests:', error);
      return null;
    }
  }
  
  /**
   * Importiert Fragen aus einem anderen Test
   * @param {string} sourceTestId - ID des Quelltests
   * @param {Array} questionIndices - Indizes der zu importierenden Fragen (optional)
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function importQuestionsFromTest(sourceTestId, questionIndices = null) {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    // Prüfen, ob TestBasicData verfügbar ist
    if (typeof TestBasicData === 'undefined' || !TestBasicData.getTestById) {
      console.error('TestBasicData-Modul nicht verfügbar.');
      return false;
    }
    
    try {
      // Quelltest laden
      const sourceTest = TestBasicData.getTestById(sourceTestId);
      
      if (!sourceTest) {
        console.error('Quelltest nicht gefunden:', sourceTestId);
        return false;
      }
      
      // Prüfen, ob Fragen vorhanden sind
      if (!sourceTest.questions || sourceTest.questions.length === 0) {
        console.error('Quelltest enthält keine Fragen.');
        return false;
      }
      
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array erstellen, falls noch nicht vorhanden
      if (!currentTest.questions) {
        currentTest.questions = [];
      }
      
      // Zu importierende Fragen bestimmen
      let questionsToImport = [];
      
      if (Array.isArray(questionIndices) && questionIndices.length > 0) {
        // Nur ausgewählte Fragen importieren
        questionIndices.forEach(index => {
          if (index >= 0 && index < sourceTest.questions.length) {
            questionsToImport.push(sourceTest.questions[index]);
          }
        });
      } else {
        // Alle Fragen importieren
        questionsToImport = sourceTest.questions;
      }
      
      // Fragen importieren (mit neuen IDs)
      const importedQuestions = questionsToImport.map(question => {
        // Tiefe Kopie erstellen
        const newQuestion = JSON.parse(JSON.stringify(question));
        
        // Neue ID generieren
        newQuestion.id = TestBasicData.generateQuestionId();
        
        // Aktualisierungsdatum setzen
        newQuestion.updatedAt = new Date().toISOString();
        
        return newQuestion;
      });
      
      // Fragen hinzufügen
      currentTest.questions = [...currentTest.questions, ...importedQuestions];
      
      // Anzahl der Fragen aktualisieren
      currentTest.questionCount = currentTest.questions.length;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      addToHistory('importQuestions', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editingStatus.isDirty = true;
      
      // Event auslösen
      triggerEvent('testChanged', { 
        changeType: 'importQuestions', 
        test: currentTest 
      });
      
      NotificationSystem.showSuccess(`${importedQuestions.length} Fragen erfolgreich importiert.`);
      
      return true;
    } catch (error) {
      console.error('Fehler beim Importieren von Fragen:', error);
      return false;
    }
  }
  
  /**
   * Exportiert den aktuellen Test als JSON
   * @returns {string|null} - JSON-String mit dem Test oder null bei Fehler
   */
  function exportTestAsJson() {
    // Prüfen, ob ein Test geladen ist
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return null;
    }
    
    try {
      // Test als JSON-String
      const testJson = JSON.stringify(currentTest, null, 2);
      
      // Zeitstempel für den Dateinamen
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      
      return {
        data: testJson,
        filename: `test_${currentTest.id}_${timestamp}.json`,
        testTitle: currentTest.title
      };
    } catch (error) {
      console.error('Fehler beim Exportieren des Tests:', error);
      return null;
    }
  }
  
  /**
   * Importiert einen Test aus JSON
   * @param {string} jsonData - JSON-String mit dem Test
   * @returns {Object|null} - Der importierte Test oder null bei Fehler
   */
  function importTestFromJson(jsonData) {
    try {
      // JSON parsen
      const testData = JSON.parse(jsonData);
      
      // Prüfen, ob es sich um einen gültigen Test handelt
      if (!testData || typeof testData !== 'object' || !testData.title) {
        console.error('Ungültiges Format für Test-Daten.');
        return null;
      }
      
      // Testdaten validieren
      const validation = TestBasicData.validateTest(testData);
      
      if (!validation.isValid) {
        console.error('Ungültiger Test:', validation.errors);
        NotificationSystem.showError(`Fehler beim Importieren des Tests: ${validation.errors.join(', ')}`);
        return null;
      }
      
      // ID entfernen, damit eine neue generiert wird
      delete testData.id;
      
      // Erstellungs- und Aktualisierungsdatum aktualisieren
      testData.createdAt = new Date().toISOString();
      testData.updatedAt = new Date().toISOString();
      
      // Test erstellen
      const testId = TestBasicData.createTest(testData);
      
      if (!testId) {
        console.error('Fehler beim Erstellen des Tests aus JSON.');
        return null;
      }
      
      NotificationSystem.showSuccess(`Test "${testData.title}" erfolgreich importiert.`);
      
      // Importierten Test laden
      return loadTest(testId);
    } catch (error) {
      console.error('Fehler beim Importieren des Tests aus JSON:', error);
      NotificationSystem.showError('Fehler beim Importieren des Tests: ' + error.message);
      return null;
    }
  }
  
  /**
   * Löst ein benutzerdefiniertes Ereignis aus
   * @param {string} eventName - Name des Ereignisses
   * @param {Object} data - Daten für das Ereignis
   */
  function triggerEvent(eventName, data) {
    if (typeof window !== 'undefined' && window.CustomEvent) {
      const event = new CustomEvent('testEditor:' + eventName, { detail: data });
      window.dispatchEvent(event);
    }
  }
  
  /**
   * Gibt den aktuellen Bearbeitungsstatus zurück
   * @returns {Object} - Bearbeitungsstatus
   */
  function getEditingStatus() {
    return { ...editingStatus };
  }
  
  /**
   * Gibt den aktuell geladenen Test zurück
   * @returns {Object|null} - Der aktuell geladene Test oder null
   */
  function getCurrentTest() {
    return currentTest ? JSON.parse(JSON.stringify(currentTest)) : null;
  }
  
  /**
   * Gibt die Änderungshistorie zurück
   * @returns {Array} - Die Änderungshistorie
   */
  function getChangeHistory() {
    return [...changeHistory];
  }
  
  // Modul initialisieren
  init();
  
  // Event-Listener für Seiten-Verlassen
  if (typeof window !== 'undefined') {
    window.addEventListener('beforeunload', (event) => {
      // Warnung anzeigen, wenn ungespeicherte Änderungen vorhanden sind
      if (editingStatus.isDirty) {
        const message = 'Es gibt ungespeicherte Änderungen. Möchten Sie die Seite wirklich verlassen?';
        event.returnValue = message;
        return message;
      }
    });
  }
  
  // Öffentliche API
  return {
    loadTest,
    saveCurrentTest,
    createNewTest,
    updateBasicData,
    updateSettings,
    undo,
    duplicateTest,
    importQuestionsFromTest,
    exportTestAsJson,
    importTestFromJson,
    getCurrentTest,
    getEditingStatus,
    getChangeHistory
  };
})();

// TestEditor global verfügbar machen
window.TestEditor = TestEditor;
/**
 * JS-Block 4.10.3: Test-Bearbeiten - Fragen und Optionen
 * 
 * Dieses Modul erweitert das Test-Bearbeiten-Modul um Funktionen zum Hinzufügen,
 * Bearbeiten und Löschen von Fragen und Antwortoptionen sowie zum Verwalten
 * der Reihenfolge von Fragen.
 */

// Test-Bearbeiten-Modul erweitern
(function() {
  // Referenz auf das existierende TestEditor-Modul
  const editor = window.TestEditor;
  
  if (!editor) {
    console.error('TestEditor-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.2 laden.');
    return;
  }
  
  /**
   * Fügt eine neue Frage zum aktuellen Test hinzu
   * @param {Object} questionData - Daten für die neue Frage
   * @param {number} position - Position, an der die Frage eingefügt werden soll (optional)
   * @returns {string|null} - ID der neuen Frage oder null bei Fehler
   */
  function addQuestion(questionData = {}, position = null) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return null;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Standard-Fragedaten
      const defaultQuestionData = {
        type: 'text',
        text: 'Neue Frage',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // Fragedaten zusammenführen
      const newQuestion = {
        ...defaultQuestionData,
        ...questionData,
        id: questionData.id || (typeof TestBasicData !== 'undefined' && TestBasicData.generateQuestionId ? 
             TestBasicData.generateQuestionId() : 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000))
      };
      
      // Fragetyp-spezifische Standarddaten hinzufügen
      if (newQuestion.type === 'multiple_choice' || newQuestion.type === 'single_choice') {
        if (!newQuestion.options || !Array.isArray(newQuestion.options) || newQuestion.options.length === 0) {
          newQuestion.options = [
            { text: 'Option 1', isCorrect: true },
            { text: 'Option 2', isCorrect: false }
          ];
        }
      } else if (newQuestion.type === 'true_false') {
        if (typeof newQuestion.correctAnswer !== 'boolean') {
          newQuestion.correctAnswer = true;
        }
      }
      
      // Fragen-Array erstellen, falls noch nicht vorhanden
      if (!currentTest.questions) {
        currentTest.questions = [];
      }
      
      // Frage an der angegebenen Position einfügen oder anhängen
      if (position !== null && position >= 0 && position <= currentTest.questions.length) {
        currentTest.questions.splice(position, 0, newQuestion);
      } else {
        currentTest.questions.push(newQuestion);
      }
      
      // Anzahl der Fragen aktualisieren
      currentTest.questionCount = currentTest.questions.length;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('addQuestion', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'addQuestion', 
        test: currentTest,
        questionId: newQuestion.id
      });
      
      return newQuestion.id;
    } catch (error) {
      console.error('Fehler beim Hinzufügen der Frage:', error);
      return null;
    }
  }
  
  /**
   * Aktualisiert eine Frage im aktuellen Test
   * @param {string} questionId - ID der zu aktualisierenden Frage
   * @param {Object} updateData - Zu aktualisierende Daten
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateQuestion(questionId, updateData) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage kopieren
      const currentQuestion = currentTest.questions[questionIndex];
      
      // Aktualisiertes Objekt erstellen
      const updatedQuestion = {
        ...currentQuestion,
        ...updateData,
        updatedAt: new Date().toISOString()
      };
      
      // Frage aktualisieren
      currentTest.questions[questionIndex] = updatedQuestion;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('updateQuestion', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'updateQuestion', 
        test: currentTest,
        questionId: questionId
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Frage:', error);
      return false;
    }
  }
  
  /**
   * Löscht eine Frage aus dem aktuellen Test
   * @param {string} questionId - ID der zu löschenden Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteQuestion(questionId) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Frage entfernen
      currentTest.questions.splice(questionIndex, 1);
      
      // Anzahl der Fragen aktualisieren
      currentTest.questionCount = currentTest.questions.length;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('deleteQuestion', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'deleteQuestion', 
        test: currentTest
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Löschen der Frage:', error);
      return false;
    }
  }
  
  /**
   * Verschiebt eine Frage im aktuellen Test
   * @param {string} questionId - ID der zu verschiebenden Frage
   * @param {number} newPosition - Neue Position der Frage
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function moveQuestion(questionId, newPosition) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Neue Position validieren
      if (newPosition < 0 || newPosition >= currentTest.questions.length) {
        console.error('Ungültige Position:', newPosition);
        return false;
      }
      
      // Wenn die Frage bereits an der gewünschten Position ist, nichts tun
      if (questionIndex === newPosition) {
        return true;
      }
      
      // Frage entfernen
      const [question] = currentTest.questions.splice(questionIndex, 1);
      
      // Frage an neuer Position einfügen
      currentTest.questions.splice(newPosition, 0, question);
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('moveQuestion', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'moveQuestion', 
        test: currentTest,
        questionId: questionId,
        newPosition: newPosition
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Verschieben der Frage:', error);
      return false;
    }
  }
  
  /**
   * Fügt eine neue Antwortoption zu einer Frage hinzu
   * @param {string} questionId - ID der Frage
   * @param {Object} optionData - Daten für die neue Option
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function addOption(questionId, optionData = {}) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage
      const question = currentTest.questions[questionIndex];
      
      // Prüfen, ob der Fragetyp Optionen unterstützt
      if (!['multiple_choice', 'single_choice'].includes(question.type)) {
        console.error('Fragetyp unterstützt keine Optionen:', question.type);
        return false;
      }
      
      // Optionen-Array erstellen, falls noch nicht vorhanden
      if (!question.options) {
        question.options = [];
      }
      
      // Standard-Optionsdaten
      const defaultOptionData = {
        text: `Option ${question.options.length + 1}`,
        isCorrect: false
      };
      
      // Optionsdaten zusammenführen
      const newOption = {
        ...defaultOptionData,
        ...optionData
      };
      
      // Bei Single-Choice sicherstellen, dass nur eine Option korrekt ist
      if (question.type === 'single_choice' && newOption.isCorrect) {
        // Alle anderen Optionen auf falsch setzen
        question.options.forEach(option => {
          option.isCorrect = false;
        });
      }
      
      // Option hinzufügen
      question.options.push(newOption);
      
      // Aktualisierungsdatum setzen
      question.updatedAt = new Date().toISOString();
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('addOption', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'addOption', 
        test: currentTest,
        questionId: questionId
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Hinzufügen der Option:', error);
      return false;
    }
  }
  
  /**
   * Aktualisiert eine Antwortoption einer Frage
   * @param {string} questionId - ID der Frage
   * @param {number} optionIndex - Index der zu aktualisierenden Option
   * @param {Object} updateData - Zu aktualisierende Daten
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function updateOption(questionId, optionIndex, updateData) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage
      const question = currentTest.questions[questionIndex];
      
      // Prüfen, ob der Fragetyp Optionen unterstützt
      if (!['multiple_choice', 'single_choice'].includes(question.type)) {
        console.error('Fragetyp unterstützt keine Optionen:', question.type);
        return false;
      }
      
      // Optionen-Array prüfen
      if (!question.options || !Array.isArray(question.options)) {
        console.error('Keine Optionen in der Frage vorhanden.');
        return false;
      }
      
      // Option-Index prüfen
      if (optionIndex < 0 || optionIndex >= question.options.length) {
        console.error('Ungültiger Option-Index:', optionIndex);
        return false;
      }
      
      // Aktuelle Option
      const option = question.options[optionIndex];
      
      // Bei Single-Choice sicherstellen, dass nur eine Option korrekt ist
      if (question.type === 'single_choice' && updateData.isCorrect === true) {
        // Alle Optionen auf falsch setzen
        question.options.forEach((opt, idx) => {
          if (idx !== optionIndex) {
            opt.isCorrect = false;
          }
        });
      }
      
      // Option aktualisieren
      question.options[optionIndex] = {
        ...option,
        ...updateData
      };
      
      // Aktualisierungsdatum setzen
      question.updatedAt = new Date().toISOString();
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('updateOption', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'updateOption', 
        test: currentTest,
        questionId: questionId,
        optionIndex: optionIndex
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Aktualisieren der Option:', error);
      return false;
    }
  }
  
  /**
   * Löscht eine Antwortoption einer Frage
   * @param {string} questionId - ID der Frage
   * @param {number} optionIndex - Index der zu löschenden Option
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function deleteOption(questionId, optionIndex) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage
      const question = currentTest.questions[questionIndex];
      
      // Prüfen, ob der Fragetyp Optionen unterstützt
      if (!['multiple_choice', 'single_choice'].includes(question.type)) {
        console.error('Fragetyp unterstützt keine Optionen:', question.type);
        return false;
      }
      
      // Optionen-Array prüfen
      if (!question.options || !Array.isArray(question.options)) {
        console.error('Keine Optionen in der Frage vorhanden.');
        return false;
      }
      
      // Option-Index prüfen
      if (optionIndex < 0 || optionIndex >= question.options.length) {
        console.error('Ungültiger Option-Index:', optionIndex);
        return false;
      }
      
      // Prüfen, ob mindestens eine Option übrig bleibt
      if (question.options.length <= 1) {
        console.error('Frage muss mindestens eine Option haben.');
        NotificationSystem.showError('Eine Frage muss mindestens eine Antwortoption haben.');
        return false;
      }
      
      // Zu löschende Option
      const optionToDelete = question.options[optionIndex];
      
      // Option entfernen
      question.options.splice(optionIndex, 1);
      
      // Wenn die gelöschte Option die einzige korrekte war, die erste Option als korrekt markieren
      if (optionToDelete.isCorrect && !question.options.some(opt => opt.isCorrect)) {
        if (question.options.length > 0) {
          question.options[0].isCorrect = true;
        }
      }
      
      // Aktualisierungsdatum setzen
      question.updatedAt = new Date().toISOString();
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('deleteOption', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'deleteOption', 
        test: currentTest,
        questionId: questionId
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Löschen der Option:', error);
      return false;
    }
  }
  
  /**
   * Verschiebt eine Antwortoption innerhalb einer Frage
   * @param {string} questionId - ID der Frage
   * @param {number} optionIndex - Index der zu verschiebenden Option
   * @param {number} newPosition - Neue Position der Option
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function moveOption(questionId, optionIndex, newPosition) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage
      const question = currentTest.questions[questionIndex];
      
      // Prüfen, ob der Fragetyp Optionen unterstützt
      if (!['multiple_choice', 'single_choice'].includes(question.type)) {
        console.error('Fragetyp unterstützt keine Optionen:', question.type);
        return false;
      }
      
      // Optionen-Array prüfen
      if (!question.options || !Array.isArray(question.options)) {
        console.error('Keine Optionen in der Frage vorhanden.');
        return false;
      }
      
      // Option-Index prüfen
      if (optionIndex < 0 || optionIndex >= question.options.length) {
        console.error('Ungültiger Option-Index:', optionIndex);
        return false;
      }
      
      // Neue Position validieren
      if (newPosition < 0 || newPosition >= question.options.length) {
        console.error('Ungültige Position:', newPosition);
        return false;
      }
      
      // Wenn die Option bereits an der gewünschten Position ist, nichts tun
      if (optionIndex === newPosition) {
        return true;
      }
      
      // Option entfernen
      const [option] = question.options.splice(optionIndex, 1);
      
      // Option an neuer Position einfügen
      question.options.splice(newPosition, 0, option);
      
      // Aktualisierungsdatum setzen
      question.updatedAt = new Date().toISOString();
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('moveOption', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'moveOption', 
        test: currentTest,
        questionId: questionId,
        optionIndex: optionIndex,
        newPosition: newPosition
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Verschieben der Option:', error);
      return false;
    }
  }
  
  /**
   * Ändert den Typ einer Frage
   * @param {string} questionId - ID der Frage
   * @param {string} newType - Neuer Fragetyp
   * @returns {boolean} - true bei Erfolg, false bei Fehler
   */
  function changeQuestionType(questionId, newType) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return false;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return false;
    }
    
    // Fragetyp validieren
    const validTypes = ['multiple_choice', 'single_choice', 'true_false', 'text'];
    if (!validTypes.includes(newType)) {
      console.error('Ungültiger Fragetyp:', newType);
      return false;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return false;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return false;
      }
      
      // Aktuelle Frage
      const question = currentTest.questions[questionIndex];
      
      // Wenn der Typ bereits gleich ist, nichts tun
      if (question.type === newType) {
        return true;
      }
      
      // Fragetyp ändern
      const oldType = question.type;
      question.type = newType;
      
      // Typ-spezifische Anpassungen
      if (newType === 'multiple_choice' || newType === 'single_choice') {
        // Option-Array erstellen/anpassen für Multiple-Choice und Single-Choice
        if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
          question.options = [
            { text: 'Option 1', isCorrect: true },
            { text: 'Option 2', isCorrect: false }
          ];
        } else if (newType === 'single_choice') {
          // Bei Single-Choice nur die erste Option als korrekt markieren
          const hasCorrectOption = question.options.some(opt => opt.isCorrect);
          
          if (!hasCorrectOption) {
            // Wenn keine korrekte Option vorhanden ist, die erste als korrekt markieren
            if (question.options.length > 0) {
              question.options[0].isCorrect = true;
            }
          } else {
            // Nur die erste korrekte Option behalten
            let foundFirst = false;
            
            question.options.forEach(option => {
              if (option.isCorrect) {
                if (!foundFirst) {
                  foundFirst = true;
                } else {
                  option.isCorrect = false;
                }
              }
            });
          }
        }
        
        // Bei Wechsel von Wahr/Falsch: correctAnswer entfernen
        if (oldType === 'true_false') {
          delete question.correctAnswer;
        }
      } else if (newType === 'true_false') {
        // Bei Wechsel zu Wahr/Falsch
        // correctAnswer setzen (falls von Choice-Typen: basierend auf vorhandenen Optionen)
        if (['multiple_choice', 'single_choice'].includes(oldType) && question.options) {
          question.correctAnswer = question.options.some(opt => opt.isCorrect);
          
          // Options-Array entfernen
          delete question.options;
        } else {
          // Standardwert setzen
          question.correctAnswer = true;
        }
      } else if (newType === 'text') {
        // Bei Wechsel zu Freitext
        // Optionen und correctAnswer entfernen
        delete question.options;
        delete question.correctAnswer;
      }
      
      // Aktualisierungsdatum setzen
      question.updatedAt = new Date().toISOString();
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('changeQuestionType', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'changeQuestionType', 
        test: currentTest,
        questionId: questionId,
        oldType: oldType,
        newType: newType
      });
      
      return true;
    } catch (error) {
      console.error('Fehler beim Ändern des Fragetyps:', error);
      return false;
    }
  }
  
  /**
   * Dupliziert eine Frage im aktuellen Test
   * @param {string} questionId - ID der zu duplizierenden Frage
   * @param {boolean} addAfterOriginal - Ob die Kopie direkt nach dem Original eingefügt werden soll
   * @returns {string|null} - ID der neuen Frage oder null bei Fehler
   */
  function duplicateQuestion(questionId, addAfterOriginal = true) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return null;
    }
    
    if (!questionId) {
      console.error('Keine Frage-ID angegeben.');
      return null;
    }
    
    try {
      // Kopie des aktuellen Zustands für die Änderungshistorie erstellen
      const prevState = JSON.parse(JSON.stringify(currentTest));
      
      // Fragen-Array prüfen
      if (!currentTest.questions || !Array.isArray(currentTest.questions)) {
        console.error('Keine Fragen im Test vorhanden.');
        return null;
      }
      
      // Frage-Index finden
      const questionIndex = currentTest.questions.findIndex(q => q.id === questionId);
      
      if (questionIndex === -1) {
        console.error('Frage nicht gefunden:', questionId);
        return null;
      }
      
      // Frage kopieren
      const originalQuestion = currentTest.questions[questionIndex];
      const duplicatedQuestion = JSON.parse(JSON.stringify(originalQuestion));
      
      // Neue ID generieren
      duplicatedQuestion.id = typeof TestBasicData !== 'undefined' && TestBasicData.generateQuestionId ? 
        TestBasicData.generateQuestionId() : 'q_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
      
      // Text anpassen
      duplicatedQuestion.text = `${originalQuestion.text} (Kopie)`;
      
      // Erstellungs- und Aktualisierungsdatum aktualisieren
      duplicatedQuestion.createdAt = new Date().toISOString();
      duplicatedQuestion.updatedAt = new Date().toISOString();
      
      // Position bestimmen
      let insertPosition = currentTest.questions.length; // Am Ende einfügen
      
      if (addAfterOriginal) {
        insertPosition = questionIndex + 1; // Direkt nach dem Original einfügen
      }
      
      // Frage einfügen
      currentTest.questions.splice(insertPosition, 0, duplicatedQuestion);
      
      // Anzahl der Fragen aktualisieren
      currentTest.questionCount = currentTest.questions.length;
      
      // Aktualisierungsdatum setzen
      currentTest.updatedAt = new Date().toISOString();
      
      // Änderung zur Historie hinzufügen
      editor.addToHistory('duplicateQuestion', prevState, JSON.parse(JSON.stringify(currentTest)));
      
      // Status aktualisieren
      editor.setEditingStatus({ isDirty: true });
      
      // Event auslösen
      editor.triggerEvent('testChanged', { 
        changeType: 'duplicateQuestion', 
        test: currentTest,
        originalQuestionId: questionId,
        newQuestionId: duplicatedQuestion.id
      });
      
      return duplicatedQuestion.id;
    } catch (error) {
      console.error('Fehler beim Duplizieren der Frage:', error);
      return null;
    }
  }
  
  // Fehlende Funktionen im Editor-Modul ergänzen
  if (!editor.addToHistory) {
    editor.addToHistory = function(action, prevState, newState) {
      // Dummy-Implementation, falls die interne Methode nicht verfügbar ist
      console.log('Änderung zur Historie hinzugefügt:', action);
    };
  }
  
  if (!editor.setEditingStatus) {
    editor.setEditingStatus = function(status) {
      // Dummy-Implementation, falls die interne Methode nicht verfügbar ist
      console.log('Bearbeitungsstatus aktualisiert:', status);
    };
  }
  
  if (!editor.triggerEvent) {
    editor.triggerEvent = function(eventName, data) {
      // Dummy-Implementation, falls die interne Methode nicht verfügbar ist
      console.log('Event ausgelöst:', eventName, data);
    };
  }
  
  // TestEditor um neue Funktionen erweitern
  editor.addQuestion = addQuestion;
  editor.updateQuestion = updateQuestion;
  editor.deleteQuestion = deleteQuestion;
  editor.moveQuestion = moveQuestion;
  editor.addOption = addOption;
  editor.updateOption = updateOption;
  editor.deleteOption = deleteOption;
  editor.moveOption = moveOption;
  editor.changeQuestionType = changeQuestionType;
  editor.duplicateQuestion = duplicateQuestion;
})();
/**
 * JS-Block 4.10.4: Test-Editor UI Teil 1 - Grundstruktur und Initialisierung
 * 
 * Dieser Teil implementiert die grundlegende UI-Struktur und Initialisierung
 * für den Test-Editor.
 */

// Test-Editor-UI-Modul als IIFE (Immediately Invoked Function Expression)
const TestEditorUI = (function() {
  // Referenzen auf andere Module
  const editor = window.TestEditor;
  
  if (!editor) {
    console.error('TestEditor-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.2-3 laden.');
    return {};
  }
  
  // DOM-Selektoren
  const selectors = {
    editorContainer: '#test-editor-container',
    testForm: '#test-form',
    testTitle: '#test-title',
    testDescription: '#test-description',
    saveButton: '#save-test-button',
    cancelButton: '#cancel-edit-button',
    questionsList: '#questions-list',
    addQuestionButton: '#add-question-button',
    notificationArea: '#editor-notification-area',
    unsavedChangesIndicator: '#unsaved-changes-indicator'
  };
  
  // Aktueller UI-Zustand
  const uiState = {
    testId: null,
    activeSection: 'basic', // 'basic', 'questions', 'settings'
    editingQuestion: null,
    unsavedChanges: false,
    lastSaveTime: null
  };
  
  /**
   * Initialisiert die Test-Editor-UI
   * @param {string} containerId - ID des Container-Elements
   * @param {string} testId - ID des zu bearbeitenden Tests (optional)
   */
  function initUI(containerId = 'test-editor-container', testId = null) {
    // Container-Element prüfen
    const container = document.getElementById(containerId);
    if (!container) {
      console.error('Container-Element nicht gefunden:', containerId);
      return;
    }
    
    // Test laden, falls ID angegeben
    if (testId) {
      loadTestForEditing(testId);
    }
    
    // Grundstruktur für den Editor erstellen
    createEditorLayout(container);
    
    // Event-Listener registrieren
    setupEventListeners();
    
    // Globale Test-Editor-Events abonnieren
    subscribeToEditorEvents();
  }
  
  /**
   * Lädt einen Test zur Bearbeitung
   * @param {string} testId - ID des Tests
   */
  function loadTestForEditing(testId) {
    if (!testId) {
      console.error('Keine Test-ID angegeben.');
      return;
    }
    
    try {
      // Test im Editor laden
      const test = editor.loadTest(testId);
      
      if (!test) {
        showNotification('Fehler: Test konnte nicht geladen werden.', 'error');
        return;
      }
      
      // UI-Zustand aktualisieren
      uiState.testId = testId;
      uiState.unsavedChanges = false;
      uiState.lastSaveTime = new Date();
      
      // UI mit Test-Daten füllen
      populateUIWithTestData(test);
      
      showNotification(`Test "${test.title}" wurde zum Bearbeiten geladen.`, 'info');
    } catch (error) {
      console.error('Fehler beim Laden des Tests:', error);
      showNotification('Fehler beim Laden des Tests: ' + error.message, 'error');
    }
  }
  
  /**
   * Erstellt einen neuen Test und lädt ihn zur Bearbeitung
   * @param {Object} basicData - Grunddaten für den neuen Test
   */
  function createNewTestForEditing(basicData = {}) {
    try {
      // Neuen Test erstellen
      const test = editor.createNewTest(basicData);
      
      if (!test) {
        showNotification('Fehler: Test konnte nicht erstellt werden.', 'error');
        return;
      }
      
      // UI-Zustand aktualisieren
      uiState.testId = test.id;
      uiState.unsavedChanges = false;
      uiState.lastSaveTime = new Date();
      
      // UI mit Test-Daten füllen
      populateUIWithTestData(test);
      
      showNotification(`Neuer Test "${test.title}" wurde erstellt.`, 'success');
    } catch (error) {
      console.error('Fehler beim Erstellen des Tests:', error);
      showNotification('Fehler beim Erstellen des Tests: ' + error.message, 'error');
    }
  }
  
  /**
   * Erstellt die grundlegende Layout-Struktur für den Editor
   * @param {HTMLElement} container - Das Container-Element
   */
  function createEditorLayout(container) {
    container.innerHTML = `
      <div class="editor-header">
        <h2>Test bearbeiten</h2>
        <div class="editor-status">
          <span id="unsaved-changes-indicator" class="unsaved-indicator" style="display: none;">
            Ungespeicherte Änderungen
          </span>
          <span id="last-saved-time"></span>
        </div>
      </div>
      
      <div class="editor-tabs">
        <button class="tab-button active" data-section="basic">Grunddaten</button>
        <button class="tab-button" data-section="questions">Fragen</button>
        <button class="tab-button" data-section="settings">Einstellungen</button>
      </div>
      
      <div id="editor-notification-area" class="notification-area"></div>
      
      <div class="editor-content">
        <!-- Grunddaten-Bereich -->
        <div id="section-basic" class="editor-section active">
          <form id="test-form" class="test-form">
            <div class="form-group">
              <label for="test-title">Titel:</label>
              <input type="text" id="test-title" class="form-control" required>
            </div>
            
            <div class="form-group">
              <label for="test-description">Beschreibung:</label>
              <textarea id="test-description" class="form-control" rows="4"></textarea>
            </div>
            
            <div class="form-group">
              <label for="test-category">Kategorie:</label>
              <input type="text" id="test-category" class="form-control">
            </div>
            
            <div class="form-group">
              <label for="test-tags">Tags (durch Komma getrennt):</label>
              <input type="text" id="test-tags" class="form-control">
            </div>
            
            <div class="form-row">
              <div class="form-group half">
                <label for="test-difficulty">Schwierigkeitsgrad:</label>
                <select id="test-difficulty" class="form-control">
                  <option value="leicht">Leicht</option>
                  <option value="mittel" selected>Mittel</option>
                  <option value="schwer">Schwer</option>
                </select>
              </div>
              
              <div class="form-group half">
                <label for="test-duration">Zeitlimit (Minuten):</label>
                <input type="number" id="test-duration" class="form-control" min="0" value="0">
                <p class="form-hint">0 = kein Zeitlimit</p>
              </div>
            </div>
          </form>
        </div>
        
        <!-- Fragen-Bereich -->
        <div id="section-questions" class="editor-section">
          <div class="questions-toolbar">
            <button id="add-question-button" class="btn btn-primary">
              <i class="icon-add"></i> Frage hinzufügen
            </button>
            
            <div class="questions-filter">
              <select id="question-type-filter" class="form-control">
                <option value="">Alle Fragetypen</option>
                <option value="multiple_choice">Multiple Choice</option>
                <option value="single_choice">Single Choice</option>
                <option value="true_false">Wahr/Falsch</option>
                <option value="text">Freitext</option>
              </select>
              
              <input type="text" id="question-search" class="form-control" placeholder="Fragen durchsuchen...">
            </div>
          </div>
          
          <div id="questions-container">
            <div id="questions-list" class="questions-list"></div>
            
            <div id="empty-questions" class="empty-state">
              <p>Keine Fragen vorhanden.</p>
              <p>Klicken Sie auf "Frage hinzufügen", um Ihrem Test Fragen hinzuzufügen.</p>
            </div>
          </div>
        </div>
        
        <!-- Einstellungen-Bereich -->
        <div id="section-settings" class="editor-section">
          <form id="settings-form" class="settings-form">
            <h3>Test-Einstellungen</h3>
            
            <div class="form-group">
              <label for="passing-score">Bestehensgrenze (%):</label>
              <input type="number" id="passing-score" class="form-control" min="0" max="100" value="70">
            </div>
            
            <div class="form-group checkbox-group">
              <label>
                <input type="checkbox" id="randomize-questions">
                Fragen in zufälliger Reihenfolge anzeigen
              </label>
            </div>
            
            <div class="form-group checkbox-group">
              <label>
                <input type="checkbox" id="show-results-immediately">
                Ergebnisse sofort nach Abschluss anzeigen
              </label>
            </div>
            
            <div class="form-group checkbox-group">
              <label>
                <input type="checkbox" id="allow-review">
                Überprüfung von Antworten erlauben
              </label>
            </div>
            
            <div class="form-group checkbox-group">
              <label>
                <input type="checkbox" id="require-all-questions">
                Beantwortung aller Fragen erforderlich
              </label>
            </div>
            
            <h3>Erweiterte Einstellungen</h3>
            
            <div class="form-group">
              <label for="max-attempts">Maximale Anzahl Versuche:</label>
              <input type="number" id="max-attempts" class="form-control" min="0" value="0">
              <p class="form-hint">0 = unbegrenzte Versuche</p>
            </div>
            
            <div class="form-group">
              <label for="feedback-mode">Feedback-Modus:</label>
              <select id="feedback-mode" class="form-control">
                <option value="none">Kein Feedback</option>
                <option value="basic" selected>Grundlegendes Feedback (bestanden/nicht bestanden)</option>
                <option value="detailed">Detailliertes Feedback (mit korrekten Antworten)</option>
                <option value="custom">Benutzerdefiniertes Feedback</option>
              </select>
            </div>
          </form>
        </div>
      </div>
      
      <div class="editor-footer">
        <button id="cancel-edit-button" class="btn btn-secondary">Abbrechen</button>
        <button id="save-test-button" class="btn btn-primary">Speichern</button>
      </div>
      
      <!-- Modaler Dialog für neue Frage -->
      <div id="question-dialog" class="modal" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h3 id="question-dialog-title">Neue Frage</h3>
            <button class="close-button">&times;</button>
          </div>
          
          <div class="modal-body">
            <form id="question-form">
              <div class="form-group">
                <label for="question-type">Fragetyp:</label>
                <select id="question-type" class="form-control">
                  <option value="multiple_choice">Multiple Choice</option>
                  <option value="single_choice">Single Choice</option>
                  <option value="true_false">Wahr/Falsch</option>
                  <option value="text">Freitext</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="question-text">Frage:</label>
                <textarea id="question-text" class="form-control" rows="4" required></textarea>
              </div>
              
              <div id="options-container" class="options-container">
                <!-- Optionen werden dynamisch eingefügt -->
              </div>
              
              <div id="true-false-container" class="true-false-container" style="display: none;">
                <div class="form-group">
                  <label>Richtige Antwort:</label>
                  <div class="radio-group">
                    <label>
                      <input type="radio" name="correct-answer" value="true" checked>
                      Wahr
                    </label>
                    <label>
                      <input type="radio" name="correct-answer" value="false">
                      Falsch
                    </label>
                  </div>
                </div>
              </div>
            </form>
          </div>
          
          <div class="modal-footer">
            <button id="question-cancel-button" class="btn btn-secondary">Abbrechen</button>
            <button id="question-save-button" class="btn btn-primary">Speichern</button>
          </div>
        </div>
      </div>
    `;
  }
  
  /**
   * Zeigt eine Benachrichtigung an (Platzhalter - wird in Teil 4 implementiert)
   */
  function showNotification(message, type = 'info') {
    console.log(`Notification (${type}): ${message}`);
    // Vollständige Implementierung in Teil 4
  }
  
  /**
   * Füllt die UI mit den Daten des geladenen Tests (Platzhalter - wird in Teil 2 implementiert)
   */
  function populateUIWithTestData(test) {
    console.log('Filling UI with test data:', test.title);
    // Vollständige Implementierung in Teil 2
  }
  
  /**
   * Richtet Event-Listener für die UI-Elemente ein (Platzhalter - wird in Teil 2 implementiert)
   */
  function setupEventListeners() {
    console.log('Setting up event listeners');
    // Vollständige Implementierung in Teil 2
  }
  
  /**
   * Abonniert globale Test-Editor-Events (Platzhalter - wird in Teil 2 implementiert)
   */
  function subscribeToEditorEvents() {
    console.log('Subscribing to editor events');
    // Vollständige Implementierung in Teil 2
  }
  
  // Die vollständige öffentliche API wird in Teil 4 definiert
  // Hier nur die grundlegenden Funktionen exportieren
  return {
    initUI,
    loadTestForEditing,
    createNewTestForEditing,
    uiState
  };
})();

// Vorläufige Zuweisung der UI zur globalen Variablen
window.TestEditorUI = TestEditorUI;
/**
 * JS-Block 4.10.4: Test-Editor UI Teil 2 - Event-Handling und Formularfunktionen
 * 
 * Dieser Teil implementiert das Event-Handling und die Formularfunktionen
 * für den Test-Editor.
 */

// Test-Editor-UI-Modul erweitern
(function() {
  // Referenz auf das existierende TestEditorUI-Modul
  const ui = window.TestEditorUI;
  
  if (!ui) {
    console.error('TestEditorUI-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.4-Teil 1 laden.');
    return;
  }
  
  // Referenz auf TestEditor
  const editor = window.TestEditor;
  
  if (!editor) {
    console.error('TestEditor-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.2-3 laden.');
    return;
  }
  
  /**
   * Richtet Event-Listener für die UI-Elemente ein
   */
  function setupEventListeners() {
    // Tab-Buttons
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const section = button.dataset.section;
        switchSection(section);
      });
    });
    
    // Speichern-Button
    const saveButton = document.querySelector('#save-test-button');
    if (saveButton) {
      saveButton.addEventListener('click', saveTest);
    }
    
    // Abbrechen-Button
    const cancelButton = document.querySelector('#cancel-edit-button');
    if (cancelButton) {
      cancelButton.addEventListener('click', confirmCancel);
    }
    
    // Frage hinzufügen-Button
    const addQuestionButton = document.querySelector('#add-question-button');
    if (addQuestionButton) {
      addQuestionButton.addEventListener('click', showAddQuestionDialog);
    }
    
    // Form-Änderungen überwachen (Grunddaten)
    const formInputs = document.querySelectorAll('#test-form input, #test-form textarea, #test-form select');
    formInputs.forEach(input => {
      input.addEventListener('change', () => {
        markUnsavedChanges();
      });
      
      // Bei Textfeldern auch auf Eingabe reagieren
      if (['text', 'textarea'].includes(input.type)) {
        input.addEventListener('input', () => {
          markUnsavedChanges();
        });
      }
    });
    
    // Form-Änderungen überwachen (Einstellungen)
    const settingsInputs = document.querySelectorAll('#settings-form input, #settings-form select');
    settingsInputs.forEach(input => {
      input.addEventListener('change', () => {
        markUnsavedChanges();
      });
    });
    
    // Filtern von Fragen
    const questionTypeFilter = document.querySelector('#question-type-filter');
    const questionSearchInput = document.querySelector('#question-search');
    
    if (questionTypeFilter) {
      questionTypeFilter.addEventListener('change', () => {
        refreshQuestionsView();
      });
    }
    
    if (questionSearchInput) {
      questionSearchInput.addEventListener('input', () => {
        refreshQuestionsView();
      });
    }
    
    // Ereignisbehandlung für den Fragen-Dialog
    setupQuestionDialogEvents();
  }
  
  /**
   * Richtet Event-Listener für den Fragen-Dialog ein
   */
  function setupQuestionDialogEvents() {
    // Dialog schließen-Button
    const closeButtons = document.querySelectorAll('#question-dialog .close-button, #question-cancel-button');
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        document.getElementById('question-dialog').style.display = 'none';
      });
    });
    
    // Fragetyp-Änderung
    const questionTypeSelect = document.getElementById('question-type');
    if (questionTypeSelect) {
      questionTypeSelect.addEventListener('change', () => {
        updateQuestionFormForType(questionTypeSelect.value);
      });
    }
    
    // Speichern-Button
    const saveButton = document.getElementById('question-save-button');
    if (saveButton) {
      saveButton.addEventListener('click', saveQuestion);
    }
  }
  
  /**
   * Abonniert globale Test-Editor-Events
   */
  function subscribeToEditorEvents() {
    // Event-Listener für Test-Änderungen
    window.addEventListener('testEditor:testChanged', (event) => {
      if (event.detail) {
        markUnsavedChanges();
        
        // Bei Änderungen an Fragen den Fragen-Bereich aktualisieren
        if (['addQuestion', 'updateQuestion', 'deleteQuestion', 'moveQuestion'].includes(event.detail.changeType)) {
          refreshQuestionsView();
        }
      }
    });
    
    // Event-Listener für Test-Speicherung
    window.addEventListener('testEditor:testSaved', (event) => {
      if (event.detail && event.detail.test) {
        clearUnsavedChanges();
        showNotification(`Test "${event.detail.test.title}" wurde erfolgreich gespeichert.`, 'success');
      }
    });
    
    // Event-Listener für Test-Laden
    window.addEventListener('testEditor:testLoaded', (event) => {
      if (event.detail && event.detail.test) {
        populateUIWithTestData(event.detail.test);
      }
    });
  }
  
  /**
   * Wechselt zwischen den Editor-Bereichen
   * @param {string} section - Der zu aktivierende Bereich
   */
  function switchSection(section) {
    // Aktiven Bereich in UI-Zustand speichern
    ui.uiState.activeSection = section;
    
    // Tab-Buttons aktualisieren
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
      if (button.dataset.section === section) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    });
    
    // Bereiche aktualisieren
    const sections = document.querySelectorAll('.editor-section');
    sections.forEach(sec => {
      if (sec.id === `section-${section}`) {
        sec.classList.add('active');
      } else {
        sec.classList.remove('active');
      }
    });
    
    // Bereichsspezifische Aktualisierungen
    if (section === 'questions') {
      refreshQuestionsView();
    }
  }
  
  /**
   * Speichert den aktuellen Test
   */
  function saveTest() {
    try {
      // Prüfen, ob ein Test geladen ist
      if (!ui.uiState.testId) {
        showNotification('Kein Test zum Speichern geladen.', 'error');
        return;
      }
      
      // Grunddaten sammeln
      const basicData = {
        title: document.getElementById('test-title').value,
        description: document.getElementById('test-description').value,
        category: document.getElementById('test-category').value,
        tags: document.getElementById('test-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag),
        difficulty: document.getElementById('test-difficulty').value,
        duration: parseInt(document.getElementById('test-duration').value, 10) || 0
      };
      
      // Einstellungen sammeln
      const settings = {
        passingScore: parseInt(document.getElementById('passing-score').value, 10) || 70,
        randomizeQuestions: document.getElementById('randomize-questions').checked,
        showResultsImmediately: document.getElementById('show-results-immediately').checked,
        allowReview: document.getElementById('allow-review').checked,
        requireAllQuestions: document.getElementById('require-all-questions').checked,
        maxAttempts: parseInt(document.getElementById('max-attempts').value, 10) || 0,
        feedbackMode: document.getElementById('feedback-mode').value
      };
      
      // Grunddaten aktualisieren
      editor.updateBasicData(basicData);
      
      // Einstellungen aktualisieren
      editor.updateSettings(settings);
      
      // Test speichern
      const success = editor.saveCurrentTest();
      
      if (success) {
        clearUnsavedChanges();
        showNotification(`Test "${basicData.title}" wurde erfolgreich gespeichert.`, 'success');
      } else {
        showNotification('Fehler beim Speichern des Tests.', 'error');
      }
    } catch (error) {
      console.error('Fehler beim Speichern des Tests:', error);
      showNotification('Fehler beim Speichern des Tests: ' + error.message, 'error');
    }
  }
  
  /**
   * Fragt nach Bestätigung beim Abbrechen der Bearbeitung
   */
  function confirmCancel() {
    if (ui.uiState.unsavedChanges) {
      const confirmed = confirm('Es gibt ungespeicherte Änderungen. Möchten Sie wirklich abbrechen?');
      
      if (!confirmed) {
        return;
      }
    }
    
    // Zur Übersichtsseite navigieren
    navigateBack();
  }
  
  /**
   * Navigiert zurück zur Übersichtsseite
   */
  function navigateBack() {
    // Prüfen, ob eine Navigation-Funktion verfügbar ist
    if (typeof Navigation !== 'undefined' && Navigation.navigateTo) {
      Navigation.navigateTo('tests');
    } else if (typeof window !== 'undefined') {
      // Fallback: URL ändern
      window.location.href = '?page=tests';
    }
  }
  
  /**
   * Füllt die UI mit den Daten des geladenen Tests
   * @param {Object} test - Der geladene Test
   */
  function populateUIWithTestData(test) {
    // Grunddaten
    document.getElementById('test-title').value = test.title || '';
    document.getElementById('test-description').value = test.description || '';
    document.getElementById('test-category').value = test.category || '';
    document.getElementById('test-tags').value = Array.isArray(test.tags) ? test.tags.join(', ') : '';
    document.getElementById('test-difficulty').value = test.difficulty || 'mittel';
    document.getElementById('test-duration').value = test.duration || 0;
    
    // Einstellungen
    const settings = test.settings || {};
    
    document.getElementById('passing-score').value = settings.passingScore !== undefined ? settings.passingScore : 70;
    document.getElementById('randomize-questions').checked = settings.randomizeQuestions === true;
    document.getElementById('show-results-immediately').checked = settings.showResultsImmediately !== false;
    document.getElementById('allow-review').checked = settings.allowReview !== false;
    document.getElementById('require-all-questions').checked = settings.requireAllQuestions === true;
    document.getElementById('max-attempts').value = settings.maxAttempts || 0;
    document.getElementById('feedback-mode').value = settings.feedbackMode || 'basic';
    
    // Fragen-Bereich aktualisieren
    refreshQuestionsView();
    
    // Zeit der letzten Speicherung anzeigen
    const timeDisplay = document.getElementById('last-saved-time');
    if (timeDisplay) {
      timeDisplay.textContent = `Zuletzt gespeichert: ${formatTime(new Date())}`;
    }
  }
  
  /**
   * Markiert den Test als mit ungespeicherten Änderungen
   */
  function markUnsavedChanges() {
    ui.uiState.unsavedChanges = true;
    
    // Indikator für ungespeicherte Änderungen anzeigen
    const indicator = document.getElementById('unsaved-changes-indicator');
    if (indicator) {
      indicator.style.display = 'inline-block';
    }
  }
  
  /**
   * Setzt den Status für ungespeicherte Änderungen zurück
   */
  function clearUnsavedChanges() {
    ui.uiState.unsavedChanges = false;
    ui.uiState.lastSaveTime = new Date();
    
    // Indikator für ungespeicherte Änderungen ausblenden
    const indicator = document.getElementById('unsaved-changes-indicator');
    if (indicator) {
      indicator.style.display = 'none';
    }
    
    // Letzte Speicherzeit anzeigen
    const timeDisplay = document.getElementById('last-saved-time');
    if (timeDisplay) {
      timeDisplay.textContent = `Zuletzt gespeichert: ${formatTime(ui.uiState.lastSaveTime)}`;
    }
  }
  
  /**
   * Formatiert eine Zeit als String
   * @param {Date} date - Das zu formatierende Datum
   * @returns {string} - Formatierte Zeit
   */
  function formatTime(date) {
    if (!date) return '';
    
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  /**
   * Aktualisiert die Anzeige der Fragen (Platzhalter - wird in Teil 3 implementiert)
   */
  function refreshQuestionsView() {
    console.log('Refreshing questions view');
    // Vollständige Implementierung in Teil 3
  }
  
  /**
   * Zeigt den Dialog zum Hinzufügen einer neuen Frage (Platzhalter - wird in Teil 3 implementiert)
   */
  function showAddQuestionDialog() {
    console.log('Showing add question dialog');
    // Vollständige Implementierung in Teil 3
  }
  
  /**
   * Aktualisiert das Fragenformular basierend auf dem Fragetyp (Platzhalter - wird in Teil 3 implementiert)
   */
  function updateQuestionFormForType() {
    console.log('Updating question form for type');
    // Vollständige Implementierung in Teil 3
  }
  
  /**
   * Speichert die aktuell bearbeitete Frage (Platzhalter - wird in Teil 3 implementiert)
   */
  function saveQuestion() {
    console.log('Saving question');
    // Vollständige Implementierung in Teil 3
  }
  
  /**
   * Zeigt eine Benachrichtigung an (Platzhalter - wird in Teil 4 implementiert)
   */
  function showNotification(message, type = 'info') {
    console.log(`Notification (${type}): ${message}`);
    // Vollständige Implementierung in Teil 4
  }
  
  // UI-Modul um neue Funktionen erweitern
  ui.setupEventListeners = setupEventListeners;
  ui.subscribeToEditorEvents = subscribeToEditorEvents;
  ui.switchSection = switchSection;
  ui.saveTest = saveTest;
  ui.confirmCancel = confirmCancel;
  ui.navigateBack = navigateBack;
  ui.populateUIWithTestData = populateUIWithTestData;
  ui.markUnsavedChanges = markUnsavedChanges;
  ui.clearUnsavedChanges = clearUnsavedChanges;
})();
/**
 * JS-Block 4.10.4: Test-Editor UI Teil 3 - Fragen-UI-Funktionen
 * 
 * Dieser Teil implementiert die UI-Funktionen für das Erstellen, Anzeigen,
 * Bearbeiten und Löschen von Fragen innerhalb des Test-Editors.
 */

// Test-Editor-UI-Modul erweitern
(function() {
  // Referenz auf das existierende TestEditorUI-Modul
  const ui = window.TestEditorUI;
  
  if (!ui) {
    console.error('TestEditorUI-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.4-Teil 1 und 2 laden.');
    return;
  }
  
  // Referenz auf TestEditor
  const editor = window.TestEditor;
  
  if (!editor) {
    console.error('TestEditor-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.2-3 laden.');
    return;
  }
  
  /**
   * Aktualisiert die Anzeige der Fragen
   */
  function refreshQuestionsView() {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest) {
      console.error('Kein Test geladen.');
      return;
    }
    
    // Fragen-Liste leeren
    const questionsList = document.getElementById('questions-list');
    if (!questionsList) return;
    
    questionsList.innerHTML = '';
    
    // Prüfen, ob Fragen vorhanden sind
    const hasQuestions = currentTest.questions && Array.isArray(currentTest.questions) && currentTest.questions.length > 0;
    
    // Leerer Zustand
    const emptyState = document.getElementById('empty-questions');
    if (emptyState) {
      emptyState.style.display = hasQuestions ? 'none' : 'block';
    }
    
    if (!hasQuestions) {
      return;
    }
    
    // Filter-Werte holen
    const typeFilter = document.getElementById('question-type-filter');
    const searchInput = document.getElementById('question-search');
    
    const typeValue = typeFilter ? typeFilter.value : '';
    const searchValue = searchInput ? searchInput.value.toLowerCase() : '';
    
    // Fragen filtern
    let filteredQuestions = currentTest.questions;
    
    if (typeValue) {
      filteredQuestions = filteredQuestions.filter(q => q.type === typeValue);
    }
    
    if (searchValue) {
      filteredQuestions = filteredQuestions.filter(q => 
        q.text && q.text.toLowerCase().includes(searchValue)
      );
    }
    
    // Fragen anzeigen
    filteredQuestions.forEach((question, index) => {
      const questionItem = createQuestionListItem(question, index);
      questionsList.appendChild(questionItem);
    });
  }
  
  /**
   * Erstellt ein Listenelement für eine Frage
   * @param {Object} question - Die Frage
   * @param {number} index - Der Index der Frage
   * @returns {HTMLElement} - Das erstellte Listenelement
   */
  function createQuestionListItem(question, index) {
    const questionItem = document.createElement('div');
    questionItem.className = 'question-item';
    questionItem.dataset.questionId = question.id;
    
    // Fragetyp-Bezeichnung
    const typeLabels = {
      'multiple_choice': 'Multiple Choice',
      'single_choice': 'Single Choice',
      'true_false': 'Wahr/Falsch',
      'text': 'Freitext'
    };
    
    const typeLabel = typeLabels[question.type] || 'Unbekannt';
    
    // HTML für die Vorschau
    questionItem.innerHTML = `
      <div class="question-header">
        <div class="question-number">${index + 1}</div>
        <div class="question-type">${typeLabel}</div>
        <div class="question-actions">
          <button class="btn btn-icon edit-question" title="Frage bearbeiten">
            <i class="icon-edit"></i>
          </button>
          <button class="btn btn-icon duplicate-question" title="Frage duplizieren">
            <i class="icon-copy"></i>
          </button>
          <button class="btn btn-icon delete-question" title="Frage löschen">
            <i class="icon-delete"></i>
          </button>
        </div>
      </div>
      
      <div class="question-content">
        <div class="question-text">${question.text || 'Keine Fragestellung'}</div>
        
        ${question.type === 'multiple_choice' || question.type === 'single_choice' ? 
          `<div class="question-preview-options">
            ${(question.options || []).map(option => 
              `<div class="preview-option ${option.isCorrect ? 'correct' : ''}">
                ${option.isCorrect ? '✓' : '○'} ${option.text || ''}
              </div>`
            ).join('')}
          </div>` : 
          ''
        }
        
        ${question.type === 'true_false' ? 
          `<div class="question-preview-options">
            <div class="preview-option ${question.correctAnswer === true ? 'correct' : ''}">
              ${question.correctAnswer === true ? '✓' : '○'} Wahr
            </div>
            <div class="preview-option ${question.correctAnswer === false ? 'correct' : ''}">
              ${question.correctAnswer === false ? '✓' : '○'} Falsch
            </div>
          </div>` : 
          ''
        }
      </div>
    `;
    
    // Event-Listener für die Aktionsbuttons
    const editButton = questionItem.querySelector('.edit-question');
    if (editButton) {
      editButton.addEventListener('click', (event) => {
        event.stopPropagation();
        showEditQuestionDialog(question.id);
      });
    }
    
    const duplicateButton = questionItem.querySelector('.duplicate-question');
    if (duplicateButton) {
      duplicateButton.addEventListener('click', (event) => {
        event.stopPropagation();
        duplicateQuestion(question.id);
      });
    }
    
    const deleteButton = questionItem.querySelector('.delete-question');
    if (deleteButton) {
      deleteButton.addEventListener('click', (event) => {
        event.stopPropagation();
        confirmDeleteQuestion(question.id);
      });
    }
    
    // Klick auf die gesamte Frage
    questionItem.addEventListener('click', () => {
      showEditQuestionDialog(question.id);
    });
    
    return questionItem;
  }
  
  /**
   * Zeigt den Dialog zum Hinzufügen einer neuen Frage
   */
  function showAddQuestionDialog() {
    // Dialog-Titel setzen
    document.getElementById('question-dialog-title').textContent = 'Neue Frage';
    
    // Formular zurücksetzen
    document.getElementById('question-form').reset();
    document.getElementById('question-text').value = '';
    
    // Optionen für den gewählten Fragetyp anzeigen
    const questionType = document.getElementById('question-type').value;
    updateQuestionFormForType(questionType);
    
    // Speicher-Funktion für neue Frage
    ui.uiState.editingQuestion = null;
    
    // Dialog anzeigen
    document.getElementById('question-dialog').style.display = 'block';
  }
  
  /**
   * Zeigt den Dialog zum Bearbeiten einer Frage
   * @param {string} questionId - ID der zu bearbeitenden Frage
   */
  function showEditQuestionDialog(questionId) {
    // Aktuellen Test holen
    const currentTest = editor.getCurrentTest();
    
    if (!currentTest || !currentTest.questions) {
      return;
    }
    
    // Frage finden
    const question = currentTest.questions.find(q => q.id === questionId);
    
    if (!question) {
      console.error('Frage nicht gefunden:', questionId);
      return;
    }
    
    // Dialog-Titel setzen
    document.getElementById('question-dialog-title').textContent = 'Frage bearbeiten';
    
    // Formular mit Fragedaten füllen
    document.getElementById('question-type').value = question.type || 'text';
    document.getElementById('question-type').disabled = true; // Typ kann nicht geändert werden
    document.getElementById('question-text').value = question.text || '';
    
    // Optionen für den Fragetyp anzeigen und füllen
    updateQuestionFormForType(question.type, question);
    
    // Speicher-Funktion für Bearbeitung
    ui.uiState.editingQuestion = questionId;
    
    // Dialog anzeigen
    document.getElementById('question-dialog').style.display = 'block';
  }
  
  /**
   * Aktualisiert das Fragenformular basierend auf dem Fragetyp
   * @param {string} questionType - Der Fragetyp
   * @param {Object} questionData - Vorhandene Fragedaten (optional)
   */
  function updateQuestionFormForType(questionType, questionData = null) {
    // Optionen-Container
    const optionsContainer = document.getElementById('options-container');
    // Wahr/Falsch-Container
    const trueFalseContainer = document.getElementById('true-false-container');
    
    // Alle Container ausblenden
    optionsContainer.style.display = 'none';
    trueFalseContainer.style.display = 'none';
    
    // Container basierend auf Fragetyp anzeigen
    if (questionType === 'multiple_choice' || questionType === 'single_choice') {
      optionsContainer.style.display = 'block';
      
      // Optionen-Container leeren
      optionsContainer.innerHTML = '';
      
      // Optionen-Header
      const header = document.createElement('div');
      header.className = 'options-header';
      header.innerHTML = `
        <h4>Antwortoptionen</h4>
        <button type="button" id="add-option-button" class="btn btn-outline btn-sm">
          <i class="icon-add"></i> Option hinzufügen
        </button>
      `;
      optionsContainer.appendChild(header);
      
      // Bereits vorhandene Optionen hinzufügen
      let options = [];
      
      if (questionData && questionData.options && Array.isArray(questionData.options)) {
        options = questionData.options;
      } else {
        // Standardoptionen für neue Fragen
        options = [
          { text: 'Option 1', isCorrect: true },
          { text: 'Option 2', isCorrect: false }
        ];
      }
      
      // Optionen erstellen
      options.forEach((option, index) => {
        const optionElement = createOptionElement(option, index, questionType);
        optionsContainer.appendChild(optionElement);
      });
      
      // Event-Listener für "Option hinzufügen" Button
      document.getElementById('add-option-button').addEventListener('click', () => {
        const newIndex = optionsContainer.querySelectorAll('.option-item').length;
        const newOption = { text: `Option ${newIndex + 1}`, isCorrect: false };
        const optionElement = createOptionElement(newOption, newIndex, questionType);
        optionsContainer.appendChild(optionElement);
      });
      
    } else if (questionType === 'true_false') {
      trueFalseContainer.style.display = 'block';
      
      // Wahr/Falsch-Wert setzen, falls vorhanden
      if (questionData && typeof questionData.correctAnswer === 'boolean') {
        const trueRadio = document.querySelector('input[name="correct-answer"][value="true"]');
        const falseRadio = document.querySelector('input[name="correct-answer"][value="false"]');
        
        if (trueRadio && falseRadio) {
          trueRadio.checked = questionData.correctAnswer === true;
          falseRadio.checked = questionData.correctAnswer === false;
        }
      }
    }
    // Bei Freitext-Fragen sind keine weiteren Elemente erforderlich
  }
  
  /**
   * Erstellt ein Element für eine Antwortoption
   * @param {Object} option - Die Antwortoption
   * @param {number} index - Der Index der Option
   * @param {string} questionType - Der Fragetyp
   * @returns {HTMLElement} - Das erstellte Optionselement
   */
  function createOptionElement(option, index, questionType) {
    const optionElement = document.createElement('div');
    optionElement.className = 'option-item';
    optionElement.dataset.index = index;
    
    // Input-Typ basierend auf Fragetyp
    const inputType = questionType === 'multiple_choice' ? 'checkbox' : 'radio';
    const inputName = questionType === 'multiple_choice' ? `option-correct-${index}` : 'option-correct';
    
    optionElement.innerHTML = `
      <div class="option-correct">
        <input type="${inputType}" name="${inputName}" class="option-correct-input" ${option.isCorrect ? 'checked' : ''}>
      </div>
      <div class="option-text">
        <input type="text" class="form-control option-text-input" value="${option.text || ''}" placeholder="Antworttext">
      </div>
      <div class="option-actions">
        <button type="button" class="btn btn-icon remove-option" title="Option entfernen">
          <i class="icon-delete"></i>
        </button>
      </div>
    `;
    
    // Event-Listener für "Option entfernen" Button
    const removeButton = optionElement.querySelector('.remove-option');
    if (removeButton) {
      removeButton.addEventListener('click', () => {
        // Prüfen, ob mindestens eine Option übrig bleibt
        const optionsCount = document.querySelectorAll('.option-item').length;
        if (optionsCount <= 1) {
          showNotification('Eine Frage muss mindestens eine Antwortoption haben.', 'error');
          return;
        }
        
        optionElement.remove();
      });
    }
    
    // Bei Single-Choice: Wenn eine Option als korrekt markiert wird, alle anderen abwählen
    if (questionType === 'single_choice') {
      const correctInput = optionElement.querySelector('.option-correct-input');
      if (correctInput) {
        correctInput.addEventListener('change', () => {
          if (correctInput.checked) {
            // Alle anderen Optionen abwählen
            document.querySelectorAll('.option-correct-input').forEach(input => {
              if (input !== correctInput) {
                input.checked = false;
              }
            });
          }
        });
      }
    }
    
    return optionElement;
  }
  
  /**
   * Speichert die aktuell bearbeitete Frage
   */
  function saveQuestion() {
    try {
      // Fragedaten sammeln
      const questionType = document.getElementById('question-type').value;
      const questionText = document.getElementById('question-text').value;
      
      if (!questionText.trim()) {
        showNotification('Bitte geben Sie einen Fragetext ein.', 'error');
        return;
      }
      
      // Grunddaten für die Frage
      const questionData = {
        type: questionType,
        text: questionText,
        updatedAt: new Date().toISOString()
      };
      
      // Typ-spezifische Daten sammeln
      if (questionType === 'multiple_choice' || questionType === 'single_choice') {
        // Optionen sammeln
        const optionItems = document.querySelectorAll('.option-item');
        
        if (optionItems.length === 0) {
          showNotification('Bitte fügen Sie mindestens eine Antwortoption hinzu.', 'error');
          return;
        }
        
        questionData.options = Array.from(optionItems).map(item => {
          return {
            text: item.querySelector('.option-text-input').value,
            isCorrect: item.querySelector('.option-correct-input').checked
          };
        });
        
        // Bei Single-Choice prüfen, ob genau eine Option als korrekt markiert ist
        if (questionType === 'single_choice') {
          const correctCount = questionData.options.filter(opt => opt.isCorrect).length;
          
          if (correctCount !== 1) {
            showNotification('Bei Single-Choice-Fragen muss genau eine Option als korrekt markiert sein.', 'error');
            return;
          }
        }
        
        // Bei Multiple-Choice prüfen, ob mindestens eine Option als korrekt markiert ist
        if (questionType === 'multiple_choice') {
          const hasCorrectOption = questionData.options.some(opt => opt.isCorrect);
          
          if (!hasCorrectOption) {
            showNotification('Bitte markieren Sie mindestens eine Option als korrekt.', 'error');
            return;
          }
        }
      } else if (questionType === 'true_false') {
        // Wahr/Falsch-Wert
        const trueRadio = document.querySelector('input[name="correct-answer"][value="true"]');
        const correctAnswer = trueRadio && trueRadio.checked;
        questionData.correctAnswer = correctAnswer;
      }
      
      // Frage speichern oder aktualisieren
      if (ui.uiState.editingQuestion) {
        // Bestehende Frage aktualisieren
        const success = editor.updateQuestion(ui.uiState.editingQuestion, questionData);
        
        if (success) {
          showNotification('Frage erfolgreich aktualisiert.', 'success');
        } else {
          showNotification('Fehler beim Aktualisieren der Frage.', 'error');
          return;
        }
      } else {
        // Neue Frage hinzufügen
        const questionId = editor.addQuestion(questionData);
        
        if (questionId) {
          showNotification('Frage erfolgreich hinzugefügt.', 'success');
        } else {
          showNotification('Fehler beim Hinzufügen der Frage.', 'error');
          return;
        }
      }
      
      // Dialog schließen
      document.getElementById('question-dialog').style.display = 'none';
      
      // Fragen-Ansicht aktualisieren
      refreshQuestionsView();
      
      // UI-Zustand aktualisieren
      ui.uiState.editingQuestion = null;
      ui.markUnsavedChanges();
    } catch (error) {
      console.error('Fehler beim Speichern der Frage:', error);
      showNotification('Fehler beim Speichern der Frage: ' + error.message, 'error');
    }
  }
  
  /**
   * Dupliziert eine Frage
   * @param {string} questionId - ID der zu duplizierenden Frage
   */
  function duplicateQuestion(questionId) {
    try {
      const newQuestionId = editor.duplicateQuestion(questionId);
      
      if (newQuestionId) {
        showNotification('Frage erfolgreich dupliziert.', 'success');
        refreshQuestionsView();
        ui.markUnsavedChanges();
      } else {
        showNotification('Fehler beim Duplizieren der Frage.', 'error');
      }
    } catch (error) {
      console.error('Fehler beim Duplizieren der Frage:', error);
      showNotification('Fehler beim Duplizieren der Frage: ' + error.message, 'error');
    }
  }
  
  /**
   * Fragt nach Bestätigung zum Löschen einer Frage
   * @param {string} questionId - ID der zu löschenden Frage
   */
  function confirmDeleteQuestion(questionId) {
    const confirmed = confirm('Möchten Sie diese Frage wirklich löschen?');
    
    if (confirmed) {
      try {
        const success = editor.deleteQuestion(questionId);
        
        if (success) {
          showNotification('Frage erfolgreich gelöscht.', 'success');
          refreshQuestionsView();
          ui.markUnsavedChanges();
        } else {
          showNotification('Fehler beim Löschen der Frage.', 'error');
        }
      } catch (error) {
        console.error('Fehler beim Löschen der Frage:', error);
        showNotification('Fehler beim Löschen der Frage: ' + error.message, 'error');
      }
    }
  }
  
  /**
   * Zeigt eine Benachrichtigung an (Platzhalter - wird in Teil 4 implementiert)
   */
  function showNotification(message, type = 'info') {
    console.log(`Notification (${type}): ${message}`);
    // Vollständige Implementierung in Teil 4
  }
  
  // UI-Modul um neue Funktionen erweitern
  ui.refreshQuestionsView = refreshQuestionsView;
  ui.showAddQuestionDialog = showAddQuestionDialog;
  ui.showEditQuestionDialog = showEditQuestionDialog;
  ui.updateQuestionFormForType = updateQuestionFormForType;
  ui.saveQuestion = saveQuestion;
  ui.duplicateQuestion = duplicateQuestion;
  ui.confirmDeleteQuestion = confirmDeleteQuestion;
})();
/**
 * JS-Block 4.10.4: Test-Editor UI Teil 4 - Hilfsfunktionen und Styling
 * 
 * Dieser Teil implementiert die Hilfsfunktionen und das CSS-Styling
 * für die Test-Editor-UI.
 */

// Test-Editor-UI-Modul erweitern
(function() {
  // Referenz auf das existierende TestEditorUI-Modul
  const ui = window.TestEditorUI;
  
  if (!ui) {
    console.error('TestEditorUI-Modul nicht gefunden. Bitte zuerst JS-Block 4.10.4-Teil 1-3 laden.');
    return;
  }
  
  /**
   * Zeigt eine Benachrichtigung an
   * @param {string} message - Die Nachricht
   * @param {string} type - Typ der Nachricht ('success', 'error', 'info')
   */
  function showNotification(message, type = 'info') {
    const notificationArea = document.getElementById('editor-notification-area');
    
    if (!notificationArea) return;
    
    // Benachrichtigung erstellen
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
      <div class="notification-content">
        <div class="notification-message">${message}</div>
        <button class="notification-close">&times;</button>
      </div>
    `;
    
    // Zur Benachrichtigungsfläche hinzufügen
    notificationArea.appendChild(notification);
    
    // Close-Button
    const closeButton = notification.querySelector('.notification-close');
    if (closeButton) {
      closeButton.addEventListener('click', () => {
        notification.classList.add('closing');
        setTimeout(() => {
          notification.remove();
        }, 300);
      });
    }
    
    // Automatisch ausblenden nach 5 Sekunden
    setTimeout(() => {
      notification.classList.add('closing');
      setTimeout(() => {
        notification.remove();
      }, 300);
    }, 5000);
  }
  
  /**
   * Erzeugt eine Excel-artige Zellenreferenz aus einer Zeilennummer und Spaltennummer
   * @param {number} row - Zeilennummer (0-basiert)
   * @param {number} col - Spaltennummer (0-basiert)
   * @returns {string} - Zellenreferenz (z.B. "A1", "B2", "AA10")
   */
  function getCellReference(row, col) {
    // Spaltenbezeichnung berechnen (A, B, C, ..., Z, AA, AB, ...)
    let columnName = '';
    let tempCol = col;
    
    while (tempCol >= 0) {
      columnName = String.fromCharCode(65 + (tempCol % 26)) + columnName;
      tempCol = Math.floor(tempCol / 26) - 1;
    }
    
    // Zeilennummer hinzufügen (1-basiert)
    return columnName + (row + 1);
  }
  
  /**
   * Generiert eine CSV-Datei für den aktuellen Test
   * @returns {string|null} - CSV-String oder null bei Fehler
   */
  function generateCsv() {
    // TestEditor-Modul verwenden
    const editor = window.TestEditor;
    
    if (!editor) {
      console.error('TestEditor-Modul nicht gefunden.');
      return null;
    }
    
    // Aktuellen Test holen
    const test = editor.getCurrentTest();
    
    if (!test) {
      console.error('Kein Test geladen.');
      return null;
    }
    
    try {
      // CSV-Zeilen
      const csvRows = [];
      
      // Header-Zeile
      csvRows.push(['ID', 'Typ', 'Frage', 'Antwortoptionen', 'Korrekte Antwort(en)'].join(','));
      
      // Fragen
      if (test.questions && Array.isArray(test.questions)) {
        test.questions.forEach(question => {
          let optionsText = '';
          let correctAnswers = '';
          
          if (question.type === 'multiple_choice' || question.type === 'single_choice') {
            // Antwortoptionen
            if (question.options && Array.isArray(question.options)) {
              optionsText = question.options.map(opt => `"${opt.text.replace(/"/g, '""')}"`).join('; ');
              
              // Korrekte Antworten
              const correctOptions = question.options.filter(opt => opt.isCorrect);
              correctAnswers = correctOptions.map(opt => `"${opt.text.replace(/"/g, '""')}"`).join('; ');
            }
          } else if (question.type === 'true_false') {
            optionsText = 'Wahr; Falsch';
            correctAnswers = question.correctAnswer === true ? 'Wahr' : 'Falsch';
          }
          
          // Zeile erstellen
          const row = [
            question.id,
            question.type,
            `"${question.text.replace(/"/g, '""')}"`,
            optionsText,
            correctAnswers
          ];
          
          csvRows.push(row.join(','));
        });
      }
      
      // CSV-String zurückgeben
      return csvRows.join('\n');
    } catch (error) {
      console.error('Fehler beim Generieren der CSV-Datei:', error);
      return null;
    }
  }
  
  /**
   * Exportiert den aktuellen Test als CSV-Datei
   */
  function exportAsCsv() {
    // CSV generieren
    const csvContent = generateCsv();
    
    if (!csvContent) {
      showNotification('Fehler beim Erstellen der CSV-Datei.', 'error');
      return;
    }
    
    // TestEditor-Modul verwenden
    const editor = window.TestEditor;
    const test = editor.getCurrentTest();
    
    // Dateinamen erstellen
    const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];
    const filename = `test_${test.id}_${timestamp}.csv`;
    
    // Download-Link erstellen
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = filename;
    
    // Link klicken und entfernen
    document.body.appendChild(downloadLink);
    downloadLink.click();
    setTimeout(() => {
      document.body.removeChild(downloadLink);
      URL.revokeObjectURL(url);
    }, 100);
    
    showNotification(`Test "${test.title}" wurde als CSV exportiert.`, 'success');
  }
  
  /**
   * Generiert eine Fragen-Vorschau im HTML-Format
   * @returns {string} - HTML-String mit der Vorschau
   */
  function generatePreview() {
    // TestEditor-Modul verwenden
    const editor = window.TestEditor;
    
    if (!editor) {
      console.error('TestEditor-Modul nicht gefunden.');
      return 'Fehler: TestEditor-Modul nicht gefunden.';
    }
    
    // Aktuellen Test holen
    const test = editor.getCurrentTest();
    
    if (!test) {
      console.error('Kein Test geladen.');
      return 'Fehler: Kein Test geladen.';
    }
    
    try {
      // HTML-Struktur
      let html = `
        <div class="test-preview">
          <h1>${test.title || 'Unbenannter Test'}</h1>
          ${test.description ? `<p class="test-description">${test.description}</p>` : ''}
          
          <div class="test-metadata">
            <div class="metadata-item">
              <span class="metadata-label">Schwierigkeit:</span>
              <span class="metadata-value">${test.difficulty || 'Mittel'}</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">Zeitlimit:</span>
              <span class="metadata-value">${test.duration ? `${test.duration} Minuten` : 'Kein Limit'}</span>
            </div>
            <div class="metadata-item">
              <span class="metadata-label">Fragen:</span>
              <span class="metadata-value">${test.questions ? test.questions.length : 0}</span>
            </div>
          </div>
          
          <div class="questions-list">
      `;
      
      // Fragen hinzufügen
      if (test.questions && Array.isArray(test.questions)) {
        test.questions.forEach((question, index) => {
          html += `
            <div class="preview-question">
              <div class="question-header">
                <div class="question-number">${index + 1}</div>
                <div class="question-type">${getQuestionTypeDisplay(question.type)}</div>
              </div>
              
              <div class="question-content">
                <div class="question-text">${question.text || 'Keine Fragestellung'}</div>
          `;
          
          // Antwortoptionen basierend auf Fragetyp
          if (question.type === 'multiple_choice' || question.type === 'single_choice') {
            html += '<div class="question-options">';
            
            if (question.options && Array.isArray(question.options)) {
              question.options.forEach(option => {
                html += `
                  <div class="option">
                    <input type="${question.type === 'multiple_choice' ? 'checkbox' : 'radio'}" ${option.isCorrect ? 'checked' : ''} disabled>
                    <span>${option.text || ''}</span>
                  </div>
                `;
              });
            }
            
            html += '</div>';
          } else if (question.type === 'true_false') {
            html += `
              <div class="question-options">
                <div class="option">
                  <input type="radio" ${question.correctAnswer === true ? 'checked' : ''} disabled>
                  <span>Wahr</span>
                </div>
                <div class="option">
                  <input type="radio" ${question.correctAnswer === false ? 'checked' : ''} disabled>
                  <span>Falsch</span>
                </div>
              </div>
            `;
          } else if (question.type === 'text') {
            html += `
              <div class="question-answer-field">
                <textarea rows="3" placeholder="Antwort eingeben..." disabled></textarea>
              </div>
            `;
          }
          
          html += `
              </div>
            </div>
          `;
        });
      } else {
        html += '<p class="empty-message">Keine Fragen vorhanden.</p>';
      }
      
      html += `
          </div>
        </div>
      `;
      
      return html;
    } catch (error) {
      console.error('Fehler beim Generieren der Vorschau:', error);
      return 'Fehler beim Generieren der Vorschau: ' + error.message;
    }
  }
  
  /**
   * Gibt die Anzeige für einen Fragetyp zurück
   * @param {string} type - Der Fragetyp
   * @returns {string} - Die Anzeige für den Fragetyp
   */
  function getQuestionTypeDisplay(type) {
    const typeLabels = {
      'multiple_choice': 'Multiple Choice',
      'single_choice': 'Single Choice',
      'true_false': 'Wahr/Falsch',
      'text': 'Freitext'
    };
    
    return typeLabels[type] || 'Unbekannt';
  }
  
  /**
   * Öffnet ein Vorschaufenster für den aktuellen Test
   */
  function showPreview() {
    // HTML-Vorschau generieren
    const previewHtml = generatePreview();
    
    // Neues Fenster öffnen
    const previewWindow = window.open('', 'test_preview', 'width=800,height=600,scrollbars=yes');
    
    // CSS-Styles für die Vorschau
    const previewStyles = `
      <style>
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 800px;
          margin: 0 auto;
          padding: 20px;
        }
        
        h1 {
          text-align: center;
          margin-bottom: 1rem;
        }
        
        .test-description {
          background-color: #f5f5f5;
          padding: 1rem;
          border-left: 4px solid #00FFD0;
          margin-bottom: 1.5rem;
        }
        
        .test-metadata {
          display: flex;
          justify-content: space-between;
          background-color: #f9f9f9;
          padding: 0.8rem;
          border-radius: 4px;
          margin-bottom: 2rem;
        }
        
        .metadata-label {
          font-weight: bold;
          margin-right: 0.5rem;
        }
        
        .preview-question {
          border: 1px solid #ddd;
          border-radius: 4px;
          margin-bottom: 1.5rem;
          overflow: hidden;
        }
        
        .question-header {
          background-color: #f5f5f5;
          padding: 0.8rem;
          display: flex;
          align-items: center;
          border-bottom: 1px solid #ddd;
        }
        
        .question-number {
          width: 24px;
          height: 24px;
          display: flex;
          align-items: center;
          justify-content: center;
          background-color: #00FFD0;
          color: #333;
          border-radius: 50%;
          font-weight: bold;
          margin-right: 0.8rem;
        }
        
        .question-type {
          font-size: 0.85rem;
          color: #666;
        }
        
        .question-content {
          padding: 1rem;
        }
        
        .question-text {
          margin-bottom: 1rem;
        }
        
        .question-options {
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
        }
        
        .option {
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }
        
        .question-answer-field textarea {
          width: 100%;
          border: 1px solid #ddd;
          border-radius: 4px;
          padding: 0.5rem;
        }
        
        .empty-message {
          text-align: center;
          color: #666;
          font-style: italic;
          padding: 2rem;
        }
        
        @media print {
          .preview-question {
            page-break-inside: avoid;
            break-inside: avoid;
          }
        }
      </style>
    `;
    
    // HTML-Dokument in das Vorschaufenster schreiben
    previewWindow.document.write('<!DOCTYPE html><html><head>');
    previewWindow.document.write('<title>Test-Vorschau</title>');
    previewWindow.document.write(previewStyles);
    previewWindow.document.write('</head><body>');
    previewWindow.document.write(previewHtml);
    previewWindow.document.write('<div style="text-align: center; margin-top: 2rem;">');
    previewWindow.document.write('<button onclick="window.print()">Drucken</button>');
    previewWindow.document.write('</div>');
    previewWindow.document.write('</body></html>');
    previewWindow.document.close();
  }
  
  // Stylesheet für den Test-Editor hinzufügen
  function addEditorStyles() {
    const style = document.createElement('style');
    style.id = 'test-editor-styles';
    style.textContent = `
      /* Editor-Container */
      .editor-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 1rem;
      }
      
      /* Editor-Header */
      .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }
      
      .editor-status {
        font-size: 0.85rem;
        color: #666;
      }
      
      .unsaved-indicator {
        color: #e74c3c;
        font-weight: bold;
        margin-right: 1rem;
      }
      
      /* Editor-Tabs */
      .editor-tabs {
        display: flex;
        border-bottom: 1px solid #ddd;
        margin-bottom: 1.5rem;
      }
      
      .tab-button {
        padding: 0.8rem 1.5rem;
        background: none;
        border: none;
        border-bottom: 3px solid transparent;
        cursor: pointer;
        font-weight: 500;
        color: #666;
      }
      
      .tab-button:hover {
        background-color: #f5f5f5;
      }
      
      .tab-button.active {
        border-bottom-color: #00FFD0;
        color: #333;
      }
      
      /* Editor-Inhaltsbereich */
      .editor-section {
        display: none;
        margin-bottom: 2rem;
      }
      
      .editor-section.active {
        display: block;
      }
      
      /* Formularstile */
      .test-form, .settings-form {
        max-width: 800px;
      }
      
      .form-group {
        margin-bottom: 1.5rem;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
      }
      
      .form-hint {
        font-size: 0.8rem;
        color: #666;
        margin-top: 0.3rem;
      }
      
      .form-row {
        display: flex;
        gap: 1.5rem;
      }
      
      .form-group.half {
        flex: 1;
      }
      
      .checkbox-group {
        display: flex;
        align-items: center;
        margin-bottom: 0.8rem;
      }
      
      .checkbox-group label {
        margin-bottom: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
      }
      
      /* Notification-Bereich */
      .notification-area {
        margin-bottom: 1.5rem;
      }
      
      .notification {
        padding: 0.8rem;
        margin-bottom: 0.8rem;
        border-radius: 4px;
        animation: slideIn 0.3s ease;
      }
      
      .notification.closing {
        animation: slideOut 0.3s ease forwards;
      }
      
      .notification.success {
        background-color: #d4edda;
        border-left: 4px solid #28a745;
        color: #155724;
      }
      
      .notification.error {
        background-color: #f8d7da;
        border-left: 4px solid #dc3545;
        color: #721c24;
      }
      
      .notification.info {
        background-color: #d1ecf1;
        border-left: 4px solid #17a2b8;
        color: #0c5460;
      }
      
      .notification-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .notification-close {
        background: none;
        border: none;
        font-size: 1.2rem;
        cursor: pointer;
        color: inherit;
        opacity: 0.7;
      }
      
      .notification-close:hover {
        opacity: 1;
      }
      
      @keyframes slideIn {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      
      /* Fragen-Bereich */
      .questions-toolbar {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1.5rem;
      }
      
      .questions-filter {
        display: flex;
        gap: 0.8rem;
      }
      
      .empty-state {
        text-align: center;
        padding: 3rem;
        background-color: #f9f9f9;
        border-radius: 4px;
        color: #666;
      }
      
      /* Fragen-Liste */
      .questions-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      
      .question-item {
        border: 1px solid #ddd;
        border-radius: 4px;
        overflow: hidden;
        transition: box-shadow 0.2s, transform 0.2s;
        background-color: #fff;
        cursor: pointer;
      }
      
      .question-item:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        transform: translateY(-2px);
      }
      
      .question-header {
        display: flex;
        align-items: center;
        padding: 0.8rem;
        background-color: #f5f5f5;
        border-bottom: 1px solid #ddd;
      }
      
      .question-number {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #00FFD0;
        color: #333;
        border-radius: 50%;
        font-weight: bold;
        margin-right: 0.8rem;
      }
      
      .question-type {
        font-size: 0.85rem;
        color: #666;
      }
      
      .question-actions {
        margin-left: auto;
        display: flex;
        gap: 0.3rem;
      }
      
      .question-content {
        padding: 1rem;
      }
      
      .question-text {
        margin-bottom: 1rem;
      }
      
      .question-preview-options {
        font-size: 0.9rem;
        color: #666;
      }
      
      .preview-option {
        margin-bottom: 0.3rem;
      }
      
      .preview-option.correct {
        color: #28a745;
        font-weight: bold;
      }
      
      /* Fragen-Dialog */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
      }
      
      .modal-content {
        background-color: #fff;
        margin: 5% auto;
        padding: 0;
        width: 90%;
        max-width: 700px;
        border-radius: 4px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        max-height: 90vh;
        display: flex;
        flex-direction: column;
      }
      
      .modal-header {
        padding: 1rem;
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .modal-header h3 {
        margin: 0;
      }
      
      .close-button {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
      }
      
      .modal-body {
        padding: 1.5rem;
        overflow-y: auto;
        flex: 1;
      }
      
      .modal-footer {
        padding: 1rem;
        border-top: 1px solid #ddd;
        display: flex;
        justify-content: flex-end;
        gap: 0.8rem;
      }
      
      /* Optionen-Bereich */
      .options-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      
      .options-container {
        margin-bottom: 1.5rem;
      }
      
      .option-item {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        margin-bottom: 0.8rem;
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
      }
      
      .option-text {
        flex: 1;
      }
      
      /* Editor-Footer */
      .editor-footer {
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
        padding-top: 1.5rem;
        border-top: 1px solid #ddd;
      }
    `;
    
    document.head.appendChild(style);
  }
  
  // Beim Laden der Seite Styles hinzufügen
  if (typeof window !== 'undefined') {
    addEditorStyles();
  }
  
  // UI-Modul um neue Funktionen erweitern
  ui.showNotification = showNotification;
  ui.exportAsCsv = exportAsCsv;
  ui.showPreview = showPreview;
  ui.generatePreview = generatePreview;
  ui.getCellReference = getCellReference;
  
  // Die vollständige öffentliche API definieren
  window.TestEditorUI = {
    // Grundfunktionen
    initUI: ui.initUI,
    loadTestForEditing: ui.loadTestForEditing,
    createNewTestForEditing: ui.createNewTestForEditing,
    saveTest: ui.saveTest,
    confirmCancel: ui.confirmCancel,
    
    // UI-Aktualisierung
    refreshQuestionsView: ui.refreshQuestionsView,
    populateUIWithTestData: ui.populateUIWithTestData,
    switchSection: ui.switchSection,
    
    // Fragen-Funktionen
    showAddQuestionDialog: ui.showAddQuestionDialog,
    showEditQuestionDialog: ui.showEditQuestionDialog,
    saveQuestion: ui.saveQuestion,
    duplicateQuestion: ui.duplicateQuestion,
    confirmDeleteQuestion: ui.confirmDeleteQuestion,
    
    // Zusatzfunktionen
    showNotification: ui.showNotification,
    exportAsCsv: ui.exportAsCsv,
    showPreview: ui.showPreview,
    
    // Status
    uiState: ui.uiState,
    markUnsavedChanges: ui.markUnsavedChanges,
    clearUnsavedChanges: ui.clearUnsavedChanges
  };
})();
// JS-Block 5.1.1: Test-Initialisierung - Testauswahl und Vorbereitung (Teil 1)
// Beschreibung: Dieser Block implementiert die Grundfunktionen für die Test-Initialisierung,
// einschließlich der Benutzeroberfläche zur Testauswahl und der Vorbereitung einer Testsitzung.

App.modules.testExecution = (function() {
  'use strict';
  
  // Private Variablen
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // DOM-Elemente
  let domElements = {
    // Test-Auswahl
    testSelectionContainer: document.getElementById('test-selection-container'),
    availableTestsList: document.getElementById('available-tests-list'),
    testSearchInput: document.getElementById('test-search'),
    testCategoryFilter: document.getElementById('test-category-filter'),
    
    // Test-Initialisierung
    testInfoContainer: document.getElementById('test-info-container'),
    testTitle: document.getElementById('test-title'),
    testDescription: document.getElementById('test-description'),
    testDuration: document.getElementById('test-duration'),
    testQuestionCount: document.getElementById('test-question-count'),
    testPassingScore: document.getElementById('test-passing-score'),
    
    // Steuerungselemente
    startTestBtn: document.getElementById('start-test-btn'),
    backToListBtn: document.getElementById('back-to-list-btn'),
    
    // Test-Durchführung
    testExecutionContainer: document.getElementById('test-execution-container'),
    questionContainer: document.getElementById('question-container'),
    navigationControls: document.getElementById('navigation-controls'),
    progressBar: document.getElementById('test-progress-bar'),
    timeRemainingDisplay: document.getElementById('time-remaining')
  };
  
  // Status einer Testsitzung
  let sessionState = {
    activeTest: null,
    currentSession: null,
    selectedTestId: null,
    questionOrder: [],
    currentQuestionIndex: 0,
    answers: {},
    timeStarted: null,
    timeRemaining: null,
    timerInterval: null,
    testCompleted: false
  };
  
  // ==============================
  // Hilfsfunktionen
  // ==============================
  
  /**
   * Konvertiert Sekunden in ein formatiertes Zeit-String (HH:MM:SS)
   * @param {number} seconds - Die zu konvertierende Zeit in Sekunden
   * @return {string} Formatierte Zeit
   */
  function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    return [
      hours.toString().padStart(2, '0'),
      minutes.toString().padStart(2, '0'),
      secs.toString().padStart(2, '0')
    ].join(':');
  }
  
  /**
   * Mischt ein Array mit dem Fisher-Yates-Algorithmus
   * @param {Array} array - Das zu mischende Array
   * @return {Array} Das gemischte Array
   */
  function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  /**
   * Erstellt eine neue Testsitzung
   * @param {string} testId - Die ID des zu startenden Tests
   * @return {Object} Die neue Testsitzung
   */
  function createNewSession(testId) {
    const test = dataStore.getTestById(testId);
    if (!test) {
      throw new Error(`Test mit ID ${testId} nicht gefunden`);
    }
    
    const currentUser = auth.getCurrentUser();
    if (!currentUser) {
      throw new Error('Kein Benutzer angemeldet');
    }
    
    // Fragen auswählen und ggf. mischen
    let questionIds = [...test.questionIds];
    
    if (test.settings.randomizeQuestions) {
      questionIds = shuffleArray(questionIds);
    }
    
    // Wenn nur eine Teilmenge der Fragen verwendet werden soll
    if (test.settings.useSubsetOfQuestions && 
        test.settings.questionSubsetSize > 0 && 
        test.settings.questionSubsetSize < questionIds.length) {
      questionIds = questionIds.slice(0, test.settings.questionSubsetSize);
    }
    
    // Neue Sitzung erstellen
    const session = {
      id: utils.generateId(),
      testId: test.id,
      userId: currentUser.id,
      startTime: new Date().toISOString(),
      endTime: null,
      completed: false,
      questionIds: questionIds,
      answers: {},
      timeSpent: 0,
      calculatedScore: null,
      passingThreshold: test.settings.passingThresholdPercentage,
      maxScore: test.settings.totalPointsPossible || questionIds.length,
      manualReview: test.settings.requireManualReview,
      reviewerId: test.settings.defaultReviewerId || null,
      reviewStatus: 'pending',
      reviewNotes: ''
    };
    
    // Sitzung speichern
    dataStore.saveTestSession(session);
    
    return session;
  }
  
  // ==============================
  // Test-Auswahl Funktionen
  // ==============================
  
  /**
   * Lädt und zeigt alle verfügbaren Tests für den aktuellen Benutzer
   */
  function loadAvailableTests() {
    const currentUser = auth.getCurrentUser();
    if (!currentUser) {
      utils.showNotification('Fehler', 'Sie müssen angemeldet sein, um Tests durchführen zu können', 'error');
      return;
    }
    
    // Alle Tests abrufen
    const allTests = dataStore.getAllTests();
    
    // Filter basierend auf Benutzerrolle und zugewiesenen Teams
    const availableTests = allTests.filter(test => {
      // Prüfen, ob der Test aktiv ist
      if (!test.active) return false;
      
      // Prüfen, ob der Test dem Benutzer zugewiesen ist
      if (test.assignedUserIds && test.assignedUserIds.includes(currentUser.id)) {
        return true;
      }
      
      // Prüfen, ob der Test einem Team des Benutzers zugewiesen ist
      if (test.assignedTeamIds && currentUser.teamIds) {
        for (const teamId of currentUser.teamIds) {
          if (test.assignedTeamIds.includes(teamId)) {
            return true;
          }
        }
      }
      
      // Administrator sieht alle Tests
      if (currentUser.role === 'administrator') {
        return true;
      }
      
      // Trainer sieht Tests, die er erstellt hat
      if (currentUser.role === 'trainer' && test.createdBy === currentUser.id) {
        return true;
      }
      
      return false;
    });
    
    // Tests anzeigen
    renderAvailableTests(availableTests);
    
    // Kategorien für Filter laden
    updateCategoryFilter(availableTests);
  }
  
  /**
   * Zeigt verfügbare Tests im UI an
   * @param {Array} tests - Array mit verfügbaren Tests
   */
  function renderAvailableTests(tests) {
    const listElement = domElements.availableTestsList;
    listElement.innerHTML = '';
    
    if (tests.length === 0) {
      listElement.innerHTML = '<div class="no-tests-message">Keine Tests verfügbar</div>';
      return;
    }
    
    tests.forEach(test => {
      const testItem = document.createElement('div');
      testItem.className = 'test-list-item';
      testItem.dataset.testId = test.id;
      
      // Test-Status ermitteln (neu, in Bearbeitung, abgeschlossen)
      const testStatus = getTestStatusForUser(test.id);
      const statusClass = `test-status-${testStatus.status}`;
      
      testItem.innerHTML = `
        <div class="test-item-header">
          <h3 class="test-item-title">${utils.escapeHtml(test.title)}</h3>
          <span class="test-item-status ${statusClass}">${testStatus.label}</span>
        </div>
        <div class="test-item-meta">
          <span class="test-item-category">${utils.escapeHtml(test.category || 'Allgemein')}</span>
          <span class="test-item-questions">${test.questionIds.length} Fragen</span>
          <span class="test-item-duration">${formatTime(test.settings.timeLimit || 0)}</span>
        </div>
        <p class="test-item-description">${utils.escapeHtml(test.description || '')}</p>
        <div class="test-item-actions">
          <button class="btn btn-primary select-test-btn">Test auswählen</button>
        </div>
      `;
      
      listElement.appendChild(testItem);
      
      // Event-Listener hinzufügen
      const selectButton = testItem.querySelector('.select-test-btn');
      selectButton.addEventListener('click', () => selectTest(test.id));
    });
  }
  
  /**
   * Ermittelt den Status eines Tests für den aktuellen Benutzer
   * @param {string} testId - Die ID des Tests
   * @return {Object} Statusobjekt mit status und label
   */
  function getTestStatusForUser(testId) {
    const currentUser = auth.getCurrentUser();
    if (!currentUser) {
      return { status: 'new', label: 'Neu' };
    }
    
    // Alle Sitzungen des Benutzers für diesen Test finden
    const userSessions = dataStore.getTestSessionsByUser(currentUser.id)
      .filter(session => session.testId === testId);
    
    if (userSessions.length === 0) {
      return { status: 'new', label: 'Neu' };
    }
    
    // Prüfen, ob es eine abgeschlossene Sitzung gibt
    const completedSessions = userSessions.filter(session => session.completed);
    if (completedSessions.length > 0) {
      // Prüfen, ob der Test bestanden wurde
      const latestCompletedSession = completedSessions.sort((a, b) => 
        new Date(b.endTime) - new Date(a.endTime))[0];
      
      const hasPassed = latestCompletedSession.calculatedScore >= latestCompletedSession.passingThreshold;
      return { 
        status: hasPassed ? 'passed' : 'failed', 
        label: hasPassed ? 'Bestanden' : 'Nicht bestanden' 
      };
    }
    
    // Es gibt angefangene, aber nicht abgeschlossene Sitzungen
    return { status: 'in-progress', label: 'In Bearbeitung' };
  }
  
  /**
   * Aktualisiert die Kategoriefilter-Dropdown basierend auf verfügbaren Tests
   * @param {Array} tests - Array mit verfügbaren Tests
   */
  function updateCategoryFilter(tests) {
    const filterElement = domElements.testCategoryFilter;
    
    // Bestehende Optionen löschen (außer "Alle Kategorien")
    while (filterElement.options.length > 1) {
      filterElement.remove(1);
    }
    
    // Unique Kategorien aus Tests extrahieren
    const categories = [...new Set(tests.map(test => test.category || 'Allgemein'))];
    
    // Optionen hinzufügen
    categories.sort().forEach(category => {
      const option = document.createElement('option');
      option.value = category;
      option.textContent = category;
      filterElement.appendChild(option);
    });
  }
  
  /**
   * Filtert Tests basierend auf Suchtext und Kategorie
   */
  function filterTests() {
    const searchText = domElements.testSearchInput.value.toLowerCase();
    const selectedCategory = domElements.testCategoryFilter.value;
    
    // Alle Tests abrufen
    const allTests = dataStore.getAllTests();
    const currentUser = auth.getCurrentUser();
    
    // Filter basierend auf Benutzerrolle und Zuweisungen
    let availableTests = allTests.filter(test => {
      // Prüfen, ob der Test aktiv ist
      if (!test.active) return false;
      
      // Prüfen, ob der Test dem Benutzer zugewiesen ist
      if (test.assignedUserIds && test.assignedUserIds.includes(currentUser.id)) {
        return true;
      }
      
      // Prüfen, ob der Test einem Team des Benutzers zugewiesen ist
      if (test.assignedTeamIds && currentUser.teamIds) {
        for (const teamId of currentUser.teamIds) {
          if (test.assignedTeamIds.includes(teamId)) {
            return true;
          }
        }
      }
      
      // Administrator sieht alle Tests
      if (currentUser.role === 'administrator') {
        return true;
      }
      
      // Trainer sieht Tests, die er erstellt hat
      if (currentUser.role === 'trainer' && test.createdBy === currentUser.id) {
        return true;
      }
      
      return false;
    });
    
    // Suchtextfilter anwenden
    if (searchText) {
      availableTests = availableTests.filter(test => 
        test.title.toLowerCase().includes(searchText) || 
        (test.description && test.description.toLowerCase().includes(searchText))
      );
    }
    
    // Kategoriefilter anwenden
    if (selectedCategory && selectedCategory !== 'all') {
      availableTests = availableTests.filter(test => 
        (test.category || 'Allgemein') === selectedCategory
      );
    }
    
    // Gefilterte Tests anzeigen
    renderAvailableTests(availableTests);
  }
  
  /**
   * Wählt einen Test aus und zeigt die Testinfos an
   * @param {string} testId - Die ID des ausgewählten Tests
   */
  function selectTest(testId) {
    // Test-Daten laden
    const test = dataStore.getTestById(testId);
    if (!test) {
      utils.showNotification('Fehler', 'Test konnte nicht gefunden werden', 'error');
      return;
    }
    
    // Testinformationen anzeigen
    sessionState.selectedTestId = testId;
    sessionState.activeTest = test;
    
    // UI aktualisieren - Test-Auswahl ausblenden, Test-Info anzeigen
    domElements.testSelectionContainer.classList.add('hidden');
    domElements.testInfoContainer.classList.remove('hidden');
    
    // Test-Informationen füllen
    domElements.testTitle.textContent = test.title;
    domElements.testDescription.textContent = test.description || 'Keine Beschreibung verfügbar';
    domElements.testDuration.textContent = test.settings.timeLimit 
      ? formatTime(test.settings.timeLimit) 
      : 'Keine Zeitbegrenzung';
    domElements.testQuestionCount.textContent = 
      test.settings.useSubsetOfQuestions && test.settings.questionSubsetSize > 0
        ? `${test.settings.questionSubsetSize} (von ${test.questionIds.length})`
        : test.questionIds.length.toString();
    domElements.testPassingScore.textContent = `${test.settings.passingThresholdPercentage}%`;
    
    // Prüfen, ob es eine nicht abgeschlossene Sitzung gibt
    const unfinishedSession = findUnfinishedSession(testId);
    if (unfinishedSession) {
      // Option zum Fortsetzen anbieten
      showResumeOption(unfinishedSession);
    }
  }
  
  /**
   * Sucht nach einer nicht abgeschlossenen Sitzung für einen Test
   * @param {string} testId - Die ID des Tests
   * @return {Object|null} Die nicht abgeschlossene Sitzung oder null
   */
  function findUnfinishedSession(testId) {
    const currentUser = auth.getCurrentUser();
    if (!currentUser) return null;
    
    const userSessions = dataStore.getTestSessionsByUser(currentUser.id);
    const unfinishedSessions = userSessions.filter(session => 
      session.testId === testId && !session.completed
    );
    
    if (unfinishedSessions.length === 0) return null;
    
    // Neueste unfertige Sitzung zurückgeben
    return unfinishedSessions.sort((a, b) => 
      new Date(b.startTime) - new Date(a.startTime)
    )[0];
  }
  
  /**
   * Zeigt Optionen zum Fortsetzen einer nicht abgeschlossenen Testsitzung
   * @param {Object} session - Die nicht abgeschlossene Sitzung
   */
  function showResumeOption(session) {
    // Berechne wie viel Zeit vergangen ist und wie viel noch übrig ist
    const test = dataStore.getTestById(session.testId);
    const timeLimitInSeconds = test.settings.timeLimit || 0;
    
    // Wenn keine Zeitbegrenzung existiert
    if (timeLimitInSeconds === 0) {
      createResumeUI(session, null);
      return;
    }
    
    // Berechne verbleibende Zeit
    const startTime = new Date(session.startTime);
    const now = new Date();
    const elapsedSeconds = Math.floor((now - startTime) / 1000) + (session.timeSpent || 0);
    const remainingSeconds = Math.max(0, timeLimitInSeconds - elapsedSeconds);
    
    createResumeUI(session, remainingSeconds);
  }
  
  /**
   * Erstellt UI-Elemente zum Fortsetzen einer Testsitzung
   * @param {Object} session - Die Testsitzung
   * @param {number|null} remainingSeconds - Verbleibende Zeit in Sekunden oder null bei keiner Zeitbegrenzung
   */
  function createResumeUI(session, remainingSeconds) {
    const resumeContainer = document.createElement('div');
    resumeContainer.className = 'resume-session-container';
    
    let timeInfo = '';
    if (remainingSeconds !== null) {
      timeInfo = remainingSeconds > 0 
        ? `<p>Verbleibende Zeit: ${formatTime(remainingSeconds)}</p>`
        : '<p>Zeitlimit überschritten, aber Sie können den Test noch abschließen.</p>';
    }
    
    const answeredQuestions = Object.keys(session.answers).length;
    const totalQuestions = session.questionIds.length;
    
    resumeContainer.innerHTML = `
      <div class="resume-info">
        <h3>Nicht abgeschlossener Test gefunden</h3>
        <p>Sie haben diesen Test bereits begonnen, aber nicht abgeschlossen.</p>
        <p>Beantwortet: ${answeredQuestions} von ${totalQuestions} Fragen</p>
        ${timeInfo}
      </div>
      <div class="resume-actions">
        <button id="resume-session-btn" class="btn btn-primary">Test fortsetzen</button>
        <button id="restart-test-btn" class="btn btn-outline">Neu starten</button>
      </div>
    `;
    
    // Container vor dem Start-Button einfügen
    const startBtnContainer = domElements.startTestBtn.parentNode;
    startBtnContainer.insertBefore(resumeContainer, domElements.startTestBtn);
    
    // Standard-Start-Button ausblenden
    domElements.startTestBtn.classList.add('hidden');
    
    // Event-Listener hinzufügen
    document.getElementById('resume-session-btn').addEventListener('click', () => {
      resumeSession(session);
    });
    
    document.getElementById('restart-test-btn').addEventListener('click', () => {
      // Alte Sitzung als abgebrochen markieren und neue starten
      session.completed = true;
      session.endTime = new Date().toISOString();
      session.reviewStatus = 'aborted';
      dataStore.saveTestSession(session);
      
      // "Fortsetzen"-Container entfernen und Start-Button wieder anzeigen
      resumeContainer.remove();
      domElements.startTestBtn.classList.remove('hidden');
    });
  }
  // JS-Block 5.1.2: Test-Initialisierung - Testauswahl und Vorbereitung (Teil 2.1)
// Beschreibung: Testsitzungs-Steuerung und Timer-Funktionalität

// Wir erweitern das bereits existierende testExecution-Modul
App.modules.testExecution = (function() {
  // Externe Module und Funktionen
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // DOM-Elemente importieren (gleiche Struktur wie in Teil 1)
  let domElements = {
    testSelectionContainer: document.getElementById('test-selection-container'),
    availableTestsList: document.getElementById('available-tests-list'),
    testSearchInput: document.getElementById('test-search'),
    testCategoryFilter: document.getElementById('test-category-filter'),
    testInfoContainer: document.getElementById('test-info-container'),
    testTitle: document.getElementById('test-title'),
    testDescription: document.getElementById('test-description'),
    testDuration: document.getElementById('test-duration'),
    testQuestionCount: document.getElementById('test-question-count'),
    testPassingScore: document.getElementById('test-passing-score'),
    startTestBtn: document.getElementById('start-test-btn'),
    backToListBtn: document.getElementById('back-to-list-btn'),
    testExecutionContainer: document.getElementById('test-execution-container'),
    questionContainer: document.getElementById('question-container'),
    navigationControls: document.getElementById('navigation-controls'),
    progressBar: document.getElementById('test-progress-bar'),
    timeRemainingDisplay: document.getElementById('time-remaining')
  };
  
  // Testsitzungs-Status (gleiche Struktur wie in Teil 1)
  let sessionState = {
    activeTest: null,
    currentSession: null,
    selectedTestId: null,
    questionOrder: [],
    currentQuestionIndex: 0,
    answers: {},
    timeStarted: null,
    timeRemaining: null,
    timerInterval: null,
    testCompleted: false
  };
  
  // Hilfsfunktionen (Referenz von Teil 1)
  function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    return [
      hours.toString().padStart(2, '0'),
      minutes.toString().padStart(2, '0'),
      secs.toString().padStart(2, '0')
    ].join(':');
  }
  
  function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  // ==============================
  // Teststart und -steuerung
  // ==============================
  
  /**
   * Startet einen neuen Test
   */
  function startTest() {
    try {
      if (!sessionState.selectedTestId) {
        throw new Error('Kein Test ausgewählt');
      }
      
      // Neue Sitzung erstellen
      const session = createNewSession(sessionState.selectedTestId);
      sessionState.currentSession = session;
      
      // Test-Daten einrichten
      setupTestExecution(session);
      
      // UI aktualisieren
      domElements.testInfoContainer.classList.add('hidden');
      domElements.testExecutionContainer.classList.remove('hidden');
      
      // Erste Frage anzeigen
      displayCurrentQuestion();
      
      // Timer starten, falls der Test eine Zeitbegrenzung hat
      if (sessionState.activeTest.settings.timeLimit) {
        startTimer(sessionState.activeTest.settings.timeLimit);
      }
      
      // Navigation und Fortschrittsanzeige initialisieren
      updateNavigationControls();
      updateProgressBar();
      
    } catch (error) {
      utils.showNotification('Fehler', `Test konnte nicht gestartet werden: ${error.message}`, 'error');
    }
  }
  
  /**
   * Setzt eine nicht abgeschlossene Testsitzung fort
   * @param {Object} session - Die fortzusetzende Testsitzung
   */
  function resumeSession(session) {
    try {
      sessionState.currentSession = session;
      sessionState.selectedTestId = session.testId;
      sessionState.activeTest = dataStore.getTestById(session.testId);
      
      if (!sessionState.activeTest) {
        throw new Error('Test konnte nicht geladen werden');
      }
      
      // Test-Daten einrichten
      setupTestExecution(session, true);
      
      // UI aktualisieren
      domElements.testInfoContainer.classList.add('hidden');
      domElements.testExecutionContainer.classList.remove('hidden');
      
      // Frage anzeigen
      displayCurrentQuestion();
      
      // Timer fortsetzen, falls der Test eine Zeitbegrenzung hat
      if (sessionState.activeTest.settings.timeLimit) {
        // Berechne verbleibende Zeit
        const startTime = new Date(session.startTime);
        const now = new Date();
        const elapsedSeconds = Math.floor((now - startTime) / 1000) + (session.timeSpent || 0);
        const totalTimeLimit = sessionState.activeTest.settings.timeLimit;
        let remainingTime = Math.max(0, totalTimeLimit - elapsedSeconds);
        
        // Timer mit verbleibender Zeit starten
        startTimer(remainingTime);
      }
      
      // Navigation und Fortschrittsanzeige initialisieren
      updateNavigationControls();
      updateProgressBar();
      
    } catch (error) {
      utils.showNotification('Fehler', `Test konnte nicht fortgesetzt werden: ${error.message}`, 'error');
    }
  }
  
  /**
   * Richtet die Testausführung ein
   * @param {Object} session - Die Testsitzung
   * @param {boolean} isResume - Flag, ob es eine fortgesetzte Sitzung ist
   */
  function setupTestExecution(session, isResume = false) {
    sessionState.questionOrder = [...session.questionIds];
    sessionState.answers = isResume ? { ...session.answers } : {};
    sessionState.timeStarted = new Date().getTime();
    sessionState.testCompleted = false;
    
    // Bei fortgesetzter Sitzung: Position der nächsten unbeantworteten Frage finden
    if (isResume) {
      for (let i = 0; i < sessionState.questionOrder.length; i++) {
        const questionId = sessionState.questionOrder[i];
        if (!session.answers[questionId]) {
          sessionState.currentQuestionIndex = i;
          break;
        }
      }
    } else {
      sessionState.currentQuestionIndex = 0;
    }
  }
  
  /**
   * Startet den Timer für den Test
   * @param {number} seconds - Gesamtzeit in Sekunden
   */
  function startTimer(seconds) {
    // Vorhandenen Timer löschen, falls vorhanden
    if (sessionState.timerInterval) {
      clearInterval(sessionState.timerInterval);
    }
    
    sessionState.timeRemaining = seconds;
    updateTimerDisplay();
    
    sessionState.timerInterval = setInterval(() => {
      sessionState.timeRemaining--;
      
      // Zeit-Update im UI
      updateTimerDisplay();
      
      // Aktualisiere die verstrichene Zeit in der Sitzung (alle 30 Sekunden)
      if (sessionState.timeRemaining % 30 === 0) {
        updateElapsedTimeInSession();
      }
      
      // Warnhinweis, wenn wenig Zeit übrig ist (5 Minuten)
      if (sessionState.timeRemaining === 300) {
        showTimeWarning(5);
      }
      
      // Warnhinweis, wenn sehr wenig Zeit übrig ist (1 Minute)
      if (sessionState.timeRemaining === 60) {
        showTimeWarning(1);
      }
      
      // Wenn die Zeit abgelaufen ist
      if (sessionState.timeRemaining <= 0) {
        clearInterval(sessionState.timerInterval);
        handleTimeExpired();
      }
    }, 1000);
  }
  
  /**
   * Aktualisiert die verstrichene Zeit in der Testsitzung
   */
  function updateElapsedTimeInSession() {
    if (!sessionState.currentSession) return;
    
    const timeElapsed = Math.floor((new Date().getTime() - sessionState.timeStarted) / 1000);
    sessionState.currentSession.timeSpent = timeElapsed;
    
    // Sitzung speichern
    dataStore.saveTestSession(sessionState.currentSession);
  }
  
  /**
   * Aktualisiert die Timer-Anzeige
   */
  function updateTimerDisplay() {
    if (!domElements.timeRemainingDisplay) return;
    
    const formattedTime = formatTime(sessionState.timeRemaining);
    domElements.timeRemainingDisplay.textContent = formattedTime;
    
    // Visuelles Feedback bei wenig verbleibender Zeit
    if (sessionState.timeRemaining <= 60) {
      domElements.timeRemainingDisplay.classList.add('time-critical');
    } else if (sessionState.timeRemaining <= 300) {
      domElements.timeRemainingDisplay.classList.add('time-warning');
      domElements.timeRemainingDisplay.classList.remove('time-critical');
    } else {
      domElements.timeRemainingDisplay.classList.remove('time-warning', 'time-critical');
    }
  }
  
  /**
   * Zeigt eine Warnung an, wenn wenig Zeit übrig ist
   * @param {number} minutes - Verbleibende Minuten
   */
  function showTimeWarning(minutes) {
    const message = `Achtung: Noch ${minutes} ${minutes === 1 ? 'Minute' : 'Minuten'} verbleibend!`;
    
    // Visuelle Warnung einblenden
    const warningElement = document.createElement('div');
    warningElement.className = 'time-warning-popup';
    warningElement.innerHTML = `
      <div class="warning-icon">⏱</div>
      <div class="warning-message">${message}</div>
    `;
    
    document.body.appendChild(warningElement);
    
    // Nach 5 Sekunden ausblenden
    setTimeout(() => {
      warningElement.classList.add('fade-out');
      setTimeout(() => {
        warningElement.remove();
      }, 500);
    }, 5000);
    
    // Optional: Ton abspielen
    if (sessionState.activeTest.settings.enableSoundAlerts) {
      playAlertSound();
    }
  }
  
  /**
   * Spielt einen Warnton ab
   */
  function playAlertSound() {
    // Falls Audio-API verfügbar ist
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gainNode.gain.value = 0.1;
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.start();
      setTimeout(() => {
        oscillator.stop();
      }, 500);
    } catch (error) {
      console.warn('Audio-Wiedergabe nicht unterstützt');
    }
  }
  
  /**
   * Behandelt den Ablauf der Zeit
   */
  function handleTimeExpired() {
    // Notification anzeigen
    utils.showNotification('Zeit abgelaufen', 'Die Testzeit ist abgelaufen. Der Test wird automatisch beendet.', 'warning');
    
    // Zeit-Display rot markieren
    domElements.timeRemainingDisplay.textContent = '00:00:00';
    domElements.timeRemainingDisplay.classList.add('time-expired');
    
    // Alle unbearbeiteten Fragen als übersprungen markieren
    for (let i = 0; i < sessionState.questionOrder.length; i++) {
      const questionId = sessionState.questionOrder[i];
      if (!sessionState.answers[questionId]) {
        sessionState.answers[questionId] = {
          skipped: true,
          answer: null,
          timestamp: new Date().toISOString()
        };
      }
    }
    
    // Test beenden (nach einer kurzen Verzögerung)
    setTimeout(() => {
      finishTest();
    }, 3000);
  }
  
  // Funktionen aus Teil 1, die benötigt werden
  function createNewSession(testId) {
    const test = dataStore.getTestById(testId);
    if (!test) {
      throw new Error(`Test mit ID ${testId} nicht gefunden`);
    }
    
    const currentUser = auth.getCurrentUser();
    if (!currentUser) {
      throw new Error('Kein Benutzer angemeldet');
    }
    
    // Fragen auswählen und ggf. mischen
    let questionIds = [...test.questionIds];
    
    if (test.settings.randomizeQuestions) {
      questionIds = shuffleArray(questionIds);
    }
    
    // Wenn nur eine Teilmenge der Fragen verwendet werden soll
    if (test.settings.useSubsetOfQuestions && 
        test.settings.questionSubsetSize > 0 && 
        test.settings.questionSubsetSize < questionIds.length) {
      questionIds = questionIds.slice(0, test.settings.questionSubsetSize);
    }
    
    // Neue Sitzung erstellen
    const session = {
      id: utils.generateId(),
      testId: test.id,
      userId: currentUser.id,
      startTime: new Date().toISOString(),
      endTime: null,
      completed: false,
      questionIds: questionIds,
      answers: {},
      timeSpent: 0,
      calculatedScore: null,
      passingThreshold: test.settings.passingThresholdPercentage,
      maxScore: test.settings.totalPointsPossible || questionIds.length,
      manualReview: test.settings.requireManualReview,
      reviewerId: test.settings.defaultReviewerId || null,
      reviewStatus: 'pending',
      reviewNotes: ''
    };
    
    // Sitzung speichern
    dataStore.saveTestSession(session);
    
    return session;
  }
  // JS-Block 5.1.2: Test-Initialisierung - Fragennavigation (Teil 2.2)
// Beschreibung: Implementierung der Fragennavigation und -anzeige

// Fortsetzung des testExecution-Moduls
(function() {
  'use strict';
  
  // Referenzen zu bestehenden Modulen
  const testExecution = App.modules.testExecution;
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // Für die externen Referenzen, damit der Code funktioniert
  let domElements = testExecution.domElements;
  let sessionState = testExecution.sessionState;
  
  // ==============================
  // Fragennavigation und -anzeige
  // ==============================
  
  /**
   * Zeigt die aktuelle Frage an
   */
  function displayCurrentQuestion() {
    if (!sessionState.questionOrder || 
        sessionState.currentQuestionIndex >= sessionState.questionOrder.length) {
      utils.showNotification('Fehler', 'Keine Fragen verfügbar', 'error');
      return;
    }
    
    const currentQuestionId = sessionState.questionOrder[sessionState.currentQuestionIndex];
    const question = dataStore.getQuestionById(currentQuestionId);
    
    if (!question) {
      utils.showNotification('Fehler', `Frage mit ID ${currentQuestionId} nicht gefunden`, 'error');
      return;
    }
    
    // Frage im UI rendern - der genaue Code hängt vom Fragetyp ab
    // und wird in den Modulen JS-Block 5.2-5.5 implementiert
    renderQuestion(question);
    
    // Gespeicherte Antwort abrufen, falls vorhanden
    const savedAnswer = sessionState.answers[currentQuestionId];
    if (savedAnswer && !savedAnswer.skipped) {
      // Antwort im UI wiederherstellen
      restoreAnswer(question, savedAnswer);
    }
    
    // Navigation und Fortschritt aktualisieren
    updateNavigationControls();
    updateProgressBar();
  }
  
  /**
   * Platzhalter für die eigentliche Fragen-Rendering-Funktion
   * Dies wird in den folgenden JS-Blöcken 5.2-5.5 implementiert
   * @param {Object} question - Die anzuzeigende Frage
   */
  function renderQuestion(question) {
    // Temporärer Platzhalter bis zur vollständigen Implementierung
    const container = domElements.questionContainer;
    container.innerHTML = '';
    
    const questionElement = document.createElement('div');
    questionElement.className = 'question';
    questionElement.dataset.questionId = question.id;
    questionElement.dataset.questionType = question.type;
    
    // Fragetext
    const questionText = document.createElement('div');
    questionText.className = 'question-text';
    questionText.innerHTML = `
      <h3>Frage ${sessionState.currentQuestionIndex + 1} von ${sessionState.questionOrder.length}</h3>
      <p>${utils.escapeHtml(question.text)}</p>
    `;
    questionElement.appendChild(questionText);
    
    // Platzhalter für die verschiedenen Fragetypen
    const answerSection = document.createElement('div');
    answerSection.className = 'answer-section';
    answerSection.innerHTML = `
      <p>Anzeige für Fragetyp "${question.type}" wird in JS-Block 5.2-5.5 implementiert.</p>
    `;
    questionElement.appendChild(answerSection);
    
    container.appendChild(questionElement);
  }
  
  /**
   * Platzhalter für die Wiederherstellung gespeicherter Antworten
   * Dies wird in den folgenden JS-Blöcken 5.2-5.5 implementiert
   * @param {Object} question - Die Frage
   * @param {Object} savedAnswer - Die gespeicherte Antwort
   */
  function restoreAnswer(question, savedAnswer) {
    // Wird in den folgenden JS-Blöcken implementiert
    console.log(`Wiederherstellung der Antwort für Frage ${question.id} wird implementiert`);
  }
  
  /**
   * Aktualisiert die Navigationssteuerungen basierend auf dem aktuellen Zustand
   */
  function updateNavigationControls() {
    const navControls = domElements.navigationControls;
    
    if (!navControls) return;
    
    // Bestehende Kontrollen löschen
    navControls.innerHTML = '';
    
    // Zurück-Button
    const prevButton = document.createElement('button');
    prevButton.className = 'btn btn-outline nav-prev';
    prevButton.textContent = 'Zurück';
    prevButton.disabled = sessionState.currentQuestionIndex === 0;
    prevButton.addEventListener('click', navigateToPreviousQuestion);
    
    // Weiter-Button
    const nextButton = document.createElement('button');
    nextButton.className = 'btn btn-primary nav-next';
    
    // Button-Text basierend auf Position
    const isLastQuestion = sessionState.currentQuestionIndex === sessionState.questionOrder.length - 1;
    nextButton.textContent = isLastQuestion ? 'Test abschließen' : 'Weiter';
    
    nextButton.addEventListener('click', () => {
      if (isLastQuestion) {
        confirmFinishTest();
      } else {
        navigateToNextQuestion();
      }
    });
    
    // Überspringen-Button (falls erlaubt)
    let skipButton = null;
    if (sessionState.activeTest.settings.allowSkippingQuestions) {
      skipButton = document.createElement('button');
      skipButton.className = 'btn btn-outline nav-skip';
      skipButton.textContent = 'Überspringen';
      skipButton.addEventListener('click', skipCurrentQuestion);
    }
    
    // Buttons zum Container hinzufügen
    navControls.appendChild(prevButton);
    if (skipButton) navControls.appendChild(skipButton);
    navControls.appendChild(nextButton);
  }
  
  /**
   * Navigiert zur vorherigen Frage
   */
  function navigateToPreviousQuestion() {
    // Aktuelle Antwort speichern
    saveCurrentAnswer();
    
    // Index reduzieren und neue Frage anzeigen
    if (sessionState.currentQuestionIndex > 0) {
      sessionState.currentQuestionIndex--;
      displayCurrentQuestion();
    }
  }
  
  /**
   * Navigiert zur nächsten Frage
   */
  function navigateToNextQuestion() {
    // Aktuelle Antwort speichern
    saveCurrentAnswer();
    
    // Index erhöhen und neue Frage anzeigen
    if (sessionState.currentQuestionIndex < sessionState.questionOrder.length - 1) {
      sessionState.currentQuestionIndex++;
      displayCurrentQuestion();
    }
  }
  
  /**
   * Überspringt die aktuelle Frage
   */
  function skipCurrentQuestion() {
    const currentQuestionId = sessionState.questionOrder[sessionState.currentQuestionIndex];
    
    // Als übersprungen markieren
    sessionState.answers[currentQuestionId] = {
      skipped: true,
      answer: null,
      timestamp: new Date().toISOString()
    };
    
    // Zur nächsten Frage navigieren oder Test beenden
    if (sessionState.currentQuestionIndex < sessionState.questionOrder.length - 1) {
      sessionState.currentQuestionIndex++;
      displayCurrentQuestion();
    } else {
      confirmFinishTest();
    }
  }
  
  /**
   * Platzhalter für die Speicherung der aktuellen Antwort
   * Wird in den folgenden JS-Blöcken für jeden Fragetyp implementiert
   */
  function saveCurrentAnswer() {
    // Dieser Code wird in den nachfolgenden JS-Blöcken implementiert
    // Hier nur temporärer Platzhalter
    const currentQuestionId = sessionState.questionOrder[sessionState.currentQuestionIndex];
    
    // Prüfen, ob bereits eine Antwort existiert (nicht überschreiben, wenn übersprungen)
    if (!sessionState.answers[currentQuestionId] || !sessionState.answers[currentQuestionId].skipped) {
      // Dummy-Antwort-Objekt - wird später mit echten Daten gefüllt
      sessionState.answers[currentQuestionId] = {
        answer: null,
        timestamp: new Date().toISOString()
      };
    }
    
    // Sitzung speichern
    if (sessionState.currentSession) {
      sessionState.currentSession.answers = { ...sessionState.answers };
      dataStore.saveTestSession(sessionState.currentSession);
    }
  }
  
  /**
   * Aktualisiert die Fortschrittsanzeige
   */
  function updateProgressBar() {
    const progressBar = domElements.progressBar;
    if (!progressBar) return;
    
    const totalQuestions = sessionState.questionOrder.length;
    const currentIndex = sessionState.currentQuestionIndex + 1;
    const progressPercent = (currentIndex / totalQuestions) * 100;
    
    // Progress-Bar aktualisieren
    const progressFill = progressBar.querySelector('.progress-fill');
    if (progressFill) {
      progressFill.style.width = `${progressPercent}%`;
    }
    
    // Progress-Text aktualisieren
    const progressText = progressBar.querySelector('.progress-text');
    if (progressText) {
      progressText.textContent = `${currentIndex} / ${totalQuestions}`;
    }
    
    // Optional: Farbliche Markierung des Fortschritts
    if (progressPercent >= 75) {
      progressBar.classList.add('progress-high');
      progressBar.classList.remove('progress-medium', 'progress-low');
    } else if (progressPercent >= 40) {
      progressBar.classList.add('progress-medium');
      progressBar.classList.remove('progress-high', 'progress-low');
    } else {
      progressBar.classList.add('progress-low');
      progressBar.classList.remove('progress-high', 'progress-medium');
    }
  }
  
  // Funktionen zum öffentlichen API hinzufügen
  testExecution.displayCurrentQuestion = displayCurrentQuestion;
  testExecution.updateNavigationControls = updateNavigationControls;
  testExecution.updateProgressBar = updateProgressBar;
  testExecution.navigateToPreviousQuestion = navigateToPreviousQuestion;
  testExecution.navigateToNextQuestion = navigateToNextQuestion;
  testExecution.skipCurrentQuestion = skipCurrentQuestion;
})();
// JS-Block 5.1.2: Test-Initialisierung - Testabschluss (Teil 2.3)
// Beschreibung: Implementierung der Funktionen zum Testabschluss

// Fortsetzung des testExecution-Moduls
(function() {
  'use strict';
  
  // Referenzen zu bestehenden Modulen
  const testExecution = App.modules.testExecution;
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // Für die externen Referenzen, damit der Code funktioniert
  let domElements = testExecution.domElements;
  let sessionState = testExecution.sessionState;
  
  // ==============================
  // Testabschluss
  // ==============================
  
  /**
   * Bestätigung zum Abschließen des Tests
   */
  function confirmFinishTest() {
    // Aktuelle Antwort speichern
    saveCurrentAnswer();
    
    // Prüfen, ob alle Fragen beantwortet wurden
    const unansweredQuestions = sessionState.questionOrder.filter(questionId => 
      !sessionState.answers[questionId] || 
      (sessionState.answers[questionId].skipped && !sessionState.activeTest.settings.allowSkippingQuestions)
    );
    
    if (unansweredQuestions.length > 0 && !sessionState.activeTest.settings.allowSkippingQuestions) {
      // Warnung anzeigen, wenn nicht alle Fragen beantwortet wurden
      const message = `Es sind noch ${unansweredQuestions.length} Fragen unbeantwortet. Möchten Sie den Test trotzdem beenden?`;
      
      // Bestätigungsdialog anzeigen
      if (confirm(message)) {
        finishTest();
      }
    } else {
      // Direkt beenden, wenn alle Fragen beantwortet wurden oder Überspringen erlaubt ist
      finishTest();
    }
  }
  
  /**
   * Schließt den Test ab
   */
  function finishTest() {
    // Timer stoppen
    if (sessionState.timerInterval) {
      clearInterval(sessionState.timerInterval);
    }
    
    // Test als abgeschlossen markieren
    sessionState.testCompleted = true;
    
    if (sessionState.currentSession) {
      // Testsitzung aktualisieren
      sessionState.currentSession.completed = true;
      sessionState.currentSession.endTime = new Date().toISOString();
      sessionState.currentSession.answers = { ...sessionState.answers };
      
      // Verstrichene Zeit berechnen
      const timeElapsed = Math.floor((new Date().getTime() - sessionState.timeStarted) / 1000);
      sessionState.currentSession.timeSpent = timeElapsed;
      
      // Sitzung speichern
      dataStore.saveTestSession(sessionState.currentSession);
      
      // Zur Auswertungsseite weiterleiten
      navigateToTestResults(sessionState.currentSession.id);
    }
  }
  
  /**
   * Leitet zur Testergebnis-Seite weiter
   * @param {string} sessionId - Die ID der Testsitzung
   */
  function navigateToTestResults(sessionId) {
    // Wenn eine echte Routing-Funktion vorhanden ist
    if (App.router && typeof App.router.navigateTo === 'function') {
      App.router.navigateTo('test-results', { sessionId });
    } else {
      // Alternativ: UI-Status ändern und Ergebnisseite direkt anzeigen
      domElements.testExecutionContainer.classList.add('hidden');
      
      // Temporäre Platzhalter-Nachricht, bis die Ergebnisseite implementiert ist
      const resultMessage = document.createElement('div');
      resultMessage.className = 'test-completion-message';
      resultMessage.innerHTML = `
        <h2>Test abgeschlossen</h2>
        <p>Ihre Antworten wurden gespeichert. Die Ergebnisseite wird in JS-Block 6.5 implementiert.</p>
        <p>Sitzungs-ID: ${sessionId}</p>
        <button id="return-to-dashboard" class="btn btn-primary">Zurück zum Dashboard</button>
      `;
      
      document.body.appendChild(resultMessage);
      
      // Event-Listener für "Zurück zum Dashboard"-Button
      document.getElementById('return-to-dashboard').addEventListener('click', () => {
        if (App.router && typeof App.router.navigateTo === 'function') {
          App.router.navigateTo('dashboard');
        } else {
          window.location.reload(); // Fallback
        }
      });
    }
  }
  
  /**
   * Zurück zur Testauswahl
   */
  function backToTestSelection() {
    // Timer stoppen, falls aktiv
    if (sessionState.timerInterval) {
      clearInterval(sessionState.timerInterval);
    }
    
    // Sicherstellen, dass alle DOM-Elemente sichtbar/unsichtbar wie gewünscht sind
    domElements.testInfoContainer.classList.add('hidden');
    domElements.testExecutionContainer.classList.add('hidden');
    domElements.testSelectionContainer.classList.remove('hidden');
    
    // Status zurücksetzen
    sessionState.selectedTestId = null;
    sessionState.activeTest = null;
    sessionState.currentSession = null;
    
    // Testliste neu laden
    loadAvailableTests();
  }
  
  /**
   * Initialisiert die Event-Listener für die Test-Initialisierung
   */
  function initEventListeners() {
    // Suchfeld und Kategoriefilter
    if (domElements.testSearchInput) {
      domElements.testSearchInput.addEventListener('input', filterTests);
    }
    
    if (domElements.testCategoryFilter) {
      domElements.testCategoryFilter.addEventListener('change', filterTests);
    }
    
    // Start-Test-Button
    if (domElements.startTestBtn) {
      domElements.startTestBtn.addEventListener('click', startTest);
    }
    
    // Zurück-zur-Liste-Button
    if (domElements.backToListBtn) {
      domElements.backToListBtn.addEventListener('click', backToTestSelection);
    }
  }
  
  /**
   * Platzhalter für die Speicherung der aktuellen Antwort (wird aus Teil 2.2 übernommen)
   */
  function saveCurrentAnswer() {
    // Dieser Code wird in den nachfolgenden JS-Blöcken implementiert
    // Hier nur temporärer Platzhalter
    const currentQuestionId = sessionState.questionOrder[sessionState.currentQuestionIndex];
    
    // Prüfen, ob bereits eine Antwort existiert (nicht überschreiben, wenn übersprungen)
    if (!sessionState.answers[currentQuestionId] || !sessionState.answers[currentQuestionId].skipped) {
      // Dummy-Antwort-Objekt - wird später mit echten Daten gefüllt
      sessionState.answers[currentQuestionId] = {
        answer: null,
        timestamp: new Date().toISOString()
      };
    }
    
    // Sitzung speichern
    if (sessionState.currentSession) {
      sessionState.currentSession.answers = { ...sessionState.answers };
      dataStore.saveTestSession(sessionState.currentSession);
    }
  }
  
  /**
   * Lädt verfügbare Tests (wird aus Teil 1 übernommen)
   */
  function loadAvailableTests() {
    // Diese Funktion ist in Teil 1 definiert und wird hier nur als Referenz verwendet
    if (typeof testExecution.loadAvailableTests === 'function') {
      testExecution.loadAvailableTests();
    } else {
      console.error('loadAvailableTests ist nicht definiert');
    }
  }
  
  /**
   * Startet einen Test (wird aus Teil 2.1 übernommen)
   */
  function startTest() {
    // Diese Funktion ist in Teil 2.1 definiert und wird hier nur als Referenz verwendet
    if (typeof testExecution.startTest === 'function') {
      testExecution.startTest();
    } else {
      console.error('startTest ist nicht definiert');
    }
  }
  
  /**
   * Filtert Tests basierend auf Suchtext und Kategorie (wird aus Teil 1 übernommen)
   */
  function filterTests() {
    // Diese Funktion ist in Teil 1 definiert und wird hier nur als Referenz verwendet
    if (typeof testExecution.filterTests === 'function') {
      testExecution.filterTests();
    } else {
      console.error('filterTests ist nicht definiert');
    }
  }
  
  // ==============================
  // Initialisierung und öffentliche API
  // ==============================
  
  /**
   * Initialisiert das Test-Ausführungs-Modul
   */
  function init() {
    // Initialisiere Event-Listener
    initEventListeners();
    
    // Lade verfügbare Tests, wenn der Container vorhanden ist
    if (domElements.testSelectionContainer && 
        !domElements.testSelectionContainer.classList.contains('hidden')) {
      loadAvailableTests();
    }
  }
  
  // Funktionen zum öffentlichen API hinzufügen
  testExecution.confirmFinishTest = confirmFinishTest;
  testExecution.finishTest = finishTest;
  testExecution.navigateToTestResults = navigateToTestResults;
  testExecution.backToTestSelection = backToTestSelection;
  testExecution.init = init;
  
  // Module initialisieren, wenn das DOM bereit ist
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(init, 1);
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }
  
  return testExecution;
})();
// JS-Block 5.1.3: Test-Initialisierung - Testsitzungs-Management (Teil 1)
// Beschreibung: Funktionen zum Speichern und Wiederaufnehmen von Testsitzungen

// Erweiterung des testExecution-Moduls
(function() {
  'use strict';
  
  // Referenzen zu bestehenden Modulen
  const testExecution = App.modules.testExecution;
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // ==============================
  // Sitzungsverwaltung - Grundfunktionen
  // ==============================
  
  /**
   * Speichert den aktuellen Status einer Testsitzung
   * @param {Object} session - Die zu speichernde Testsitzung
   * @param {boolean} updateTimeSpent - Ob die verstrichene Zeit aktualisiert werden soll
   * @return {Object} Die aktualisierte Testsitzung
   */
  function saveSessionState(session, updateTimeSpent = false) {
    if (!session) return null;
    
    // Speichern der aktuellen Sitzung im Datenspeicher
    try {
      // Aktuelle Zeit berechnen, falls erforderlich
      if (updateTimeSpent && session.startTime) {
        const startTime = new Date(session.startTime);
        const now = new Date();
        session.timeSpent = (session.timeSpent || 0) + 
                           Math.floor((now - startTime) / 1000);
      }
      
      // Sitzung in den Datenspeicher schreiben
      dataStore.saveTestSession(session);
      
      return session;
    } catch (error) {
      console.error('Fehler beim Speichern der Testsitzung:', error);
      utils.showNotification('Fehler', 'Testsitzung konnte nicht gespeichert werden', 'error');
      return null;
    }
  }
  
  /**
   * Sucht nach unterbrochenen Testsitzungen eines Benutzers
   * @param {string} userId - Die ID des Benutzers
   * @return {Array} Array mit nicht abgeschlossenen Testsitzungen
   */
  function findInterruptedSessions(userId) {
    if (!userId) return [];
    
    try {
      // Alle Sitzungen des Benutzers abrufen
      const userSessions = dataStore.getTestSessionsByUser(userId);
      
      // Nicht abgeschlossene Sitzungen filtern
      return userSessions.filter(session => !session.completed);
    } catch (error) {
      console.error('Fehler beim Abrufen unterbrochener Testsitzungen:', error);
      return [];
    }
  }
  
  /**
   * Prüft, ob ein Benutzer einen bestimmten Test bereits bestanden hat
   * @param {string} userId - Die ID des Benutzers
   * @param {string} testId - Die ID des Tests
   * @return {boolean} True, wenn der Test bestanden wurde, sonst false
   */
  function hasUserPassedTest(userId, testId) {
    if (!userId || !testId) return false;
    
    try {
      // Alle Sitzungen des Benutzers für diesen Test abrufen
      const userSessions = dataStore.getTestSessionsByUser(userId)
        .filter(session => session.testId === testId && session.completed);
      
      // Prüfen, ob mindestens eine Sitzung bestanden wurde
      return userSessions.some(session => 
        session.calculatedScore >= session.passingThreshold);
    } catch (error) {
      console.error('Fehler beim Überprüfen von bestandenen Tests:', error);
      return false;
    }
  }
  
  /**
   * Prüft, ob die maximale Anzahl von Versuchen für einen Test erreicht wurde
   * @param {string} userId - Die ID des Benutzers
   * @param {string} testId - Die ID des Tests
   * @return {boolean} True, wenn die maximale Anzahl erreicht wurde, sonst false
   */
  function hasReachedMaxAttempts(userId, testId) {
    if (!userId || !testId) return false;
    
    try {
      // Test-Objekt mit Einstellungen abrufen
      const test = dataStore.getTestById(testId);
      if (!test || !test.settings.maxAttempts) {
        return false; // Keine Beschränkung, wenn maxAttempts nicht gesetzt
      }
      
      // Anzahl der Versuche zählen (nur abgeschlossene Sitzungen)
      const attemptCount = dataStore.getTestSessionsByUser(userId)
        .filter(session => session.testId === testId && session.completed)
        .length;
      
      return attemptCount >= test.settings.maxAttempts;
    } catch (error) {
      console.error('Fehler beim Überprüfen der maximalen Versuche:', error);
      return false;
    }
  }
  
  /**
   * Prüft, ob ein Benutzer derzeit eine aktive Sperre für einen Test hat
   * @param {string} userId - Die ID des Benutzers
   * @param {string} testId - Die ID des Tests
   * @return {Object|null} Objekt mit Sperrdetails oder null, wenn keine Sperre
   */
  function getActiveTestLock(userId, testId) {
    if (!userId || !testId) return null;
    
    try {
      // Test-Objekt mit Einstellungen abrufen
      const test = dataStore.getTestById(testId);
      if (!test || !test.settings.attemptCooldownMinutes) {
        return null; // Keine Wartezeit zwischen Versuchen
      }
      
      // Letzte abgeschlossene Sitzung finden
      const userSessions = dataStore.getTestSessionsByUser(userId)
        .filter(session => session.testId === testId && session.completed);
      
      if (userSessions.length === 0) {
        return null; // Kein vorheriger Versuch
      }
      
      // Neueste Sitzung finden
      const latestSession = userSessions.sort((a, b) => 
        new Date(b.endTime) - new Date(a.endTime))[0];
      
      // Prüfen, ob die Wartezeit noch aktiv ist
      const endTime = new Date(latestSession.endTime);
      const cooldownEnd = new Date(endTime.getTime() + 
                                 test.settings.attemptCooldownMinutes * 60 * 1000);
      const now = new Date();
      
      if (now < cooldownEnd) {
        // Sperre ist aktiv
        return {
          endTime: cooldownEnd,
          remainingMinutes: Math.ceil((cooldownEnd - now) / (60 * 1000))
        };
      }
      
      return null; // Keine aktive Sperre
    } catch (error) {
      console.error('Fehler beim Überprüfen der Test-Sperre:', error);
      return null;
    }
  }
  
  // ==============================
  // Hilfsfunktionen für Testsitzungen
  // ==============================
  
  /**
   * Formatiert eine Testsitzung für die Anzeige im UI
   * @param {Object} session - Die zu formatierende Testsitzung
   * @return {Object} Formatierte Sessiondaten für die UI
   */
  function formatSessionForUI(session) {
    if (!session) return null;
    
    try {
      // Test-Infos abrufen
      const test = dataStore.getTestById(session.testId);
      const testTitle = test ? test.title : 'Unbekannter Test';
      
      // Start- und Endzeit formatieren
      const formatDate = (dateStr) => {
        if (!dateStr) return '';
        const date = new Date(dateStr);
        return date.toLocaleDateString('de-DE') + ' ' + 
               date.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
      };
      
      // Dauer berechnen
      let duration = '';
      if (session.startTime && session.timeSpent) {
        const minutes = Math.floor(session.timeSpent / 60);
        const seconds = session.timeSpent % 60;
        duration = `${minutes}:${seconds.toString().padStart(2, '0')} Min.`;
      }
      
      // Fortschritt berechnen
      let progressPercent = 0;
      if (session.questionIds && session.questionIds.length > 0) {
        const answeredCount = Object.keys(session.answers || {}).length;
        progressPercent = Math.round((answeredCount / session.questionIds.length) * 100);
      }
      
      // Status bestimmen
      let status = 'In Bearbeitung';
      let statusClass = 'status-in-progress';
      
      if (session.completed) {
        if (session.reviewStatus === 'aborted') {
          status = 'Abgebrochen';
          statusClass = 'status-aborted';
        } else if (session.reviewStatus === 'pending' && session.manualReview) {
          status = 'Prüfung ausstehend';
          statusClass = 'status-pending-review';
        } else if (session.calculatedScore >= session.passingThreshold) {
          status = 'Bestanden';
          statusClass = 'status-passed';
        } else {
          status = 'Nicht bestanden';
          statusClass = 'status-failed';
        }
      }
      
      return {
        id: session.id,
        testId: session.testId,
        testTitle: testTitle,
        startTime: formatDate(session.startTime),
        endTime: formatDate(session.endTime),
        duration: duration,
        progress: progressPercent,
        status: status,
        statusClass: statusClass,
        score: session.calculatedScore !== null ? session.calculatedScore : '--',
        passingThreshold: session.passingThreshold || 0,
        isCompleted: session.completed || false
      };
    } catch (error) {
      console.error('Fehler beim Formatieren der Testsitzung:', error);
      return null;
    }
  }
  
  // Funktionen zum öffentlichen API hinzufügen
  testExecution.saveSessionState = saveSessionState;
  testExecution.findInterruptedSessions = findInterruptedSessions;
  testExecution.hasUserPassedTest = hasUserPassedTest;
  testExecution.hasReachedMaxAttempts = hasReachedMaxAttempts;
  testExecution.getActiveTestLock = getActiveTestLock;
  testExecution.formatSessionForUI = formatSessionForUI;
})();
// JS-Block 5.1.3: Test-Initialisierung - Testsitzungs-Management (Teil 2)
// Beschreibung: Funktionen zur Auswertung und Übersicht von Testsitzungen

// Fortsetzung des testExecution-Moduls
(function() {
  'use strict';
  
  // Referenzen zu bestehenden Modulen
  const testExecution = App.modules.testExecution;
  const dataStore = App.modules.dataStore;
  const auth = App.modules.auth;
  const utils = App.utils;
  
  // ==============================
  // Ergebnisauswertung
  // ==============================
  
  /**
   * Erstellt eine Übersicht der Testergebnisse eines Benutzers
   * @param {string} userId - Die ID des Benutzers
   * @param {string} testId - Die ID des Tests
   * @return {Object} Objekt mit Ergebnisübersicht
   */
  function createTestResultsSummary(userId, testId) {
    if (!userId || !testId) return {};
    
    try {
      // Test-Objekt abrufen
      const test = dataStore.getTestById(testId);
      if (!test) return {};
      
      // Alle abgeschlossenen Sitzungen des Benutzers für diesen Test abrufen
      const userSessions = dataStore.getTestSessionsByUser(userId)
        .filter(session => session.testId === testId && session.completed);
      
      if (userSessions.length === 0) return {};
      
      // Basis-Informationen
      const summary = {
        userId: userId,
        testId: testId,
        testTitle: test.title,
        attemptCount: userSessions.length,
        maxAttemptsAllowed: test.settings.maxAttempts || 'Unbegrenzt',
        passedAttempts: 0,
        bestScore: 0,
        averageScore: 0,
        lastAttemptDate: null,
        lastScore: 0,
        improvement: false,
        sessionsData: []
      };
      
      // Sitzungen nach Datum sortieren (neueste zuerst)
      userSessions.sort((a, b) => new Date(b.endTime) - new Date(a.endTime));
      
      // Daten aus Sitzungen extrahieren
      let totalScore = 0;
      userSessions.forEach((session, index) => {
        // Bestanden?
        if (session.calculatedScore >= session.passingThreshold) {
          summary.passedAttempts++;
        }
        
        // Beste Punktzahl
        if (session.calculatedScore > summary.bestScore) {
          summary.bestScore = session.calculatedScore;
        }
        
        // Summe für Durchschnitt
        totalScore += session.calculatedScore || 0;
        
        // Letzte Sitzung speichern
        if (index === 0) {
          summary.lastAttemptDate = session.endTime;
          summary.lastScore = session.calculatedScore || 0;
        }
        
        // Verbesserung prüfen (zwischen letztem und vorletztem Versuch)
        if (index === 0 && userSessions.length > 1) {
          const previousScore = userSessions[1].calculatedScore || 0;
          summary.improvement = summary.lastScore > previousScore;
        }
        
        // Sitzungsdaten für detaillierte Ansicht
        summary.sessionsData.push({
          id: session.id,
          date: session.endTime,
          score: session.calculatedScore || 0,
          passed: (session.calculatedScore || 0) >= session.passingThreshold,
          duration: session.timeSpent || 0
        });
      });
      
      // Durchschnitt berechnen
      summary.averageScore = totalScore / userSessions.length;
      
      return summary;
    } catch (error) {
      console.error('Fehler beim Erstellen der Testergebnisübersicht:', error);
      return {};
    }
  }
  
  /**
   * Berechnet Statistiken zu einem Test über alle Benutzer hinweg
   * @param {string} testId - Die ID des Tests
   * @return {Object} Statistik-Objekt
   */
  function calculateTestStatistics(testId) {
    if (!testId) return null;
    
    try {
      // Test-Objekt abrufen
      const test = dataStore.getTestById(testId);
      if (!test) return null;
      
      // Alle abgeschlossenen Sitzungen für diesen Test abrufen
      const allSessions = dataStore.getAllTestSessions()
        .filter(session => session.testId === testId && session.completed);
      
      if (allSessions.length === 0) {
        return {
          testId: testId,
          testTitle: test.title,
          sessionCount: 0,
          participantCount: 0,
          averageScore: 0,
          passRate: 0,
          averageCompletionTime: 0,
          difficultQuestions: []
        };
      }
      
      // Eindeutige Teilnehmer zählen
      const uniqueParticipants = new Set(allSessions.map(s => s.userId)).size;
      
      // Punktzahlen und Bestanden/Nicht-Bestanden
      let totalScore = 0;
      let passedCount = 0;
      let totalTime = 0;
      
      allSessions.forEach(session => {
        totalScore += session.calculatedScore || 0;
        if (session.calculatedScore >= session.passingThreshold) {
          passedCount++;
        }
        totalTime += session.timeSpent || 0;
      });
      
      // Durchschnittliche Werte berechnen
      const averageScore = totalScore / allSessions.length;
      const passRate = (passedCount / allSessions.length) * 100;
      const averageCompletionTime = totalTime / allSessions.length;
      
      // Schwierige Fragen identifizieren (Fragen mit niedrigster Erfolgsrate)
      const questionStatistics = calculateQuestionDifficulty(testId, allSessions);
      
      // Nach Schwierigkeit sortieren und die 5 schwierigsten auswählen
      const difficultQuestions = questionStatistics
        .sort((a, b) => a.successRate - b.successRate)
        .slice(0, 5);
      
      return {
        testId: testId,
        testTitle: test.title,
        sessionCount: allSessions.length,
        participantCount: uniqueParticipants,
        averageScore: averageScore,
        passRate: passRate,
        averageCompletionTime: averageCompletionTime,
        difficultQuestions: difficultQuestions
      };
    } catch (error) {
      console.error('Fehler beim Berechnen der Teststatistiken:', error);
      return null;
    }
  }
  
  /**
   * Berechnet die Schwierigkeit jeder Frage in einem Test
   * @param {string} testId - Die ID des Tests
   * @param {Array} sessions - Array mit Testsitzungen
   * @return {Array} Array mit Statistiken zu jeder Frage
   */
  function calculateQuestionDifficulty(testId, sessions) {
    try {
      const test = dataStore.getTestById(testId);
      if (!test) return [];
      
      // Ergebnis-Array vorbereiten
      const questionStats = {};
      
      // Alle Fragen aus dem Test abrufen
      test.questionIds.forEach(questionId => {
        const question = dataStore.getQuestionById(questionId);
        if (question) {
          questionStats[questionId] = {
            id: questionId,
            text: question.text.substring(0, 50) + (question.text.length > 50 ? '...' : ''),
            type: question.type,
            totalAnswers: 0,
            correctAnswers: 0,
            successRate: 0,
            averageTimeSpent: 0,
            skipRate: 0
          };
        }
      });
      
      // Sitzungen durchlaufen und Statistiken aufbauen
      sessions.forEach(session => {
        // Antworten zu jeder Frage in der Sitzung
        const answers = session.answers || {};
        
        Object.keys(answers).forEach(questionId => {
          if (questionStats[questionId]) {
            const answer = answers[questionId];
            
            // Anzahl der Antworten erhöhen
            questionStats[questionId].totalAnswers++;
            
            // Übersprungen?
            if (answer.skipped) {
              questionStats[questionId].skipCount = (questionStats[questionId].skipCount || 0) + 1;
            } 
            // Richtig beantwortet?
            else if (answer.isCorrect) {
              questionStats[questionId].correctAnswers++;
            }
          }
        });
      });
      
      // Erfolgsraten berechnen
      Object.keys(questionStats).forEach(questionId => {
        const stats = questionStats[questionId];
        
        if (stats.totalAnswers > 0) {
          stats.successRate = (stats.correctAnswers / stats.totalAnswers) * 100;
          stats.skipRate = ((stats.skipCount || 0) / stats.totalAnswers) * 100;
        }
      });
      
      // In Array umwandeln
      return Object.values(questionStats);
    } catch (error) {
      console.error('Fehler bei der Berechnung der Fragenschwierigkeit:', error);
      return [];
    }
  }
  
  /**
   * Generiert eine Übersicht der letzten Tests eines Benutzers
   * @param {string} userId - Die ID des Benutzers
   * @param {number} limit - Maximale Anzahl der anzuzeigenden Tests
   * @return {Array} Array mit Testübersichten
   */
  function getUserRecentTests(userId, limit = 5) {
    if (!userId) return [];
    
    try {
      // Alle abgeschlossenen Sitzungen des Benutzers abrufen
      const userSessions = dataStore.getTestSessionsByUser(userId)
        .filter(session => session.completed);
      
      // Nach Abschlussdatum sortieren (neueste zuerst)
      userSessions.sort((a, b) => new Date(b.endTime) - new Date(a.endTime));
      
      // Tests nach ID gruppieren
      const testGroups = {};
      userSessions.forEach(session => {
        if (!testGroups[session.testId]) {
          const test = dataStore.getTestById(session.testId);
          if (test) {
            testGroups[session.testId] = {
              testId: session.testId,
              testTitle: test.title,
              category: test.category || 'Allgemein',
              lastCompleted: session.endTime,
              lastScore: session.calculatedScore || 0,
              passed: (session.calculatedScore || 0) >= session.passingThreshold,
              attemptCount: 1,
              bestScore: session.calculatedScore || 0
            };
          }
        } else {
          // Update für bestehenden Test
          testGroups[session.testId].attemptCount++;
          
          // Beste Punktzahl aktualisieren
          if ((session.calculatedScore || 0) > testGroups[session.testId].bestScore) {
            testGroups[session.testId].bestScore = session.calculatedScore || 0;
          }
        }
      });
      
      // In Array umwandeln und begrenzen
      return Object.values(testGroups).slice(0, limit);
    } catch (error) {
      console.error('Fehler beim Abrufen der letzten Tests des Benutzers:', error);
      return [];
    }
  }
  
  // Funktionen zum öffentlichen API hinzufügen
  testExecution.createTestResultsSummary = createTestResultsSummary;
  testExecution.calculateTestStatistics = calculateTestStatistics;
  testExecution.calculateQuestionDifficulty = calculateQuestionDifficulty;
  testExecution.getUserRecentTests = getUserRecentTests;
})();
/**
 * JS-Block 5.2.1-part1: Fragenanzeige - Multiple Choice (Anzeige und Interaktion, Teil 1.1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Multiple-Choice-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Multiple-Choice-Fragenmoduls
const MultipleChoiceQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswers = [];
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    /**
     * Initialisiert die Anzeige einer Multiple-Choice-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('MultipleChoiceQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Multiple-Choice-Fragetyp arbeiten
        if (questionData.type !== 'multiple-choice') {
            console.error('MultipleChoiceQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antworten, falls vorhanden
        const sessionAnswers = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswers && Array.isArray(sessionAnswers)) {
            selectedAnswers = [...sessionAnswers];
        } else {
            selectedAnswers = [];
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Multiple-Choice-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content multiple-choice-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Multiple-Choice hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Wählen Sie alle zutreffenden Antworten aus (Mehrfachauswahl möglich).';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options multiple-choice-options';
        
        // Antwortoptionen hinzufügen
        if (currentQuestionData.options && Array.isArray(currentQuestionData.options)) {
            currentQuestionData.options.forEach((option, index) => {
                const optionElement = createAnswerOption(option, index);
                optionsContainer.appendChild(optionElement);
            });
        } else {
            console.error('MultipleChoiceQuestionHandler: Keine Antwortoptionen gefunden');
        }
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekten Antworten anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antworten markieren
        updateSelectedAnswersUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {Object} option - Die Antwortoption
     * @param {number} index - Der Index der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(option, index) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option multiple-choice-option';
        optionElement.dataset.optionIndex = index;
        
        // Checkbox-Container für bessere Styling-Möglichkeiten
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'checkbox-container';
        
        // Checkbox erstellen
        const checkbox = document.createElement('div');
        checkbox.className = 'custom-checkbox';
        
        // Icon für Checkbox (wird durch CSS angezeigt)
        const checkIcon = document.createElement('i');
        checkIcon.className = 'check-icon fas fa-check';
        checkbox.appendChild(checkIcon);
        
        checkboxContainer.appendChild(checkbox);
        optionElement.appendChild(checkboxContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerHTML = option.text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Liste der korrekten Antworten zusammenstellen
        const correctOptions = currentQuestionData.options
            .filter(option => option.isCorrect)
            .map(option => option.text);
        
        const correctAnswersHtml = correctOptions.length > 0 
            ? correctOptions.map(text => `<li>${text}</li>`).join('') 
            : '<li>Keine korrekte Antwort definiert</li>';
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekten Antworten sind:</p>
                <ul class="correct-answers-list">
                    ${correctAnswersHtml}
                </ul>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (!currentQuestionData || !currentQuestionData.options) return false;
        
        // Keine ausgewählten Antworten, aber korrekte erforderlich
        if (selectedAnswers.length === 0) {
            const hasCorrectOptions = currentQuestionData.options.some(option => option.isCorrect);
            return !hasCorrectOptions; // Nur richtig, wenn keine korrekten Optionen definiert sind
        }
        
        // Prüfen, ob alle ausgewählten Antworten korrekt sind und alle korrekten Antworten ausgewählt wurden
        const correctOptionIndices = currentQuestionData.options
            .map((option, index) => option.isCorrect ? index : -1)
            .filter(index => index !== -1);
            
        // Alle korrekten Optionen müssen ausgewählt sein
        const allCorrectOptionsSelected = correctOptionIndices.every(index => 
            selectedAnswers.includes(index));
            
        // Keine falschen Optionen dürfen ausgewählt sein
        const noIncorrectOptionsSelected = selectedAnswers.every(index => 
            correctOptionIndices.includes(index));
            
        return allCorrectOptionsSelected && noIncorrectOptionsSelected;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
	/**
 * JS-Block 5.2.1-part1: Fragenanzeige - Multiple Choice (Anzeige und Interaktion, Teil 1.1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Multiple-Choice-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Multiple-Choice-Fragenmoduls
const MultipleChoiceQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswers = [];
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    /**
     * Initialisiert die Anzeige einer Multiple-Choice-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('MultipleChoiceQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Multiple-Choice-Fragetyp arbeiten
        if (questionData.type !== 'multiple-choice') {
            console.error('MultipleChoiceQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antworten, falls vorhanden
        const sessionAnswers = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswers && Array.isArray(sessionAnswers)) {
            selectedAnswers = [...sessionAnswers];
        } else {
            selectedAnswers = [];
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Multiple-Choice-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content multiple-choice-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Multiple-Choice hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Wählen Sie alle zutreffenden Antworten aus (Mehrfachauswahl möglich).';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options multiple-choice-options';
        
        // Antwortoptionen hinzufügen
        if (currentQuestionData.options && Array.isArray(currentQuestionData.options)) {
            currentQuestionData.options.forEach((option, index) => {
                const optionElement = createAnswerOption(option, index);
                optionsContainer.appendChild(optionElement);
            });
        } else {
            console.error('MultipleChoiceQuestionHandler: Keine Antwortoptionen gefunden');
        }
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekten Antworten anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antworten markieren
        updateSelectedAnswersUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {Object} option - Die Antwortoption
     * @param {number} index - Der Index der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(option, index) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option multiple-choice-option';
        optionElement.dataset.optionIndex = index;
        
        // Checkbox-Container für bessere Styling-Möglichkeiten
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'checkbox-container';
        
        // Checkbox erstellen
        const checkbox = document.createElement('div');
        checkbox.className = 'custom-checkbox';
        
        // Icon für Checkbox (wird durch CSS angezeigt)
        const checkIcon = document.createElement('i');
        checkIcon.className = 'check-icon fas fa-check';
        checkbox.appendChild(checkIcon);
        
        checkboxContainer.appendChild(checkbox);
        optionElement.appendChild(checkboxContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerHTML = option.text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Liste der korrekten Antworten zusammenstellen
        const correctOptions = currentQuestionData.options
            .filter(option => option.isCorrect)
            .map(option => option.text);
        
        const correctAnswersHtml = correctOptions.length > 0 
            ? correctOptions.map(text => `<li>${text}</li>`).join('') 
            : '<li>Keine korrekte Antwort definiert</li>';
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekten Antworten sind:</p>
                <ul class="correct-answers-list">
                    ${correctAnswersHtml}
                </ul>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (!currentQuestionData || !currentQuestionData.options) return false;
        
        // Keine ausgewählten Antworten, aber korrekte erforderlich
        if (selectedAnswers.length === 0) {
            const hasCorrectOptions = currentQuestionData.options.some(option => option.isCorrect);
            return !hasCorrectOptions; // Nur richtig, wenn keine korrekten Optionen definiert sind
        }
        
        // Prüfen, ob alle ausgewählten Antworten korrekt sind und alle korrekten Antworten ausgewählt wurden
        const correctOptionIndices = currentQuestionData.options
            .map((option, index) => option.isCorrect ? index : -1)
            .filter(index => index !== -1);
            
        // Alle korrekten Optionen müssen ausgewählt sein
        const allCorrectOptionsSelected = correctOptionIndices.every(index => 
            selectedAnswers.includes(index));
            
        // Keine falschen Optionen dürfen ausgewählt sein
        const noIncorrectOptionsSelected = selectedAnswers.every(index => 
            correctOptionIndices.includes(index));
            
        return allCorrectOptionsSelected && noIncorrectOptionsSelected;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('multiple-choice-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.optionIndex) return;
        
        const optionIndex = parseInt(optionElement.dataset.optionIndex, 10);
        
        // Status umschalten (hinzufügen/entfernen)
        toggleAnswerSelection(optionIndex);
        
        // UI aktualisieren
        updateSelectedAnswersUI();
        
        // Antworten im TestSessionManager speichern
        saveAnswers();
    }
    
    /**
     * Fügt eine Antwort zur Auswahl hinzu oder entfernt sie
     * @param {number} optionIndex - Der Index der Option
     * @returns {void}
     */
    function toggleAnswerSelection(optionIndex) {
        const index = selectedAnswers.indexOf(optionIndex);
        
        if (index === -1) {
            // Antwort hinzufügen
            selectedAnswers.push(optionIndex);
        } else {
            // Antwort entfernen
            selectedAnswers.splice(index, 1);
        }
    }
    
    /**
     * Aktualisiert die Benutzeroberfläche basierend auf den ausgewählten Antworten
     * @returns {void}
     */
    function updateSelectedAnswersUI() {
        if (!questionContainer) return;
        
        // Alle Optionselemente durchgehen
        const optionElements = questionContainer.querySelectorAll('.multiple-choice-option');
        
        optionElements.forEach(element => {
            const optionIndex = parseInt(element.dataset.optionIndex, 10);
            const isSelected = selectedAnswers.includes(optionIndex);
            
            // Styling anpassen
            if (isSelected) {
                element.classList.add('selected');
            } else {
                element.classList.remove('selected');
            }
            
            // Checkbox-Status aktualisieren
            const checkbox = element.querySelector('.custom-checkbox');
            if (checkbox) {
                if (isSelected) {
                    checkbox.classList.add('checked');
                } else {
                    checkbox.classList.remove('checked');
                }
            }
        });
        
        // Im Review-Modus zusätzliches Styling für richtige/falsche Antworten
        if (isReviewMode && currentQuestionData && currentQuestionData.options) {
            optionElements.forEach(element => {
                const optionIndex = parseInt(element.dataset.optionIndex, 10);
                const option = currentQuestionData.options[optionIndex];
                
                if (option.isCorrect) {
                    element.classList.add('correct-answer');
                } else if (selectedAnswers.includes(optionIndex)) {
                    element.classList.add('incorrect-answer');
                }
            });
        }
    }
    
    /**
     * Speichert die ausgewählten Antworten in der Testsitzung
     * @returns {void}
     */
    function saveAnswers() {
        if (!currentQuestionData || !currentQuestionData.id) return;
        
        TestSessionManager.saveQuestionAnswer(
            currentQuestionData.id,
            selectedAnswers
        );
        
        // Event auslösen, um andere Komponenten über die Antwortänderung zu informieren
        const event = new CustomEvent('answerUpdated', {
            detail: {
                questionId: currentQuestionData.id,
                answer: selectedAnswers,
                answerType: 'multiple-choice'
            }
        });
        document.dispatchEvent(event);
    }
	/**
 * JS-Block 5.2.1-part1: Fragenanzeige - Multiple Choice (Anzeige und Interaktion, Teil 1.1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Multiple-Choice-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Multiple-Choice-Fragenmoduls
const MultipleChoiceQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswers = [];
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    /**
     * Initialisiert die Anzeige einer Multiple-Choice-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('MultipleChoiceQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Multiple-Choice-Fragetyp arbeiten
        if (questionData.type !== 'multiple-choice') {
            console.error('MultipleChoiceQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antworten, falls vorhanden
        const sessionAnswers = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswers && Array.isArray(sessionAnswers)) {
            selectedAnswers = [...sessionAnswers];
        } else {
            selectedAnswers = [];
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Multiple-Choice-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content multiple-choice-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Multiple-Choice hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Wählen Sie alle zutreffenden Antworten aus (Mehrfachauswahl möglich).';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options multiple-choice-options';
        
        // Antwortoptionen hinzufügen
        if (currentQuestionData.options && Array.isArray(currentQuestionData.options)) {
            currentQuestionData.options.forEach((option, index) => {
                const optionElement = createAnswerOption(option, index);
                optionsContainer.appendChild(optionElement);
            });
        } else {
            console.error('MultipleChoiceQuestionHandler: Keine Antwortoptionen gefunden');
        }
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekten Antworten anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antworten markieren
        updateSelectedAnswersUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {Object} option - Die Antwortoption
     * @param {number} index - Der Index der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(option, index) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option multiple-choice-option';
        optionElement.dataset.optionIndex = index;
        
        // Checkbox-Container für bessere Styling-Möglichkeiten
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'checkbox-container';
        
        // Checkbox erstellen
        const checkbox = document.createElement('div');
        checkbox.className = 'custom-checkbox';
        
        // Icon für Checkbox (wird durch CSS angezeigt)
        const checkIcon = document.createElement('i');
        checkIcon.className = 'check-icon fas fa-check';
        checkbox.appendChild(checkIcon);
        
        checkboxContainer.appendChild(checkbox);
        optionElement.appendChild(checkboxContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerHTML = option.text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Liste der korrekten Antworten zusammenstellen
        const correctOptions = currentQuestionData.options
            .filter(option => option.isCorrect)
            .map(option => option.text);
        
        const correctAnswersHtml = correctOptions.length > 0 
            ? correctOptions.map(text => `<li>${text}</li>`).join('') 
            : '<li>Keine korrekte Antwort definiert</li>';
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekten Antworten sind:</p>
                <ul class="correct-answers-list">
                    ${correctAnswersHtml}
                </ul>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (!currentQuestionData || !currentQuestionData.options) return false;
        
        // Keine ausgewählten Antworten, aber korrekte erforderlich
        if (selectedAnswers.length === 0) {
            const hasCorrectOptions = currentQuestionData.options.some(option => option.isCorrect);
            return !hasCorrectOptions; // Nur richtig, wenn keine korrekten Optionen definiert sind
        }
        
        // Prüfen, ob alle ausgewählten Antworten korrekt sind und alle korrekten Antworten ausgewählt wurden
        const correctOptionIndices = currentQuestionData.options
            .map((option, index) => option.isCorrect ? index : -1)
            .filter(index => index !== -1);
            
        // Alle korrekten Optionen müssen ausgewählt sein
        const allCorrectOptionsSelected = correctOptionIndices.every(index => 
            selectedAnswers.includes(index));
            
        // Keine falschen Optionen dürfen ausgewählt sein
        const noIncorrectOptionsSelected = selectedAnswers.every(index => 
            correctOptionIndices.includes(index));
            
        return allCorrectOptionsSelected && noIncorrectOptionsSelected;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('multiple-choice-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.optionIndex) return;
        
        const optionIndex = parseInt(optionElement.dataset.optionIndex, 10);
        
        // Status umschalten (hinzufügen/entfernen)
        toggleAnswerSelection(optionIndex);
        
        // UI aktualisieren
        updateSelectedAnswersUI();
        
        // Antworten im TestSessionManager speichern
        saveAnswers();
    }
    
    /**
     * Fügt eine Antwort zur Auswahl hinzu oder entfernt sie
     * @param {number} optionIndex - Der Index der Option
     * @returns {void}
     */
    function toggleAnswerSelection(optionIndex) {
        const index = selectedAnswers.indexOf(optionIndex);
        
        if (index === -1) {
            // Antwort hinzufügen
            selectedAnswers.push(optionIndex);
        } else {
            // Antwort entfernen
            selectedAnswers.splice(index, 1);
        }
    }
    
    /**
     * Aktualisiert die Benutzeroberfläche basierend auf den ausgewählten Antworten
     * @returns {void}
     */
    function updateSelectedAnswersUI() {
        if (!questionContainer) return;
        
        // Alle Optionselemente durchgehen
        const optionElements = questionContainer.querySelectorAll('.multiple-choice-option');
        
        optionElements.forEach(element => {
            const optionIndex = parseInt(element.dataset.optionIndex, 10);
            const isSelected = selectedAnswers.includes(optionIndex);
            
            // Styling anpassen
            if (isSelected) {
                element.classList.add('selected');
            } else {
                element.classList.remove('selected');
            }
            
            // Checkbox-Status aktualisieren
            const checkbox = element.querySelector('.custom-checkbox');
            if (checkbox) {
                if (isSelected) {
                    checkbox.classList.add('checked');
                } else {
                    checkbox.classList.remove('checked');
                }
            }
        });
        
        // Im Review-Modus zusätzliches Styling für richtige/falsche Antworten
        if (isReviewMode && currentQuestionData && currentQuestionData.options) {
            optionElements.forEach(element => {
                const optionIndex = parseInt(element.dataset.optionIndex, 10);
                const option = currentQuestionData.options[optionIndex];
                
                if (option.isCorrect) {
                    element.classList.add('correct-answer');
                } else if (selectedAnswers.includes(optionIndex)) {
                    element.classList.add('incorrect-answer');
                }
            });
        }
    }
    
    /**
     * Speichert die ausgewählten Antworten in der Testsitzung
     * @returns {void}
     */
    function saveAnswers() {
        if (!currentQuestionData || !currentQuestionData.id) return;
        
        TestSessionManager.saveQuestionAnswer(
            currentQuestionData.id,
            selectedAnswers
        );
        
        // Event auslösen, um andere Komponenten über die Antwortänderung zu informieren
        const event = new CustomEvent('answerUpdated', {
            detail: {
                questionId: currentQuestionData.id,
                answer: selectedAnswers,
                answerType: 'multiple-choice'
            }
        });
        document.dispatchEvent(event);
    }
    
    /**
     * Aktualisiert die Antwortauswahl basierend auf den übergebenen Daten
     * @param {Array<number>} answerIndices - Die Indizes der ausgewählten Antworten
     * @returns {void}
     */
    function updateSelectedAnswers(answerIndices) {
        if (!Array.isArray(answerIndices)) return;
        
        selectedAnswers = [...answerIndices];
        updateSelectedAnswersUI();
    }
    
    /**
     * Sperrt die Benutzerinteraktion mit der Frage
     * @param {boolean} lock - Ob die Interaktion gesperrt werden soll
     * @returns {void}
     */
    function lockAnswers(lock = true) {
        userAnswersLocked = lock;
        
        // Visuelles Feedback für gesperrten Zustand
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                if (lock) {
                    optionsContainer.classList.add('locked');
                } else {
                    optionsContainer.classList.remove('locked');
                }
            }
        }
    }
    
    /**
     * Aktiviert den Review-Modus, um korrekte Antworten anzuzeigen
     * @param {boolean} enable - Ob der Review-Modus aktiviert werden soll
     * @returns {void}
     */
    function enableReviewMode(enable = true) {
        if (isReviewMode === enable) return; // Keine Änderung nötig
        
        isReviewMode = enable;
        
        // Neu rendern, wenn sich der Modus ändert
        renderQuestion();
    }
    
    /**
     * Prüft, ob die aktuelle Frage beantwortet wurde
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isAnswered() {
        return selectedAnswers.length > 0;
    }
    
    /**
     * Gibt die Auswahl des Benutzers zurück
     * @returns {Array<number>} Die ausgewählten Antwortindizes
     */
    function getSelectedAnswers() {
        return [...selectedAnswers];
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                optionsContainer.removeEventListener('click', handleOptionClick);
            }
        }
        
        // Referenzen zurücksetzen
        currentQuestionData = null;
        selectedAnswers = [];
        questionContainer = null;
    }
    
    // Öffentliche API
    return {
        initializeQuestion,
        updateSelectedAnswers,
        lockAnswers,
        enableReviewMode,
        isAnswered,
        getSelectedAnswers,
        cleanup
    };
})();

// Module registrieren
if (typeof QuestionHandlerRegistry !== 'undefined') {
    QuestionHandlerRegistry.registerHandler('multiple-choice', MultipleChoiceQuestionHandler);
}
/**
 * JS-Block 5.2.1-part2: Fragenanzeige - Multiple Choice (Anzeige und Interaktion, Teil 1.2)
 * 
 * Dieser Block erweitert die Multiple-Choice-Funktionalität mit Barrierefreiheits-Features,
 * Tastaturunterstützung und Hilfsfunktionen zum Validieren und Navigieren.
 */

// IIFE für den Multiple-Choice Accessibility-Enhancer
const MultipleChoiceAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Multiple-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastaturnavigation hinzufügen
        addKeyboardNavigation();
        
        // Fokus-Management verbessern
        improveFocusManagement();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Multiple-Choice-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Antwortoptionen als Checkboxen markieren
        const optionElements = currentQuestionContainer.querySelectorAll('.multiple-choice-option');
        optionElements.forEach((option, index) => {
            option.setAttribute('role', 'checkbox');
            option.setAttribute('aria-checked', 'false');
            option.setAttribute('tabindex', '0');
            option.setAttribute('aria-label', `Option ${index + 1}`);
            
            // Text-Inhalt auslesen für vollständiges aria-label
            const optionText = option.querySelector('.option-text');
            if (optionText) {
                option.setAttribute('aria-label', optionText.textContent.trim());
            }
            
            // Prüfen, ob ausgewählt
            if (option.classList.contains('selected')) {
                option.setAttribute('aria-checked', 'true');
            }
        });
    }
    
    /**
     * Fügt Tastaturnavigation für die Antwortoptionen hinzu
     * @returns {void}
     */
    function addKeyboardNavigation() {
        if (!currentQuestionContainer) return;
        
        // Event-Listener für Tastatursteuerung
        currentQuestionContainer.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        const target = event.target;
        
        // Prüfen, ob das Event von einer Antwortoption kommt
        if (!target.classList.contains('multiple-choice-option')) return;
        
        // Tastatursteuerung
        switch (event.key) {
            case ' ':  // Leertaste
            case 'Enter':
                // Option auswählen/abwählen
                event.preventDefault();
                toggleOption(target);
                break;
                
            case 'ArrowDown':
            case 'ArrowRight':
                // Zur nächsten Option navigieren
                event.preventDefault();
                navigateToNextOption(target);
                break;
                
            case 'ArrowUp':
            case 'ArrowLeft':
                // Zur vorherigen Option navigieren
                event.preventDefault();
                navigateToPreviousOption(target);
                break;
                
            case 'Home':
                // Zur ersten Option navigieren
                event.preventDefault();
                navigateToFirstOption();
                break;
                
            case 'End':
                // Zur letzten Option navigieren
                event.preventDefault();
                navigateToLastOption();
                break;
        }
    }
    
    /**
     * Wählt eine Option aus oder ab
     * @param {HTMLElement} optionElement - Das Option-Element
     * @returns {void}
     */
    function toggleOption(optionElement) {
        // Simuliere einen Klick auf die Option
        optionElement.click();
        
        // ARIA-Attribute aktualisieren
        const isSelected = optionElement.classList.contains('selected');
        optionElement.setAttribute('aria-checked', isSelected ? 'true' : 'false');
    }
    
    /**
     * Navigiert zur nächsten Option
     * @param {HTMLElement} currentOption - Die aktuelle Option
     * @returns {void}
     */
    function navigateToNextOption(currentOption) {
        const options = getOptionElements();
        const currentIndex = Array.from(options).indexOf(currentOption);
        
        if (currentIndex < options.length - 1) {
            options[currentIndex + 1].focus();
        }
    }
    
    /**
     * Navigiert zur vorherigen Option
     * @param {HTMLElement} currentOption - Die aktuelle Option
     * @returns {void}
     */
    function navigateToPreviousOption(currentOption) {
        const options = getOptionElements();
        const currentIndex = Array.from(options).indexOf(currentOption);
        
        if (currentIndex > 0) {
            options[currentIndex - 1].focus();
        }
    }
    
    /**
     * Navigiert zur ersten Option
     * @returns {void}
     */
    function navigateToFirstOption() {
        const options = getOptionElements();
        if (options.length > 0) {
            options[0].focus();
        }
    }
    
    /**
     * Navigiert zur letzten Option
     * @returns {void}
     */
    function navigateToLastOption() {
        const options = getOptionElements();
        if (options.length > 0) {
            options[options.length - 1].focus();
        }
    }
    
    /**
     * Holt alle Optionselemente aus dem Container
     * @returns {NodeList} Liste der Option-Elemente
     */
    function getOptionElements() {
        if (!currentQuestionContainer) return [];
        return currentQuestionContainer.querySelectorAll('.multiple-choice-option');
    }
    
    /**
     * Verbessert das Fokus-Management für Tastaturnavigation
     * @returns {void}
     */
    function improveFocusManagement() {
        if (!currentQuestionContainer) return;
        
        // Fokus-Outline für Tastaturbenutzer verbessern
        const optionElements = getOptionElements();
        
        optionElements.forEach(option => {
            // Nur Fokus-Outline anzeigen, wenn mit Tastatur fokussiert
            option.addEventListener('mousedown', () => {
                option.classList.add('mouse-focus');
            });
            
            option.addEventListener('focusin', () => {
                if (!option.classList.contains('mouse-focus')) {
                    option.classList.add('keyboard-focus');
                }
                option.classList.remove('mouse-focus');
            });
            
            option.addEventListener('focusout', () => {
                option.classList.remove('keyboard-focus');
            });
        });
    }
    
    /**
     * Aktualisiert die ARIA-Attribute nach Statusänderungen
     * @returns {void}
     */
    function updateAriaStatus() {
        if (!currentQuestionContainer) return;
        
        const optionElements = currentQuestionContainer.querySelectorAll('.multiple-choice-option');
        
        optionElements.forEach(option => {
            const isSelected = option.classList.contains('selected');
            option.setAttribute('aria-checked', isSelected ? 'true' : 'false');
        });
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (currentQuestionContainer) {
            currentQuestionContainer.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        updateAriaStatus,
        cleanup
    };
})();

// Erweiterung für den MultipleChoiceQuestionHandler mit Validierungsfunktionen
document.addEventListener('DOMContentLoaded', function() {
    // Erweitert den MultipleChoiceQuestionHandler, falls vorhanden
    if (typeof MultipleChoiceQuestionHandler !== 'undefined') {
        // Event-Listener für die Frage-Initialisierung hinzufügen
        document.addEventListener('questionRendered', function(event) {
            if (event.detail && event.detail.type === 'multiple-choice' && event.detail.container) {
                // Barrierefreiheit verbessern
                MultipleChoiceAccessibilityEnhancer.enhanceAccessibility(event.detail.container);
            }
        });
        
        // Event-Listener für Antwortänderungen
        document.addEventListener('answerUpdated', function(event) {
            if (event.detail && event.detail.answerType === 'multiple-choice') {
                // ARIA-Attribute aktualisieren
                MultipleChoiceAccessibilityEnhancer.updateAriaStatus();
            }
        });
    }
});

// CSS-Klassen für Tastaturnavigation hinzufügen
(function addKeyboardNavigationStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .multiple-choice-option {
            position: relative;
            transition: all 0.2s ease;
        }
        
        .multiple-choice-option:focus {
            outline: none;
        }
        
        .multiple-choice-option.keyboard-focus {
            box-shadow: 0 0 0 2px #00FFD0;
            border-radius: 4px;
        }
        
        .multiple-choice-option.selected .custom-checkbox {
            background-color: #00FFD0;
            border-color: #00B090;
        }
        
        .multiple-choice-option.selected .custom-checkbox .check-icon {
            opacity: 1;
        }
        
        .answer-options.locked .multiple-choice-option {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .multiple-choice-option.correct-answer {
            background-color: rgba(0, 255, 0, 0.1);
            border-left: 3px solid #00B090;
        }
        
        .multiple-choice-option.incorrect-answer {
            background-color: rgba(255, 0, 0, 0.1);
            border-left: 3px solid #FF4040;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.2.2-part1: Fragenanzeige - Multiple Choice (Antwortvalidierung, Teil 2.1)
 * 
 * Dieser Block implementiert die Validierungsfunktionen für Multiple-Choice-Fragen.
 * Er enthält die Logik zur Prüfung der Benutzerantworten, zur Punkteberechnung und 
 * zur Bestimmung des Antwortenstatus.
 */

// IIFE für den Multiple-Choice-Fragenvalidator
const MultipleChoiceValidator = (function() {
    // Private Variablen
    const PARTIAL_CREDIT_ENABLED = true; // Standardmäßig teilweise Punkte erlauben
    
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Object} options - Konfigurationsoptionen für die Validierung
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswers, options = {}) {
        if (!questionData || !Array.isArray(userAnswers)) {
            console.error('MultipleChoiceValidator: Ungültige Eingabedaten');
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'invalid',
                feedback: 'Ungültige Antwortdaten' 
            };
        }
        
        // Standardoptionen mit übergebenen Optionen zusammenführen
        const validationOptions = {
            allowPartialCredit: options.allowPartialCredit !== undefined ? 
                options.allowPartialCredit : PARTIAL_CREDIT_ENABLED,
            requireAllCorrect: options.requireAllCorrect !== undefined ?
                options.requireAllCorrect : true,
            strictMode: options.strictMode !== undefined ?
                options.strictMode : false
        };
        
        // Korrekte Antwortindizes ermitteln
        const correctIndices = getCorrectAnswerIndices(questionData);
        
        // Prüfen, ob Antwort vollständig richtig ist
        const isFullyCorrect = isAnswerFullyCorrect(userAnswers, correctIndices);
        
        // Punktzahl berechnen
        const { 
            score, 
            maxScore, 
            correctSelections,
            incorrectSelections,
            missedCorrectSelections 
        } = calculateScore(questionData, userAnswers, correctIndices, validationOptions);
        
        // Status der Antwort bestimmen
        const status = determineAnswerStatus(
            score, 
            maxScore, 
            isFullyCorrect,
            validationOptions
        );
        
        // Feedback generieren
        const feedback = generateFeedback(
            status, 
            correctSelections,
            incorrectSelections,
            missedCorrectSelections
        );
        
        return {
            score,
            maxScore,
            status,
            feedback,
            details: {
                correctSelections,
                incorrectSelections,
                missedCorrectSelections,
                isFullyCorrect
            }
        };
    }
    
    /**
     * Ermittelt die Indizes der korrekten Antworten aus den Fragedaten
     * @param {Object} questionData - Die Fragendaten
     * @returns {Array<number>} Array mit den Indizes der korrekten Antworten
     */
    function getCorrectAnswerIndices(questionData) {
        if (!questionData || !questionData.options || !Array.isArray(questionData.options)) {
            return [];
        }
        
        return questionData.options
            .map((option, index) => option.isCorrect ? index : -1)
            .filter(index => index !== -1);
    }
    
    /**
     * Prüft, ob die Benutzerantwort vollständig korrekt ist
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Array<number>} correctIndices - Die Indizes der korrekten Antworten
     * @returns {boolean} Ob die Antwort vollständig korrekt ist
     */
    function isAnswerFullyCorrect(userAnswers, correctIndices) {
        // Alle korrekten müssen ausgewählt sein
        const allCorrectSelected = correctIndices.every(index => 
            userAnswers.includes(index)
        );
        
        // Keine falschen dürfen ausgewählt sein
        const noIncorrectSelected = userAnswers.every(index => 
            correctIndices.includes(index)
        );
        
        return allCorrectSelected && noIncorrectSelected;
    }
    
    /**
     * Berechnet die erreichte Punktzahl basierend auf den Antworten
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Array<number>} correctIndices - Die Indizes der korrekten Antworten
     * @param {Object} options - Validierungsoptionen
     * @returns {Object} Berechnungsergebnis mit Punktzahl und Details
     */
    function calculateScore(questionData, userAnswers, correctIndices, options) {
        const maxScore = questionData.points || 0;
        let score = 0;
        
        // Listen für korrekte/falsche Auswahlen vorbereiten
        const correctSelections = [];
        const incorrectSelections = [];
        const missedCorrectSelections = [];
        
        // Bei vollständig korrekter Antwort volle Punktzahl
        if (isAnswerFullyCorrect(userAnswers, correctIndices)) {
            score = maxScore;
            
            // Korrekte Auswahlen sammeln
            correctIndices.forEach(index => {
                if (questionData.options[index]) {
                    correctSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
        } 
        // Bei teilweiser Korrektheit und aktivierter Teilpunktevergabe
        else if (options.allowPartialCredit) {
            // Prüfen, welche Antworten korrekt/falsch sind
            // und entsprechende Punkte vergeben/abziehen
            
            // Gesamtzahl der Antwortoptionen
            const totalOptions = questionData.options ? questionData.options.length : 0;
            // Punktwert pro Option
            const pointsPerOption = maxScore / (correctIndices.length > 0 ? correctIndices.length : 1);
            
            // Korrekte Auswahlen
            userAnswers.forEach(index => {
                if (correctIndices.includes(index)) {
                    // Korrekte Auswahl
                    score += pointsPerOption;
                    
                    if (questionData.options[index]) {
                        correctSelections.push({
                            index,
                            text: questionData.options[index].text
                        });
                    }
                } else {
                    // Falsche Auswahl
                    if (options.strictMode) {
                        // Im strengen Modus: Punktabzug für falsche Auswahlen
                        score -= pointsPerOption;
                    }
                    
                    if (questionData.options[index]) {
                        incorrectSelections.push({
                            index,
                            text: questionData.options[index].text
                        });
                    }
                }
            });
            
            // Verpasste korrekte Antworten
            correctIndices.forEach(index => {
                if (!userAnswers.includes(index) && questionData.options[index]) {
                    missedCorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
            
            // Keine negativen Punkte
            score = Math.max(0, score);
            
            // Wenn alle korrekten Antworten erforderlich sind und nicht alle ausgewählt wurden
            if (options.requireAllCorrect && missedCorrectSelections.length > 0) {
                // Score reduzieren
                score *= (correctSelections.length / correctIndices.length);
            }
        } else {
            // Keine Teilpunkte möglich - 0 Punkte bei nicht vollständig korrekter Antwort
            score = 0;
            
            // Sammle trotzdem Informationen für Feedback
            userAnswers.forEach(index => {
                if (correctIndices.includes(index) && questionData.options[index]) {
                    correctSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                } else if (questionData.options[index]) {
                    incorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
            
            correctIndices.forEach(index => {
                if (!userAnswers.includes(index) && questionData.options[index]) {
                    missedCorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
        }
        
        // Auf 2 Nachkommastellen runden
        score = Math.round(score * 100) / 100;
        
        return {
            score,
            maxScore,
            correctSelections,
            incorrectSelections,
            missedCorrectSelections
        };
    }
    
    /**
     * Bestimmt den Status der Antwort basierend auf der erreichten Punktzahl
     * @param {number} score - Erreichte Punktzahl
     * @param {number} maxScore - Maximale Punktzahl
     * @param {boolean} isFullyCorrect - Ob die Antwort vollständig korrekt ist
     * @param {Object} options - Validierungsoptionen
     * @returns {string} Antwortstatus ('correct', 'partially_correct', 'incorrect')
     */
    function determineAnswerStatus(score, maxScore, isFullyCorrect, options) {
        if (isFullyCorrect) {
            return 'correct';
        }
        
        if (options.allowPartialCredit && score > 0) {
            return 'partially_correct';
        }
        
        return 'incorrect';
    }
	/**
 * JS-Block 5.2.2-part1: Fragenanzeige - Multiple Choice (Antwortvalidierung, Teil 2.1)
 * 
 * Dieser Block implementiert die Validierungsfunktionen für Multiple-Choice-Fragen.
 * Er enthält die Logik zur Prüfung der Benutzerantworten, zur Punkteberechnung und 
 * zur Bestimmung des Antwortenstatus.
 */

// IIFE für den Multiple-Choice-Fragenvalidator
const MultipleChoiceValidator = (function() {
    // Private Variablen
    const PARTIAL_CREDIT_ENABLED = true; // Standardmäßig teilweise Punkte erlauben
    
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Object} options - Konfigurationsoptionen für die Validierung
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswers, options = {}) {
        if (!questionData || !Array.isArray(userAnswers)) {
            console.error('MultipleChoiceValidator: Ungültige Eingabedaten');
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'invalid',
                feedback: 'Ungültige Antwortdaten' 
            };
        }
        
        // Standardoptionen mit übergebenen Optionen zusammenführen
        const validationOptions = {
            allowPartialCredit: options.allowPartialCredit !== undefined ? 
                options.allowPartialCredit : PARTIAL_CREDIT_ENABLED,
            requireAllCorrect: options.requireAllCorrect !== undefined ?
                options.requireAllCorrect : true,
            strictMode: options.strictMode !== undefined ?
                options.strictMode : false
        };
        
        // Korrekte Antwortindizes ermitteln
        const correctIndices = getCorrectAnswerIndices(questionData);
        
        // Prüfen, ob Antwort vollständig richtig ist
        const isFullyCorrect = isAnswerFullyCorrect(userAnswers, correctIndices);
        
        // Punktzahl berechnen
        const { 
            score, 
            maxScore, 
            correctSelections,
            incorrectSelections,
            missedCorrectSelections 
        } = calculateScore(questionData, userAnswers, correctIndices, validationOptions);
        
        // Status der Antwort bestimmen
        const status = determineAnswerStatus(
            score, 
            maxScore, 
            isFullyCorrect,
            validationOptions
        );
        
        // Feedback generieren
        const feedback = generateFeedback(
            status, 
            correctSelections,
            incorrectSelections,
            missedCorrectSelections
        );
        
        return {
            score,
            maxScore,
            status,
            feedback,
            details: {
                correctSelections,
                incorrectSelections,
                missedCorrectSelections,
                isFullyCorrect
            }
        };
    }
    
    /**
     * Ermittelt die Indizes der korrekten Antworten aus den Fragedaten
     * @param {Object} questionData - Die Fragendaten
     * @returns {Array<number>} Array mit den Indizes der korrekten Antworten
     */
    function getCorrectAnswerIndices(questionData) {
        if (!questionData || !questionData.options || !Array.isArray(questionData.options)) {
            return [];
        }
        
        return questionData.options
            .map((option, index) => option.isCorrect ? index : -1)
            .filter(index => index !== -1);
    }
    
    /**
     * Prüft, ob die Benutzerantwort vollständig korrekt ist
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Array<number>} correctIndices - Die Indizes der korrekten Antworten
     * @returns {boolean} Ob die Antwort vollständig korrekt ist
     */
    function isAnswerFullyCorrect(userAnswers, correctIndices) {
        // Alle korrekten müssen ausgewählt sein
        const allCorrectSelected = correctIndices.every(index => 
            userAnswers.includes(index)
        );
        
        // Keine falschen dürfen ausgewählt sein
        const noIncorrectSelected = userAnswers.every(index => 
            correctIndices.includes(index)
        );
        
        return allCorrectSelected && noIncorrectSelected;
    }
    
    /**
     * Berechnet die erreichte Punktzahl basierend auf den Antworten
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {Array<number>} correctIndices - Die Indizes der korrekten Antworten
     * @param {Object} options - Validierungsoptionen
     * @returns {Object} Berechnungsergebnis mit Punktzahl und Details
     */
    function calculateScore(questionData, userAnswers, correctIndices, options) {
        const maxScore = questionData.points || 0;
        let score = 0;
        
        // Listen für korrekte/falsche Auswahlen vorbereiten
        const correctSelections = [];
        const incorrectSelections = [];
        const missedCorrectSelections = [];
        
        // Bei vollständig korrekter Antwort volle Punktzahl
        if (isAnswerFullyCorrect(userAnswers, correctIndices)) {
            score = maxScore;
            
            // Korrekte Auswahlen sammeln
            correctIndices.forEach(index => {
                if (questionData.options[index]) {
                    correctSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
        } 
        // Bei teilweiser Korrektheit und aktivierter Teilpunktevergabe
        else if (options.allowPartialCredit) {
            // Prüfen, welche Antworten korrekt/falsch sind
            // und entsprechende Punkte vergeben/abziehen
            
            // Gesamtzahl der Antwortoptionen
            const totalOptions = questionData.options ? questionData.options.length : 0;
            // Punktwert pro Option
            const pointsPerOption = maxScore / (correctIndices.length > 0 ? correctIndices.length : 1);
            
            // Korrekte Auswahlen
            userAnswers.forEach(index => {
                if (correctIndices.includes(index)) {
                    // Korrekte Auswahl
                    score += pointsPerOption;
                    
                    if (questionData.options[index]) {
                        correctSelections.push({
                            index,
                            text: questionData.options[index].text
                        });
                    }
                } else {
                    // Falsche Auswahl
                    if (options.strictMode) {
                        // Im strengen Modus: Punktabzug für falsche Auswahlen
                        score -= pointsPerOption;
                    }
                    
                    if (questionData.options[index]) {
                        incorrectSelections.push({
                            index,
                            text: questionData.options[index].text
                        });
                    }
                }
            });
            
            // Verpasste korrekte Antworten
            correctIndices.forEach(index => {
                if (!userAnswers.includes(index) && questionData.options[index]) {
                    missedCorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
            
            // Keine negativen Punkte
            score = Math.max(0, score);
            
            // Wenn alle korrekten Antworten erforderlich sind und nicht alle ausgewählt wurden
            if (options.requireAllCorrect && missedCorrectSelections.length > 0) {
                // Score reduzieren
                score *= (correctSelections.length / correctIndices.length);
            }
        } else {
            // Keine Teilpunkte möglich - 0 Punkte bei nicht vollständig korrekter Antwort
            score = 0;
            
            // Sammle trotzdem Informationen für Feedback
            userAnswers.forEach(index => {
                if (correctIndices.includes(index) && questionData.options[index]) {
                    correctSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                } else if (questionData.options[index]) {
                    incorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
            
            correctIndices.forEach(index => {
                if (!userAnswers.includes(index) && questionData.options[index]) {
                    missedCorrectSelections.push({
                        index,
                        text: questionData.options[index].text
                    });
                }
            });
        }
        
        // Auf 2 Nachkommastellen runden
        score = Math.round(score * 100) / 100;
        
        return {
            score,
            maxScore,
            correctSelections,
            incorrectSelections,
            missedCorrectSelections
        };
    }
    
    /**
     * Bestimmt den Status der Antwort basierend auf der erreichten Punktzahl
     * @param {number} score - Erreichte Punktzahl
     * @param {number} maxScore - Maximale Punktzahl
     * @param {boolean} isFullyCorrect - Ob die Antwort vollständig korrekt ist
     * @param {Object} options - Validierungsoptionen
     * @returns {string} Antwortstatus ('correct', 'partially_correct', 'incorrect')
     */
    function determineAnswerStatus(score, maxScore, isFullyCorrect, options) {
        if (isFullyCorrect) {
            return 'correct';
        }
        
        if (options.allowPartialCredit && score > 0) {
            return 'partially_correct';
        }
        
        return 'incorrect';
    }
    
    /**
     * Generiert Feedback zur Benutzerantwort
     * @param {string} status - Antwortstatus
     * @param {Array} correctSelections - Korrekt ausgewählte Antworten
     * @param {Array} incorrectSelections - Falsch ausgewählte Antworten
     * @param {Array} missedCorrectSelections - Verpasste korrekte Antworten
     * @returns {string} Feedback-Text
     */
    function generateFeedback(status, correctSelections, incorrectSelections, missedCorrectSelections) {
        let feedback = '';
        
        switch (status) {
            case 'correct':
                feedback = 'Ihre Antwort ist komplett richtig!';
                break;
                
            case 'partially_correct':
                feedback = 'Ihre Antwort ist teilweise richtig.';
                
                if (incorrectSelections.length > 0) {
                    feedback += ' Sie haben ' + incorrectSelections.length + 
                        (incorrectSelections.length === 1 ? 
                            ' falsche Option' : ' falsche Optionen') + ' ausgewählt.';
                }
                
                if (missedCorrectSelections.length > 0) {
                    feedback += ' Sie haben ' + missedCorrectSelections.length + 
                        (missedCorrectSelections.length === 1 ? 
                            ' richtige Option nicht' : ' richtige Optionen nicht') + ' ausgewählt.';
                }
                break;
                
            case 'incorrect':
                feedback = 'Ihre Antwort ist leider falsch.';
                break;
                
            default:
                feedback = 'Bitte überprüfen Sie Ihre Antwort.';
        }
        
        return feedback;
    }
    
    /**
     * Bestimmt, ob eine Frage überhaupt beantwortet wurde
     * @param {Array} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isQuestionAnswered(userAnswers) {
        return Array.isArray(userAnswers) && userAnswers.length > 0;
    }
    
    /**
     * Liefert eine detaillierte Analyse der Benutzerantwort
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @returns {Object} Detaillierte Antwortanalyse
     */
    function analyzeAnswer(questionData, userAnswers) {
        if (!questionData || !Array.isArray(userAnswers)) {
            return { answered: false };
        }
        
        const correctIndices = getCorrectAnswerIndices(questionData);
        const isAnswered = isQuestionAnswered(userAnswers);
        
        if (!isAnswered) {
            return { 
                answered: false,
                message: 'Die Frage wurde nicht beantwortet.'
            };
        }
        
        // Korrekte und falsche Auswahlen zählen
        let correctCount = 0;
        let incorrectCount = 0;
        
        userAnswers.forEach(index => {
            if (correctIndices.includes(index)) {
                correctCount++;
            } else {
                incorrectCount++;
            }
        });
        
        // Verpasste korrekte Antworten zählen
        const missedCount = correctIndices.length - correctCount;
        
        // Vollständigkeit bestimmen
        const allCorrectOptionsSelected = missedCount === 0;
        const noIncorrectOptionsSelected = incorrectCount === 0;
        
        // Prozentualer Anteil der korrekten Antworten
        const correctPercentage = correctIndices.length > 0 
            ? (correctCount / correctIndices.length) * 100 
            : 0;
            
        // Gesamtbewertung
        const isFullyCorrect = allCorrectOptionsSelected && noIncorrectOptionsSelected;
        const isPartiallyCorrect = correctCount > 0 && (incorrectCount > 0 || missedCount > 0);
        
        let answerQuality = 'incorrect';
        if (isFullyCorrect) {
            answerQuality = 'correct';
        } else if (isPartiallyCorrect) {
            answerQuality = 'partially_correct';
        }
        
        return {
            answered: true,
            correctCount,
            incorrectCount,
            missedCount,
            totalCorrectOptions: correctIndices.length,
            allCorrectOptionsSelected,
            noIncorrectOptionsSelected,
            correctPercentage,
            answerQuality,
            isFullyCorrect
        };
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswers) {
        const analysis = analyzeAnswer(questionData, userAnswers);
        const correctIndices = getCorrectAnswerIndices(questionData);
        
        if (!analysis.answered) {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Gesamtergebnis
        reportHtml += `<h4 class="report-heading ${analysis.answerQuality}">`;
        
        if (analysis.isFullyCorrect) {
            reportHtml += '<i class="fas fa-check-circle"></i> Vollständig korrekt';
        } else if (analysis.answerQuality === 'partially_correct') {
            reportHtml += '<i class="fas fa-adjust"></i> Teilweise korrekt';
        } else {
            reportHtml += '<i class="fas fa-times-circle"></i> Falsch';
        }
        
        reportHtml += '</h4>';
        
        // Detaillierte Statistik
        reportHtml += '<div class="answer-statistics">';
        reportHtml += `<p>Korrekt ausgewählte Antworten: ${analysis.correctCount} von ${analysis.totalCorrectOptions}</p>`;
        
        if (analysis.incorrectCount > 0) {
            reportHtml += `<p>Falsch ausgewählte Antworten: ${analysis.incorrectCount}</p>`;
        }
        
        if (analysis.missedCount > 0) {
            reportHtml += `<p>Verpasste korrekte Antworten: ${analysis.missedCount}</p>`;
        }
        
        reportHtml += `<p>Korrektheit: ${Math.round(analysis.correctPercentage)}%</p>`;
        reportHtml += '</div>';
        
        // Detaillierte Auflistung der Optionen
        reportHtml += '<div class="options-breakdown">';
        reportHtml += '<h5>Detaillierte Aufschlüsselung:</h5>';
        reportHtml += '<ul>';
        
        if (questionData.options && Array.isArray(questionData.options)) {
            questionData.options.forEach((option, index) => {
                const isCorrectOption = correctIndices.includes(index);
                const wasSelected = userAnswers.includes(index);
                
                let optionClass = '';
                let iconHtml = '';
                
                if (isCorrectOption && wasSelected) {
                    optionClass = 'correct-selected';
                    iconHtml = '<i class="fas fa-check-circle"></i>';
                } else if (isCorrectOption && !wasSelected) {
                    optionClass = 'correct-not-selected';
                    iconHtml = '<i class="fas fa-minus-circle"></i>';
                } else if (!isCorrectOption && wasSelected) {
                    optionClass = 'incorrect-selected';
                    iconHtml = '<i class="fas fa-times-circle"></i>';
                } else {
                    optionClass = 'incorrect-not-selected';
                    iconHtml = '<i class="fas fa-check"></i>';
                }
                
                reportHtml += `<li class="${optionClass}">
                    ${iconHtml}
                    <span class="option-text">${option.text}</span>
                    <span class="option-status">
                        ${wasSelected ? 'Ausgewählt' : 'Nicht ausgewählt'} 
                        (${isCorrectOption ? 'Korrekt' : 'Falsch'})
                    </span>
                </li>`;
            });
        }
        
        reportHtml += '</ul>';
        reportHtml += '</div>';
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
    
    // Öffentliche API
    return {
        validateAnswer,
        analyzeAnswer,
        generateDetailedReport,
        isQuestionAnswered
    };
})();

// Verbindung mit dem MultipleChoiceQuestionHandler herstellen
document.addEventListener('DOMContentLoaded', function() {
    // Nur registrieren, wenn das globale Registry-Objekt existiert
    if (typeof ValidationRegistry !== 'undefined') {
        ValidationRegistry.registerValidator('multiple-choice', MultipleChoiceValidator);
    }
    
    // Test-Event-Listener für die Validierung von Multiple-Choice-Fragen
    document.addEventListener('validateMultipleChoiceQuestion', function(event) {
        if (event.detail && event.detail.questionData && event.detail.userAnswers) {
            const validationResult = MultipleChoiceValidator.validateAnswer(
                event.detail.questionData,
                event.detail.userAnswers,
                event.detail.options
            );
            
            // Validierungsergebnis zurückgeben
            const resultEvent = new CustomEvent('multipleChoiceValidationResult', {
                detail: {
                    questionId: event.detail.questionData.id,
                    result: validationResult
                }
            });
            document.dispatchEvent(resultEvent);
        }
    });
});

// CSS-Stile für die Antwortvalidierung und Berichte
(function addValidationStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .detailed-answer-report {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .report-heading {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .report-heading i {
            margin-right: 10px;
        }
        
        .report-heading.correct {
            color: #28a745;
        }
        
        .report-heading.partially_correct {
            color: #fd7e14;
        }
        
        .report-heading.incorrect {
            color: #dc3545;
        }
        
        .answer-statistics {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .options-breakdown ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .options-breakdown li {
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        
        .options-breakdown li i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        
        .options-breakdown li.correct-selected {
            background-color: rgba(40, 167, 69, 0.2);
            border-left: 3px solid #28a745;
        }
        
        .options-breakdown li.correct-not-selected {
            background-color: rgba(253, 126, 20, 0.2);
            border-left: 3px solid #fd7e14;
        }
        
        .options-breakdown li.incorrect-selected {
            background-color: rgba(220, 53, 69, 0.2);
            border-left: 3px solid #dc3545;
        }
        
        .options-breakdown li.incorrect-not-selected {
            background-color: rgba(108, 117, 125, 0.1);
            border-left: 3px solid #6c757d;
        }
        
        .option-text {
            flex-grow: 1;
        }
        
        .option-status {
            font-size: 0.85em;
            color: #6c757d;
            margin-left: 10px;
        }
        
        .report-not-answered {
            color: #6c757d;
            font-style: italic;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.2.2-part2: Fragenanzeige - Multiple Choice (Feedback-Mechanismen, Teil 2.2)
 * 
 * Dieser Block implementiert Feedback-Mechanismen für Multiple-Choice-Fragen.
 * Er bietet visuelle und textuelle Rückmeldungen zu den Antworten des Benutzers
 * und integriert sich mit dem Validierungssystem.
 */

// IIFE für den Multiple-Choice-Feedback-Handler
const MultipleChoiceFeedbackHandler = (function() {
    // Private Variablen
    let currentQuestionContainer = null;
    let currentQuestionData = null;
    let feedbackContainer = null;
    let feedbackEnabled = true;
    let instantFeedbackEnabled = false;
    let animationEnabled = true;
    
    /**
     * Initialisiert den Feedback-Handler für eine Multiple-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @param {Object} questionData - Die Fragendaten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function initialize(container, questionData, options = {}) {
        if (!container || !questionData) {
            console.error('MultipleChoiceFeedbackHandler: Fehlende Container- oder Fragedaten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionContainer = container;
        currentQuestionData = questionData;
        
        // Konfigurationsoptionen übernehmen
        feedbackEnabled = options.feedbackEnabled !== undefined ? 
            options.feedbackEnabled : true;
        instantFeedbackEnabled = options.instantFeedbackEnabled !== undefined ? 
            options.instantFeedbackEnabled : false;
        animationEnabled = options.animationEnabled !== undefined ? 
            options.animationEnabled : true;
        
        // Feedback-Container erstellen, falls nicht vorhanden
        createFeedbackContainer();
        
        // Event-Listener für Antwortänderungen hinzufügen
        if (instantFeedbackEnabled) {
            addAnswerChangeListener();
        }
    }
    
    /**
     * Erstellt den Container für Feedback-Nachrichten
     * @returns {void}
     */
    function createFeedbackContainer() {
        if (!currentQuestionContainer) return;
        
        // Prüfen, ob bereits ein Feedback-Container existiert
        let existingContainer = currentQuestionContainer.querySelector('.feedback-container');
        
        if (existingContainer) {
            feedbackContainer = existingContainer;
            return;
        }
        
        // Neuen Feedback-Container erstellen
        feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';
        feedbackContainer.style.display = 'none';
        
        // Zum Frage-Container hinzufügen, nach den Antwortoptionen
        const optionsContainer = currentQuestionContainer.querySelector('.answer-options');
        
        if (optionsContainer) {
            optionsContainer.insertAdjacentElement('afterend', feedbackContainer);
        } else {
            currentQuestionContainer.appendChild(feedbackContainer);
        }
    }
    
    /**
     * Fügt einen Event-Listener für Antwortänderungen hinzu (für sofortiges Feedback)
     * @returns {void}
     */
    function addAnswerChangeListener() {
        if (!currentQuestionData) return;
        
        document.addEventListener('answerUpdated', function(event) {
            if (event.detail && event.detail.questionId === currentQuestionData.id) {
                // Sofortiges Feedback anzeigen, wenn aktiviert
                if (instantFeedbackEnabled && feedbackEnabled) {
                    const userAnswers = event.detail.answer;
                    
                    if (Array.isArray(userAnswers)) {
                        provideFeedback(userAnswers);
                    }
                }
            }
        });
    }
    
    /**
     * Zeigt Feedback zur Benutzerantwort an
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @returns {void}
     */
    function provideFeedback(userAnswers) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Feedback über den Validator generieren
        if (typeof MultipleChoiceValidator === 'undefined') {
            console.error('MultipleChoiceFeedbackHandler: Validator nicht gefunden');
            return;
        }
        
        const validationResult = MultipleChoiceValidator.validateAnswer(
            currentQuestionData, 
            userAnswers
        );
        
        displayFeedback(validationResult);
    }
    
    /**
     * Zeigt das Validierungsergebnis als Feedback an
     * @param {Object} validationResult - Das Validierungsergebnis
     * @returns {void}
     */
    function displayFeedback(validationResult) {
        if (!feedbackContainer) return;
        
        // Feedback-Container leeren
        feedbackContainer.innerHTML = '';
        
        // Feedback-Element erstellen
        const feedbackElement = document.createElement('div');
        feedbackElement.className = `feedback-message ${validationResult.status}`;
        
        // Icon hinzufügen
        const iconElement = document.createElement('i');
        
        switch (validationResult.status) {
            case 'correct':
                iconElement.className = 'fas fa-check-circle';
                break;
                
            case 'partially_correct':
                iconElement.className = 'fas fa-adjust';
                break;
                
            case 'incorrect':
                iconElement.className = 'fas fa-times-circle';
                break;
                
            default:
                iconElement.className = 'fas fa-info-circle';
        }
        
        feedbackElement.appendChild(iconElement);
        
        // Textuelle Rückmeldung hinzufügen
        const textElement = document.createElement('span');
        textElement.textContent = validationResult.feedback;
        feedbackElement.appendChild(textElement);
        
        // Punktzahl anzeigen, falls verfügbar
        if (validationResult.score !== undefined && validationResult.maxScore !== undefined) {
            const scoreElement = document.createElement('div');
            scoreElement.className = 'feedback-score';
            scoreElement.textContent = `Punktzahl: ${validationResult.score} / ${validationResult.maxScore}`;
            feedbackElement.appendChild(scoreElement);
        }
        
        // Zum Container hinzufügen
        feedbackContainer.appendChild(feedbackElement);
        
        // Container anzeigen
        feedbackContainer.style.display = 'block';
        
        // Animation hinzufügen, falls aktiviert
        if (animationEnabled) {
            feedbackElement.classList.add('animated');
            feedbackElement.classList.add('fadeIn');
            
            // Animation nach 5 Sekunden entfernen
            setTimeout(() => {
                feedbackElement.classList.remove('animated');
                feedbackElement.classList.remove('fadeIn');
            }, 5000);
        }
    }
    
    /**
     * Zeigt detailliertes Feedback mit vollständiger Antwortanalyse
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {boolean} showDetailedReport - Ob ein detaillierter Bericht angezeigt werden soll
     * @returns {void}
     */
    function provideDetailedFeedback(userAnswers, showDetailedReport = true) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Standard-Feedback anzeigen
        provideFeedback(userAnswers);
        
        if (!showDetailedReport) return;
        
        // Detaillierten Bericht generieren und anzeigen
        if (typeof MultipleChoiceValidator !== 'undefined') {
            const detailedReport = MultipleChoiceValidator.generateDetailedReport(
                currentQuestionData,
                userAnswers
            );
            
            // Detailbericht-Container erstellen
            const reportContainer = document.createElement('div');
            reportContainer.className = 'detailed-report-container';
            reportContainer.innerHTML = detailedReport;
            
            // Zum Feedback-Container hinzufügen
            feedbackContainer.appendChild(reportContainer);
            
            // Animation hinzufügen, falls aktiviert
            if (animationEnabled) {
                reportContainer.classList.add('animated');
                reportContainer.classList.add('fadeIn');
                
                // Animation nach 5 Sekunden entfernen
                setTimeout(() => {
                    reportContainer.classList.remove('animated');
                    reportContainer.classList.remove('fadeIn');
                }, 5000);
            }
        }
    }
    
    /**
     * Aktiviert oder deaktiviert das sofortige Feedback
     * @param {boolean} enable - Ob sofortiges Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleInstantFeedback(enable) {
        instantFeedbackEnabled = enable;
    }
    
    /**
     * Aktiviert oder deaktiviert Feedback generell
     * @param {boolean} enable - Ob Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleFeedback(enable) {
        feedbackEnabled = enable;
        
        // Feedback-Container ausblenden, wenn deaktiviert
        if (!enable && feedbackContainer) {
            feedbackContainer.style.display = 'none';
        }
    }
    
    /**
     * Aktiviert oder deaktiviert Animationen
     * @param {boolean} enable - Ob Animationen aktiviert werden sollen
     * @returns {void}
     */
    function toggleAnimation(enable) {
        animationEnabled = enable;
    }
    
    /**
     * Blendet das Feedback aus
     * @returns {void}
     */
    function hideFeedback() {
        if (feedbackContainer) {
            feedbackContainer.style.display = 'none';
        }
    }
    
    /**
     * Bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (feedbackContainer) {
            feedbackContainer.innerHTML = '';
        }
        
        currentQuestionContainer = null;
        currentQuestionData = null;
        feedbackContainer = null;
    }
    
    // Öffentliche API
    return {
        initialize,
        provideFeedback,
        provideDetailedFeedback,
        toggleInstantFeedback,
        toggleFeedback,
        toggleAnimation,
        hideFeedback,
        cleanup
    };
})();

// IIFE für den Gamification-Feedback-Enhancer
const MultipleChoiceGamificationEnhancer = (function() {
    // Private Variablen
    let confettiEnabled = true;
    let soundEffectsEnabled = false;
    let achievementNotificationsEnabled = true;
    
    /**
     * Spielt eine Erfolgsanimation ab, wenn der Benutzer eine Frage richtig beantwortet
     * @param {string} status - Der Status der Antwort
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playSuccessAnimation(status, container) {
        if (!container) return;
        
        if (status === 'correct' && confettiEnabled) {
            // Konfetti-Animation abspielen
            playConfettiAnimation(container);
        } else if (status === 'partially_correct') {
            // Teilweise Erfolgsanimation abspielen
            playPartialSuccessAnimation(container);
        }
        
        // Sound-Effekte abspielen, falls aktiviert
        if (soundEffectsEnabled) {
            playFeedbackSound(status);
        }
    }
    
    /**
     * Spielt eine Konfetti-Animation ab
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playConfettiAnimation(container) {
        // Konfetti-Element erstellen
        const confettiContainer = document.createElement('div');
        confettiContainer.className = 'confetti-container';
        
        // Konfetti-Partikel erstellen
        for (let i = 0; i < 50; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            
            // Zufällige Farbe zuweisen (ImmoScout24-Farbschema)
            const colors = ['#00FFD0', '#00B090', '#57D9A3', '#008055', '#00FFD0'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.backgroundColor = randomColor;
            
            // Zufällige Position und Animation
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            
            confettiContainer.appendChild(confetti);
        }
        
        // Zum Container hinzufügen
        container.appendChild(confettiContainer);
        
        // Nach 5 Sekunden entfernen
        setTimeout(() => {
            if (confettiContainer.parentNode) {
                confettiContainer.parentNode.removeChild(confettiContainer);
            }
        }, 5000);
    }
    
    /**
     * Spielt eine Animation für teilweise korrekte Antworten ab
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playPartialSuccessAnimation(container) {
        // Element für teilweise Erfolgsanimation erstellen
        const animationContainer = document.createElement('div');
        animationContainer.className = 'partial-success-animation';
        
        // Pulsierendes Element hinzufügen
        const pulseElement = document.createElement('div');
        pulseElement.className = 'pulse-element';
        animationContainer.appendChild(pulseElement);
        
        // Zum Container hinzufügen
        container.appendChild(animationContainer);
        
        // Nach 3 Sekunden entfernen
        setTimeout(() => {
            if (animationContainer.parentNode) {
                animationContainer.parentNode.removeChild(animationContainer);
            }
        }, 3000);
    }
    
    /**
     * Spielt einen Sound-Effekt basierend auf dem Antwortstatus ab
     * @param {string} status - Der Status der Antwort
     * @returns {void}
     */
    function playFeedbackSound(status) {
        let soundUrl = '';
        
        switch (status) {
            case 'correct':
                soundUrl = 'assets/sounds/success.mp3';
                break;
                
            case 'partially_correct':
                soundUrl = 'assets/sounds/partial_success.mp3';
                break;
                
            case 'incorrect':
                soundUrl = 'assets/sounds/failure.mp3';
                break;
        }
        
        if (soundUrl) {
            try {
                const audio = new Audio(soundUrl);
                audio.volume = 0.5;
                audio.play().catch(error => {
                    console.log('Sound konnte nicht abgespielt werden:', error);
                });
            } catch (error) {
                console.log('Fehler beim Abspielen des Sounds:', error);
            }
        }
    }
    
    /**
     * Zeigt eine Achievement-Benachrichtigung an
     * @param {string} achievementTitle - Der Titel des Achievements
     * @param {string} achievementDescription - Die Beschreibung des Achievements
     * @returns {void}
     */
    function showAchievementNotification(achievementTitle, achievementDescription) {
        if (!achievementNotificationsEnabled) return;
        
        // Achievement-Benachrichtigung erstellen
        const notification = document.createElement('div');
        notification.className = 'achievement-notification animated fadeInRight';
        
        notification.innerHTML = `
            <div class="achievement-icon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="achievement-content">
                <h4>${achievementTitle}</h4>
                <p>${achievementDescription}</p>
            </div>
            <div class="achievement-close">
                <i class="fas fa-times"></i>
            </div>
        `;
        
        // Zum Body hinzufügen
        document.body.appendChild(notification);
        
        // Schließen-Button funktional machen
        const closeButton = notification.querySelector('.achievement-close');
        if (closeButton) {
            closeButton.addEventListener('click', function() {
                notification.classList.remove('fadeInRight');
                notification.classList.add('fadeOutRight');
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            });
        }
        
        // Nach 5 Sekunden automatisch ausblenden
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.remove('fadeInRight');
                notification.classList.add('fadeOutRight');
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }
        }, 5000);
    }
	/**
 * JS-Block 5.2.2-part2: Fragenanzeige - Multiple Choice (Feedback-Mechanismen, Teil 2.2)
 * 
 * Dieser Block implementiert Feedback-Mechanismen für Multiple-Choice-Fragen.
 * Er bietet visuelle und textuelle Rückmeldungen zu den Antworten des Benutzers
 * und integriert sich mit dem Validierungssystem.
 */

// IIFE für den Multiple-Choice-Feedback-Handler
const MultipleChoiceFeedbackHandler = (function() {
    // Private Variablen
    let currentQuestionContainer = null;
    let currentQuestionData = null;
    let feedbackContainer = null;
    let feedbackEnabled = true;
    let instantFeedbackEnabled = false;
    let animationEnabled = true;
    
    /**
     * Initialisiert den Feedback-Handler für eine Multiple-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @param {Object} questionData - Die Fragendaten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function initialize(container, questionData, options = {}) {
        if (!container || !questionData) {
            console.error('MultipleChoiceFeedbackHandler: Fehlende Container- oder Fragedaten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionContainer = container;
        currentQuestionData = questionData;
        
        // Konfigurationsoptionen übernehmen
        feedbackEnabled = options.feedbackEnabled !== undefined ? 
            options.feedbackEnabled : true;
        instantFeedbackEnabled = options.instantFeedbackEnabled !== undefined ? 
            options.instantFeedbackEnabled : false;
        animationEnabled = options.animationEnabled !== undefined ? 
            options.animationEnabled : true;
        
        // Feedback-Container erstellen, falls nicht vorhanden
        createFeedbackContainer();
        
        // Event-Listener für Antwortänderungen hinzufügen
        if (instantFeedbackEnabled) {
            addAnswerChangeListener();
        }
    }
    
    /**
     * Erstellt den Container für Feedback-Nachrichten
     * @returns {void}
     */
    function createFeedbackContainer() {
        if (!currentQuestionContainer) return;
        
        // Prüfen, ob bereits ein Feedback-Container existiert
        let existingContainer = currentQuestionContainer.querySelector('.feedback-container');
        
        if (existingContainer) {
            feedbackContainer = existingContainer;
            return;
        }
        
        // Neuen Feedback-Container erstellen
        feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';
        feedbackContainer.style.display = 'none';
        
        // Zum Frage-Container hinzufügen, nach den Antwortoptionen
        const optionsContainer = currentQuestionContainer.querySelector('.answer-options');
        
        if (optionsContainer) {
            optionsContainer.insertAdjacentElement('afterend', feedbackContainer);
        } else {
            currentQuestionContainer.appendChild(feedbackContainer);
        }
    }
    
    /**
     * Fügt einen Event-Listener für Antwortänderungen hinzu (für sofortiges Feedback)
     * @returns {void}
     */
    function addAnswerChangeListener() {
        if (!currentQuestionData) return;
        
        document.addEventListener('answerUpdated', function(event) {
            if (event.detail && event.detail.questionId === currentQuestionData.id) {
                // Sofortiges Feedback anzeigen, wenn aktiviert
                if (instantFeedbackEnabled && feedbackEnabled) {
                    const userAnswers = event.detail.answer;
                    
                    if (Array.isArray(userAnswers)) {
                        provideFeedback(userAnswers);
                    }
                }
            }
        });
    }
    
    /**
     * Zeigt Feedback zur Benutzerantwort an
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @returns {void}
     */
    function provideFeedback(userAnswers) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Feedback über den Validator generieren
        if (typeof MultipleChoiceValidator === 'undefined') {
            console.error('MultipleChoiceFeedbackHandler: Validator nicht gefunden');
            return;
        }
        
        const validationResult = MultipleChoiceValidator.validateAnswer(
            currentQuestionData, 
            userAnswers
        );
        
        displayFeedback(validationResult);
    }
    
    /**
     * Zeigt das Validierungsergebnis als Feedback an
     * @param {Object} validationResult - Das Validierungsergebnis
     * @returns {void}
     */
    function displayFeedback(validationResult) {
        if (!feedbackContainer) return;
        
        // Feedback-Container leeren
        feedbackContainer.innerHTML = '';
        
        // Feedback-Element erstellen
        const feedbackElement = document.createElement('div');
        feedbackElement.className = `feedback-message ${validationResult.status}`;
        
        // Icon hinzufügen
        const iconElement = document.createElement('i');
        
        switch (validationResult.status) {
            case 'correct':
                iconElement.className = 'fas fa-check-circle';
                break;
                
            case 'partially_correct':
                iconElement.className = 'fas fa-adjust';
                break;
                
            case 'incorrect':
                iconElement.className = 'fas fa-times-circle';
                break;
                
            default:
                iconElement.className = 'fas fa-info-circle';
        }
        
        feedbackElement.appendChild(iconElement);
        
        // Textuelle Rückmeldung hinzufügen
        const textElement = document.createElement('span');
        textElement.textContent = validationResult.feedback;
        feedbackElement.appendChild(textElement);
        
        // Punktzahl anzeigen, falls verfügbar
        if (validationResult.score !== undefined && validationResult.maxScore !== undefined) {
            const scoreElement = document.createElement('div');
            scoreElement.className = 'feedback-score';
            scoreElement.textContent = `Punktzahl: ${validationResult.score} / ${validationResult.maxScore}`;
            feedbackElement.appendChild(scoreElement);
        }
        
        // Zum Container hinzufügen
        feedbackContainer.appendChild(feedbackElement);
        
        // Container anzeigen
        feedbackContainer.style.display = 'block';
        
        // Animation hinzufügen, falls aktiviert
        if (animationEnabled) {
            feedbackElement.classList.add('animated');
            feedbackElement.classList.add('fadeIn');
            
            // Animation nach 5 Sekunden entfernen
            setTimeout(() => {
                feedbackElement.classList.remove('animated');
                feedbackElement.classList.remove('fadeIn');
            }, 5000);
        }
    }
    
    /**
     * Zeigt detailliertes Feedback mit vollständiger Antwortanalyse
     * @param {Array<number>} userAnswers - Die vom Benutzer ausgewählten Antwortindizes
     * @param {boolean} showDetailedReport - Ob ein detaillierter Bericht angezeigt werden soll
     * @returns {void}
     */
    function provideDetailedFeedback(userAnswers, showDetailedReport = true) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Standard-Feedback anzeigen
        provideFeedback(userAnswers);
        
        if (!showDetailedReport) return;
        
        // Detaillierten Bericht generieren und anzeigen
        if (typeof MultipleChoiceValidator !== 'undefined') {
            const detailedReport = MultipleChoiceValidator.generateDetailedReport(
                currentQuestionData,
                userAnswers
            );
            
            // Detailbericht-Container erstellen
            const reportContainer = document.createElement('div');
            reportContainer.className = 'detailed-report-container';
            reportContainer.innerHTML = detailedReport;
            
            // Zum Feedback-Container hinzufügen
            feedbackContainer.appendChild(reportContainer);
            
            // Animation hinzufügen, falls aktiviert
            if (animationEnabled) {
                reportContainer.classList.add('animated');
                reportContainer.classList.add('fadeIn');
                
                // Animation nach 5 Sekunden entfernen
                setTimeout(() => {
                    reportContainer.classList.remove('animated');
                    reportContainer.classList.remove('fadeIn');
                }, 5000);
            }
        }
    }
    
    /**
     * Aktiviert oder deaktiviert das sofortige Feedback
     * @param {boolean} enable - Ob sofortiges Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleInstantFeedback(enable) {
        instantFeedbackEnabled = enable;
    }
    
    /**
     * Aktiviert oder deaktiviert Feedback generell
     * @param {boolean} enable - Ob Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleFeedback(enable) {
        feedbackEnabled = enable;
        
        // Feedback-Container ausblenden, wenn deaktiviert
        if (!enable && feedbackContainer) {
            feedbackContainer.style.display = 'none';
        }
    }
    
    /**
     * Aktiviert oder deaktiviert Animationen
     * @param {boolean} enable - Ob Animationen aktiviert werden sollen
     * @returns {void}
     */
    function toggleAnimation(enable) {
        animationEnabled = enable;
    }
    
    /**
     * Blendet das Feedback aus
     * @returns {void}
     */
    function hideFeedback() {
        if (feedbackContainer) {
            feedbackContainer.style.display = 'none';
        }
    }
    
    /**
     * Bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (feedbackContainer) {
            feedbackContainer.innerHTML = '';
        }
        
        currentQuestionContainer = null;
        currentQuestionData = null;
        feedbackContainer = null;
    }
    
    // Öffentliche API
    return {
        initialize,
        provideFeedback,
        provideDetailedFeedback,
        toggleInstantFeedback,
        toggleFeedback,
        toggleAnimation,
        hideFeedback,
        cleanup
    };
})();

// IIFE für den Gamification-Feedback-Enhancer
const MultipleChoiceGamificationEnhancer = (function() {
    // Private Variablen
    let confettiEnabled = true;
    let soundEffectsEnabled = false;
    let achievementNotificationsEnabled = true;
    
    /**
     * Spielt eine Erfolgsanimation ab, wenn der Benutzer eine Frage richtig beantwortet
     * @param {string} status - Der Status der Antwort
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playSuccessAnimation(status, container) {
        if (!container) return;
        
        if (status === 'correct' && confettiEnabled) {
            // Konfetti-Animation abspielen
            playConfettiAnimation(container);
        } else if (status === 'partially_correct') {
            // Teilweise Erfolgsanimation abspielen
            playPartialSuccessAnimation(container);
        }
        
        // Sound-Effekte abspielen, falls aktiviert
        if (soundEffectsEnabled) {
            playFeedbackSound(status);
        }
    }
    
    /**
     * Spielt eine Konfetti-Animation ab
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playConfettiAnimation(container) {
        // Konfetti-Element erstellen
        const confettiContainer = document.createElement('div');
        confettiContainer.className = 'confetti-container';
        
        // Konfetti-Partikel erstellen
        for (let i = 0; i < 50; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            
            // Zufällige Farbe zuweisen (ImmoScout24-Farbschema)
            const colors = ['#00FFD0', '#00B090', '#57D9A3', '#008055', '#00FFD0'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.backgroundColor = randomColor;
            
            // Zufällige Position und Animation
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            
            confettiContainer.appendChild(confetti);
        }
        
        // Zum Container hinzufügen
        container.appendChild(confettiContainer);
        
        // Nach 5 Sekunden entfernen
        setTimeout(() => {
            if (confettiContainer.parentNode) {
                confettiContainer.parentNode.removeChild(confettiContainer);
            }
        }, 5000);
    }
    
    /**
     * Spielt eine Animation für teilweise korrekte Antworten ab
     * @param {HTMLElement} container - Der Container für die Animation
     * @returns {void}
     */
    function playPartialSuccessAnimation(container) {
        // Element für teilweise Erfolgsanimation erstellen
        const animationContainer = document.createElement('div');
        animationContainer.className = 'partial-success-animation';
        
        // Pulsierendes Element hinzufügen
        const pulseElement = document.createElement('div');
        pulseElement.className = 'pulse-element';
        animationContainer.appendChild(pulseElement);
        
        // Zum Container hinzufügen
        container.appendChild(animationContainer);
        
        // Nach 3 Sekunden entfernen
        setTimeout(() => {
            if (animationContainer.parentNode) {
                animationContainer.parentNode.removeChild(animationContainer);
            }
        }, 3000);
    }
    
    /**
     * Spielt einen Sound-Effekt basierend auf dem Antwortstatus ab
     * @param {string} status - Der Status der Antwort
     * @returns {void}
     */
    function playFeedbackSound(status) {
        let soundUrl = '';
        
        switch (status) {
            case 'correct':
                soundUrl = 'assets/sounds/success.mp3';
                break;
                
            case 'partially_correct':
                soundUrl = 'assets/sounds/partial_success.mp3';
                break;
                
            case 'incorrect':
                soundUrl = 'assets/sounds/failure.mp3';
                break;
        }
        
        if (soundUrl) {
            try {
                const audio = new Audio(soundUrl);
                audio.volume = 0.5;
                audio.play().catch(error => {
                    console.log('Sound konnte nicht abgespielt werden:', error);
                });
            } catch (error) {
                console.log('Fehler beim Abspielen des Sounds:', error);
            }
        }
    }
    
    /**
     * Zeigt eine Achievement-Benachrichtigung an
     * @param {string} achievementTitle - Der Titel des Achievements
     * @param {string} achievementDescription - Die Beschreibung des Achievements
     * @returns {void}
     */
    function showAchievementNotification(achievementTitle, achievementDescription) {
        if (!achievementNotificationsEnabled) return;
        
        // Achievement-Benachrichtigung erstellen
        const notification = document.createElement('div');
        notification.className = 'achievement-notification animated fadeInRight';
        
        notification.innerHTML = `
            <div class="achievement-icon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="achievement-content">
                <h4>${achievementTitle}</h4>
                <p>${achievementDescription}</p>
            </div>
            <div class="achievement-close">
                <i class="fas fa-times"></i>
            </div>
        `;
        
        // Zum Body hinzufügen
        document.body.appendChild(notification);
        
        // Schließen-Button funktional machen
        const closeButton = notification.querySelector('.achievement-close');
        if (closeButton) {
            closeButton.addEventListener('click', function() {
                notification.classList.remove('fadeInRight');
                notification.classList.add('fadeOutRight');
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            });
        }
        
        // Nach 5 Sekunden automatisch ausblenden
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.remove('fadeInRight');
                notification.classList.add('fadeOutRight');
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }
        }, 5000);
    }
    
    /**
     * Überprüft, ob Achievements erreicht wurden
     * @param {string} status - Der Status der Antwort
     * @param {number} answerTime - Die Zeit, die für die Antwort benötigt wurde (in Sekunden)
     * @returns {Array} Erreichte Achievements
     */
    function checkAchievements(status, answerTime) {
        const achievements = [];
        
        // Beispiel-Achievements
        if (status === 'correct') {
            achievements.push({
                title: 'Korrekte Antwort',
                description: 'Sie haben die Frage vollständig korrekt beantwortet.'
            });
            
            if (answerTime && answerTime < 10) {
                achievements.push({
                    title: 'Schnelle Antwort',
                    description: 'Sie haben die Frage in unter 10 Sekunden korrekt beantwortet.'
                });
            }
        } else if (status === 'partially_correct') {
            achievements.push({
                title: 'Auf dem richtigen Weg',
                description: 'Sie haben die Frage teilweise korrekt beantwortet.'
            });
        }
        
        return achievements;
    }
    
    /**
     * Aktiviert oder deaktiviert Konfetti-Animationen
     * @param {boolean} enable - Ob Konfetti aktiviert werden soll
     * @returns {void}
     */
    function toggleConfetti(enable) {
        confettiEnabled = enable;
    }
    
    /**
     * Aktiviert oder deaktiviert Sound-Effekte
     * @param {boolean} enable - Ob Sound-Effekte aktiviert werden sollen
     * @returns {void}
     */
    function toggleSoundEffects(enable) {
        soundEffectsEnabled = enable;
    }
    
    /**
     * Aktiviert oder deaktiviert Achievement-Benachrichtigungen
     * @param {boolean} enable - Ob Achievement-Benachrichtigungen aktiviert werden sollen
     * @returns {void}
     */
    function toggleAchievementNotifications(enable) {
        achievementNotificationsEnabled = enable;
    }
    
    // Öffentliche API
    return {
        playSuccessAnimation,
        showAchievementNotification,
        checkAchievements,
        toggleConfetti,
        toggleSoundEffects,
        toggleAchievementNotifications
    };
})();

// Integration mit dem Frage-Handler
document.addEventListener('DOMContentLoaded', function() {
    // Event-Listener für Antwortvalidierung
    document.addEventListener('multipleChoiceValidationResult', function(event) {
        if (event.detail && event.detail.result) {
            const result = event.detail.result;
            const container = document.querySelector(`[data-question-id="${event.detail.questionId}"]`);
            
            if (container && result.status === 'correct') {
                // Erfolgsanimation abspielen
                MultipleChoiceGamificationEnhancer.playSuccessAnimation(result.status, container);
                
                // Achievements überprüfen
                const achievements = MultipleChoiceGamificationEnhancer.checkAchievements(
                    result.status,
                    event.detail.answerTime
                );
                
                // Achievement-Benachrichtigungen anzeigen
                if (achievements.length > 0) {
                    // Verzögerung, damit die Konfetti-Animation zuerst abgespielt wird
                    setTimeout(() => {
                        achievements.forEach(achievement => {
                            MultipleChoiceGamificationEnhancer.showAchievementNotification(
                                achievement.title,
                                achievement.description
                            );
                        });
                    }, 500);
                }
            }
        }
    });
});

// Verbindung mit dem Rest des Systems über eine globale Registry
if (typeof FeedbackRegistry === 'undefined') {
    window.FeedbackRegistry = {};
}

FeedbackRegistry.MultipleChoice = {
    feedbackHandler: MultipleChoiceFeedbackHandler,
    gamificationEnhancer: MultipleChoiceGamificationEnhancer
};

// CSS-Stile für Feedback-Elemente und Animationen
(function addFeedbackStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Feedback-Container */
        .feedback-container {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        /* Feedback-Nachricht */
        .feedback-message {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .feedback-message i {
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        .feedback-message.correct {
            background-color: rgba(40, 167, 69, 0.2);
            border-left: 4px solid #28a745;
            color: #155724;
        }
        
        .feedback-message.partially_correct {
            background-color: rgba(253, 126, 20, 0.2);
            border-left: 4px solid #fd7e14;
            color: #856404;
        }
        
        .feedback-message.incorrect {
            background-color: rgba(220, 53, 69, 0.2);
            border-left: 4px solid #dc3545;
            color: #721c24;
        }
        
        /* Feedback-Punktzahl */
        .feedback-score {
            margin-top: 5px;
            font-weight: bold;
        }
        
        /* Konfetti-Animation */
        .confetti-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 100;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.7;
            border-radius: 2px;
            animation: fall linear forwards;
        }
        
        @keyframes fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(600px) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Pulse-Animation für teilweise korrekte Antworten */
        .partial-success-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        
        .pulse-element {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(253, 126, 20, 0.7);
            animation: pulse 2s ease-out infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        /* Achievement-Benachrichtigung */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            background-color: #00FFD0;
            color: #333;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-width: 350px;
        }
        
        .achievement-icon {
            background-color: #00B090;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            color: white;
            font-size: 1.2em;
        }
        
        .achievement-content {
            flex-grow: 1;
        }
        
        .achievement-content h4 {
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .achievement-content p {
            margin: 0;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .achievement-close {
            cursor: pointer;
            padding: 5px;
        }
        
        /* Animationen */
        .animated {
            animation-duration: 0.5s;
            animation-fill-mode: both;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .fadeIn {
            animation-name: fadeIn;
        }
        
        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translate3d(100%, 0, 0);
            }
            to {
                opacity: 1;
                transform: translate3d(0, 0, 0);
            }
        }
        
        .fadeInRight {
            animation-name: fadeInRight;
        }
        
        @keyframes fadeOutRight {
            from {
                opacity: 1;
                transform: translate3d(0, 0, 0);
            }
            to {
                opacity: 0;
                transform: translate3d(100%, 0, 0);
            }
        }
        
        .fadeOutRight {
            animation-name: fadeOutRight;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.3.1-part1: Fragenanzeige - Single Choice (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Single-Choice-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Single-Choice-Fragenmoduls
const SingleChoiceQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswer = null;
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    /**
     * Initialisiert die Anzeige einer Single-Choice-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('SingleChoiceQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Single-Choice-Fragetyp arbeiten
        if (questionData.type !== 'single-choice') {
            console.error('SingleChoiceQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined) {
            selectedAnswer = sessionAnswer;
        } else {
            selectedAnswer = null;
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Single-Choice-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content single-choice-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Single-Choice hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Wählen Sie eine Antwort aus.';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options single-choice-options';
        
        // Antwortoptionen hinzufügen
        if (currentQuestionData.options && Array.isArray(currentQuestionData.options)) {
            currentQuestionData.options.forEach((option, index) => {
                const optionElement = createAnswerOption(option, index);
                optionsContainer.appendChild(optionElement);
            });
        } else {
            console.error('SingleChoiceQuestionHandler: Keine Antwortoptionen gefunden');
        }
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekten Antworten anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antwort markieren
        updateSelectedAnswerUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {Object} option - Die Antwortoption
     * @param {number} index - Der Index der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(option, index) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option single-choice-option';
        optionElement.dataset.optionIndex = index;
        
        // Radio-Button-Container für bessere Styling-Möglichkeiten
        const radioContainer = document.createElement('div');
        radioContainer.className = 'radio-container';
        
        // Radio-Button erstellen
        const radioButton = document.createElement('div');
        radioButton.className = 'custom-radio';
        
        // Innerer Punkt für Radio-Button (wird durch CSS angezeigt)
        const radioInner = document.createElement('div');
        radioInner.className = 'radio-inner';
        radioButton.appendChild(radioInner);
        
        radioContainer.appendChild(radioButton);
        optionElement.appendChild(radioContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerHTML = option.text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Die korrekte Antwort ermitteln
        const correctOption = currentQuestionData.options.find(option => option.isCorrect);
        const correctAnswerText = correctOption ? correctOption.text : 'Keine korrekte Antwort definiert';
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekte Antwort ist:</p>
                <div class="correct-answer">${correctAnswerText}</div>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (selectedAnswer === null || !currentQuestionData || !currentQuestionData.options) return false;
        
        // Prüfen, ob die ausgewählte Option korrekt ist
        const selectedOption = currentQuestionData.options[selectedAnswer];
        return selectedOption && selectedOption.isCorrect === true;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('single-choice-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.optionIndex) return;
        
        const optionIndex = parseInt(optionElement.dataset.optionIndex, 10);
        
        // Antwort umschalten (bei Single Choice wird immer die neue Option ausgewählt)
        selectAnswer(optionIndex);
        
        // UI aktualisieren
        updateSelectedAnswerUI();
        
        // Antwort im TestSessionManager speichern
        saveAnswer();
    }
	/**
 * JS-Block 5.3.1-part1: Fragenanzeige - Single Choice (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Single-Choice-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Single-Choice-Fragenmoduls
const SingleChoiceQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswer = null;
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    /**
     * Initialisiert die Anzeige einer Single-Choice-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('SingleChoiceQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Single-Choice-Fragetyp arbeiten
        if (questionData.type !== 'single-choice') {
            console.error('SingleChoiceQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined) {
            selectedAnswer = sessionAnswer;
        } else {
            selectedAnswer = null;
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Single-Choice-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content single-choice-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Single-Choice hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Wählen Sie eine Antwort aus.';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options single-choice-options';
        
        // Antwortoptionen hinzufügen
        if (currentQuestionData.options && Array.isArray(currentQuestionData.options)) {
            currentQuestionData.options.forEach((option, index) => {
                const optionElement = createAnswerOption(option, index);
                optionsContainer.appendChild(optionElement);
            });
        } else {
            console.error('SingleChoiceQuestionHandler: Keine Antwortoptionen gefunden');
        }
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekten Antworten anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antwort markieren
        updateSelectedAnswerUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {Object} option - Die Antwortoption
     * @param {number} index - Der Index der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(option, index) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option single-choice-option';
        optionElement.dataset.optionIndex = index;
        
        // Radio-Button-Container für bessere Styling-Möglichkeiten
        const radioContainer = document.createElement('div');
        radioContainer.className = 'radio-container';
        
        // Radio-Button erstellen
        const radioButton = document.createElement('div');
        radioButton.className = 'custom-radio';
        
        // Innerer Punkt für Radio-Button (wird durch CSS angezeigt)
        const radioInner = document.createElement('div');
        radioInner.className = 'radio-inner';
        radioButton.appendChild(radioInner);
        
        radioContainer.appendChild(radioButton);
        optionElement.appendChild(radioContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerHTML = option.text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Die korrekte Antwort ermitteln
        const correctOption = currentQuestionData.options.find(option => option.isCorrect);
        const correctAnswerText = correctOption ? correctOption.text : 'Keine korrekte Antwort definiert';
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekte Antwort ist:</p>
                <div class="correct-answer">${correctAnswerText}</div>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (selectedAnswer === null || !currentQuestionData || !currentQuestionData.options) return false;
        
        // Prüfen, ob die ausgewählte Option korrekt ist
        const selectedOption = currentQuestionData.options[selectedAnswer];
        return selectedOption && selectedOption.isCorrect === true;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('single-choice-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.optionIndex) return;
        
        const optionIndex = parseInt(optionElement.dataset.optionIndex, 10);
        
        // Antwort umschalten (bei Single Choice wird immer die neue Option ausgewählt)
        selectAnswer(optionIndex);
        
        // UI aktualisieren
        updateSelectedAnswerUI();
        
        // Antwort im TestSessionManager speichern
        saveAnswer();
    }
    
    /**
     * Wählt eine Antwort aus
     * @param {number} optionIndex - Der Index der Option
     * @returns {void}
     */
    function selectAnswer(optionIndex) {
        selectedAnswer = optionIndex;
    }
    
    /**
     * Aktualisiert die Benutzeroberfläche basierend auf der ausgewählten Antwort
     * @returns {void}
     */
    function updateSelectedAnswerUI() {
        if (!questionContainer) return;
        
        // Alle Optionselemente durchgehen
        const optionElements = questionContainer.querySelectorAll('.single-choice-option');
        
        optionElements.forEach(element => {
            const optionIndex = parseInt(element.dataset.optionIndex, 10);
            const isSelected = selectedAnswer === optionIndex;
            
            // Styling anpassen
            if (isSelected) {
                element.classList.add('selected');
            } else {
                element.classList.remove('selected');
            }
            
            // Radio-Button-Status aktualisieren
            const radioButton = element.querySelector('.custom-radio');
            if (radioButton) {
                if (isSelected) {
                    radioButton.classList.add('checked');
                } else {
                    radioButton.classList.remove('checked');
                }
            }
        });
        
        // Im Review-Modus zusätzliches Styling für richtige/falsche Antworten
        if (isReviewMode && currentQuestionData && currentQuestionData.options) {
            optionElements.forEach(element => {
                const optionIndex = parseInt(element.dataset.optionIndex, 10);
                const option = currentQuestionData.options[optionIndex];
                
                if (option.isCorrect) {
                    element.classList.add('correct-answer');
                } else if (selectedAnswer === optionIndex) {
                    element.classList.add('incorrect-answer');
                }
            });
        }
    }
    
    /**
     * Speichert die ausgewählte Antwort in der Testsitzung
     * @returns {void}
     */
    function saveAnswer() {
        if (!currentQuestionData || !currentQuestionData.id) return;
        
        TestSessionManager.saveQuestionAnswer(
            currentQuestionData.id,
            selectedAnswer
        );
        
        // Event auslösen, um andere Komponenten über die Antwortänderung zu informieren
        const event = new CustomEvent('answerUpdated', {
            detail: {
                questionId: currentQuestionData.id,
                answer: selectedAnswer,
                answerType: 'single-choice'
            }
        });
        document.dispatchEvent(event);
    }
    
    /**
     * Aktualisiert die Antwortauswahl basierend auf dem übergebenen Index
     * @param {number} answerIndex - Der Index der ausgewählten Antwort
     * @returns {void}
     */
    function updateSelectedAnswer(answerIndex) {
        if (typeof answerIndex !== 'number') return;
        
        selectedAnswer = answerIndex;
        updateSelectedAnswerUI();
    }
    
    /**
     * Sperrt die Benutzerinteraktion mit der Frage
     * @param {boolean} lock - Ob die Interaktion gesperrt werden soll
     * @returns {void}
     */
    function lockAnswers(lock = true) {
        userAnswersLocked = lock;
        
        // Visuelles Feedback für gesperrten Zustand
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                if (lock) {
                    optionsContainer.classList.add('locked');
                } else {
                    optionsContainer.classList.remove('locked');
                }
            }
        }
    }
    
    /**
     * Aktiviert den Review-Modus, um korrekte Antworten anzuzeigen
     * @param {boolean} enable - Ob der Review-Modus aktiviert werden soll
     * @returns {void}
     */
    function enableReviewMode(enable = true) {
        if (isReviewMode === enable) return; // Keine Änderung nötig
        
        isReviewMode = enable;
        
        // Neu rendern, wenn sich der Modus ändert
        renderQuestion();
    }
    
    /**
     * Prüft, ob die aktuelle Frage beantwortet wurde
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isAnswered() {
        return selectedAnswer !== null;
    }
    
    /**
     * Gibt die Auswahl des Benutzers zurück
     * @returns {number|null} Der ausgewählte Antwortindex oder null, wenn keine Auswahl
     */
    function getSelectedAnswer() {
        return selectedAnswer;
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                optionsContainer.removeEventListener('click', handleOptionClick);
            }
        }
        
        // Referenzen zurücksetzen
        currentQuestionData = null;
        selectedAnswer = null;
        questionContainer = null;
    }
    
    // Öffentliche API
    return {
        initializeQuestion,
        updateSelectedAnswer,
        lockAnswers,
        enableReviewMode,
        isAnswered,
        getSelectedAnswer,
        cleanup
    };
})();

// Module registrieren
if (typeof QuestionHandlerRegistry !== 'undefined') {
    QuestionHandlerRegistry.registerHandler('single-choice', SingleChoiceQuestionHandler);
}

// CSS-Stile für Single-Choice-Fragen
(function addSingleChoiceStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Single-Choice Optionen */
        .single-choice-option {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .single-choice-option:hover {
            background-color: #e9ecef;
            border-color: #ced4da;
        }
        
        .single-choice-option.selected {
            background-color: rgba(0, 255, 208, 0.1);
            border: 1px solid #00FFD0;
        }
        
        /* Radio-Button Styling */
        .radio-container {
            margin-right: 15px;
        }
        
        .custom-radio {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #ced4da;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .radio-inner {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #00FFD0;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .custom-radio.checked {
            border-color: #00B090;
        }
        
        .custom-radio.checked .radio-inner {
            opacity: 1;
        }
        
        /* Optionstext */
        .option-text {
            flex-grow: 1;
        }
        
        /* Zustände im Review-Modus */
        .single-choice-option.correct-answer {
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 3px solid #28a745;
        }
        
        .single-choice-option.incorrect-answer {
            background-color: rgba(220, 53, 69, 0.1);
            border-left: 3px solid #dc3545;
        }
        
        /* Gesperrter Zustand */
        .answer-options.locked .single-choice-option {
            opacity: 0.7;
            pointer-events: none;
        }
        
        /* Feedback-Darstellung */
        .question-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .feedback-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .feedback-header i {
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        .feedback-header.correct {
            color: #28a745;
        }
        
        .feedback-header.incorrect {
            color: #dc3545;
        }
        
        .correct-answer {
            padding: 8px 12px;
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 3px solid #28a745;
            margin-top: 8px;
            border-radius: 4px;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.3.1-part2: Fragenanzeige - Single Choice (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Single-Choice-Funktionalität mit Barrierefreiheits-Features,
 * Tastaturunterstützung und Hilfsfunktionen zum Validieren und Navigieren.
 */

// IIFE für den Single-Choice Accessibility-Enhancer
const SingleChoiceAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Single-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastaturnavigation hinzufügen
        addKeyboardNavigation();
        
        // Fokus-Management verbessern
        improveFocusManagement();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Single-Choice-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionsContainer = currentQuestionContainer.querySelector('.single-choice-options');
        if (optionsContainer) {
            optionsContainer.setAttribute('role', 'radiogroup');
            optionsContainer.setAttribute('aria-labelledby', 'question-title');
            
            // Falls ein Titel existiert, diesem eine ID geben
            if (questionText) {
                questionText.id = 'question-title';
            }
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        optionElements.forEach((option, index) => {
            option.setAttribute('role', 'radio');
            option.setAttribute('aria-checked', 'false');
            option.setAttribute('tabindex', '0');
            option.setAttribute('aria-label', `Option ${index + 1}`);
            
            // Text-Inhalt auslesen für vollständiges aria-label
            const optionText = option.querySelector('.option-text');
            if (optionText) {
                option.setAttribute('aria-label', optionText.textContent.trim());
            }
            
            // Prüfen, ob ausgewählt
            if (option.classList.contains('selected')) {
                option.setAttribute('aria-checked', 'true');
                
                // Wenn ausgewählt, dann focus aktivieren, andere deaktivieren
                option.setAttribute('tabindex', '0');
            } else {
                option.setAttribute('tabindex', '-1');
            }
        });
    }
    
    /**
     * Fügt Tastaturnavigation für die Antwortoptionen hinzu
     * @returns {void}
     */
    function addKeyboardNavigation() {
        if (!currentQuestionContainer) return;
        
        // Event-Listener für Tastatursteuerung
        currentQuestionContainer.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        const target = event.target;
        
        // Prüfen, ob das Event von einer Antwortoption kommt
        if (!target.classList.contains('single-choice-option')) return;
        
        const optionsContainer = currentQuestionContainer.querySelector('.single-choice-options');
        if (!optionsContainer) return;
        
        const options = Array.from(optionsContainer.querySelectorAll('.single-choice-option'));
        const currentIndex = options.indexOf(target);
        let nextIndex = -1;
        
        // Tastatursteuerung
        switch (event.key) {
            case ' ':  // Leertaste
            case 'Enter':
                // Option auswählen
                event.preventDefault();
                selectOption(target);
                break;
                
            case 'ArrowDown':
            case 'ArrowRight':
                // Zur nächsten Option navigieren
                event.preventDefault();
                nextIndex = (currentIndex + 1) % options.length;
                navigateToOption(options[nextIndex]);
                break;
                
            case 'ArrowUp':
            case 'ArrowLeft':
                // Zur vorherigen Option navigieren
                event.preventDefault();
                nextIndex = (currentIndex - 1 + options.length) % options.length;
                navigateToOption(options[nextIndex]);
                break;
                
            case 'Home':
                // Zur ersten Option navigieren
                event.preventDefault();
                navigateToOption(options[0]);
                break;
                
            case 'End':
                // Zur letzten Option navigieren
                event.preventDefault();
                navigateToOption(options[options.length - 1]);
                break;
        }
    }
    
    /**
     * Wählt eine Option aus
     * @param {HTMLElement} optionElement - Das Option-Element
     * @returns {void}
     */
    function selectOption(optionElement) {
        // Simuliere einen Klick auf die Option
        optionElement.click();
        
        // ARIA-Attribute aktualisieren
        updateAriaStatus();
    }
    
    /**
     * Navigiert zu einer bestimmten Option
     * @param {HTMLElement} optionElement - Das Option-Element
     * @returns {void}
     */
    function navigateToOption(optionElement) {
        if (!optionElement) return;
        
        // Fokus auf die Option setzen
        optionElement.focus();
    }
    
    /**
     * Verbessert das Fokus-Management für Tastaturnavigation
     * @returns {void}
     */
    function improveFocusManagement() {
        if (!currentQuestionContainer) return;
        
        // Fokus-Outline für Tastaturbenutzer verbessern
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        
        optionElements.forEach(option => {
            // Nur Fokus-Outline anzeigen, wenn mit Tastatur fokussiert
            option.addEventListener('mousedown', () => {
                option.classList.add('mouse-focus');
            });
            
            option.addEventListener('focusin', () => {
                if (!option.classList.contains('mouse-focus')) {
                    option.classList.add('keyboard-focus');
                }
                option.classList.remove('mouse-focus');
            });
            
            option.addEventListener('focusout', () => {
                option.classList.remove('keyboard-focus');
            });
        });
    }
    
    /**
     * Aktualisiert die ARIA-Attribute nach Statusänderungen
     * @returns {void}
     */
    function updateAriaStatus() {
        if (!currentQuestionContainer) return;
        
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        
        optionElements.forEach(option => {
            const isSelected = option.classList.contains('selected');
            option.setAttribute('aria-checked', isSelected ? 'true' : 'false');
            
            // Wenn ausgewählt, dann focus aktivieren, andere deaktivieren
            option.setAttribute('tabindex', isSelected ? '0' : '-1');
        });
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (currentQuestionContainer) {
            currentQuestionContainer.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        updateAriaStatus,
        cleanup
    };
})();

// IIFE für den Single-Choice-Validator
const SingleChoiceValidator = (function() {
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswer) {
        if (!questionData || userAnswer === null || userAnswer === undefined) {
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'unanswered',
                feedback: 'Die Frage wurde nicht beantwortet.'
            };
        }
        
        const maxScore = questionData.points || 0;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        const isCorrect = questionData.options && 
                          questionData.options[userAnswer] && 
                          questionData.options[userAnswer].isCorrect === true;
        
        const score = isCorrect ? maxScore : 0;
        const status = isCorrect ? 'correct' : 'incorrect';
        
        // Feedback-Text generieren
        let feedback = '';
        if (isCorrect) {
            feedback = 'Ihre Antwort ist korrekt!';
        } else {
            // Die korrekte Antwort ermitteln
            const correctOption = questionData.options.find(option => option.isCorrect);
            const correctAnswerText = correctOption ? correctOption.text : 'Keine korrekte Antwort definiert';
            
            feedback = `Ihre Antwort ist leider falsch. Die richtige Antwort ist: ${correctAnswerText}`;
        }
        
        return {
            score,
            maxScore,
            status,
            feedback,
            isCorrect
        };
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswer) {
        if (userAnswer === null || userAnswer === undefined) {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        const validationResult = validateAnswer(questionData, userAnswer);
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Gesamtergebnis
        reportHtml += `<h4 class="report-heading ${validationResult.status}">`;
        
        if (validationResult.isCorrect) {
            reportHtml += '<i class="fas fa-check-circle"></i> Korrekt';
        } else {
            reportHtml += '<i class="fas fa-times-circle"></i> Falsch';
        }
        
        reportHtml += '</h4>';
        
        // Detaillierte Auflistung der Optionen
        reportHtml += '<div class="options-breakdown">';
        reportHtml += '<h5>Gewählte Antwort:</h5>';
        reportHtml += '<ul>';
        
        if (questionData.options && Array.isArray(questionData.options)) {
            // Die ausgewählte Option anzeigen
            const selectedOption = questionData.options[userAnswer];
            if (selectedOption) {
                const optionClass = selectedOption.isCorrect ? 'correct-selected' : 'incorrect-selected';
                const icon = selectedOption.isCorrect ? 
                    '<i class="fas fa-check-circle"></i>' : 
                    '<i class="fas fa-times-circle"></i>';
                
                reportHtml += `<li class="${optionClass}">
                    ${icon}
                    <span class="option-text">${selectedOption.text}</span>
                    <span class="option-status">
                        Ihre Auswahl (${selectedOption.isCorrect ? 'Korrekt' : 'Falsch'})
                    </span>
                </li>`;
            }
            
            // Die korrekte Option anzeigen, falls die ausgewählte falsch war
            if (!validationResult.isCorrect) {
                reportHtml += '<h5>Korrekte Antwort:</h5>';
                
                const correctOption = questionData.options.find(option => option.isCorrect);
                if (correctOption) {
                    reportHtml += `<li class="correct-not-selected">
                        <i class="fas fa-check-circle"></i>
                        <span class="option-text">${correctOption.text}</span>
                        <span class="option-status">
                            Korrekte Antwort
                        </span>
                    </li>`;
                }
            }
        }
        
        reportHtml += '</ul>';
        reportHtml += '</div>';
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
	/**
 * JS-Block 5.3.1-part2: Fragenanzeige - Single Choice (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Single-Choice-Funktionalität mit Barrierefreiheits-Features,
 * Tastaturunterstützung und Hilfsfunktionen zum Validieren und Navigieren.
 */

// IIFE für den Single-Choice Accessibility-Enhancer
const SingleChoiceAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Single-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastaturnavigation hinzufügen
        addKeyboardNavigation();
        
        // Fokus-Management verbessern
        improveFocusManagement();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Single-Choice-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionsContainer = currentQuestionContainer.querySelector('.single-choice-options');
        if (optionsContainer) {
            optionsContainer.setAttribute('role', 'radiogroup');
            optionsContainer.setAttribute('aria-labelledby', 'question-title');
            
            // Falls ein Titel existiert, diesem eine ID geben
            if (questionText) {
                questionText.id = 'question-title';
            }
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        optionElements.forEach((option, index) => {
            option.setAttribute('role', 'radio');
            option.setAttribute('aria-checked', 'false');
            option.setAttribute('tabindex', '0');
            option.setAttribute('aria-label', `Option ${index + 1}`);
            
            // Text-Inhalt auslesen für vollständiges aria-label
            const optionText = option.querySelector('.option-text');
            if (optionText) {
                option.setAttribute('aria-label', optionText.textContent.trim());
            }
            
            // Prüfen, ob ausgewählt
            if (option.classList.contains('selected')) {
                option.setAttribute('aria-checked', 'true');
                
                // Wenn ausgewählt, dann focus aktivieren, andere deaktivieren
                option.setAttribute('tabindex', '0');
            } else {
                option.setAttribute('tabindex', '-1');
            }
        });
    }
    
    /**
     * Fügt Tastaturnavigation für die Antwortoptionen hinzu
     * @returns {void}
     */
    function addKeyboardNavigation() {
        if (!currentQuestionContainer) return;
        
        // Event-Listener für Tastatursteuerung
        currentQuestionContainer.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        const target = event.target;
        
        // Prüfen, ob das Event von einer Antwortoption kommt
        if (!target.classList.contains('single-choice-option')) return;
        
        const optionsContainer = currentQuestionContainer.querySelector('.single-choice-options');
        if (!optionsContainer) return;
        
        const options = Array.from(optionsContainer.querySelectorAll('.single-choice-option'));
        const currentIndex = options.indexOf(target);
        let nextIndex = -1;
        
        // Tastatursteuerung
        switch (event.key) {
            case ' ':  // Leertaste
            case 'Enter':
                // Option auswählen
                event.preventDefault();
                selectOption(target);
                break;
                
            case 'ArrowDown':
            case 'ArrowRight':
                // Zur nächsten Option navigieren
                event.preventDefault();
                nextIndex = (currentIndex + 1) % options.length;
                navigateToOption(options[nextIndex]);
                break;
                
            case 'ArrowUp':
            case 'ArrowLeft':
                // Zur vorherigen Option navigieren
                event.preventDefault();
                nextIndex = (currentIndex - 1 + options.length) % options.length;
                navigateToOption(options[nextIndex]);
                break;
                
            case 'Home':
                // Zur ersten Option navigieren
                event.preventDefault();
                navigateToOption(options[0]);
                break;
                
            case 'End':
                // Zur letzten Option navigieren
                event.preventDefault();
                navigateToOption(options[options.length - 1]);
                break;
        }
    }
    
    /**
     * Wählt eine Option aus
     * @param {HTMLElement} optionElement - Das Option-Element
     * @returns {void}
     */
    function selectOption(optionElement) {
        // Simuliere einen Klick auf die Option
        optionElement.click();
        
        // ARIA-Attribute aktualisieren
        updateAriaStatus();
    }
    
    /**
     * Navigiert zu einer bestimmten Option
     * @param {HTMLElement} optionElement - Das Option-Element
     * @returns {void}
     */
    function navigateToOption(optionElement) {
        if (!optionElement) return;
        
        // Fokus auf die Option setzen
        optionElement.focus();
    }
    
    /**
     * Verbessert das Fokus-Management für Tastaturnavigation
     * @returns {void}
     */
    function improveFocusManagement() {
        if (!currentQuestionContainer) return;
        
        // Fokus-Outline für Tastaturbenutzer verbessern
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        
        optionElements.forEach(option => {
            // Nur Fokus-Outline anzeigen, wenn mit Tastatur fokussiert
            option.addEventListener('mousedown', () => {
                option.classList.add('mouse-focus');
            });
            
            option.addEventListener('focusin', () => {
                if (!option.classList.contains('mouse-focus')) {
                    option.classList.add('keyboard-focus');
                }
                option.classList.remove('mouse-focus');
            });
            
            option.addEventListener('focusout', () => {
                option.classList.remove('keyboard-focus');
            });
        });
    }
    
    /**
     * Aktualisiert die ARIA-Attribute nach Statusänderungen
     * @returns {void}
     */
    function updateAriaStatus() {
        if (!currentQuestionContainer) return;
        
        const optionElements = currentQuestionContainer.querySelectorAll('.single-choice-option');
        
        optionElements.forEach(option => {
            const isSelected = option.classList.contains('selected');
            option.setAttribute('aria-checked', isSelected ? 'true' : 'false');
            
            // Wenn ausgewählt, dann focus aktivieren, andere deaktivieren
            option.setAttribute('tabindex', isSelected ? '0' : '-1');
        });
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (currentQuestionContainer) {
            currentQuestionContainer.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        updateAriaStatus,
        cleanup
    };
})();

// IIFE für den Single-Choice-Validator
const SingleChoiceValidator = (function() {
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswer) {
        if (!questionData || userAnswer === null || userAnswer === undefined) {
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'unanswered',
                feedback: 'Die Frage wurde nicht beantwortet.'
            };
        }
        
        const maxScore = questionData.points || 0;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        const isCorrect = questionData.options && 
                          questionData.options[userAnswer] && 
                          questionData.options[userAnswer].isCorrect === true;
        
        const score = isCorrect ? maxScore : 0;
        const status = isCorrect ? 'correct' : 'incorrect';
        
        // Feedback-Text generieren
        let feedback = '';
        if (isCorrect) {
            feedback = 'Ihre Antwort ist korrekt!';
        } else {
            // Die korrekte Antwort ermitteln
            const correctOption = questionData.options.find(option => option.isCorrect);
            const correctAnswerText = correctOption ? correctOption.text : 'Keine korrekte Antwort definiert';
            
            feedback = `Ihre Antwort ist leider falsch. Die richtige Antwort ist: ${correctAnswerText}`;
        }
        
        return {
            score,
            maxScore,
            status,
            feedback,
            isCorrect
        };
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswer) {
        if (userAnswer === null || userAnswer === undefined) {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        const validationResult = validateAnswer(questionData, userAnswer);
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Gesamtergebnis
        reportHtml += `<h4 class="report-heading ${validationResult.status}">`;
        
        if (validationResult.isCorrect) {
            reportHtml += '<i class="fas fa-check-circle"></i> Korrekt';
        } else {
            reportHtml += '<i class="fas fa-times-circle"></i> Falsch';
        }
        
        reportHtml += '</h4>';
        
        // Detaillierte Auflistung der Optionen
        reportHtml += '<div class="options-breakdown">';
        reportHtml += '<h5>Gewählte Antwort:</h5>';
        reportHtml += '<ul>';
        
        if (questionData.options && Array.isArray(questionData.options)) {
            // Die ausgewählte Option anzeigen
            const selectedOption = questionData.options[userAnswer];
            if (selectedOption) {
                const optionClass = selectedOption.isCorrect ? 'correct-selected' : 'incorrect-selected';
                const icon = selectedOption.isCorrect ? 
                    '<i class="fas fa-check-circle"></i>' : 
                    '<i class="fas fa-times-circle"></i>';
                
                reportHtml += `<li class="${optionClass}">
                    ${icon}
                    <span class="option-text">${selectedOption.text}</span>
                    <span class="option-status">
                        Ihre Auswahl (${selectedOption.isCorrect ? 'Korrekt' : 'Falsch'})
                    </span>
                </li>`;
            }
            
            // Die korrekte Option anzeigen, falls die ausgewählte falsch war
            if (!validationResult.isCorrect) {
                reportHtml += '<h5>Korrekte Antwort:</h5>';
                
                const correctOption = questionData.options.find(option => option.isCorrect);
                if (correctOption) {
                    reportHtml += `<li class="correct-not-selected">
                        <i class="fas fa-check-circle"></i>
                        <span class="option-text">${correctOption.text}</span>
                        <span class="option-status">
                            Korrekte Antwort
                        </span>
                    </li>`;
                }
            }
        }
        
        reportHtml += '</ul>';
        reportHtml += '</div>';
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
    
    /**
     * Bestimmt, ob eine Frage überhaupt beantwortet wurde
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isQuestionAnswered(userAnswer) {
        return userAnswer !== null && userAnswer !== undefined;
    }
    
    // Öffentliche API
    return {
        validateAnswer,
        generateDetailedReport,
        isQuestionAnswered
    };
})();

// IIFE für den Single-Choice-Feedback-Handler
const SingleChoiceFeedbackHandler = (function() {
    // Private Variablen
    let currentQuestionContainer = null;
    let currentQuestionData = null;
    let feedbackContainer = null;
    let feedbackEnabled = true;
    let instantFeedbackEnabled = false;
    let animationEnabled = true;
    
    /**
     * Initialisiert den Feedback-Handler für eine Single-Choice-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @param {Object} questionData - Die Fragendaten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function initialize(container, questionData, options = {}) {
        if (!container || !questionData) {
            console.error('SingleChoiceFeedbackHandler: Fehlende Container- oder Fragedaten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionContainer = container;
        currentQuestionData = questionData;
        
        // Konfigurationsoptionen übernehmen
        feedbackEnabled = options.feedbackEnabled !== undefined ? 
            options.feedbackEnabled : true;
        instantFeedbackEnabled = options.instantFeedbackEnabled !== undefined ? 
            options.instantFeedbackEnabled : false;
        animationEnabled = options.animationEnabled !== undefined ? 
            options.animationEnabled : true;
        
        // Feedback-Container erstellen, falls nicht vorhanden
        createFeedbackContainer();
        
        // Event-Listener für Antwortänderungen hinzufügen
        if (instantFeedbackEnabled) {
            addAnswerChangeListener();
        }
    }
    
    /**
     * Erstellt den Container für Feedback-Nachrichten
     * @returns {void}
     */
    function createFeedbackContainer() {
        if (!currentQuestionContainer) return;
        
        // Prüfen, ob bereits ein Feedback-Container existiert
        let existingContainer = currentQuestionContainer.querySelector('.feedback-container');
        
        if (existingContainer) {
            feedbackContainer = existingContainer;
            return;
        }
        
        // Neuen Feedback-Container erstellen
        feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';
        feedbackContainer.style.display = 'none';
        
        // Zum Frage-Container hinzufügen, nach den Antwortoptionen
        const optionsContainer = currentQuestionContainer.querySelector('.answer-options');
        
        if (optionsContainer) {
            optionsContainer.insertAdjacentElement('afterend', feedbackContainer);
        } else {
            currentQuestionContainer.appendChild(feedbackContainer);
        }
    }
    
    /**
     * Fügt einen Event-Listener für Antwortänderungen hinzu (für sofortiges Feedback)
     * @returns {void}
     */
    function addAnswerChangeListener() {
        if (!currentQuestionData) return;
        
        document.addEventListener('answerUpdated', function(event) {
            if (event.detail && event.detail.questionId === currentQuestionData.id) {
                // Sofortiges Feedback anzeigen, wenn aktiviert
                if (instantFeedbackEnabled && feedbackEnabled) {
                    const userAnswer = event.detail.answer;
                    
                    if (userAnswer !== null && userAnswer !== undefined) {
                        provideFeedback(userAnswer);
                    }
                }
            }
        });
    }
    
    /**
     * Zeigt Feedback zur Benutzerantwort an
     * @param {number} userAnswer - Der vom Benutzer ausgewählte Antwortindex
     * @returns {void}
     */
    function provideFeedback(userAnswer) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Feedback über den Validator generieren
        if (typeof SingleChoiceValidator === 'undefined') {
            console.error('SingleChoiceFeedbackHandler: Validator nicht gefunden');
            return;
        }
        
        const validationResult = SingleChoiceValidator.validateAnswer(
            currentQuestionData, 
            userAnswer
        );
        
        displayFeedback(validationResult);
    }
    
    /**
     * Zeigt das Validierungsergebnis als Feedback an
     * @param {Object} validationResult - Das Validierungsergebnis
     * @returns {void}
     */
    function displayFeedback(validationResult) {
        if (!feedbackContainer) return;
        
        // Feedback-Container leeren
        feedbackContainer.innerHTML = '';
        
        // Feedback-Element erstellen
        const feedbackElement = document.createElement('div');
        feedbackElement.className = `feedback-message ${validationResult.status}`;
        
        // Icon hinzufügen
        const iconElement = document.createElement('i');
        
        switch (validationResult.status) {
            case 'correct':
                iconElement.className = 'fas fa-check-circle';
                break;
                
            case 'incorrect':
                iconElement.className = 'fas fa-times-circle';
                break;
                
            default:
                iconElement.className = 'fas fa-info-circle';
        }
        
        feedbackElement.appendChild(iconElement);
        
        // Textuelle Rückmeldung hinzufügen
        const textElement = document.createElement('span');
        textElement.textContent = validationResult.feedback;
        feedbackElement.appendChild(textElement);
        
        // Punktzahl anzeigen, falls verfügbar
        if (validationResult.score !== undefined && validationResult.maxScore !== undefined) {
            const scoreElement = document.createElement('div');
            scoreElement.className = 'feedback-score';
            scoreElement.textContent = `Punktzahl: ${validationResult.score} / ${validationResult.maxScore}`;
            feedbackElement.appendChild(scoreElement);
        }
        
        // Zum Container hinzufügen
        feedbackContainer.appendChild(feedbackElement);
        
        // Container anzeigen
        feedbackContainer.style.display = 'block';
        
        // Animation hinzufügen, falls aktiviert
        if (animationEnabled) {
            feedbackElement.classList.add('animated');
            feedbackElement.classList.add('fadeIn');
            
            // Animation nach 5 Sekunden entfernen
            setTimeout(() => {
                feedbackElement.classList.remove('animated');
                feedbackElement.classList.remove('fadeIn');
            }, 5000);
        }
        
        // Bei korrekter Antwort eine Erfolgsanimation abspielen
        if (validationResult.status === 'correct' && typeof SingleChoiceGamificationEnhancer !== 'undefined') {
            SingleChoiceGamificationEnhancer.playSuccessAnimation(currentQuestionContainer);
        }
    }
    
    // Öffentliche API
    return {
        initialize,
        provideFeedback
    };
})();

// Verbindung mit dem SingleChoiceQuestionHandler herstellen
document.addEventListener('DOMContentLoaded', function() {
    // Event-Listener für Frage-Initialisierung
    document.addEventListener('questionRendered', function(event) {
        if (event.detail && event.detail.type === 'single-choice' && event.detail.container) {
            // Barrierefreiheit verbessern
            SingleChoiceAccessibilityEnhancer.enhanceAccessibility(event.detail.container);
        }
    });
    
    // Event-Listener für Antwortänderungen
    document.addEventListener('answerUpdated', function(event) {
        if (event.detail && event.detail.answerType === 'single-choice') {
            // ARIA-Attribute aktualisieren
            SingleChoiceAccessibilityEnhancer.updateAriaStatus();
        }
    });
    
    // Nur registrieren, wenn das globale Registry-Objekt existiert
    if (typeof ValidationRegistry !== 'undefined') {
        ValidationRegistry.registerValidator('single-choice', SingleChoiceValidator);
    }
    
    // Feedback-Handler registrieren
    if (typeof FeedbackRegistry === 'undefined') {
        window.FeedbackRegistry = {};
    }
    
    FeedbackRegistry.SingleChoice = {
        feedbackHandler: SingleChoiceFeedbackHandler
    };
});

// CSS-Stile für Tastaturnavigation
(function addKeyboardNavigationStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .single-choice-option {
            position: relative;
            transition: all 0.2s ease;
        }
        
        .single-choice-option:focus {
            outline: none;
        }
        
        .single-choice-option.keyboard-focus {
            box-shadow: 0 0 0 2px #00FFD0;
            border-radius: 4px;
        }
        
        /* Detailed Report Styling */
        .detailed-answer-report {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .report-heading {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .report-heading i {
            margin-right: 10px;
        }
        
        .report-heading.correct {
            color: #28a745;
        }
        
        .report-heading.incorrect {
            color: #dc3545;
        }
        
        .options-breakdown ul {
            list-style-type: none;
            padding-left: 0;
        }
        
        .options-breakdown li {
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        
        .options-breakdown li i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        
        .options-breakdown li.correct-selected {
            background-color: rgba(40, 167, 69, 0.2);
            border-left: 3px solid #28a745;
        }
        
        .options-breakdown li.correct-not-selected {
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 3px solid #28a745;
        }
        
        .options-breakdown li.incorrect-selected {
            background-color: rgba(220, 53, 69, 0.2);
            border-left: 3px solid #dc3545;
        }
        
        .option-text {
            flex-grow: 1;
        }
        
        .option-status {
            font-size: 0.85em;
            color: #6c757d;
            margin-left: 10px;
        }
        
        .report-not-answered {
            color: #6c757d;
            font-style: italic;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.4.1-part1: Fragenanzeige - Wahr/Falsch (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Wahr/Falsch-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Wahr/Falsch-Fragenmoduls
const TrueFalseQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswer = null; // true für "Wahr", false für "Falsch", null für keine Auswahl
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    // Texte für die Antwortoptionen
    const TRUE_TEXT = 'Wahr';
    const FALSE_TEXT = 'Falsch';
    
    /**
     * Initialisiert die Anzeige einer Wahr/Falsch-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('TrueFalseQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Wahr/Falsch-Fragetyp arbeiten
        if (questionData.type !== 'true-false') {
            console.error('TrueFalseQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined) {
            selectedAnswer = sessionAnswer;
        } else {
            selectedAnswer = null;
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Wahr/Falsch-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content true-false-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Wahr/Falsch hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Ist diese Aussage wahr oder falsch?';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options true-false-options';
        
        // Wahr-Option erstellen
        const trueOption = createAnswerOption(TRUE_TEXT, true);
        optionsContainer.appendChild(trueOption);
        
        // Falsch-Option erstellen
        const falseOption = createAnswerOption(FALSE_TEXT, false);
        optionsContainer.appendChild(falseOption);
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekte Antwort anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antwort markieren
        updateSelectedAnswerUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {string} text - Der Text der Option
     * @param {boolean} value - Der Wahrheitswert der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(text, value) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option true-false-option';
        optionElement.dataset.value = value.toString();
        
        // Icon-Container für bessere Styling-Möglichkeiten
        const iconContainer = document.createElement('div');
        iconContainer.className = 'option-icon-container';
        
        // Icon basierend auf dem Wert
        const icon = document.createElement('i');
        icon.className = `fas ${value ? 'fa-check' : 'fa-times'}`;
        iconContainer.appendChild(icon);
        
        optionElement.appendChild(iconContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerText = text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Die korrekte Antwort ermitteln
        const correctAnswer = currentQuestionData.correctAnswer === true;
        const correctAnswerText = correctAnswer ? TRUE_TEXT : FALSE_TEXT;
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekte Antwort ist: <strong>${correctAnswerText}</strong></p>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (selectedAnswer === null || !currentQuestionData) return false;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        return selectedAnswer === currentQuestionData.correctAnswer;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('true-false-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.value) return;
        
        // String "true"/"false" in Boolean umwandeln
        const value = optionElement.dataset.value === 'true';
        
        // Antwort umschalten
        selectAnswer(value);
        
        // UI aktualisieren
        updateSelectedAnswerUI();
        
        // Antwort im TestSessionManager speichern
        saveAnswer();
    }
	/**
 * JS-Block 5.4.1-part1: Fragenanzeige - Wahr/Falsch (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Wahr/Falsch-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Benutzerinteraktionen
 * und bietet visuelle Rückmeldung über den Auswahlstatus.
 */

// IIFE für die Kapselung des Wahr/Falsch-Fragenmoduls
const TrueFalseQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let selectedAnswer = null; // true für "Wahr", false für "Falsch", null für keine Auswahl
    let questionContainer = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    
    // Texte für die Antwortoptionen
    const TRUE_TEXT = 'Wahr';
    const FALSE_TEXT = 'Falsch';
    
    /**
     * Initialisiert die Anzeige einer Wahr/Falsch-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false) {
        if (!questionData || !container) {
            console.error('TrueFalseQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Sicherstellen, dass wir mit einem Wahr/Falsch-Fragetyp arbeiten
        if (questionData.type !== 'true-false') {
            console.error('TrueFalseQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined) {
            selectedAnswer = sessionAnswer;
        } else {
            selectedAnswer = null;
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Wahr/Falsch-Frage mit ihren Antwortoptionen
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content true-false-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Wahr/Falsch hinzufügen
        const selectionHint = document.createElement('p');
        selectionHint.className = 'selection-hint';
        selectionHint.innerHTML = 'Ist diese Aussage wahr oder falsch?';
        
        questionText.appendChild(selectionHint);
        questionElement.appendChild(questionText);
        
        // Antwortoptionen-Container
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'answer-options true-false-options';
        
        // Wahr-Option erstellen
        const trueOption = createAnswerOption(TRUE_TEXT, true);
        optionsContainer.appendChild(trueOption);
        
        // Falsch-Option erstellen
        const falseOption = createAnswerOption(FALSE_TEXT, false);
        optionsContainer.appendChild(falseOption);
        
        questionElement.appendChild(optionsContainer);
        
        // Im Review-Modus die korrekte Antwort anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // Ausgewählte Antwort markieren
        updateSelectedAnswerUI();
    }
    
    /**
     * Erstellt ein Element für eine Antwortoption
     * @param {string} text - Der Text der Option
     * @param {boolean} value - Der Wahrheitswert der Option
     * @returns {HTMLElement} Das erzeugte Antwortoption-Element
     */
    function createAnswerOption(text, value) {
        const optionElement = document.createElement('div');
        optionElement.className = 'answer-option true-false-option';
        optionElement.dataset.value = value.toString();
        
        // Icon-Container für bessere Styling-Möglichkeiten
        const iconContainer = document.createElement('div');
        iconContainer.className = 'option-icon-container';
        
        // Icon basierend auf dem Wert
        const icon = document.createElement('i');
        icon.className = `fas ${value ? 'fa-check' : 'fa-times'}`;
        iconContainer.appendChild(icon);
        
        optionElement.appendChild(iconContainer);
        
        // Text-Container
        const textContainer = document.createElement('div');
        textContainer.className = 'option-text';
        textContainer.innerText = text;
        optionElement.appendChild(textContainer);
        
        return optionElement;
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Die korrekte Antwort ermitteln
        const correctAnswer = currentQuestionData.correctAnswer === true;
        const correctAnswerText = correctAnswer ? TRUE_TEXT : FALSE_TEXT;
        
        // Berechnen, ob die Antwort des Benutzers korrekt war
        const userCorrect = checkIfUserAnswerIsCorrect();
        
        feedbackElement.innerHTML = `
            <div class="feedback-header ${userCorrect ? 'correct' : 'incorrect'}">
                <i class="fas ${userCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                <h4>${userCorrect ? 'Korrekt beantwortet' : 'Falsch beantwortet'}</h4>
            </div>
            <div class="feedback-details">
                <p>Die korrekte Antwort ist: <strong>${correctAnswerText}</strong></p>
            </div>
        `;
        
        return feedbackElement;
    }
    
    /**
     * Überprüft, ob die Benutzerantwort korrekt ist
     * @returns {boolean} Ob die Antwort korrekt ist
     */
    function checkIfUserAnswerIsCorrect() {
        if (selectedAnswer === null || !currentQuestionData) return false;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        return selectedAnswer === currentQuestionData.correctAnswer;
    }
    
    /**
     * Event-Listener für die Antwortoptionen hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!questionContainer) return;
        
        // Event-Delegation für Antwortoptionen
        const optionsContainer = questionContainer.querySelector('.answer-options');
        if (optionsContainer) {
            optionsContainer.addEventListener('click', handleOptionClick);
        }
    }
    
    /**
     * Handler für Klicks auf Antwortoptionen
     * @param {Event} event - Das Klick-Event
     * @returns {void}
     */
    function handleOptionClick(event) {
        if (userAnswersLocked) return;
        
        // Den geklickten Option-Container finden
        let optionElement = event.target;
        while (optionElement && !optionElement.classList.contains('true-false-option')) {
            optionElement = optionElement.parentElement;
            if (optionElement === null || optionElement === questionContainer) {
                return; // Kein passendes Element gefunden
            }
        }
        
        if (!optionElement || !optionElement.dataset.value) return;
        
        // String "true"/"false" in Boolean umwandeln
        const value = optionElement.dataset.value === 'true';
        
        // Antwort umschalten
        selectAnswer(value);
        
        // UI aktualisieren
        updateSelectedAnswerUI();
        
        // Antwort im TestSessionManager speichern
        saveAnswer();
    }
    
    /**
     * Wählt eine Antwort aus
     * @param {boolean} value - Der Wahrheitswert der Antwort
     * @returns {void}
     */
    function selectAnswer(value) {
        selectedAnswer = value;
    }
    
    /**
     * Aktualisiert die Benutzeroberfläche basierend auf der ausgewählten Antwort
     * @returns {void}
     */
    function updateSelectedAnswerUI() {
        if (!questionContainer) return;
        
        // Alle Optionselemente durchgehen
        const trueOption = questionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = questionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (trueOption && falseOption) {
            // Auswahlstatus aktualisieren
            if (selectedAnswer === true) {
                trueOption.classList.add('selected');
                falseOption.classList.remove('selected');
            } else if (selectedAnswer === false) {
                trueOption.classList.remove('selected');
                falseOption.classList.add('selected');
            } else {
                // Keine Auswahl
                trueOption.classList.remove('selected');
                falseOption.classList.remove('selected');
            }
            
            // Im Review-Modus zusätzliches Styling für richtige/falsche Antworten
            if (isReviewMode && currentQuestionData) {
                const correctAnswer = currentQuestionData.correctAnswer === true;
                
                // Richtige Antwort markieren
                if (correctAnswer) {
                    trueOption.classList.add('correct-answer');
                    
                    // Falsch ausgewählte Option markieren
                    if (selectedAnswer === false) {
                        falseOption.classList.add('incorrect-answer');
                    }
                } else {
                    falseOption.classList.add('correct-answer');
                    
                    // Falsch ausgewählte Option markieren
                    if (selectedAnswer === true) {
                        trueOption.classList.add('incorrect-answer');
                    }
                }
            }
        }
    }
    
    /**
     * Speichert die ausgewählte Antwort in der Testsitzung
     * @returns {void}
     */
    function saveAnswer() {
        if (!currentQuestionData || !currentQuestionData.id) return;
        
        TestSessionManager.saveQuestionAnswer(
            currentQuestionData.id,
            selectedAnswer
        );
        
        // Event auslösen, um andere Komponenten über die Antwortänderung zu informieren
        const event = new CustomEvent('answerUpdated', {
            detail: {
                questionId: currentQuestionData.id,
                answer: selectedAnswer,
                answerType: 'true-false'
            }
        });
        document.dispatchEvent(event);
    }
    
    /**
     * Aktualisiert die Antwortauswahl basierend auf dem übergebenen Wert
     * @param {boolean} answer - Der Wahrheitswert der Antwort
     * @returns {void}
     */
    function updateSelectedAnswer(answer) {
        if (typeof answer !== 'boolean') return;
        
        selectedAnswer = answer;
        updateSelectedAnswerUI();
    }
    
    /**
     * Sperrt die Benutzerinteraktion mit der Frage
     * @param {boolean} lock - Ob die Interaktion gesperrt werden soll
     * @returns {void}
     */
    function lockAnswers(lock = true) {
        userAnswersLocked = lock;
        
        // Visuelles Feedback für gesperrten Zustand
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                if (lock) {
                    optionsContainer.classList.add('locked');
                } else {
                    optionsContainer.classList.remove('locked');
                }
            }
        }
    }
    
    /**
     * Aktiviert den Review-Modus, um korrekte Antworten anzuzeigen
     * @param {boolean} enable - Ob der Review-Modus aktiviert werden soll
     * @returns {void}
     */
    function enableReviewMode(enable = true) {
        if (isReviewMode === enable) return; // Keine Änderung nötig
        
        isReviewMode = enable;
        
        // Neu rendern, wenn sich der Modus ändert
        renderQuestion();
    }
    
    /**
     * Prüft, ob die aktuelle Frage beantwortet wurde
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isAnswered() {
        return selectedAnswer !== null;
    }
    
    /**
     * Gibt die Auswahl des Benutzers zurück
     * @returns {boolean|null} Der ausgewählte Wahrheitswert oder null, wenn keine Auswahl
     */
    function getSelectedAnswer() {
        return selectedAnswer;
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (questionContainer) {
            const optionsContainer = questionContainer.querySelector('.answer-options');
            if (optionsContainer) {
                optionsContainer.removeEventListener('click', handleOptionClick);
            }
        }
        
        // Referenzen zurücksetzen
        currentQuestionData = null;
        selectedAnswer = null;
        questionContainer = null;
    }
    
    // Öffentliche API
    return {
        initializeQuestion,
        updateSelectedAnswer,
        lockAnswers,
        enableReviewMode,
        isAnswered,
        getSelectedAnswer,
        cleanup
    };
})();

// Module registrieren
if (typeof QuestionHandlerRegistry !== 'undefined') {
    QuestionHandlerRegistry.registerHandler('true-false', TrueFalseQuestionHandler);
}

// CSS-Stile für Wahr/Falsch-Fragen
(function addTrueFalseStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* True/False Optionen Container */
        .true-false-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        /* True/False Option */
        .true-false-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            width: 140px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .true-false-option:hover {
            background-color: #e9ecef;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        /* Styling für "Wahr" Option */
        .true-false-option[data-value="true"] {
            border-color: #28a745;
        }
        
        .true-false-option[data-value="true"] .option-icon-container {
            color: #28a745;
        }
        
        /* Styling für "Falsch" Option */
        .true-false-option[data-value="false"] {
            border-color: #dc3545;
        }
        
        .true-false-option[data-value="false"] .option-icon-container {
            color: #dc3545;
        }
        
        /* Icon Container */
        .option-icon-container {
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        /* Ausgewählte Option */
        .true-false-option.selected {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .true-false-option[data-value="true"].selected {
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .true-false-option[data-value="false"].selected {
            background-color: rgba(220, 53, 69, 0.1);
        }
        
        /* Korrekte/Falsche Antwort im Review-Modus */
        .true-false-option.correct-answer {
            background-color: rgba(40, 167, 69, 0.2) !important;
            border-color: #28a745 !important;
            position: relative;
        }
        
        .true-false-option.correct-answer::after {
            content: '✓';
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #28a745;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        
        .true-false-option.incorrect-answer {
            background-color: rgba(220, 53, 69, 0.2) !important;
            border-color: #dc3545 !important;
            position: relative;
        }
        
        .true-false-option.incorrect-answer::after {
            content: '✗';
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #dc3545;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* Gesperrter Zustand */
        .answer-options.locked .true-false-option {
            opacity: 0.7;
            pointer-events: none;
            transform: none;
            box-shadow: none;
        }
        
        /* Feedback-Darstellung */
        .question-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        /* Responsive Design für kleinere Bildschirme */
        @media (max-width: 576px) {
            .true-false-options {
                flex-direction: column;
                align-items: center;
            }
            
            .true-false-option {
                width: 100%;
                max-width: 200px;
                margin-bottom: 10px;
            }
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.4.1-part2: Fragenanzeige - Wahr/Falsch (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Wahr/Falsch-Funktionalität mit Barrierefreiheits-Features,
 * Tastaturunterstützung, Validierung und Feedback-Mechanismen.
 */

// IIFE für den Wahr/Falsch Accessibility-Enhancer
const TrueFalseAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Wahr/Falsch-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastaturnavigation hinzufügen
        addKeyboardNavigation();
        
        // Fokus-Management verbessern
        improveFocusManagement();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Wahr/Falsch-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionsContainer = currentQuestionContainer.querySelector('.true-false-options');
        if (optionsContainer) {
            optionsContainer.setAttribute('role', 'radiogroup');
            optionsContainer.setAttribute('aria-labelledby', 'question-title');
            
            // Falls ein Titel existiert, diesem eine ID geben
            if (questionText) {
                questionText.id = 'question-title';
            }
        }
        
        // Optionen mit ARIA-Attributen versehen
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (trueOption) {
            trueOption.setAttribute('role', 'radio');
            trueOption.setAttribute('aria-checked', 'false');
            trueOption.setAttribute('tabindex', '0');
            trueOption.setAttribute('aria-label', 'Wahr');
        }
        
        if (falseOption) {
            falseOption.setAttribute('role', 'radio');
            falseOption.setAttribute('aria-checked', 'false');
            falseOption.setAttribute('tabindex', '0');
            falseOption.setAttribute('aria-label', 'Falsch');
        }
        
        // Prüfen, ob bereits eine Auswahl getroffen wurde
        updateAriaStatus();
    }
    
    /**
     * Aktualisiert die ARIA-Attribute nach Statusänderungen
     * @returns {void}
     */
    function updateAriaStatus() {
        if (!currentQuestionContainer) return;
        
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (trueOption && falseOption) {
            const isTrueSelected = trueOption.classList.contains('selected');
            const isFalseSelected = falseOption.classList.contains('selected');
            
            trueOption.setAttribute('aria-checked', isTrueSelected ? 'true' : 'false');
            falseOption.setAttribute('aria-checked', isFalseSelected ? 'true' : 'false');
        }
    }
    
    /**
     * Fügt Tastaturnavigation für die Antwortoptionen hinzu
     * @returns {void}
     */
    function addKeyboardNavigation() {
        if (!currentQuestionContainer) return;
        
        // Event-Listener für Tastatursteuerung
        currentQuestionContainer.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        const target = event.target;
        
        // Prüfen, ob das Event von einer Antwortoption kommt
        if (!target.classList.contains('true-false-option')) return;
        
        const optionsContainer = currentQuestionContainer.querySelector('.true-false-options');
        if (!optionsContainer) return;
        
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (!trueOption || !falseOption) return;
        
        // Tastatursteuerung
        switch (event.key) {
            case ' ':  // Leertaste
            case 'Enter':
                // Option auswählen
                event.preventDefault();
                target.click();
                break;
                
            case 'ArrowRight':
            case 'ArrowDown':
                // Zur nächsten Option navigieren
                event.preventDefault();
                if (target === trueOption) {
                    falseOption.focus();
                } else {
                    trueOption.focus();
                }
                break;
                
            case 'ArrowLeft':
            case 'ArrowUp':
                // Zur vorherigen Option navigieren
                event.preventDefault();
                if (target === trueOption) {
                    falseOption.focus();
                } else {
                    trueOption.focus();
                }
                break;
                
            case 'Home':
                // Zur ersten Option navigieren
                event.preventDefault();
                trueOption.focus();
                break;
                
            case 'End':
                // Zur letzten Option navigieren
                event.preventDefault();
                falseOption.focus();
                break;
                
            case 'T':
            case 't':
                // Shortcut für "True"
                event.preventDefault();
                trueOption.click();
                break;
                
            case 'F':
            case 'f':
                // Shortcut für "False"
                event.preventDefault();
                falseOption.click();
                break;
        }
    }
    
    /**
     * Verbessert das Fokus-Management für Tastaturnavigation
     * @returns {void}
     */
    function improveFocusManagement() {
        if (!currentQuestionContainer) return;
        
        // Fokus-Styling für Tastaturbenutzer verbessern
        const optionElements = currentQuestionContainer.querySelectorAll('.true-false-option');
        
        optionElements.forEach(option => {
            // Nur Fokus-Outline anzeigen, wenn mit Tastatur fokussiert
            option.addEventListener('mousedown', () => {
                option.classList.add('mouse-focus');
            });
            
            option.addEventListener('focusin', () => {
                if (!option.classList.contains('mouse-focus')) {
                    option.classList.add('keyboard-focus');
                }
                option.classList.remove('mouse-focus');
            });
            
            option.addEventListener('focusout', () => {
                option.classList.remove('keyboard-focus');
            });
        });
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (currentQuestionContainer) {
            currentQuestionContainer.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        updateAriaStatus,
        cleanup
    };
})();

// IIFE für den Wahr/Falsch-Validator
const TrueFalseValidator = (function() {
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswer) {
        if (!questionData || userAnswer === null || userAnswer === undefined) {
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'unanswered',
                feedback: 'Die Frage wurde nicht beantwortet.'
            };
        }
        
        const maxScore = questionData.points || 0;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        const isCorrect = userAnswer === questionData.correctAnswer;
        
        const score = isCorrect ? maxScore : 0;
        const status = isCorrect ? 'correct' : 'incorrect';
        
        // Feedback-Text generieren
        let feedback = '';
        if (isCorrect) {
            feedback = 'Ihre Antwort ist korrekt!';
        } else {
            const correctText = questionData.correctAnswer ? 'Wahr' : 'Falsch';
            feedback = `Ihre Antwort ist leider falsch. Die richtige Antwort ist: ${correctText}`;
        }
        
        return {
            score,
            maxScore,
            status,
            feedback,
            isCorrect
        };
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswer) {
        if (userAnswer === null || userAnswer === undefined) {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        const validationResult = validateAnswer(questionData, userAnswer);
        const userAnswerText = userAnswer ? 'Wahr' : 'Falsch';
        const correctAnswerText = questionData.correctAnswer ? 'Wahr' : 'Falsch';
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Gesamtergebnis
        reportHtml += `<h4 class="report-heading ${validationResult.status}">`;
        
        if (validationResult.isCorrect) {
            reportHtml += '<i class="fas fa-check-circle"></i> Korrekt';
        } else {
            reportHtml += '<i class="fas fa-times-circle"></i> Falsch';
        }
        
        reportHtml += '</h4>';
        
        // Detaillierte Auflistung
        reportHtml += '<div class="answer-details">';
        reportHtml += `<p>Ihre Antwort: <strong>${userAnswerText}</strong></p>`;
        
        if (!validationResult.isCorrect) {
            reportHtml += `<p>Korrekte Antwort: <strong>${correctAnswerText}</strong></p>`;
        }
        
        reportHtml += '</div>';
        
        // Falls es eine Erklärung gibt, diese anzeigen
        if (questionData.explanation) {
            reportHtml += `
                <div class="question-explanation">
                    <h5>Erklärung:</h5>
                    <p>${questionData.explanation}</p>
                </div>
            `;
        }
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
    
    /**
     * Bestimmt, ob eine Frage überhaupt beantwortet wurde
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isQuestionAnswered(userAnswer) {
        return userAnswer === true || userAnswer === false;
    }
    
    // Öffentliche API
    return {
        validateAnswer,
        generateDetailedReport,
        isQuestionAnswered
    };
})();

// IIFE für den Wahr/Falsch-Feedback-Handler
const TrueFalseFeedbackHandler = (function() {
    // Private Variablen
    let currentQuestionContainer = null;
    let currentQuestionData = null;
    let feedbackContainer = null;
    let feedbackEnabled = true;
    let instantFeedbackEnabled = false;
    let animationEnabled = true;
    
    /**
     * Initialisiert den Feedback-Handler für eine Wahr/Falsch-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @param {Object} questionData - Die Fragendaten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function initialize(container, questionData, options = {}) {
        if (!container || !questionData) {
            console.error('TrueFalseFeedbackHandler: Fehlende Container- oder Fragedaten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionContainer = container;
        currentQuestionData = questionData;
        
        // Konfigurationsoptionen übernehmen
        feedbackEnabled = options.feedbackEnabled !== undefined ? 
            options.feedbackEnabled : true;
        instantFeedbackEnabled = options.instantFeedbackEnabled !== undefined ? 
            options.instantFeedbackEnabled : false;
        animationEnabled = options.animationEnabled !== undefined ? 
            options.animationEnabled : true;
        
        // Feedback-Container erstellen, falls nicht vorhanden
        createFeedbackContainer();
        
        // Event-Listener für Antwortänderungen hinzufügen
        if (instantFeedbackEnabled) {
            addAnswerChangeListener();
        }
    }
    
    /**
     * Erstellt den Container für Feedback-Nachrichten
     * @returns {void}
     */
    function createFeedbackContainer() {
        if (!currentQuestionContainer) return;
        
        // Prüfen, ob bereits ein Feedback-Container existiert
        let existingContainer = currentQuestionContainer.querySelector('.feedback-container');
        
        if (existingContainer) {
            feedbackContainer = existingContainer;
            return;
        }
        
        // Neuen Feedback-Container erstellen
        feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';
        feedbackContainer.style.display = 'none';
        
        // Zum Frage-Container hinzufügen, nach den Antwortoptionen
        const optionsContainer = currentQuestionContainer.querySelector('.answer-options');
        
        if (optionsContainer) {
            optionsContainer.insertAdjacentElement('afterend', feedbackContainer);
        } else {
            currentQuestionContainer.appendChild(feedbackContainer);
        }
    }
	/**
 * JS-Block 5.4.1-part2: Fragenanzeige - Wahr/Falsch (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Wahr/Falsch-Funktionalität mit Barrierefreiheits-Features,
 * Tastaturunterstützung, Validierung und Feedback-Mechanismen.
 */

// IIFE für den Wahr/Falsch Accessibility-Enhancer
const TrueFalseAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Wahr/Falsch-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastaturnavigation hinzufügen
        addKeyboardNavigation();
        
        // Fokus-Management verbessern
        improveFocusManagement();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Wahr/Falsch-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Antwortoptionen als Radiobuttons markieren
        const optionsContainer = currentQuestionContainer.querySelector('.true-false-options');
        if (optionsContainer) {
            optionsContainer.setAttribute('role', 'radiogroup');
            optionsContainer.setAttribute('aria-labelledby', 'question-title');
            
            // Falls ein Titel existiert, diesem eine ID geben
            if (questionText) {
                questionText.id = 'question-title';
            }
        }
        
        // Optionen mit ARIA-Attributen versehen
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (trueOption) {
            trueOption.setAttribute('role', 'radio');
            trueOption.setAttribute('aria-checked', 'false');
            trueOption.setAttribute('tabindex', '0');
            trueOption.setAttribute('aria-label', 'Wahr');
        }
        
        if (falseOption) {
            falseOption.setAttribute('role', 'radio');
            falseOption.setAttribute('aria-checked', 'false');
            falseOption.setAttribute('tabindex', '0');
            falseOption.setAttribute('aria-label', 'Falsch');
        }
        
        // Prüfen, ob bereits eine Auswahl getroffen wurde
        updateAriaStatus();
    }
    
    /**
     * Aktualisiert die ARIA-Attribute nach Statusänderungen
     * @returns {void}
     */
    function updateAriaStatus() {
        if (!currentQuestionContainer) return;
        
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (trueOption && falseOption) {
            const isTrueSelected = trueOption.classList.contains('selected');
            const isFalseSelected = falseOption.classList.contains('selected');
            
            trueOption.setAttribute('aria-checked', isTrueSelected ? 'true' : 'false');
            falseOption.setAttribute('aria-checked', isFalseSelected ? 'true' : 'false');
        }
    }
    
    /**
     * Fügt Tastaturnavigation für die Antwortoptionen hinzu
     * @returns {void}
     */
    function addKeyboardNavigation() {
        if (!currentQuestionContainer) return;
        
        // Event-Listener für Tastatursteuerung
        currentQuestionContainer.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        const target = event.target;
        
        // Prüfen, ob das Event von einer Antwortoption kommt
        if (!target.classList.contains('true-false-option')) return;
        
        const optionsContainer = currentQuestionContainer.querySelector('.true-false-options');
        if (!optionsContainer) return;
        
        const trueOption = currentQuestionContainer.querySelector('.true-false-option[data-value="true"]');
        const falseOption = currentQuestionContainer.querySelector('.true-false-option[data-value="false"]');
        
        if (!trueOption || !falseOption) return;
        
        // Tastatursteuerung
        switch (event.key) {
            case ' ':  // Leertaste
            case 'Enter':
                // Option auswählen
                event.preventDefault();
                target.click();
                break;
                
            case 'ArrowRight':
            case 'ArrowDown':
                // Zur nächsten Option navigieren
                event.preventDefault();
                if (target === trueOption) {
                    falseOption.focus();
                } else {
                    trueOption.focus();
                }
                break;
                
            case 'ArrowLeft':
            case 'ArrowUp':
                // Zur vorherigen Option navigieren
                event.preventDefault();
                if (target === trueOption) {
                    falseOption.focus();
                } else {
                    trueOption.focus();
                }
                break;
                
            case 'Home':
                // Zur ersten Option navigieren
                event.preventDefault();
                trueOption.focus();
                break;
                
            case 'End':
                // Zur letzten Option navigieren
                event.preventDefault();
                falseOption.focus();
                break;
                
            case 'T':
            case 't':
                // Shortcut für "True"
                event.preventDefault();
                trueOption.click();
                break;
                
            case 'F':
            case 'f':
                // Shortcut für "False"
                event.preventDefault();
                falseOption.click();
                break;
        }
    }
    
    /**
     * Verbessert das Fokus-Management für Tastaturnavigation
     * @returns {void}
     */
    function improveFocusManagement() {
        if (!currentQuestionContainer) return;
        
        // Fokus-Styling für Tastaturbenutzer verbessern
        const optionElements = currentQuestionContainer.querySelectorAll('.true-false-option');
        
        optionElements.forEach(option => {
            // Nur Fokus-Outline anzeigen, wenn mit Tastatur fokussiert
            option.addEventListener('mousedown', () => {
                option.classList.add('mouse-focus');
            });
            
            option.addEventListener('focusin', () => {
                if (!option.classList.contains('mouse-focus')) {
                    option.classList.add('keyboard-focus');
                }
                option.classList.remove('mouse-focus');
            });
            
            option.addEventListener('focusout', () => {
                option.classList.remove('keyboard-focus');
            });
        });
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (currentQuestionContainer) {
            currentQuestionContainer.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        updateAriaStatus,
        cleanup
    };
})();

// IIFE für den Wahr/Falsch-Validator
const TrueFalseValidator = (function() {
    /**
     * Validiert die Benutzerantwort und berechnet die erreichte Punktzahl
     * @param {Object} questionData - Die Fragendaten
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {Object} Validierungsergebnis mit Punktzahl und Status
     */
    function validateAnswer(questionData, userAnswer) {
        if (!questionData || userAnswer === null || userAnswer === undefined) {
            return { 
                score: 0, 
                maxScore: questionData?.points || 0,
                status: 'unanswered',
                feedback: 'Die Frage wurde nicht beantwortet.'
            };
        }
        
        const maxScore = questionData.points || 0;
        
        // Prüfen, ob die ausgewählte Antwort korrekt ist
        const isCorrect = userAnswer === questionData.correctAnswer;
        
        const score = isCorrect ? maxScore : 0;
        const status = isCorrect ? 'correct' : 'incorrect';
        
        // Feedback-Text generieren
        let feedback = '';
        if (isCorrect) {
            feedback = 'Ihre Antwort ist korrekt!';
        } else {
            const correctText = questionData.correctAnswer ? 'Wahr' : 'Falsch';
            feedback = `Ihre Antwort ist leider falsch. Die richtige Antwort ist: ${correctText}`;
        }
        
        return {
            score,
            maxScore,
            status,
            feedback,
            isCorrect
        };
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswer) {
        if (userAnswer === null || userAnswer === undefined) {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        const validationResult = validateAnswer(questionData, userAnswer);
        const userAnswerText = userAnswer ? 'Wahr' : 'Falsch';
        const correctAnswerText = questionData.correctAnswer ? 'Wahr' : 'Falsch';
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Gesamtergebnis
        reportHtml += `<h4 class="report-heading ${validationResult.status}">`;
        
        if (validationResult.isCorrect) {
            reportHtml += '<i class="fas fa-check-circle"></i> Korrekt';
        } else {
            reportHtml += '<i class="fas fa-times-circle"></i> Falsch';
        }
        
        reportHtml += '</h4>';
        
        // Detaillierte Auflistung
        reportHtml += '<div class="answer-details">';
        reportHtml += `<p>Ihre Antwort: <strong>${userAnswerText}</strong></p>`;
        
        if (!validationResult.isCorrect) {
            reportHtml += `<p>Korrekte Antwort: <strong>${correctAnswerText}</strong></p>`;
        }
        
        reportHtml += '</div>';
        
        // Falls es eine Erklärung gibt, diese anzeigen
        if (questionData.explanation) {
            reportHtml += `
                <div class="question-explanation">
                    <h5>Erklärung:</h5>
                    <p>${questionData.explanation}</p>
                </div>
            `;
        }
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
    
    /**
     * Bestimmt, ob eine Frage überhaupt beantwortet wurde
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isQuestionAnswered(userAnswer) {
        return userAnswer === true || userAnswer === false;
    }
    
    // Öffentliche API
    return {
        validateAnswer,
        generateDetailedReport,
        isQuestionAnswered
    };
})();

// IIFE für den Wahr/Falsch-Feedback-Handler
const TrueFalseFeedbackHandler = (function() {
    // Private Variablen
    let currentQuestionContainer = null;
    let currentQuestionData = null;
    let feedbackContainer = null;
    let feedbackEnabled = true;
    let instantFeedbackEnabled = false;
    let animationEnabled = true;
    
    /**
     * Initialisiert den Feedback-Handler für eine Wahr/Falsch-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @param {Object} questionData - Die Fragendaten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function initialize(container, questionData, options = {}) {
        if (!container || !questionData) {
            console.error('TrueFalseFeedbackHandler: Fehlende Container- oder Fragedaten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionContainer = container;
        currentQuestionData = questionData;
        
        // Konfigurationsoptionen übernehmen
        feedbackEnabled = options.feedbackEnabled !== undefined ? 
            options.feedbackEnabled : true;
        instantFeedbackEnabled = options.instantFeedbackEnabled !== undefined ? 
            options.instantFeedbackEnabled : false;
        animationEnabled = options.animationEnabled !== undefined ? 
            options.animationEnabled : true;
        
        // Feedback-Container erstellen, falls nicht vorhanden
        createFeedbackContainer();
        
        // Event-Listener für Antwortänderungen hinzufügen
        if (instantFeedbackEnabled) {
            addAnswerChangeListener();
        }
    }
    
    /**
     * Erstellt den Container für Feedback-Nachrichten
     * @returns {void}
     */
    function createFeedbackContainer() {
        if (!currentQuestionContainer) return;
        
        // Prüfen, ob bereits ein Feedback-Container existiert
        let existingContainer = currentQuestionContainer.querySelector('.feedback-container');
        
        if (existingContainer) {
            feedbackContainer = existingContainer;
            return;
        }
        
        // Neuen Feedback-Container erstellen
        feedbackContainer = document.createElement('div');
        feedbackContainer.className = 'feedback-container';
        feedbackContainer.style.display = 'none';
        
        // Zum Frage-Container hinzufügen, nach den Antwortoptionen
        const optionsContainer = currentQuestionContainer.querySelector('.answer-options');
        
        if (optionsContainer) {
            optionsContainer.insertAdjacentElement('afterend', feedbackContainer);
        } else {
            currentQuestionContainer.appendChild(feedbackContainer);
        }
    }
    
    /**
     * Fügt einen Event-Listener für Antwortänderungen hinzu (für sofortiges Feedback)
     * @returns {void}
     */
    function addAnswerChangeListener() {
        if (!currentQuestionData) return;
        
        document.addEventListener('answerUpdated', function(event) {
            if (event.detail && event.detail.questionId === currentQuestionData.id) {
                // Sofortiges Feedback anzeigen, wenn aktiviert
                if (instantFeedbackEnabled && feedbackEnabled) {
                    const userAnswer = event.detail.answer;
                    
                    if (typeof userAnswer === 'boolean') {
                        provideFeedback(userAnswer);
                    }
                }
            }
        });
    }
    
    /**
     * Zeigt Feedback zur Benutzerantwort an
     * @param {boolean} userAnswer - Die vom Benutzer ausgewählte Antwort
     * @returns {void}
     */
    function provideFeedback(userAnswer) {
        if (!feedbackEnabled || !feedbackContainer || !currentQuestionData) return;
        
        // Feedback über den Validator generieren
        if (typeof TrueFalseValidator === 'undefined') {
            console.error('TrueFalseFeedbackHandler: Validator nicht gefunden');
            return;
        }
        
        const validationResult = TrueFalseValidator.validateAnswer(
            currentQuestionData, 
            userAnswer
        );
        
        displayFeedback(validationResult);
    }
    
    /**
     * Zeigt das Validierungsergebnis als Feedback an
     * @param {Object} validationResult - Das Validierungsergebnis
     * @returns {void}
     */
    function displayFeedback(validationResult) {
        if (!feedbackContainer) return;
        
        // Feedback-Container leeren
        feedbackContainer.innerHTML = '';
        
        // Feedback-Element erstellen
        const feedbackElement = document.createElement('div');
        feedbackElement.className = `feedback-message ${validationResult.status}`;
        
        // Icon hinzufügen
        const iconElement = document.createElement('i');
        
        switch (validationResult.status) {
            case 'correct':
                iconElement.className = 'fas fa-check-circle';
                break;
                
            case 'incorrect':
                iconElement.className = 'fas fa-times-circle';
                break;
                
            default:
                iconElement.className = 'fas fa-info-circle';
        }
        
        feedbackElement.appendChild(iconElement);
        
        // Textuelle Rückmeldung hinzufügen
        const textElement = document.createElement('span');
        textElement.textContent = validationResult.feedback;
        feedbackElement.appendChild(textElement);
        
        // Punktzahl anzeigen, falls verfügbar
        if (validationResult.score !== undefined && validationResult.maxScore !== undefined) {
            const scoreElement = document.createElement('div');
            scoreElement.className = 'feedback-score';
            scoreElement.textContent = `Punktzahl: ${validationResult.score} / ${validationResult.maxScore}`;
            feedbackElement.appendChild(scoreElement);
        }
        
        // Zum Container hinzufügen
        feedbackContainer.appendChild(feedbackElement);
        
        // Container anzeigen
        feedbackContainer.style.display = 'block';
        
        // Animation hinzufügen, falls aktiviert
        if (animationEnabled) {
            feedbackElement.classList.add('animated');
            feedbackElement.classList.add('fadeIn');
            
            // Animation nach 5 Sekunden entfernen
            setTimeout(() => {
                feedbackElement.classList.remove('animated');
                feedbackElement.classList.remove('fadeIn');
            }, 5000);
        }
        
        // Erfolgsanimation abspielen
        playSuccessAnimation(validationResult.status);
    }
    
    /**
     * Spielt eine Erfolgsanimation ab, wenn der Benutzer eine Frage richtig beantwortet
     * @param {string} status - Der Status der Antwort
     * @returns {void}
     */
    function playSuccessAnimation(status) {
        if (!currentQuestionContainer || !animationEnabled) return;
        
        if (status === 'correct') {
            // Option finden, die ausgewählt wurde
            const selectedOption = currentQuestionContainer.querySelector('.true-false-option.selected');
            
            if (selectedOption) {
                // Pulsierende Animation hinzufügen
                selectedOption.classList.add('pulse-success');
                
                // Nach 2 Sekunden entfernen
                setTimeout(() => {
                    selectedOption.classList.remove('pulse-success');
                }, 2000);
                
                // Konfetti-Effekt über der Option
                createConfetti(selectedOption);
            }
        }
    }
    
    /**
     * Erstellt einen Konfetti-Effekt über dem ausgewählten Element
     * @param {HTMLElement} element - Das Element, über dem der Konfetti-Effekt erscheinen soll
     * @returns {void}
     */
    function createConfetti(element) {
        if (!element || !animationEnabled) return;
        
        // Konfetti-Container erstellen
        const confettiContainer = document.createElement('div');
        confettiContainer.className = 'confetti-container';
        confettiContainer.style.position = 'absolute';
        confettiContainer.style.zIndex = '100';
        confettiContainer.style.pointerEvents = 'none';
        
        // Position relativ zum Element berechnen
        const rect = element.getBoundingClientRect();
        confettiContainer.style.top = '0';
        confettiContainer.style.left = '0';
        confettiContainer.style.width = `${rect.width}px`;
        confettiContainer.style.height = '0px';
        
        // Zum Element hinzufügen
        element.style.position = 'relative';
        element.style.overflow = 'visible';
        element.appendChild(confettiContainer);
        
        // Konfetti-Partikel erstellen
        for (let i = 0; i < 30; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-particle';
            
            // Zufällige Farbe zuweisen (ImmoScout24-Farbschema)
            const colors = ['#00FFD0', '#00B090', '#57D9A3', '#008055', '#00FFD0'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.backgroundColor = randomColor;
            
            // Zufällige Form (Kreis oder Quadrat)
            confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
            
            // Zufällige Größe
            const size = Math.random() * 8 + 4;
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            
            // Zufällige Position
            confetti.style.left = `${Math.random() * 100}%`;
            confetti.style.top = '0';
            
            // Zufällige Animation
            confetti.style.animationDuration = `${Math.random() * 2 + 1}s`;
            confetti.style.animationDelay = `${Math.random() * 0.5}s`;
            
            confettiContainer.appendChild(confetti);
        }
        
        // Nach 3 Sekunden entfernen
        setTimeout(() => {
            if (confettiContainer.parentNode) {
                confettiContainer.parentNode.removeChild(confettiContainer);
            }
        }, 3000);
    }
    
    /**
     * Aktiviert oder deaktiviert das sofortige Feedback
     * @param {boolean} enable - Ob sofortiges Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleInstantFeedback(enable) {
        instantFeedbackEnabled = enable;
    }
    
    /**
     * Aktiviert oder deaktiviert Feedback generell
     * @param {boolean} enable - Ob Feedback aktiviert werden soll
     * @returns {void}
     */
    function toggleFeedback(enable) {
        feedbackEnabled = enable;
        
        // Feedback-Container ausblenden, wenn deaktiviert
        if (!enable && feedbackContainer) {
            feedbackContainer.style.display = 'none';
        }
    }
    
    /**
     * Aktiviert oder deaktiviert Animationen
     * @param {boolean} enable - Ob Animationen aktiviert werden sollen
     * @returns {void}
     */
    function toggleAnimation(enable) {
        animationEnabled = enable;
    }
    
    /**
     * Bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (feedbackContainer) {
            feedbackContainer.innerHTML = '';
        }
        
        currentQuestionContainer = null;
        currentQuestionData = null;
        feedbackContainer = null;
    }
    
    // Öffentliche API
    return {
        initialize,
        provideFeedback,
        toggleInstantFeedback,
        toggleFeedback,
        toggleAnimation,
        cleanup
    };
})();

// Verbindung mit dem Rest des Systems
document.addEventListener('DOMContentLoaded', function() {
    // Event-Listener für Frage-Initialisierung
    document.addEventListener('questionRendered', function(event) {
        if (event.detail && event.detail.type === 'true-false' && event.detail.container) {
            // Barrierefreiheit verbessern
            TrueFalseAccessibilityEnhancer.enhanceAccessibility(event.detail.container);
            
            // Feedback-Handler initialisieren, falls vorhanden
            if (event.detail.questionData && typeof TrueFalseFeedbackHandler !== 'undefined') {
                TrueFalseFeedbackHandler.initialize(
                    event.detail.container,
                    event.detail.questionData,
                    {
                        instantFeedbackEnabled: event.detail.instantFeedback || false
                    }
                );
            }
        }
    });
    
    // Event-Listener für Antwortänderungen
    document.addEventListener('answerUpdated', function(event) {
        if (event.detail && event.detail.answerType === 'true-false') {
            // ARIA-Attribute aktualisieren
            TrueFalseAccessibilityEnhancer.updateAriaStatus();
        }
    });
    
    // Validator registrieren, falls das Registry-Objekt existiert
    if (typeof ValidationRegistry !== 'undefined') {
        ValidationRegistry.registerValidator('true-false', TrueFalseValidator);
    }
    
    // Feedback-Handler registrieren
    if (typeof FeedbackRegistry === 'undefined') {
        window.FeedbackRegistry = {};
    }
    
    FeedbackRegistry.TrueFalse = {
        feedbackHandler: TrueFalseFeedbackHandler
    };
});

// CSS-Stile für Tastaturnavigation und Animationen
(function addTrueFalseAccessibilityStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Tastatur-Fokus Styling */
        .true-false-option:focus {
            outline: none;
        }
        
        .true-false-option.keyboard-focus {
            box-shadow: 0 0 0 3px #00FFD0, 0 4px 8px rgba(0,0,0,0.1);
        }
        
        /* Erfolgsanimation */
        @keyframes pulse-success {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(0, 255, 208, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(0, 255, 208, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(0, 255, 208, 0);
            }
        }
        
        .pulse-success {
            animation: pulse-success 1s infinite;
        }
        
        /* Konfetti-Animation */
        .confetti-particle {
            position: absolute;
            opacity: 0;
            animation: confetti-fall 2s ease-in-out forwards;
        }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100px) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* Feedback-Darstellung */
        .feedback-container {
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        .feedback-message {
            display: flex;
            align-items: center;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
            animation: fadeIn 0.5s;
        }
        
        .feedback-message i {
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        .feedback-message.correct {
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 4px solid #28a745;
            color: #155724;
        }
        
        .feedback-message.incorrect {
            background-color: rgba(220, 53, 69, 0.1);
            border-left: 4px solid #dc3545;
            color: #721c24;
        }
        
        /* Detaillierter Bericht */
        .detailed-answer-report {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .answer-details {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .question-explanation {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }
        
        /* Animationen */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animated {
            animation-duration: 0.5s;
            animation-fill-mode: both;
        }
        
        .fadeIn {
            animation-name: fadeIn;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.5.1-part1: Fragenanzeige - Freitext (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Freitext-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Texteingabe
 * und bietet visuelle Rückmeldung während der Beantwortung.
 */

// IIFE für die Kapselung des Freitext-Fragenmoduls
const FreeTextQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let userAnswer = '';
    let questionContainer = null;
    let textareaElement = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    let autoSaveTimer = null;
    let characterCounter = null;
    
    // Konfigurationsoptionen
    const DEFAULT_OPTIONS = {
        minCharacters: 0,
        maxCharacters: 0, // 0 bedeutet kein Limit
        rows: 5,
        autoGrow: true,
        showCharacterCount: true,
        placeholderText: 'Geben Sie Ihre Antwort hier ein...',
        autoSaveInterval: 3000 // 3 Sekunden
    };
    
    let options = {...DEFAULT_OPTIONS};
    
    /**
     * Initialisiert die Anzeige einer Freitext-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @param {Object} customOptions - Benutzerdefinierte Optionen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false, customOptions = {}) {
        if (!questionData || !container) {
            console.error('FreeTextQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Optionen übernehmen
        options = { ...DEFAULT_OPTIONS, ...customOptions };
        
        // Fragetyp überprüfen
        if (questionData.type !== 'free-text') {
            console.error('FreeTextQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Fragenspezifische Optionen übernehmen, falls vorhanden
        if (questionData.options) {
            options = { ...options, ...questionData.options };
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined && typeof sessionAnswer === 'string') {
            userAnswer = sessionAnswer;
        } else {
            userAnswer = '';
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Freitext-Frage mit dem Texteingabefeld
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content free-text-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Freitext hinzufügen, falls vorhanden
        if (currentQuestionData.hint) {
            const hintElement = document.createElement('p');
            hintElement.className = 'input-hint';
            hintElement.textContent = currentQuestionData.hint;
            questionText.appendChild(hintElement);
        }
        
        questionElement.appendChild(questionText);
        
        // Antwort-Container erstellen
        const answerContainer = document.createElement('div');
        answerContainer.className = 'free-text-answer-container';
        
        // Textarea für die Antwort erstellen
        textareaElement = document.createElement('textarea');
        textareaElement.className = 'free-text-input';
        textareaElement.placeholder = options.placeholderText;
        textareaElement.rows = options.rows;
        textareaElement.value = userAnswer;
        
        // Min/Max Zeichen setzen, falls definiert
        if (options.minCharacters > 0) {
            textareaElement.setAttribute('minlength', options.minCharacters);
        }
        
        if (options.maxCharacters > 0) {
            textareaElement.setAttribute('maxlength', options.maxCharacters);
        }
        
        // Im Review-Modus oder wenn Antworten gesperrt sind, das Textfeld deaktivieren
        if (isReviewMode || userAnswersLocked) {
            textareaElement.disabled = true;
        }
        
        answerContainer.appendChild(textareaElement);
        
        // Zeichenzähler hinzufügen, wenn aktiviert
        if (options.showCharacterCount) {
            characterCounter = document.createElement('div');
            characterCounter.className = 'character-counter';
            updateCharacterCounter();
            answerContainer.appendChild(characterCounter);
        }
        
        questionElement.appendChild(answerContainer);
        
        // Im Review-Modus zusätzliche Informationen anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // AutoGrow für Textarea aktivieren, falls gewünscht
        if (options.autoGrow) {
            enableTextareaAutoGrow();
        }
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Bei Freitext-Fragen gibt es keine automatische Bewertung,
        // daher zeigen wir nur die Antwort des Benutzers an
        
        let feedbackContent = '';
        
        // Falls im Fragetyp eine Musterlösung hinterlegt ist, diese anzeigen
        if (currentQuestionData.modelAnswer) {
            feedbackContent = `
                <div class="feedback-header">
                    <i class="fas fa-info-circle"></i>
                    <h4>Musterlösung</h4>
                </div>
                <div class="feedback-details">
                    <p>Ihre Antwort:</p>
                    <div class="user-answer">${userAnswer || '<em>Keine Antwort angegeben</em>'}</div>
                    
                    <p>Beispiel für eine gute Antwort:</p>
                    <div class="model-answer">${currentQuestionData.modelAnswer}</div>
                </div>
            `;
        } else {
            feedbackContent = `
                <div class="feedback-header">
                    <i class="fas fa-info-circle"></i>
                    <h4>Ihre Antwort</h4>
                </div>
                <div class="feedback-details">
                    <div class="user-answer">${userAnswer || '<em>Keine Antwort angegeben</em>'}</div>
                </div>
            `;
        }
        
        feedbackElement.innerHTML = feedbackContent;
        
        return feedbackElement;
    }
    
    /**
     * Aktualisiert den Zeichenzähler
     * @returns {void}
     */
    function updateCharacterCounter() {
        if (!characterCounter || !textareaElement) return;
        
        const currentLength = textareaElement.value.length;
        
        // Text für den Zähler erstellen
        let counterText = `${currentLength} Zeichen`;
        
        // Wenn ein Maximum definiert ist, dies anzeigen
        if (options.maxCharacters > 0) {
            counterText += ` / ${options.maxCharacters}`;
            
            // Visuelles Feedback, wenn man sich dem Limit nähert
            const remainingChars = options.maxCharacters - currentLength;
            
            if (remainingChars <= 10) {
                characterCounter.classList.add('limit-approaching');
                
                if (remainingChars <= 0) {
                    characterCounter.classList.add('limit-reached');
                } else {
                    characterCounter.classList.remove('limit-reached');
                }
            } else {
                characterCounter.classList.remove('limit-approaching', 'limit-reached');
            }
        }
        
        // Wenn ein Minimum definiert ist, auch dieses anzeigen
        if (options.minCharacters > 0) {
            if (currentLength < options.minCharacters) {
                counterText += ` (Minimum: ${options.minCharacters})`;
                characterCounter.classList.add('below-minimum');
            } else {
                characterCounter.classList.remove('below-minimum');
            }
        }
        
        characterCounter.textContent = counterText;
    }
    
    /**
     * Aktiviert das automatische Wachsen der Textarea
     * @returns {void}
     */
    function enableTextareaAutoGrow() {
        if (!textareaElement) return;
        
        // Initial anpassen
        adjustTextareaHeight();
        
        // Event-Listener für Eingabeänderungen
        textareaElement.addEventListener('input', adjustTextareaHeight);
    }
    
    /**
     * Passt die Höhe der Textarea an den Inhalt an
     * @returns {void}
     */
    function adjustTextareaHeight() {
        if (!textareaElement) return;
        
        // Höhe zurücksetzen, um korrekt neu zu berechnen
        textareaElement.style.height = 'auto';
        
        // Höhe an Inhalt anpassen, plus etwas Puffer
        const newHeight = textareaElement.scrollHeight;
        textareaElement.style.height = `${newHeight}px`;
    }
	/**
 * JS-Block 5.5.1-part1: Fragenanzeige - Freitext (Anzeige und Interaktion, Teil 1)
 * 
 * Dieser Block implementiert die Anzeige und Interaktion für Freitext-Fragen.
 * Er ist verantwortlich für das Rendern der Fragen, das Handling der Texteingabe
 * und bietet visuelle Rückmeldung während der Beantwortung.
 */

// IIFE für die Kapselung des Freitext-Fragenmoduls
const FreeTextQuestionHandler = (function() {
    // Private Variablen und Funktionen
    let currentQuestionData = null;
    let userAnswer = '';
    let questionContainer = null;
    let textareaElement = null;
    let isReviewMode = false;
    let userAnswersLocked = false;
    let autoSaveTimer = null;
    let characterCounter = null;
    
    // Konfigurationsoptionen
    const DEFAULT_OPTIONS = {
        minCharacters: 0,
        maxCharacters: 0, // 0 bedeutet kein Limit
        rows: 5,
        autoGrow: true,
        showCharacterCount: true,
        placeholderText: 'Geben Sie Ihre Antwort hier ein...',
        autoSaveInterval: 3000 // 3 Sekunden
    };
    
    let options = {...DEFAULT_OPTIONS};
    
    /**
     * Initialisiert die Anzeige einer Freitext-Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {HTMLElement} container - Der Container für die Frage
     * @param {boolean} reviewMode - Ob im Überprüfungsmodus (nach Testabschluss)
     * @param {boolean} lockAnswers - Ob Antworten gesperrt sein sollen
     * @param {Object} customOptions - Benutzerdefinierte Optionen
     * @returns {void}
     */
    function initializeQuestion(questionData, container, reviewMode = false, lockAnswers = false, customOptions = {}) {
        if (!questionData || !container) {
            console.error('FreeTextQuestionHandler: Fehlende Frage- oder Container-Daten');
            return;
        }
        
        // Speichern der übergebenen Daten
        currentQuestionData = questionData;
        questionContainer = container;
        isReviewMode = reviewMode;
        userAnswersLocked = lockAnswers;
        
        // Optionen übernehmen
        options = { ...DEFAULT_OPTIONS, ...customOptions };
        
        // Fragetyp überprüfen
        if (questionData.type !== 'free-text') {
            console.error('FreeTextQuestionHandler: Falscher Fragentyp erhalten:', questionData.type);
            return;
        }
        
        // Fragenspezifische Optionen übernehmen, falls vorhanden
        if (questionData.options) {
            options = { ...options, ...questionData.options };
        }
        
        // Lade vorhandene Antwort, falls vorhanden
        const sessionAnswer = TestSessionManager.getQuestionAnswer(questionData.id);
        
        if (sessionAnswer !== null && sessionAnswer !== undefined && typeof sessionAnswer === 'string') {
            userAnswer = sessionAnswer;
        } else {
            userAnswer = '';
        }
        
        // Rendern der Frage
        renderQuestion();
        
        // Event-Listener hinzufügen, wenn Antworten nicht gesperrt sind
        if (!userAnswersLocked) {
            attachEventListeners();
        }
    }
    
    /**
     * Rendert die Freitext-Frage mit dem Texteingabefeld
     * @returns {void}
     */
    function renderQuestion() {
        if (!currentQuestionData || !questionContainer) return;
        
        // Container leeren
        questionContainer.innerHTML = '';
        
        // Frage-Container erstellen
        const questionElement = document.createElement('div');
        questionElement.className = 'question-content free-text-question';
        
        // Fragentext anzeigen
        const questionText = document.createElement('div');
        questionText.className = 'question-text';
        questionText.innerHTML = `<h3>${currentQuestionData.text}</h3>`;
        
        // Hinweis für Freitext hinzufügen, falls vorhanden
        if (currentQuestionData.hint) {
            const hintElement = document.createElement('p');
            hintElement.className = 'input-hint';
            hintElement.textContent = currentQuestionData.hint;
            questionText.appendChild(hintElement);
        }
        
        questionElement.appendChild(questionText);
        
        // Antwort-Container erstellen
        const answerContainer = document.createElement('div');
        answerContainer.className = 'free-text-answer-container';
        
        // Textarea für die Antwort erstellen
        textareaElement = document.createElement('textarea');
        textareaElement.className = 'free-text-input';
        textareaElement.placeholder = options.placeholderText;
        textareaElement.rows = options.rows;
        textareaElement.value = userAnswer;
        
        // Min/Max Zeichen setzen, falls definiert
        if (options.minCharacters > 0) {
            textareaElement.setAttribute('minlength', options.minCharacters);
        }
        
        if (options.maxCharacters > 0) {
            textareaElement.setAttribute('maxlength', options.maxCharacters);
        }
        
        // Im Review-Modus oder wenn Antworten gesperrt sind, das Textfeld deaktivieren
        if (isReviewMode || userAnswersLocked) {
            textareaElement.disabled = true;
        }
        
        answerContainer.appendChild(textareaElement);
        
        // Zeichenzähler hinzufügen, wenn aktiviert
        if (options.showCharacterCount) {
            characterCounter = document.createElement('div');
            characterCounter.className = 'character-counter';
            updateCharacterCounter();
            answerContainer.appendChild(characterCounter);
        }
        
        questionElement.appendChild(answerContainer);
        
        // Im Review-Modus zusätzliche Informationen anzeigen
        if (isReviewMode) {
            const feedbackElement = createFeedbackElement();
            questionElement.appendChild(feedbackElement);
        }
        
        // Zum Container hinzufügen
        questionContainer.appendChild(questionElement);
        
        // AutoGrow für Textarea aktivieren, falls gewünscht
        if (options.autoGrow) {
            enableTextareaAutoGrow();
        }
    }
    
    /**
     * Erstellt ein Feedback-Element für den Review-Modus
     * @returns {HTMLElement} Das erzeugte Feedback-Element
     */
    function createFeedbackElement() {
        const feedbackElement = document.createElement('div');
        feedbackElement.className = 'question-feedback';
        
        // Bei Freitext-Fragen gibt es keine automatische Bewertung,
        // daher zeigen wir nur die Antwort des Benutzers an
        
        let feedbackContent = '';
        
        // Falls im Fragetyp eine Musterlösung hinterlegt ist, diese anzeigen
        if (currentQuestionData.modelAnswer) {
            feedbackContent = `
                <div class="feedback-header">
                    <i class="fas fa-info-circle"></i>
                    <h4>Musterlösung</h4>
                </div>
                <div class="feedback-details">
                    <p>Ihre Antwort:</p>
                    <div class="user-answer">${userAnswer || '<em>Keine Antwort angegeben</em>'}</div>
                    
                    <p>Beispiel für eine gute Antwort:</p>
                    <div class="model-answer">${currentQuestionData.modelAnswer}</div>
                </div>
            `;
        } else {
            feedbackContent = `
                <div class="feedback-header">
                    <i class="fas fa-info-circle"></i>
                    <h4>Ihre Antwort</h4>
                </div>
                <div class="feedback-details">
                    <div class="user-answer">${userAnswer || '<em>Keine Antwort angegeben</em>'}</div>
                </div>
            `;
        }
        
        feedbackElement.innerHTML = feedbackContent;
        
        return feedbackElement;
    }
    
    /**
     * Aktualisiert den Zeichenzähler
     * @returns {void}
     */
    function updateCharacterCounter() {
        if (!characterCounter || !textareaElement) return;
        
        const currentLength = textareaElement.value.length;
        
        // Text für den Zähler erstellen
        let counterText = `${currentLength} Zeichen`;
        
        // Wenn ein Maximum definiert ist, dies anzeigen
        if (options.maxCharacters > 0) {
            counterText += ` / ${options.maxCharacters}`;
            
            // Visuelles Feedback, wenn man sich dem Limit nähert
            const remainingChars = options.maxCharacters - currentLength;
            
            if (remainingChars <= 10) {
                characterCounter.classList.add('limit-approaching');
                
                if (remainingChars <= 0) {
                    characterCounter.classList.add('limit-reached');
                } else {
                    characterCounter.classList.remove('limit-reached');
                }
            } else {
                characterCounter.classList.remove('limit-approaching', 'limit-reached');
            }
        }
        
        // Wenn ein Minimum definiert ist, auch dieses anzeigen
        if (options.minCharacters > 0) {
            if (currentLength < options.minCharacters) {
                counterText += ` (Minimum: ${options.minCharacters})`;
                characterCounter.classList.add('below-minimum');
            } else {
                characterCounter.classList.remove('below-minimum');
            }
        }
        
        characterCounter.textContent = counterText;
    }
    
    /**
     * Aktiviert das automatische Wachsen der Textarea
     * @returns {void}
     */
    function enableTextareaAutoGrow() {
        if (!textareaElement) return;
        
        // Initial anpassen
        adjustTextareaHeight();
        
        // Event-Listener für Eingabeänderungen
        textareaElement.addEventListener('input', adjustTextareaHeight);
    }
    
    /**
     * Passt die Höhe der Textarea an den Inhalt an
     * @returns {void}
     */
    function adjustTextareaHeight() {
        if (!textareaElement) return;
        
        // Höhe zurücksetzen, um korrekt neu zu berechnen
        textareaElement.style.height = 'auto';
        
        // Höhe an Inhalt anpassen, plus etwas Puffer
        const newHeight = textareaElement.scrollHeight;
        textareaElement.style.height = `${newHeight}px`;
    }
    
    /**
     * Event-Listener für die Texteingabe hinzufügen
     * @returns {void}
     */
    function attachEventListeners() {
        if (!textareaElement) return;
        
        // Input-Event für Änderungen an der Texteingabe
        textareaElement.addEventListener('input', handleTextInput);
        
        // Fokus-Events für visuelles Feedback
        textareaElement.addEventListener('focus', handleTextareaFocus);
        textareaElement.addEventListener('blur', handleTextareaBlur);
        
        // Auto-Save beim Verlassen des Textfelds
        textareaElement.addEventListener('blur', saveAnswer);
    }
    
    /**
     * Handler für Texteingabe-Events
     * @param {Event} event - Das Input-Event
     * @returns {void}
     */
    function handleTextInput(event) {
        // Aktuelle Eingabe speichern
        userAnswer = textareaElement.value;
        
        // Zeichenzähler aktualisieren, falls vorhanden
        if (options.showCharacterCount) {
            updateCharacterCounter();
        }
        
        // Auto-Save mit Verzögerung
        setupAutoSave();
    }
    
    /**
     * Handler für Fokus-Events der Textarea
     * @returns {void}
     */
    function handleTextareaFocus() {
        // Visuelles Feedback beim Fokussieren
        if (textareaElement) {
            textareaElement.classList.add('focused');
        }
    }
    
    /**
     * Handler für Blur-Events der Textarea
     * @returns {void}
     */
    function handleTextareaBlur() {
        // Visuelles Feedback beim Verlassen
        if (textareaElement) {
            textareaElement.classList.remove('focused');
        }
    }
    
    /**
     * Konfiguriert das automatische Speichern mit Verzögerung
     * @returns {void}
     */
    function setupAutoSave() {
        // Bestehenden Timer löschen, um Mehrfachausführung zu vermeiden
        if (autoSaveTimer) {
            clearTimeout(autoSaveTimer);
        }
        
        // Neuen Timer erstellen
        autoSaveTimer = setTimeout(() => {
            saveAnswer();
        }, options.autoSaveInterval);
    }
    
    /**
     * Speichert die aktuelle Antwort im TestSessionManager
     * @returns {void}
     */
    function saveAnswer() {
        if (!currentQuestionData || !currentQuestionData.id) return;
        
        TestSessionManager.saveQuestionAnswer(
            currentQuestionData.id,
            userAnswer
        );
        
        // Event auslösen, um andere Komponenten über die Antwortänderung zu informieren
        const event = new CustomEvent('answerUpdated', {
            detail: {
                questionId: currentQuestionData.id,
                answer: userAnswer,
                answerType: 'free-text'
            }
        });
        document.dispatchEvent(event);
    }
    
    /**
     * Aktualisiert die Antwort
     * @param {string} answer - Die neue Antwort
     * @returns {void}
     */
    function updateAnswer(answer) {
        if (typeof answer !== 'string') return;
        
        userAnswer = answer;
        
        // Textarea aktualisieren, falls sie existiert
        if (textareaElement) {
            textareaElement.value = userAnswer;
            
            // Zeichenzähler aktualisieren
            if (options.showCharacterCount) {
                updateCharacterCounter();
            }
            
            // Höhe anpassen, falls auto-grow aktiviert ist
            if (options.autoGrow) {
                adjustTextareaHeight();
            }
        }
    }
    
    /**
     * Sperrt die Benutzerinteraktion mit der Frage
     * @param {boolean} lock - Ob die Interaktion gesperrt werden soll
     * @returns {void}
     */
    function lockAnswers(lock = true) {
        userAnswersLocked = lock;
        
        // Textarea deaktivieren/aktivieren
        if (textareaElement) {
            textareaElement.disabled = lock;
            
            // Visuelles Feedback für gesperrten Zustand
            if (lock) {
                textareaElement.classList.add('locked');
            } else {
                textareaElement.classList.remove('locked');
            }
        }
    }
    
    /**
     * Aktiviert den Review-Modus
     * @param {boolean} enable - Ob der Review-Modus aktiviert werden soll
     * @returns {void}
     */
    function enableReviewMode(enable = true) {
        if (isReviewMode === enable) return; // Keine Änderung nötig
        
        isReviewMode = enable;
        
        // Neu rendern, wenn sich der Modus ändert
        renderQuestion();
    }
    
    /**
     * Prüft, ob die aktuelle Frage beantwortet wurde
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    function isAnswered() {
        // Prüfen, ob überhaupt Text eingegeben wurde
        if (!userAnswer || userAnswer.trim() === '') {
            return false;
        }
        
        // Wenn ein Minimum an Zeichen erforderlich ist, dies prüfen
        if (options.minCharacters > 0 && userAnswer.length < options.minCharacters) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Prüft, ob die Antwort das Mindestzeichenlimit erreicht
     * @returns {boolean} Ob die Antwort das Mindestzeichenlimit erreicht
     */
    function isMinimumCharactersMet() {
        if (options.minCharacters <= 0) return true;
        return userAnswer.length >= options.minCharacters;
    }
    
    /**
     * Gibt die aktuelle Antwort zurück
     * @returns {string} Die aktuelle Antwort
     */
    function getAnswer() {
        return userAnswer;
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (textareaElement) {
            textareaElement.removeEventListener('input', handleTextInput);
            textareaElement.removeEventListener('focus', handleTextareaFocus);
            textareaElement.removeEventListener('blur', handleTextareaBlur);
            textareaElement.removeEventListener('blur', saveAnswer);
            
            if (options.autoGrow) {
                textareaElement.removeEventListener('input', adjustTextareaHeight);
            }
        }
        
        // Auto-Save-Timer löschen, falls vorhanden
        if (autoSaveTimer) {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = null;
        }
        
        // Referenzen zurücksetzen
        currentQuestionData = null;
        userAnswer = '';
        questionContainer = null;
        textareaElement = null;
        characterCounter = null;
    }
    
    // Öffentliche API
    return {
        initializeQuestion,
        updateAnswer,
        lockAnswers,
        enableReviewMode,
        isAnswered,
        isMinimumCharactersMet,
        getAnswer,
        cleanup
    };
})();

// Module registrieren
if (typeof QuestionHandlerRegistry !== 'undefined') {
    QuestionHandlerRegistry.registerHandler('free-text', FreeTextQuestionHandler);
}

// CSS-Stile für Freitext-Fragen
(function addFreeTextStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Freitext-Antwort-Container */
        .free-text-answer-container {
            margin-top: 15px;
            position: relative;
        }
        
        /* Freitext-Eingabefeld */
        .free-text-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 4px;
            font-family: inherit;
            font-size: 16px;
            line-height: 1.5;
            transition: all 0.2s ease;
            resize: vertical;
            min-height: 120px;
        }
        
        .free-text-input:hover {
            border-color: #ced4da;
        }
        
        .free-text-input.focused,
        .free-text-input:focus {
            border-color: #00FFD0;
            box-shadow: 0 0 0 3px rgba(0, 255, 208, 0.25);
            outline: none;
        }
        
        /* Deaktiviertes Textfeld */
        .free-text-input:disabled {
            background-color: #f8f9fa;
            cursor: not-allowed;
            opacity: 0.8;
        }
        
        .free-text-input.locked {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        
        /* Zeichenzähler */
        .character-counter {
            margin-top: 8px;
            font-size: 14px;
            color: #6c757d;
            text-align: right;
            transition: all 0.2s ease;
        }
        
        .character-counter.limit-approaching {
            color: #fd7e14;
            font-weight: 500;
        }
        
        .character-counter.limit-reached {
            color: #dc3545;
            font-weight: 600;
        }
        
        .character-counter.below-minimum {
            color: #dc3545;
            font-weight: 500;
        }
        
        /* Eingabehinweis */
        .input-hint {
            color: #6c757d;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        /* Feedback im Review-Modus */
        .question-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .feedback-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .feedback-header i {
            margin-right: 10px;
            color: #00B090;
            font-size: 1.2em;
        }
        
        .user-answer {
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            white-space: pre-wrap;
        }
        
        .model-answer {
            background-color: rgba(0, 255, 208, 0.1);
            border: 1px solid #00B090;
            border-left: 4px solid #00B090;
            border-radius: 4px;
            padding: 10px;
            white-space: pre-wrap;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.5.1-part2: Fragenanzeige - Freitext (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Freitext-Funktionalität mit Barrierefreiheits-Features,
 * Validierungsmechanismen, Rechtschreibprüfung und erweiterten Bearbeitungsoptionen.
 */

// IIFE für den Freitext Accessibility-Enhancer
const FreeTextAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    let textareaElement = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Freitext-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        textareaElement = container.querySelector('.free-text-input');
        
        if (!textareaElement) return;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastatur-Shortcuts für Bearbeitung
        addKeyboardShortcuts();
        
        // Label für Screenreader
        addAccessibleLabels();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer || !textareaElement) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Freitext-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Textarea mit zusätzlichen Attributen
        textareaElement.setAttribute('role', 'textbox');
        textareaElement.setAttribute('aria-multiline', 'true');
        
        // Hinweise auf Mindest-/Maximalzeichen
        const minChars = textareaElement.getAttribute('minlength');
        const maxChars = textareaElement.getAttribute('maxlength');
        
        if (minChars) {
            textareaElement.setAttribute('aria-describedby', 'min-chars-hint');
            
            // Hinweis-Element erstellen, falls nicht vorhanden
            let minCharsHint = currentQuestionContainer.querySelector('#min-chars-hint');
            if (!minCharsHint) {
                minCharsHint = document.createElement('div');
                minCharsHint.id = 'min-chars-hint';
                minCharsHint.className = 'sr-only'; // Nur für Screenreader
                minCharsHint.textContent = `Diese Antwort erfordert mindestens ${minChars} Zeichen.`;
                currentQuestionContainer.appendChild(minCharsHint);
            }
        }
        
        if (maxChars) {
            textareaElement.setAttribute('aria-describedby', 
                (minChars ? 'min-chars-hint max-chars-hint' : 'max-chars-hint'));
            
            // Hinweis-Element erstellen, falls nicht vorhanden
            let maxCharsHint = currentQuestionContainer.querySelector('#max-chars-hint');
            if (!maxCharsHint) {
                maxCharsHint = document.createElement('div');
                maxCharsHint.id = 'max-chars-hint';
                maxCharsHint.className = 'sr-only'; // Nur für Screenreader
                maxCharsHint.textContent = `Diese Antwort ist auf maximal ${maxChars} Zeichen begrenzt.`;
                currentQuestionContainer.appendChild(maxCharsHint);
            }
        }
    }
    
    /**
     * Fügt Tastatur-Shortcuts für die einfachere Bearbeitung hinzu
     * @returns {void}
     */
    function addKeyboardShortcuts() {
        if (!textareaElement) return;
        
        textareaElement.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        // Tab innerhalb der Textarea mit Einrückung
        if (event.key === 'Tab' && !event.shiftKey && !event.ctrlKey && !event.altKey) {
            // Tab-Taste abfangen und Einrückung einfügen
            event.preventDefault();
            
            const start = textareaElement.selectionStart;
            const end = textareaElement.selectionEnd;
            
            // Tab-Zeichen einfügen
            textareaElement.value = 
                textareaElement.value.substring(0, start) + 
                '    ' + // 4 Leerzeichen als Tab
                textareaElement.value.substring(end);
            
            // Cursor nach dem Tab positionieren
            textareaElement.selectionStart = textareaElement.selectionEnd = start + 4;
            
            // Änderung auslösen, um Auto-Save anzustoßen
            const inputEvent = new Event('input', { bubbles: true });
            textareaElement.dispatchEvent(inputEvent);
        }
        
        // Strg+S zum Speichern (verhindert Browser-Speicherdialog)
        if (event.key === 's' && event.ctrlKey) {
            event.preventDefault();
            
            // Speichern-Event auslösen
            const saveEvent = new CustomEvent('manualSave', {
                detail: {
                    sourceElement: textareaElement
                }
            });
            document.dispatchEvent(saveEvent);
            
            // Feedback für den Benutzer
            showSaveFeedback();
        }
    }
    
    /**
     * Zeigt kurzes visuelles Feedback beim manuellen Speichern
     * @returns {void}
     */
    function showSaveFeedback() {
        if (!textareaElement || !currentQuestionContainer) return;
        
        // Finde den Feedback-Container oder erstelle ihn
        let saveIndicator = currentQuestionContainer.querySelector('.save-indicator');
        
        if (!saveIndicator) {
            saveIndicator = document.createElement('div');
            saveIndicator.className = 'save-indicator';
            saveIndicator.setAttribute('aria-live', 'polite');
            currentQuestionContainer.appendChild(saveIndicator);
        }
        
        // Feedback anzeigen
        saveIndicator.textContent = 'Gespeichert';
        saveIndicator.classList.add('visible');
        
        // Nach kurzer Zeit ausblenden
        setTimeout(() => {
            saveIndicator.classList.remove('visible');
        }, 1500);
    }
    
    /**
     * Fügt zugängliche Labels für Screenreader hinzu
     * @returns {void}
     */
    function addAccessibleLabels() {
        if (!textareaElement || !currentQuestionContainer) return;
        
        // Eindeutige ID für die Frage
        const questionId = 'free-text-question-' + Math.random().toString(36).substr(2, 9);
        
        // Fragetext als Label für das Textfeld verwenden
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        
        if (questionText) {
            questionText.id = questionId;
            textareaElement.setAttribute('aria-labelledby', questionId);
        }
        
        // Charakterzähler für Screenreader zugänglich machen
        const charCounter = currentQuestionContainer.querySelector('.character-counter');
        
        if (charCounter) {
            charCounter.id = 'char-counter-' + questionId;
            charCounter.setAttribute('aria-live', 'polite');
            
            // Zusätzliche Beschreibung mit Zeichenzähler
            let ariaDescribedBy = textareaElement.getAttribute('aria-describedby') || '';
            
            if (ariaDescribedBy) {
                ariaDescribedBy += ' ' + charCounter.id;
            } else {
                ariaDescribedBy = charCounter.id;
            }
            
            textareaElement.setAttribute('aria-describedby', ariaDescribedBy.trim());
        }
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (textareaElement) {
            textareaElement.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
        textareaElement = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        cleanup
    };
})();

// IIFE für den Freitext-Validator
const FreeTextValidator = (function() {
    /**
     * Validiert die Benutzerantwort
     * @param {Object} questionData - Die Fragendaten
     * @param {string} userAnswer - Die vom Benutzer eingegebene Antwort
     * @param {Object} options - Validierungsoptionen
     * @returns {Object} Validierungsergebnis
     */
    function validateAnswer(questionData, userAnswer, options = {}) {
        if (!questionData) {
            return { 
                valid: false,
                message: 'Ungültige Fragendaten'
            };
        }
        
        // Standardwerte für Validierungsoptionen
        const validationOptions = {
            minCharacters: questionData.options?.minCharacters || 0,
            maxCharacters: questionData.options?.maxCharacters || 0,
            requiredWords: questionData.options?.requiredWords || [],
            autoGrading: questionData.options?.autoGrading || false,
            ...options
        };
        
        // Prüfen, ob überhaupt eine Antwort gegeben wurde
        if (!userAnswer || userAnswer.trim() === '') {
            return {
                valid: false,
                status: 'unanswered',
                message: 'Die Frage wurde nicht beantwortet.',
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen der Mindestanzahl an Zeichen
        if (validationOptions.minCharacters > 0 && userAnswer.length < validationOptions.minCharacters) {
            return {
                valid: false,
                status: 'too_short',
                message: `Die Antwort ist zu kurz. Mindestens ${validationOptions.minCharacters} Zeichen erforderlich.`,
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen der Maximalanzahl an Zeichen
        if (validationOptions.maxCharacters > 0 && userAnswer.length > validationOptions.maxCharacters) {
            return {
                valid: false,
                status: 'too_long',
                message: `Die Antwort ist zu lang. Maximal ${validationOptions.maxCharacters} Zeichen erlaubt.`,
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen, ob alle erforderlichen Wörter enthalten sind
        const missingWords = [];
        
        if (validationOptions.requiredWords && validationOptions.requiredWords.length > 0) {
            const normalizedAnswer = userAnswer.toLowerCase();
            
            validationOptions.requiredWords.forEach(word => {
                if (!normalizedAnswer.includes(word.toLowerCase())) {
                    missingWords.push(word);
                }
            });
            
            if (missingWords.length > 0) {
                return {
                    valid: false,
                    status: 'missing_keywords',
                    message: `Folgende Schlüsselwörter fehlen in Ihrer Antwort: ${missingWords.join(', ')}`,
                    score: 0,
                    maxScore: questionData.points || 0,
                    missingWords
                };
            }
        }
        
        // Automatische Bewertung, falls aktiviert
        if (validationOptions.autoGrading && questionData.modelAnswer) {
            // Hier nur eine einfache Bewertung - in Teil 2 wird das erweitert
            const score = calculateSimpleScore(userAnswer, questionData.modelAnswer, questionData.points || 10);
            
            return {
                valid: true,
                status: 'auto_graded',
                message: 'Die Antwort wurde automatisch bewertet.',
                score,
                maxScore: questionData.points || 10,
                autoGraded: true
            };
        }
        
        // Wenn keine automatische Bewertung, dann als valide markieren
        // Die eigentliche Bewertung erfolgt dann manuell
        return {
            valid: true,
            status: 'valid',
            message: 'Die Antwort erfüllt alle formalen Anforderungen.',
            score: null, // Noch keine Punktzahl vergeben
            maxScore: questionData.points || 0,
            needsManualGrading: true
        };
    }
    
    /**
     * Berechnet eine einfache Punktzahl basierend auf Übereinstimmung mit der Musterlösung
     * @param {string} userAnswer - Die Benutzerantwort
     * @param {string} modelAnswer - Die Musterlösung
     * @param {number} maxScore - Die maximale Punktzahl
     * @returns {number} Die berechnete Punktzahl
     */
    function calculateSimpleScore(userAnswer, modelAnswer, maxScore) {
        if (!userAnswer || !modelAnswer) return 0;
        
        // Normalisierung der Texte
        const normalizedUserAnswer = userAnswer.toLowerCase().trim();
        const normalizedModelAnswer = modelAnswer.toLowerCase().trim();
        
        // Berechnung der Jaccard-Ähnlichkeit
        const userWords = new Set(normalizedUserAnswer.split(/\s+/).filter(w => w.length > 2));
        const modelWords = new Set(normalizedModelAnswer.split(/\s+/).filter(w => w.length > 2));
        
        // Schnittmenge und Vereinigung berechnen
        const intersection = new Set([...userWords].filter(word => modelWords.has(word)));
        const union = new Set([...userWords, ...modelWords]);
        
        // Jaccard-Koeffizient: Größe der Schnittmenge / Größe der Vereinigung
        const similarity = union.size === 0 ? 0 : intersection.size / union.size;
        
        // Punktzahl basierend auf Ähnlichkeit
        const score = Math.round(similarity * maxScore * 10) / 10; // Auf eine Dezimalstelle runden
        
        return score;
    }
    
    /**
     * Prüft, ob die Antwort allen formalen Anforderungen entspricht
     * @param {Object} questionData - Die Fragendaten
     * @param {string} userAnswer - Die vom Benutzer eingegebene Antwort
     * @returns {boolean} Ob die Antwort formal gültig ist
     */
    function isAnswerFormValid(questionData, userAnswer) {
        if (!questionData || !userAnswer) return false;
        
        const result = validateAnswer(questionData, userAnswer);
        return result.valid;
    }
	/**
 * JS-Block 5.5.1-part2: Fragenanzeige - Freitext (Anzeige und Interaktion, Teil 2)
 * 
 * Dieser Block erweitert die Freitext-Funktionalität mit Barrierefreiheits-Features,
 * Validierungsmechanismen, Rechtschreibprüfung und erweiterten Bearbeitungsoptionen.
 */

// IIFE für den Freitext Accessibility-Enhancer
const FreeTextAccessibilityEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    let textareaElement = null;
    
    /**
     * Verbessert die Zugänglichkeit einer Freitext-Frage
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceAccessibility(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        textareaElement = container.querySelector('.free-text-input');
        
        if (!textareaElement) return;
        
        // Aria-Attribute für Barrierefreiheit hinzufügen
        addAriaAttributes();
        
        // Tastatur-Shortcuts für Bearbeitung
        addKeyboardShortcuts();
        
        // Label für Screenreader
        addAccessibleLabels();
    }
    
    /**
     * Fügt ARIA-Attribute für Screenreader-Unterstützung hinzu
     * @returns {void}
     */
    function addAriaAttributes() {
        if (!currentQuestionContainer || !textareaElement) return;
        
        // Fragen-Bereich als "region" markieren
        currentQuestionContainer.setAttribute('role', 'region');
        currentQuestionContainer.setAttribute('aria-label', 'Freitext-Frage');
        
        // Fragentext als "heading" markieren
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        if (questionText) {
            questionText.setAttribute('role', 'heading');
            questionText.setAttribute('aria-level', '3');
        }
        
        // Textarea mit zusätzlichen Attributen
        textareaElement.setAttribute('role', 'textbox');
        textareaElement.setAttribute('aria-multiline', 'true');
        
        // Hinweise auf Mindest-/Maximalzeichen
        const minChars = textareaElement.getAttribute('minlength');
        const maxChars = textareaElement.getAttribute('maxlength');
        
        if (minChars) {
            textareaElement.setAttribute('aria-describedby', 'min-chars-hint');
            
            // Hinweis-Element erstellen, falls nicht vorhanden
            let minCharsHint = currentQuestionContainer.querySelector('#min-chars-hint');
            if (!minCharsHint) {
                minCharsHint = document.createElement('div');
                minCharsHint.id = 'min-chars-hint';
                minCharsHint.className = 'sr-only'; // Nur für Screenreader
                minCharsHint.textContent = `Diese Antwort erfordert mindestens ${minChars} Zeichen.`;
                currentQuestionContainer.appendChild(minCharsHint);
            }
        }
        
        if (maxChars) {
            textareaElement.setAttribute('aria-describedby', 
                (minChars ? 'min-chars-hint max-chars-hint' : 'max-chars-hint'));
            
            // Hinweis-Element erstellen, falls nicht vorhanden
            let maxCharsHint = currentQuestionContainer.querySelector('#max-chars-hint');
            if (!maxCharsHint) {
                maxCharsHint = document.createElement('div');
                maxCharsHint.id = 'max-chars-hint';
                maxCharsHint.className = 'sr-only'; // Nur für Screenreader
                maxCharsHint.textContent = `Diese Antwort ist auf maximal ${maxChars} Zeichen begrenzt.`;
                currentQuestionContainer.appendChild(maxCharsHint);
            }
        }
    }
    
    /**
     * Fügt Tastatur-Shortcuts für die einfachere Bearbeitung hinzu
     * @returns {void}
     */
    function addKeyboardShortcuts() {
        if (!textareaElement) return;
        
        textareaElement.addEventListener('keydown', handleKeyDown);
    }
    
    /**
     * Handler für Tastatur-Events
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleKeyDown(event) {
        // Tab innerhalb der Textarea mit Einrückung
        if (event.key === 'Tab' && !event.shiftKey && !event.ctrlKey && !event.altKey) {
            // Tab-Taste abfangen und Einrückung einfügen
            event.preventDefault();
            
            const start = textareaElement.selectionStart;
            const end = textareaElement.selectionEnd;
            
            // Tab-Zeichen einfügen
            textareaElement.value = 
                textareaElement.value.substring(0, start) + 
                '    ' + // 4 Leerzeichen als Tab
                textareaElement.value.substring(end);
            
            // Cursor nach dem Tab positionieren
            textareaElement.selectionStart = textareaElement.selectionEnd = start + 4;
            
            // Änderung auslösen, um Auto-Save anzustoßen
            const inputEvent = new Event('input', { bubbles: true });
            textareaElement.dispatchEvent(inputEvent);
        }
        
        // Strg+S zum Speichern (verhindert Browser-Speicherdialog)
        if (event.key === 's' && event.ctrlKey) {
            event.preventDefault();
            
            // Speichern-Event auslösen
            const saveEvent = new CustomEvent('manualSave', {
                detail: {
                    sourceElement: textareaElement
                }
            });
            document.dispatchEvent(saveEvent);
            
            // Feedback für den Benutzer
            showSaveFeedback();
        }
    }
    
    /**
     * Zeigt kurzes visuelles Feedback beim manuellen Speichern
     * @returns {void}
     */
    function showSaveFeedback() {
        if (!textareaElement || !currentQuestionContainer) return;
        
        // Finde den Feedback-Container oder erstelle ihn
        let saveIndicator = currentQuestionContainer.querySelector('.save-indicator');
        
        if (!saveIndicator) {
            saveIndicator = document.createElement('div');
            saveIndicator.className = 'save-indicator';
            saveIndicator.setAttribute('aria-live', 'polite');
            currentQuestionContainer.appendChild(saveIndicator);
        }
        
        // Feedback anzeigen
        saveIndicator.textContent = 'Gespeichert';
        saveIndicator.classList.add('visible');
        
        // Nach kurzer Zeit ausblenden
        setTimeout(() => {
            saveIndicator.classList.remove('visible');
        }, 1500);
    }
    
    /**
     * Fügt zugängliche Labels für Screenreader hinzu
     * @returns {void}
     */
    function addAccessibleLabels() {
        if (!textareaElement || !currentQuestionContainer) return;
        
        // Eindeutige ID für die Frage
        const questionId = 'free-text-question-' + Math.random().toString(36).substr(2, 9);
        
        // Fragetext als Label für das Textfeld verwenden
        const questionText = currentQuestionContainer.querySelector('.question-text h3');
        
        if (questionText) {
            questionText.id = questionId;
            textareaElement.setAttribute('aria-labelledby', questionId);
        }
        
        // Charakterzähler für Screenreader zugänglich machen
        const charCounter = currentQuestionContainer.querySelector('.character-counter');
        
        if (charCounter) {
            charCounter.id = 'char-counter-' + questionId;
            charCounter.setAttribute('aria-live', 'polite');
            
            // Zusätzliche Beschreibung mit Zeichenzähler
            let ariaDescribedBy = textareaElement.getAttribute('aria-describedby') || '';
            
            if (ariaDescribedBy) {
                ariaDescribedBy += ' ' + charCounter.id;
            } else {
                ariaDescribedBy = charCounter.id;
            }
            
            textareaElement.setAttribute('aria-describedby', ariaDescribedBy.trim());
        }
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (textareaElement) {
            textareaElement.removeEventListener('keydown', handleKeyDown);
        }
        
        currentQuestionContainer = null;
        textareaElement = null;
    }
    
    // Öffentliche API
    return {
        enhanceAccessibility,
        cleanup
    };
})();

// IIFE für den Freitext-Validator
const FreeTextValidator = (function() {
    /**
     * Validiert die Benutzerantwort
     * @param {Object} questionData - Die Fragendaten
     * @param {string} userAnswer - Die vom Benutzer eingegebene Antwort
     * @param {Object} options - Validierungsoptionen
     * @returns {Object} Validierungsergebnis
     */
    function validateAnswer(questionData, userAnswer, options = {}) {
        if (!questionData) {
            return { 
                valid: false,
                message: 'Ungültige Fragendaten'
            };
        }
        
        // Standardwerte für Validierungsoptionen
        const validationOptions = {
            minCharacters: questionData.options?.minCharacters || 0,
            maxCharacters: questionData.options?.maxCharacters || 0,
            requiredWords: questionData.options?.requiredWords || [],
            autoGrading: questionData.options?.autoGrading || false,
            ...options
        };
        
        // Prüfen, ob überhaupt eine Antwort gegeben wurde
        if (!userAnswer || userAnswer.trim() === '') {
            return {
                valid: false,
                status: 'unanswered',
                message: 'Die Frage wurde nicht beantwortet.',
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen der Mindestanzahl an Zeichen
        if (validationOptions.minCharacters > 0 && userAnswer.length < validationOptions.minCharacters) {
            return {
                valid: false,
                status: 'too_short',
                message: `Die Antwort ist zu kurz. Mindestens ${validationOptions.minCharacters} Zeichen erforderlich.`,
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen der Maximalanzahl an Zeichen
        if (validationOptions.maxCharacters > 0 && userAnswer.length > validationOptions.maxCharacters) {
            return {
                valid: false,
                status: 'too_long',
                message: `Die Antwort ist zu lang. Maximal ${validationOptions.maxCharacters} Zeichen erlaubt.`,
                score: 0,
                maxScore: questionData.points || 0
            };
        }
        
        // Prüfen, ob alle erforderlichen Wörter enthalten sind
        const missingWords = [];
        
        if (validationOptions.requiredWords && validationOptions.requiredWords.length > 0) {
            const normalizedAnswer = userAnswer.toLowerCase();
            
            validationOptions.requiredWords.forEach(word => {
                if (!normalizedAnswer.includes(word.toLowerCase())) {
                    missingWords.push(word);
                }
            });
            
            if (missingWords.length > 0) {
                return {
                    valid: false,
                    status: 'missing_keywords',
                    message: `Folgende Schlüsselwörter fehlen in Ihrer Antwort: ${missingWords.join(', ')}`,
                    score: 0,
                    maxScore: questionData.points || 0,
                    missingWords
                };
            }
        }
        
        // Automatische Bewertung, falls aktiviert
        if (validationOptions.autoGrading && questionData.modelAnswer) {
            // Hier nur eine einfache Bewertung - in Teil 2 wird das erweitert
            const score = calculateSimpleScore(userAnswer, questionData.modelAnswer, questionData.points || 10);
            
            return {
                valid: true,
                status: 'auto_graded',
                message: 'Die Antwort wurde automatisch bewertet.',
                score,
                maxScore: questionData.points || 10,
                autoGraded: true
            };
        }
        
        // Wenn keine automatische Bewertung, dann als valide markieren
        // Die eigentliche Bewertung erfolgt dann manuell
        return {
            valid: true,
            status: 'valid',
            message: 'Die Antwort erfüllt alle formalen Anforderungen.',
            score: null, // Noch keine Punktzahl vergeben
            maxScore: questionData.points || 0,
            needsManualGrading: true
        };
    }
    
    /**
     * Berechnet eine einfache Punktzahl basierend auf Übereinstimmung mit der Musterlösung
     * @param {string} userAnswer - Die Benutzerantwort
     * @param {string} modelAnswer - Die Musterlösung
     * @param {number} maxScore - Die maximale Punktzahl
     * @returns {number} Die berechnete Punktzahl
     */
    function calculateSimpleScore(userAnswer, modelAnswer, maxScore) {
        if (!userAnswer || !modelAnswer) return 0;
        
        // Normalisierung der Texte
        const normalizedUserAnswer = userAnswer.toLowerCase().trim();
        const normalizedModelAnswer = modelAnswer.toLowerCase().trim();
        
        // Berechnung der Jaccard-Ähnlichkeit
        const userWords = new Set(normalizedUserAnswer.split(/\s+/).filter(w => w.length > 2));
        const modelWords = new Set(normalizedModelAnswer.split(/\s+/).filter(w => w.length > 2));
        
        // Schnittmenge und Vereinigung berechnen
        const intersection = new Set([...userWords].filter(word => modelWords.has(word)));
        const union = new Set([...userWords, ...modelWords]);
        
        // Jaccard-Koeffizient: Größe der Schnittmenge / Größe der Vereinigung
        const similarity = union.size === 0 ? 0 : intersection.size / union.size;
        
        // Punktzahl basierend auf Ähnlichkeit
        const score = Math.round(similarity * maxScore * 10) / 10; // Auf eine Dezimalstelle runden
        
        return score;
    }
    
    /**
     * Prüft, ob die Antwort allen formalen Anforderungen entspricht
     * @param {Object} questionData - Die Fragendaten
     * @param {string} userAnswer - Die vom Benutzer eingegebene Antwort
     * @returns {boolean} Ob die Antwort formal gültig ist
     */
    function isAnswerFormValid(questionData, userAnswer) {
        if (!questionData || !userAnswer) return false;
        
        const result = validateAnswer(questionData, userAnswer);
        return result.valid;
    }
    
    /**
     * Generiert einen detaillierten Bericht zur Beantwortung der Frage
     * @param {Object} questionData - Die Fragendaten
     * @param {string} userAnswer - Die vom Benutzer eingegebene Antwort
     * @returns {string} HTML-formatierter Bericht
     */
    function generateDetailedReport(questionData, userAnswer) {
        if (!userAnswer || userAnswer.trim() === '') {
            return '<p class="report-not-answered">Diese Frage wurde nicht beantwortet.</p>';
        }
        
        const validationResult = validateAnswer(questionData, userAnswer);
        
        let reportHtml = '<div class="detailed-answer-report">';
        
        // Überschrift mit Status
        reportHtml += `<h4 class="report-heading ${validationResult.valid ? 'valid' : 'invalid'}">`;
        
        if (validationResult.valid) {
            reportHtml += '<i class="fas fa-check-circle"></i> Antwort erfasst';
        } else {
            reportHtml += '<i class="fas fa-exclamation-circle"></i> Formale Anforderungen nicht erfüllt';
        }
        
        reportHtml += '</h4>';
        
        // Antworttext anzeigen
        reportHtml += '<div class="answer-content">';
        reportHtml += '<h5>Ihre Antwort:</h5>';
        reportHtml += `<div class="user-answer">${escapeHTML(userAnswer) || '<em>Keine Antwort angegeben</em>'}</div>`;
        reportHtml += '</div>';
        
        // Validierungsdetails anzeigen
        reportHtml += '<div class="validation-details">';
        
        // Anforderungen anzeigen
        reportHtml += '<h5>Anforderungen:</h5>';
        reportHtml += '<ul class="requirements-list">';
        
        // Zeichenanzahl
        const minChars = questionData.options?.minCharacters || 0;
        const maxChars = questionData.options?.maxCharacters || 0;
        const charCount = userAnswer.length;
        
        if (minChars > 0) {
            const isMinMet = charCount >= minChars;
            reportHtml += `
                <li class="${isMinMet ? 'requirement-met' : 'requirement-not-met'}">
                    <i class="fas ${isMinMet ? 'fa-check' : 'fa-times'}"></i>
                    Mindestens ${minChars} Zeichen 
                    <span class="requirement-status">(${charCount} / ${minChars})</span>
                </li>
            `;
        }
        
        if (maxChars > 0) {
            const isMaxMet = charCount <= maxChars;
            reportHtml += `
                <li class="${isMaxMet ? 'requirement-met' : 'requirement-not-met'}">
                    <i class="fas ${isMaxMet ? 'fa-check' : 'fa-times'}"></i>
                    Maximal ${maxChars} Zeichen
                    <span class="requirement-status">(${charCount} / ${maxChars})</span>
                </li>
            `;
        }
        
        // Erforderliche Wörter
        const requiredWords = questionData.options?.requiredWords || [];
        if (requiredWords.length > 0) {
            const normalizedAnswer = userAnswer.toLowerCase();
            
            requiredWords.forEach(word => {
                const isIncluded = normalizedAnswer.includes(word.toLowerCase());
                reportHtml += `
                    <li class="${isIncluded ? 'requirement-met' : 'requirement-not-met'}">
                        <i class="fas ${isIncluded ? 'fa-check' : 'fa-times'}"></i>
                        Enthält "${word}"
                    </li>
                `;
            });
        }
        
        reportHtml += '</ul>';
        
        // Bewertungsinformationen
        if (validationResult.autoGraded) {
            reportHtml += `
                <div class="scoring-info">
                    <h5>Automatische Bewertung:</h5>
                    <p>Punktzahl: ${validationResult.score} / ${validationResult.maxScore}</p>
                    <p class="auto-grade-note">Hinweis: Dies ist eine automatische Bewertung und kann von der finalen Bewertung abweichen.</p>
                </div>
            `;
        } else if (validationResult.needsManualGrading) {
            reportHtml += `
                <div class="scoring-info">
                    <h5>Bewertung ausstehend</h5>
                    <p>Diese Antwort wird manuell bewertet.</p>
                </div>
            `;
        }
        
        reportHtml += '</div>';
        
        // Falls im Fragetyp eine Musterlösung hinterlegt ist, diese anzeigen
        if (questionData.modelAnswer) {
            reportHtml += `
                <div class="model-answer-section">
                    <h5>Musterlösung:</h5>
                    <div class="model-answer">${escapeHTML(questionData.modelAnswer)}</div>
                </div>
            `;
        }
        
        reportHtml += '</div>';
        
        return reportHtml;
    }
    
    /**
     * Hilfsfunktion zum Escapen von HTML-Sonderzeichen
     * @param {string} text - Der zu escapende Text
     * @returns {string} Der escapte Text
     */
    function escapeHTML(text) {
        if (!text) return '';
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML.replace(/\n/g, '<br>');
    }
    
    // Öffentliche API
    return {
        validateAnswer,
        isAnswerFormValid,
        generateDetailedReport
    };
})();

// IIFE für den Freitext-Enhancer mit zusätzlichen Funktionen
const FreeTextEnhancer = (function() {
    // Private Variablen und Funktionen
    let currentQuestionContainer = null;
    let textareaElement = null;
    let toolbarElement = null;
    
    /**
     * Erweitert das Freitext-Eingabefeld mit zusätzlichen Funktionen
     * @param {HTMLElement} container - Der Frage-Container
     * @returns {void}
     */
    function enhanceTextarea(container) {
        if (!container) return;
        
        currentQuestionContainer = container;
        textareaElement = container.querySelector('.free-text-input');
        
        if (!textareaElement) return;
        
        // Bearbeitungsleiste hinzufügen
        addEditingToolbar();
        
        // Rechtschreibprüfung konfigurieren
        configureSpellCheck();
        
        // Erweiterte Bearbeitungsfunktionen
        enableAdvancedEditing();
    }
    
    /**
     * Fügt eine Bearbeitungsleiste mit Formatierungsoptionen hinzu
     * @returns {void}
     */
    function addEditingToolbar() {
        if (!textareaElement || !currentQuestionContainer) return;
        
        // Toolbar-Container erstellen
        toolbarElement = document.createElement('div');
        toolbarElement.className = 'editing-toolbar';
        
        // Toolbar-Buttons hinzufügen
        const toolbarButtons = [
            { icon: 'fa-bold', title: 'Fett (Strg+B)', action: 'bold' },
            { icon: 'fa-italic', title: 'Kursiv (Strg+I)', action: 'italic' },
            { icon: 'fa-underline', title: 'Unterstrichen (Strg+U)', action: 'underline' },
            { icon: 'fa-list-ul', title: 'Aufzählung', action: 'bullet-list' },
            { icon: 'fa-list-ol', title: 'Nummerierte Liste', action: 'numbered-list' },
            { icon: 'fa-indent', title: 'Einrücken (Tab)', action: 'indent' },
            { icon: 'fa-outdent', title: 'Ausrücken (Shift+Tab)', action: 'outdent' },
            { icon: 'fa-eraser', title: 'Formatierung entfernen', action: 'clear-format' }
        ];
        
        toolbarButtons.forEach(button => {
            const btnElement = document.createElement('button');
            btnElement.type = 'button';
            btnElement.className = 'toolbar-button';
            btnElement.title = button.title;
            btnElement.dataset.action = button.action;
            btnElement.innerHTML = `<i class="fas ${button.icon}"></i>`;
            
            btnElement.addEventListener('click', () => handleToolbarAction(button.action));
            
            toolbarElement.appendChild(btnElement);
        });
        
        // Toolbar vor dem Textfeld einfügen
        const answerContainer = textareaElement.parentElement;
        if (answerContainer) {
            answerContainer.insertBefore(toolbarElement, textareaElement);
        }
    }
    
    /**
     * Konfiguriert die Rechtschreibprüfung für das Textfeld
     * @returns {void}
     */
    function configureSpellCheck() {
        if (!textareaElement) return;
        
        // Rechtschreibprüfung aktivieren
        textareaElement.setAttribute('spellcheck', 'true');
        
        // Sprache erkennen, falls möglich
        const docLang = document.documentElement.lang || 'de';
        textareaElement.setAttribute('lang', docLang);
        
        // Autokorrektur deaktivieren (besser manuell kontrollieren)
        textareaElement.setAttribute('autocorrect', 'off');
    }
    
    /**
     * Aktiviert erweiterte Bearbeitungsfunktionen über Tastaturkürzel
     * @returns {void}
     */
    function enableAdvancedEditing() {
        if (!textareaElement) return;
        
        textareaElement.addEventListener('keydown', handleEditingShortcuts);
    }
    
    /**
     * Handler für Toolbar-Aktionen
     * @param {string} action - Die auszuführende Aktion
     * @returns {void}
     */
    function handleToolbarAction(action) {
        if (!textareaElement) return;
        
        // Aktuelle Auswahl speichern
        const startPos = textareaElement.selectionStart;
        const endPos = textareaElement.selectionEnd;
        const selectedText = textareaElement.value.substring(startPos, endPos);
        
        let newText = '';
        let newCursorPos = endPos;
        
        // Je nach Aktion unterschiedliche Formatierung anwenden
        switch (action) {
            case 'bold':
                newText = `**${selectedText}**`;
                newCursorPos = startPos + newText.length;
                break;
                
            case 'italic':
                newText = `*${selectedText}*`;
                newCursorPos = startPos + newText.length;
                break;
                
            case 'underline':
                newText = `_${selectedText}_`;
                newCursorPos = startPos + newText.length;
                break;
                
            case 'bullet-list':
                // Jede Zeile mit Bullet beginnen
                if (selectedText) {
                    const lines = selectedText.split('\n');
                    newText = lines.map(line => `• ${line}`).join('\n');
                } else {
                    newText = '• ';
                }
                newCursorPos = startPos + newText.length;
                break;
                
            case 'numbered-list':
                // Jede Zeile nummerieren
                if (selectedText) {
                    const lines = selectedText.split('\n');
                    newText = lines.map((line, index) => `${index + 1}. ${line}`).join('\n');
                } else {
                    newText = '1. ';
                }
                newCursorPos = startPos + newText.length;
                break;
                
            case 'indent':
                // Vier Leerzeichen am Anfang jeder Zeile
                if (selectedText) {
                    const lines = selectedText.split('\n');
                    newText = lines.map(line => `    ${line}`).join('\n');
                } else {
                    newText = '    ';
                }
                newCursorPos = startPos + newText.length;
                break;
                
            case 'outdent':
                // Einrückung entfernen (bis zu 4 Leerzeichen)
                if (selectedText) {
                    const lines = selectedText.split('\n');
                    newText = lines.map(line => line.replace(/^[ \t]{1,4}/, '')).join('\n');
                } else {
                    newText = selectedText;
                }
                newCursorPos = startPos + newText.length;
                break;
                
            case 'clear-format':
                // Formatierungszeichen entfernen
                newText = selectedText.replace(/(\*\*|\*|_|~|`)/g, '');
                newCursorPos = startPos + newText.length;
                break;
        }
        
        // Text einfügen
        if (newText !== selectedText) {
            textareaElement.value = 
                textareaElement.value.substring(0, startPos) + 
                newText + 
                textareaElement.value.substring(endPos);
                
            // Cursor positionieren
            textareaElement.selectionStart = textareaElement.selectionEnd = newCursorPos;
            
            // Änderung auslösen
            const inputEvent = new Event('input', { bubbles: true });
            textareaElement.dispatchEvent(inputEvent);
            
            // Fokus zurück auf Textfeld
            textareaElement.focus();
        }
    }
    
    /**
     * Handler für Tastaturkürzel zur Textformatierung
     * @param {KeyboardEvent} event - Das Tastatur-Event
     * @returns {void}
     */
    function handleEditingShortcuts(event) {
        // Formatierungs-Shortcuts nur mit Strg-Taste
        if (!event.ctrlKey) return;
        
        switch (event.key.toLowerCase()) {
            case 'b': // Bold
                event.preventDefault();
                handleToolbarAction('bold');
                break;
                
            case 'i': // Italic
                event.preventDefault();
                handleToolbarAction('italic');
                break;
                
            case 'u': // Underline
                event.preventDefault();
                handleToolbarAction('underline');
                break;
        }
    }
    
    /**
     * Entfernt alle Event-Listener und bereinigt Ressourcen
     * @returns {void}
     */
    function cleanup() {
        if (textareaElement) {
            textareaElement.removeEventListener('keydown', handleEditingShortcuts);
        }
        
        if (toolbarElement) {
            // Alle Button-Listener entfernen
            const buttons = toolbarElement.querySelectorAll('.toolbar-button');
            buttons.forEach(button => {
                button.replaceWith(button.cloneNode(true));
            });
        }
        
        currentQuestionContainer = null;
        textareaElement = null;
        toolbarElement = null;
    }
    
    // Öffentliche API
    return {
        enhanceTextarea,
        cleanup
    };
})();

// Verbindung mit dem Rest des Systems
document.addEventListener('DOMContentLoaded', function() {
    // Event-Listener für Frage-Initialisierung
    document.addEventListener('questionRendered', function(event) {
        if (event.detail && event.detail.type === 'free-text' && event.detail.container) {
            // Barrierefreiheit verbessern
            FreeTextAccessibilityEnhancer.enhanceAccessibility(event.detail.container);
            
            // Erweiterte Funktionen hinzufügen
            FreeTextEnhancer.enhanceTextarea(event.detail.container);
        }
    });
    
    // Manuelles Speichern über Strg+S
    document.addEventListener('manualSave', function(event) {
        if (event.detail && event.detail.sourceElement) {
            // "Save" Button suchen und triggern oder direkt Speicherfunktion aufrufen
            const saveButton = document.querySelector('.save-answer-button');
            if (saveButton) {
                saveButton.click();
            } else if (typeof FreeTextQuestionHandler !== 'undefined' && 
                       typeof FreeTextQuestionHandler.saveAnswer === 'function') {
                FreeTextQuestionHandler.saveAnswer();
            }
        }
    });
    
    // Validator registrieren, falls das Registry-Objekt existiert
    if (typeof ValidationRegistry !== 'undefined') {
        ValidationRegistry.registerValidator('free-text', FreeTextValidator);
    }
});

// CSS-Stile für erweiterte Freitext-Funktionen
(function addFreeTextEnhancementStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Bearbeitungsleiste */
        .editing-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .toolbar-button {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .toolbar-button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        
        .toolbar-button:active {
            background-color: #dae0e5;
            transform: translateY(1px);
        }
        
        /* Speicher-Indikator */
        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #00FFD0;
            color: #333;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .save-indicator.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Screenreader-only Elemente */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Detaillierter Bericht */
        .detailed-answer-report {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .report-heading {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .report-heading i {
            margin-right: 10px;
        }
        
        .report-heading.valid {
            color: #28a745;
        }
        
        .report-heading.invalid {
            color: #dc3545;
        }
        
        .answer-content {
            margin-bottom: 15px;
        }
        
        .requirements-list {
            list-style: none;
            padding-left: 0;
        }
        
        .requirements-list li {
            padding: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .requirements-list li i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        
        .requirement-met {
            color: #28a745;
        }
        
        .requirement-not-met {
            color: #dc3545;
        }
        
        .requirement-status {
            margin-left: 10px;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .scoring-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .auto-grade-note {
            font-style: italic;
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .model-answer-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        
        .model-answer {
            background-color: rgba(0, 255, 208, 0.1);
            border: 1px solid #00B090;
            border-left: 4px solid #00B090;
            border-radius: 4px;
            padding: 10px;
            white-space: pre-wrap;
        }
    `;
    document.head.appendChild(styleElement);
})();
/**
 * JS-Block 5.6.1-part1: Datenstruktur für Antworten (Teil 1)
 * 
 * Dieser Block definiert die Datenstrukturen zum Speichern von Benutzerantworten
 * während und nach der Testdurchführung.
 */

// Namespace für die Antwortenspeicherung definieren
app.answerStorage = {};

// Konfiguration für das Antwortspeichersystem
app.answerStorage.config = {
    // Speicherintervall für automatisches Speichern (in Millisekunden)
    autoSaveInterval: 30000, // 30 Sekunden
    
    // Maximale Anzahl an Historie-Einträgen pro Antwort
    maxHistoryEntries: 5,
    
    // Flag für erweiterte Debugging-Informationen
    debugMode: false,
    
    // Flag für lokale Zwischenspeicherung im localStorage
    enableLocalStorage: true,
    
    // Schlüssel für localStorage
    localStorageKey: 'immoscout24_test_answers'
};

/**
 * Datenstruktur für eine einzelne Antwort
 * @typedef {Object} Answer
 * @property {string} questionId - ID der beantworteten Frage
 * @property {string} testId - ID des Tests, zu dem die Frage gehört
 * @property {string} sessionId - ID der Testsitzung
 * @property {string} userId - ID des Benutzers, der die Frage beantwortet hat
 * @property {*} value - Der Wert der Antwort (abhängig vom Fragetyp)
 * @property {string} questionType - Typ der Frage (multiple-choice, single-choice, true-false, free-text)
 * @property {number} timestamp - Zeitstempel der Antwortabgabe
 * @property {boolean} isSubmitted - Flag, ob die Antwort final abgegeben wurde
 * @property {boolean} isCorrect - Flag, ob die Antwort als korrekt bewertet wurde (wenn automatisch auswertbar)
 * @property {number} score - Erreichte Punktzahl für diese Antwort (falls anwendbar)
 * @property {Array<Object>} history - Verlauf früherer Antwortversionen
 * @property {Object} metadata - Zusätzliche Metadaten zur Antwort
 */

/**
 * Erstellt ein neues Answer-Objekt mit Standardwerten
 * @param {string} questionId - ID der Frage
 * @param {string} testId - ID des Tests
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} userId - ID des Benutzers
 * @param {string} questionType - Fragetyp
 * @returns {Answer} Ein neu initialisiertes Answer-Objekt
 */
app.answerStorage.createAnswer = function(questionId, testId, sessionId, userId, questionType) {
    return {
        questionId: questionId,
        testId: testId,
        sessionId: sessionId,
        userId: userId,
        value: null, // Standardwert abhängig vom Fragetyp wird später gesetzt
        questionType: questionType,
        timestamp: Date.now(),
        isSubmitted: false,
        isCorrect: null, // Wird erst nach Auswertung gesetzt
        score: 0,
        history: [],
        metadata: {
            timeSpent: 0,       // Zeit in Millisekunden, die der Benutzer mit dieser Frage verbracht hat
            interactions: 0,     // Anzahl der Interaktionen mit dieser Frage
            lastModified: null,  // Zeitpunkt der letzten Änderung
            device: app.utils.detectDeviceType(), // Gerätetyp (Desktop, Tablet, Mobile)
            browser: app.utils.detectBrowser()    // Verwendeter Browser
        }
    };
};

/**
 * Spezifische Initialisierung für verschiedene Fragetypen
 * Setzt den entsprechenden Standardwert für value
 */
app.answerStorage.initializeAnswerValue = function(answer) {
    switch(answer.questionType) {
        case 'multiple-choice':
            answer.value = []; // Array für ausgewählte Optionen
            break;
        case 'single-choice':
            answer.value = null; // ID der ausgewählten Option
            break;
        case 'true-false':
            answer.value = null; // true, false oder null
            break;
        case 'free-text':
            answer.value = ''; // Leerer Text
            break;
        default:
            console.warn(`Unbekannter Fragetyp: ${answer.questionType}`);
            answer.value = null;
    }
    return answer;
};

/**
 * Datenstruktur für eine Antwortensammlung (alle Antworten in einer Testsitzung)
 * @typedef {Object} AnswerCollection
 * @property {string} sessionId - ID der Testsitzung
 * @property {string} testId - ID des Tests
 * @property {string} userId - ID des Benutzers
 * @property {Object.<string, Answer>} answers - Key-Value-Store von Frage-IDs zu Antworten
 * @property {number} startTime - Zeitstempel des Testbeginns
 * @property {number} lastUpdateTime - Zeitstempel der letzten Aktualisierung
 * @property {boolean} isCompleted - Flag, ob der Test abgeschlossen wurde
 * @property {Object} summary - Zusammenfassung der Ergebnisse (wird nach Abschluss gefüllt)
 */

/**
 * Erstellt eine neue Antwortensammlung für eine Testsitzung
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} testId - ID des Tests
 * @param {string} userId - ID des Benutzers
 * @returns {AnswerCollection} Eine neue Antwortensammlung
 */
app.answerStorage.createAnswerCollection = function(sessionId, testId, userId) {
    return {
        sessionId: sessionId,
        testId: testId,
        userId: userId,
        answers: {},
        startTime: Date.now(),
        lastUpdateTime: Date.now(),
        isCompleted: false,
        summary: {
            totalQuestions: 0,
            answeredQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            partiallyCorrectAnswers: 0,
            unansweredQuestions: 0,
            totalScore: 0,
            maxPossibleScore: 0,
            percentageScore: 0,
            timeTaken: 0,
            isPassed: null
        }
    };
};

/**
 * In-Memory-Speicher für aktive Antwortensammlungen
 * Key: sessionId, Value: AnswerCollection
 */
app.answerStorage.activeCollections = {};

/**
 * Erstellt und registriert eine neue Antwortensammlung für eine Testsitzung
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} testId - ID des Tests
 * @param {string} userId - ID des Benutzers
 * @returns {AnswerCollection} Die erstellte Antwortensammlung
 */
app.answerStorage.initializeCollection = function(sessionId, testId, userId) {
    const collection = this.createAnswerCollection(sessionId, testId, userId);
    this.activeCollections[sessionId] = collection;
    
    // Wenn lokalSpeicherung aktiviert ist, initialisierer wir auch dort
    if (this.config.enableLocalStorage) {
        this.saveToLocalStorage(collection);
    }
    
    if (this.config.debugMode) {
        console.log(`Antwortensammlung für Sitzung ${sessionId} initialisiert`, collection);
    }
    
    return collection;
};

/**
 * Holt eine aktive Antwortensammlung nach sessionId
 * @param {string} sessionId - ID der Testsitzung
 * @returns {AnswerCollection|null} Die Antwortensammlung oder null, wenn nicht gefunden
 */
app.answerStorage.getCollection = function(sessionId) {
    // Zuerst im aktiven In-Memory-Speicher prüfen
    if (this.activeCollections[sessionId]) {
        return this.activeCollections[sessionId];
    }
    
    // Falls nicht im Speicher, versuchen aus localStorage zu laden
    if (this.config.enableLocalStorage) {
        const storedCollection = this.loadFromLocalStorage(sessionId);
        if (storedCollection) {
            // In den aktiven Speicher übernehmen
            this.activeCollections[sessionId] = storedCollection;
            return storedCollection;
        }
    }
    
    // Nicht gefunden
    if (this.config.debugMode) {
        console.warn(`Keine Antwortensammlung für Sitzung ${sessionId} gefunden`);
    }
    
    return null;
};

/**
 * Integration mit dem localStorage für Persistenz
 */

/**
 * Speichert eine Antwortensammlung im localStorage
 * @param {AnswerCollection} collection - Die zu speichernde Sammlung
 */
app.answerStorage.saveToLocalStorage = function(collection) {
    try {
        if (!this.config.enableLocalStorage) return;
        
        const storageKey = `${this.config.localStorageKey}_${collection.sessionId}`;
        const serialized = JSON.stringify(collection);
        localStorage.setItem(storageKey, serialized);
        
        if (this.config.debugMode) {
            console.log(`Antwortensammlung für Sitzung ${collection.sessionId} im localStorage gespeichert`);
        }
    } catch (error) {
        console.error('Fehler beim Speichern der Antwortensammlung im localStorage:', error);
    }
};

/**
 * Lädt eine Antwortensammlung aus dem localStorage
 * @param {string} sessionId - ID der Testsitzung
 * @returns {AnswerCollection|null} Die geladene Sammlung oder null bei Fehler
 */
app.answerStorage.loadFromLocalStorage = function(sessionId) {
    try {
        if (!this.config.enableLocalStorage) return null;
        
        const storageKey = `${this.config.localStorageKey}_${sessionId}`;
        const serialized = localStorage.getItem(storageKey);
        
        if (!serialized) {
            return null;
        }
        
        const collection = JSON.parse(serialized);
        
        if (this.config.debugMode) {
            console.log(`Antwortensammlung für Sitzung ${sessionId} aus localStorage geladen`);
        }
        
        return collection;
    } catch (error) {
        console.error('Fehler beim Laden der Antwortensammlung aus localStorage:', error);
        return null;
    }
};

/**
 * Löscht eine Antwortensammlung aus dem localStorage
 * @param {string} sessionId - ID der Testsitzung
 */
app.answerStorage.removeFromLocalStorage = function(sessionId) {
    try {
        if (!this.config.enableLocalStorage) return;
        
        const storageKey = `${this.config.localStorageKey}_${sessionId}`;
        localStorage.removeItem(storageKey);
        
        if (this.config.debugMode) {
            console.log(`Antwortensammlung für Sitzung ${sessionId} aus localStorage entfernt`);
        }
    } catch (error) {
        console.error('Fehler beim Entfernen der Antwortensammlung aus localStorage:', error);
    }
};

// Hilfsfunktionen für die Interaktion mit dem TestSessionManager

/**
 * Synchronisiert die Antwortensammlung mit dem TestSessionManager
 * @param {string} sessionId - ID der Testsitzung
 */
app.answerStorage.syncWithSessionManager = function(sessionId) {
    try {
        const collection = this.getCollection(sessionId);
        if (!collection) {
            throw new Error(`Keine Antwortensammlung für Sitzung ${sessionId} gefunden`);
        }
        
        // Testsitzung aus dem SessionManager holen
        const session = app.testSessionManager.getSession(sessionId);
        if (!session) {
            throw new Error(`Keine Testsitzung mit ID ${sessionId} im SessionManager gefunden`);
        }
        
        // Antworten in die Session übertragen
        session.answers = collection.answers;
        
        // Session-Status aktualisieren
        session.lastActivityTimestamp = Date.now();
        
        // Fortschritt berechnen und aktualisieren
        const totalQuestions = Object.keys(session.testData.questions || {}).length;
        const answeredQuestions = Object.keys(collection.answers).length;
        session.progress = totalQuestions > 0 ? (answeredQuestions / totalQuestions) * 100 : 0;
        
        // Session im Manager aktualisieren
        app.testSessionManager.updateSession(session);
        
        if (this.config.debugMode) {
            console.log(`Antwortensammlung mit SessionManager synchronisiert`, {
                sessionId,
                progress: session.progress,
                answeredQuestions,
                totalQuestions
            });
        }
    } catch (error) {
        console.error('Fehler bei der Synchronisation mit dem SessionManager:', error);
    }
};

// Export der Schnittstelle für die Verwendung in anderen Modulen
app.answerStorage.interface = {
    initialize: app.answerStorage.initializeCollection,
    getCollection: app.answerStorage.getCollection,
    syncWithSessionManager: app.answerStorage.syncWithSessionManager
};

// Initialisierung beim Laden
(function() {
    console.log('Antwortenspeicher-Modul initialisiert');
    
    // Event-Listener für automatische Speicherung
    if (app.answerStorage.config.autoSaveInterval > 0) {
        setInterval(function() {
            // Alle aktiven Sammlungen im localStorage speichern
            Object.values(app.answerStorage.activeCollections).forEach(function(collection) {
                if (!collection.isCompleted) {
                    app.answerStorage.saveToLocalStorage(collection);
                }
            });
        }, app.answerStorage.config.autoSaveInterval);
    }
})();
/**
 * JS-Block 5.6.1-part2: Datenstruktur für Antworten (Teil 2)
 * 
 * Dieser Block erweitert die Datenstruktur um typspezifische Funktionen,
 * Validierung und fortgeschrittene Features für das Antwortensystem.
 */

// Typspezifische Funktionen für die verschiedenen Fragetypen
app.answerStorage.typeHandlers = {};

/**
 * Handler für Multiple-Choice-Fragen
 */
app.answerStorage.typeHandlers['multiple-choice'] = {
    /**
     * Antwort für Multiple-Choice-Frage aktualisieren
     * @param {Answer} answer - Das Antwortobjekt
     * @param {string[]} selectedOptionIds - Array der ausgewählten Optionen-IDs
     * @returns {Answer} Das aktualisierte Antwortobjekt
     */
    updateAnswer: function(answer, selectedOptionIds) {
        // Historischen Eintrag erstellen, bevor wir die Änderung vornehmen
        app.answerStorage.addToHistory(answer);
        
        // Antwort aktualisieren
        answer.value = Array.isArray(selectedOptionIds) ? [...selectedOptionIds] : [];
        answer.timestamp = Date.now();
        answer.metadata.lastModified = Date.now();
        answer.metadata.interactions++;
        
        return answer;
    },
    
    /**
     * Antwort bewerten (automatische Bewertung)
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit den korrekten Antworten
     * @returns {Object} Bewertungsergebnis mit Score und Korrektheit
     */
    evaluate: function(answer, question) {
        const selectedOptions = answer.value || [];
        const correctOptions = question.correctOptions || [];
        
        // Übereinstimmende Optionen zählen
        const correctSelections = selectedOptions.filter(id => correctOptions.includes(id));
        const incorrectSelections = selectedOptions.filter(id => !correctOptions.includes(id));
        
        // Punkteberechnung
        let score = 0;
        let isCorrect = false;
        
        // Volle Punktzahl, wenn alle richtigen Optionen ausgewählt und keine falschen
        if (correctSelections.length === correctOptions.length && incorrectSelections.length === 0) {
            score = question.points || 1;
            isCorrect = true;
        } 
        // Teilpunkte, wenn einige richtige Optionen ausgewählt wurden und keine falschen
        else if (correctSelections.length > 0 && incorrectSelections.length === 0) {
            score = ((correctSelections.length / correctOptions.length) * (question.points || 1)).toFixed(2);
            isCorrect = null; // teilweise korrekt
        }
        
        return {
            score: parseFloat(score),
            isCorrect: isCorrect,
            details: {
                totalOptions: (question.options || []).length,
                correctOptions: correctOptions.length,
                selectedOptions: selectedOptions.length,
                correctSelections: correctSelections.length,
                incorrectSelections: incorrectSelections.length
            }
        };
    },
    
    /**
     * Prüft, ob die Antwort gültig ist (nicht unbedingt korrekt)
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit Validierungsregeln
     * @returns {boolean} Ob die Antwort gültig ist
     */
    validate: function(answer, question) {
        const selectedOptions = answer.value || [];
        
        // Prüfung auf Mindestzahl ausgewählter Optionen
        if (question.validation && question.validation.minSelected) {
            if (selectedOptions.length < question.validation.minSelected) {
                return false;
            }
        }
        
        // Prüfung auf Höchstzahl ausgewählter Optionen
        if (question.validation && question.validation.maxSelected) {
            if (selectedOptions.length > question.validation.maxSelected) {
                return false;
            }
        }
        
        return true;
    }
};

/**
 * Handler für Single-Choice-Fragen
 */
app.answerStorage.typeHandlers['single-choice'] = {
    /**
     * Antwort für Single-Choice-Frage aktualisieren
     * @param {Answer} answer - Das Antwortobjekt
     * @param {string} selectedOptionId - ID der ausgewählten Option
     * @returns {Answer} Das aktualisierte Antwortobjekt
     */
    updateAnswer: function(answer, selectedOptionId) {
        // Historischen Eintrag erstellen, bevor wir die Änderung vornehmen
        app.answerStorage.addToHistory(answer);
        
        // Antwort aktualisieren
        answer.value = selectedOptionId;
        answer.timestamp = Date.now();
        answer.metadata.lastModified = Date.now();
        answer.metadata.interactions++;
        
        return answer;
    },
    
    /**
     * Antwort bewerten (automatische Bewertung)
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit den korrekten Antworten
     * @returns {Object} Bewertungsergebnis mit Score und Korrektheit
     */
    evaluate: function(answer, question) {
        const selectedOption = answer.value;
        const correctOption = question.correctOption;
        
        // Einfacher Vergleich - entweder richtig oder falsch
        const isCorrect = selectedOption === correctOption;
        const score = isCorrect ? (question.points || 1) : 0;
        
        return {
            score: score,
            isCorrect: isCorrect,
            details: {
                selectedOption: selectedOption,
                correctOption: correctOption
            }
        };
    },
    
    /**
     * Prüft, ob die Antwort gültig ist (nicht unbedingt korrekt)
     * @param {Answer} answer - Das Antwortobjekt
     * @returns {boolean} Ob die Antwort gültig ist
     */
    validate: function(answer) {
        // Bei Single-Choice muss ein Wert ausgewählt sein
        return answer.value !== null && answer.value !== undefined;
    }
};

/**
 * Handler für Wahr/Falsch-Fragen
 */
app.answerStorage.typeHandlers['true-false'] = {
    /**
     * Antwort für Wahr/Falsch-Frage aktualisieren
     * @param {Answer} answer - Das Antwortobjekt
     * @param {boolean} value - Ausgewählter Wert (true/false)
     * @returns {Answer} Das aktualisierte Antwortobjekt
     */
    updateAnswer: function(answer, value) {
        // Historischen Eintrag erstellen, bevor wir die Änderung vornehmen
        app.answerStorage.addToHistory(answer);
        
        // Antwort aktualisieren (stellen sicher, dass es ein boolescher Wert ist)
        answer.value = value === true || value === false ? value : null;
        answer.timestamp = Date.now();
        answer.metadata.lastModified = Date.now();
        answer.metadata.interactions++;
        
        return answer;
    },
    
    /**
     * Antwort bewerten (automatische Bewertung)
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit der korrekten Antwort
     * @returns {Object} Bewertungsergebnis mit Score und Korrektheit
     */
    evaluate: function(answer, question) {
        const selectedValue = answer.value;
        const correctValue = question.correctValue;
        
        // Direkter Vergleich der booleschen Werte
        const isCorrect = selectedValue === correctValue;
        const score = isCorrect ? (question.points || 1) : 0;
        
        return {
            score: score,
            isCorrect: isCorrect,
            details: {
                selectedValue: selectedValue,
                correctValue: correctValue
            }
        };
    },
    
    /**
     * Prüft, ob die Antwort gültig ist
     * @param {Answer} answer - Das Antwortobjekt
     * @returns {boolean} Ob die Antwort gültig ist
     */
    validate: function(answer) {
        return answer.value === true || answer.value === false;
    }
};

/**
 * Handler für Freitext-Fragen
 */
app.answerStorage.typeHandlers['free-text'] = {
    /**
     * Antwort für Freitext-Frage aktualisieren
     * @param {Answer} answer - Das Antwortobjekt
     * @param {string} text - Eingegebener Text
     * @returns {Answer} Das aktualisierte Antwortobjekt
     */
    updateAnswer: function(answer, text) {
        // Nur zur Historie hinzufügen, wenn sich der Text wesentlich geändert hat
        if (!answer.value || Math.abs(answer.value.length - text.length) > 10) {
            app.answerStorage.addToHistory(answer);
        }
        
        // Antwort aktualisieren
        answer.value = text || '';
        answer.timestamp = Date.now();
        answer.metadata.lastModified = Date.now();
        answer.metadata.interactions++;
        
        // Bei Freitext, zusätzliche Metadaten erfassen
        if (!answer.metadata.textMetrics) {
            answer.metadata.textMetrics = {};
        }
        
        answer.metadata.textMetrics.charCount = text ? text.length : 0;
        answer.metadata.textMetrics.wordCount = text ? text.split(/\s+/).filter(Boolean).length : 0;
        
        return answer;
    },
    
    /**
     * Antwort bewerten (automatische Bewertung wenn möglich, sonst für manuelle Bewertung vorbereiten)
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit Bewertungskriterien
     * @returns {Object} Bewertungsergebnis oder Hinweis auf manuelle Bewertung
     */
    evaluate: function(answer, question) {
        const text = answer.value || '';
        
        // Standardfall: Manuelle Bewertung erforderlich
        if (!question.autoEvaluate) {
            return {
                requiresManualEvaluation: true,
                score: null,
                isCorrect: null,
                details: {
                    textLength: text.length,
                    wordCount: text.split(/\s+/).filter(Boolean).length
                }
            };
        }
        
        // Automatische Bewertung, wenn konfiguriert
        let score = 0;
        let isCorrect = false;
        const details = {
            keywordsFound: [],
            keywordsMissing: [],
            keywordMatches: 0,
            totalRequiredKeywords: 0
        };
        
        // Bewertung basierend auf Schlüsselwörtern
        if (question.keywords && question.keywords.length > 0) {
            details.totalRequiredKeywords = question.keywords.length;
            
            // Prüfen, welche Schlüsselwörter enthalten sind
            question.keywords.forEach(keyword => {
                if (text.toLowerCase().includes(keyword.toLowerCase())) {
                    details.keywordsFound.push(keyword);
                    details.keywordMatches++;
                } else {
                    details.keywordsMissing.push(keyword);
                }
            });
            
            // Punkteberechnung basierend auf gefundenen Schlüsselwörtern
            if (details.keywordMatches === details.totalRequiredKeywords) {
                score = question.points || 1;
                isCorrect = true;
            } else if (details.keywordMatches > 0) {
                score = ((details.keywordMatches / details.totalRequiredKeywords) * (question.points || 1)).toFixed(2);
                isCorrect = null; // teilweise korrekt
            }
        }
        
        // Exakte Textübereinstimmung (wenn konfiguriert)
        if (question.exactMatch && question.exactMatch === text) {
            score = question.points || 1;
            isCorrect = true;
            details.exactMatchFound = true;
        }
        
        return {
            score: parseFloat(score),
            isCorrect: isCorrect,
            details: details
        };
    },
    
    /**
     * Prüft, ob die Antwort gültig ist
     * @param {Answer} answer - Das Antwortobjekt
     * @param {Object} question - Das Fragenobjekt mit Validierungsregeln
     * @returns {boolean} Ob die Antwort gültig ist
     */
    validate: function(answer, question) {
        const text = answer.value || '';
        
        // Prüfung auf Mindestlänge
        if (question.validation && question.validation.minLength) {
            if (text.length < question.validation.minLength) {
                return false;
            }
        }
        
        // Prüfung auf Maximallänge
        if (question.validation && question.validation.maxLength) {
            if (text.length > question.validation.maxLength) {
                return false;
            }
        }
        
        // Prüfung auf Mindestanzahl an Wörtern
        if (question.validation && question.validation.minWords) {
            const wordCount = text.split(/\s+/).filter(Boolean).length;
            if (wordCount < question.validation.minWords) {
                return false;
            }
        }
        
        return true;
    }
};

/**
 * Generische Funktionen für alle Antworttypen
 */

/**
 * Fügt den aktuellen Zustand zur Antworthistorie hinzu
 * @param {Answer} answer - Das Antwortobjekt
 */
app.answerStorage.addToHistory = function(answer) {
    // Nur historisieren, wenn es bereits einen Wert gibt
    if (answer.value !== null && answer.value !== undefined && answer.value !== '') {
        // Kopie des aktuellen Zustands erstellen
        const historicalEntry = {
            value: JSON.parse(JSON.stringify(answer.value)), // Deep copy
            timestamp: answer.timestamp
        };
        
        // Zur Historie hinzufügen (neuster Eintrag zuerst)
        answer.history.unshift(historicalEntry);
        
        // Begrenzen der Historienlänge
        if (answer.history.length > this.config.maxHistoryEntries) {
            answer.history.pop(); // Ältesten Eintrag entfernen
        }
    }
};

/**
 * Fügt eine Antwort zur Sammlung hinzu oder aktualisiert sie
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} questionId - ID der Frage
 * @param {*} value - Antwortwert (abhängig vom Fragetyp)
 * @returns {Answer} Die hinzugefügte oder aktualisierte Antwort
 */
app.answerStorage.setAnswer = function(sessionId, questionId, value) {
    // Sammlung abrufen oder erstellen
    let collection = this.getCollection(sessionId);
    if (!collection) {
        throw new Error(`Keine Antwortensammlung für Sitzung ${sessionId} gefunden`);
    }
    
    // Testsitzung abrufen, um Informationen zur Frage zu erhalten
    const session = app.testSessionManager.getSession(sessionId);
    if (!session) {
        throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
    }
    
    // Frage-Informationen abrufen
    const question = session.testData.questions[questionId];
    if (!question) {
        throw new Error(`Frage mit ID ${questionId} nicht im Test gefunden`);
    }
    
    let answer;
    
    // Prüfen, ob bereits eine Antwort existiert
    if (collection.answers[questionId]) {
        answer = collection.answers[questionId];
    } else {
        // Neue Antwort erstellen
        answer = this.createAnswer(
            questionId,
            session.testId,
            sessionId,
            session.userId,
            question.type
        );
        
        // Standardwert für den Fragetyp initialisieren
        answer = this.initializeAnswerValue(answer);
    }
    
    // Typspezifischer Handler für die Aktualisierung
    const handler = this.typeHandlers[question.type];
    if (handler && handler.updateAnswer) {
        answer = handler.updateAnswer(answer, value);
    } else {
        // Fallback für unbekannte Typen
        this.addToHistory(answer);
        answer.value = value;
        answer.timestamp = Date.now();
        answer.metadata.lastModified = Date.now();
        answer.metadata.interactions++;
    }
    
    // Aktualisierte Antwort in der Sammlung speichern
    collection.answers[questionId] = answer;
    collection.lastUpdateTime = Date.now();
    
    // Sammlung auf Speicher schreiben
    this.activeCollections[sessionId] = collection;
    this.saveToLocalStorage(collection);
    
    // Mit Session-Manager synchronisieren
    this.syncWithSessionManager(sessionId);
    
    return answer;
};

/**
 * Ruft eine Antwort aus der Sammlung ab
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} questionId - ID der Frage
 * @returns {Answer|null} Die Antwort oder null wenn nicht gefunden
 */
app.answerStorage.getAnswer = function(sessionId, questionId) {
    const collection = this.getCollection(sessionId);
    if (!collection || !collection.answers[questionId]) {
        return null;
    }
    
    return collection.answers[questionId];
};

/**
 * Bewertet eine Antwort automatisch
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} questionId - ID der Frage
 * @returns {Object} Bewertungsergebnis
 */
app.answerStorage.evaluateAnswer = function(sessionId, questionId) {
    // Antwort und Frage abrufen
    const answer = this.getAnswer(sessionId, questionId);
    if (!answer) {
        throw new Error(`Keine Antwort für Frage ${questionId} in Sitzung ${sessionId} gefunden`);
    }
    
    // Testsitzung abrufen, um Informationen zur Frage zu erhalten
    const session = app.testSessionManager.getSession(sessionId);
    if (!session) {
        throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
    }
    
    // Frage-Informationen abrufen
    const question = session.testData.questions[questionId];
    if (!question) {
        throw new Error(`Frage mit ID ${questionId} nicht im Test gefunden`);
    }
    
    // Bewertung mit typspezifischem Handler durchführen
    const handler = this.typeHandlers[question.type];
    let evaluation;
    
    if (handler && handler.evaluate) {
        evaluation = handler.evaluate(answer, question);
    } else {
        // Fallback für unbekannte Typen: Manuelle Bewertung erforderlich
        evaluation = {
            requiresManualEvaluation: true,
            score: null,
            isCorrect: null
        };
    }
    
    // Bewertungsergebnis in der Antwort speichern
    answer.isCorrect = evaluation.isCorrect;
    answer.score = evaluation.score;
    
    // Sammlung aktualisieren
    const collection = this.getCollection(sessionId);
    collection.answers[questionId] = answer;
    collection.lastUpdateTime = Date.now();
    
    // Speichern und synchronisieren
    this.saveToLocalStorage(collection);
    this.syncWithSessionManager(sessionId);
    
    return evaluation;
};

/**
 * Validiert eine Antwort (prüft auf Gültigkeit, nicht auf Korrektheit)
 * @param {string} sessionId - ID der Testsitzung
 * @param {string} questionId - ID der Frage
 * @returns {boolean} Ob die Antwort gültig ist
 */
app.answerStorage.validateAnswer = function(sessionId, questionId) {
    // Antwort und Frage abrufen
    const answer = this.getAnswer(sessionId, questionId);
    if (!answer) {
        return false; // Keine Antwort vorhanden = ungültig
    }
    
    // Testsitzung abrufen, um Informationen zur Frage zu erhalten
    const session = app.testSessionManager.getSession(sessionId);
    if (!session) {
        throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
    }
    
    // Frage-Informationen abrufen
    const question = session.testData.questions[questionId];
    if (!question) {
        throw new Error(`Frage mit ID ${questionId} nicht im Test gefunden`);
    }
    
    // Validierung mit typspezifischem Handler durchführen
    const handler = this.typeHandlers[question.type];
    
    if (handler && handler.validate) {
        return handler.validate(answer, question);
    }
    
    // Fallback für unbekannte Typen: Antwort muss einen Wert haben
    return answer.value !== null && answer.value !== undefined;
};

/**
 * Erweitert die öffentliche Schnittstelle um die neuen Funktionen
 */
Object.assign(app.answerStorage.interface, {
    setAnswer: app.answerStorage.setAnswer,
    getAnswer: app.answerStorage.getAnswer,
    evaluateAnswer: app.answerStorage.evaluateAnswer,
    validateAnswer: app.answerStorage.validateAnswer
});

// Initialisierung der typspezifischen Funktionen
(function() {
    console.log('Antwortenspeicher-Modul (Teil 2) initialisiert');
    
    // Event-Listener registrieren
    
    // Testabschluss-Event: Alle Antworten auswerten und zusammenfassen
    document.addEventListener('testSubmitted', function(event) {
        const sessionId = event.detail.sessionId;
        
        try {
            const collection = app.answerStorage.getCollection(sessionId);
            if (!collection) return;
            
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) return;
            
            // Test als abgeschlossen markieren
            collection.isCompleted = true;
            
            // Einzelne Antworten auswerten
            const questionsData = session.testData.questions || {};
            const questions = Object.keys(questionsData);
            let totalScore = 0;
            let maxPossibleScore = 0;
            let correctCount = 0;
            let incorrectCount = 0;
            let partialCount = 0;
            
            questions.forEach(questionId => {
                const question = questionsData[questionId];
                maxPossibleScore += (question.points || 1);
                
                // Wenn die Frage beantwortet wurde, bewerten
                if (collection.answers[questionId]) {
                    const evaluation = app.answerStorage.evaluateAnswer(sessionId, questionId);
                    
                    if (!evaluation.requiresManualEvaluation) {
                        totalScore += evaluation.score || 0;
                        
                        if (evaluation.isCorrect === true) {
                            correctCount++;
                        } else if (evaluation.isCorrect === false) {
                            incorrectCount++;
                        } else {
                            partialCount++; // teilweise korrekt
                        }
                    }
                }
            });
            
            // Zusammenfassung erstellen
            collection.summary = {
                totalQuestions: questions.length,
                answeredQuestions: Object.keys(collection.answers).length,
                correctAnswers: correctCount,
                incorrectAnswers: incorrectCount,
                partiallyCorrectAnswers: partialCount,
                unansweredQuestions: questions.length - Object.keys(collection.answers).length,
                totalScore: totalScore,
                maxPossibleScore: maxPossibleScore,
                percentageScore: maxPossibleScore > 0 ? (totalScore / maxPossibleScore * 100).toFixed(2) : 0,
                timeTaken: collection.lastUpdateTime - collection.startTime,
                isPassed: totalScore >= (session.testData.passingScore || 0)
            };
            
            // Testzeit berechnen
            const testDuration = collection.lastUpdateTime - collection.startTime;
            collection.summary.testDurationMinutes = Math.floor(testDuration / 60000);
            collection.summary.testDurationSeconds = Math.floor((testDuration % 60000) / 1000);
            
            // Sammlung speichern und synchronisieren
            app.answerStorage.saveToLocalStorage(collection);
            app.answerStorage.syncWithSessionManager(sessionId);
            
            // Ergebnis-Event auslösen
            const resultEvent = new CustomEvent('testResultsReady', {
                detail: {
                    sessionId: sessionId,
                    summary: collection.summary
                }
            });
            document.dispatchEvent(resultEvent);
            
            console.log(`Test-Auswertung für Sitzung ${sessionId} abgeschlossen`, collection.summary);
        } catch (error) {
            console.error('Fehler bei der Testauswertung:', error);
        }
    });
})();
/**
 * JS-Block 5.6.2-part1: Speichermechanismen (Teil 1)
 * 
 * Dieser Block implementiert die erweiterten Speichermechanismen für Antworten,
 * einschließlich Echtzeit-Speicherung, Synchronisierung und Wiederherstellung.
 */

// Namespace für erweiterte Speichermechanismen
app.answerStorage.persistence = {
    // Status des Speichervorgangs
    status: {
        lastSaved: null,
        pendingChanges: false,
        savingInProgress: false,
        errorCount: 0,
        maxRetries: 3
    },
    
    // Konfiguration
    config: {
        // Intervall (ms) für automatisches Speichern während der Eingabe
        autoSaveDelay: 3000,
        
        // Debug-Flag für erweiterte Logging
        debug: false,
        
        // Speichermodi
        modes: {
            // Automatisches Speichern während der Eingabe
            autoSave: true,
            
            // Speichern beim Verlassen einer Frage
            saveOnQuestionChange: true,
            
            // Speichern beim Drücken von Strg+S
            saveOnKeyboardShortcut: true,
            
            // Speichern bei expliziter Benutzerforderung ('Speichern'-Button)
            saveOnExplicitRequest: true
        }
    },
    
    // Timer für verzögertes Speichern
    autoSaveTimer: null,
    
    /**
     * Initialisiert die Speichermechanismen
     */
    initialize: function() {
        this.setupEventListeners();
        console.log('Erweiterte Speichermechanismen initialisiert');
    },
    
    /**
     * Richtet Event-Listener für die verschiedenen Speichermodi ein
     */
    setupEventListeners: function() {
        // Tastatur-Shortcut (Strg+S)
        if (this.config.modes.saveOnKeyboardShortcut) {
            document.addEventListener('keydown', function(event) {
                if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                    event.preventDefault(); // Browser-Speichern verhindern
                    app.answerStorage.persistence.saveAllPending();
                }
            });
        }
        
        // Speichern bei Fragewechsel
        if (this.config.modes.saveOnQuestionChange) {
            document.addEventListener('questionChanged', function(event) {
                app.answerStorage.persistence.saveAllPending();
            });
        }
        
        // Speichern bei Test-Abschluss
        document.addEventListener('testSubmitting', function(event) {
            app.answerStorage.persistence.saveAllPending();
        });
        
        // Speichern bei Fenster-Schließen/Navigation
        window.addEventListener('beforeunload', function(event) {
            app.answerStorage.persistence.saveAllPending();
        });
        
        // Event-Delegation für 'Speichern'-Buttons
        if (this.config.modes.saveOnExplicitRequest) {
            document.addEventListener('click', function(event) {
                if (event.target.classList.contains('save-answer-btn') || 
                    event.target.closest('.save-answer-btn')) {
                    
                    // Aktuelle Frage-ID aus dem Button-Datensatz oder dem Container extrahieren
                    let questionId = event.target.dataset.questionId || 
                                    event.target.closest('.question-container')?.dataset.questionId;
                    
                    // Aktuelle Sitzungs-ID extrahieren
                    let sessionId = app.testSessionManager.getCurrentSessionId();
                    
                    if (questionId && sessionId) {
                        app.answerStorage.persistence.saveSpecificAnswer(sessionId, questionId);
                    } else {
                        app.answerStorage.persistence.saveAllPending();
                    }
                }
            });
        }
    },
    
    /**
     * Stößt das auto-save-Timer für verzögertes Speichern an
     * @param {string} sessionId - ID der Testsitzung
     * @param {string} questionId - ID der Frage
     */
    triggerAutoSave: function(sessionId, questionId) {
        if (!this.config.modes.autoSave) return;
        
        // Status aktualisieren
        this.status.pendingChanges = true;
        
        // Bestehenden Timer löschen, um Mehrfachspeicherungen zu vermeiden
        if (this.autoSaveTimer) {
            clearTimeout(this.autoSaveTimer);
        }
        
        // Neuen Timer starten
        this.autoSaveTimer = setTimeout(() => {
            if (questionId) {
                this.saveSpecificAnswer(sessionId, questionId);
            } else {
                this.saveAllPending();
            }
        }, this.config.autoSaveDelay);
    },
    
    /**
     * Speichert eine bestimmte Antwort
     * @param {string} sessionId - ID der Testsitzung
     * @param {string} questionId - ID der Frage
     * @returns {Promise} Promise, der nach Abschluss des Speichervorgangs aufgelöst wird
     */
    saveSpecificAnswer: function(sessionId, questionId) {
        return new Promise((resolve, reject) => {
            try {
                // Antwort abrufen
                const answer = app.answerStorage.getAnswer(sessionId, questionId);
                if (!answer) {
                    if (this.config.debug) {
                        console.warn(`Keine Antwort für Frage ${questionId} gefunden, Speicherung übersprungen`);
                    }
                    resolve(null);
                    return;
                }
                
                // Sammlung abrufen
                const collection = app.answerStorage.getCollection(sessionId);
                if (!collection) {
                    reject(new Error(`Keine Sammlung für Sitzung ${sessionId} gefunden`));
                    return;
                }
                
                // Frage zugehörige UI-Elemente finden (für visuelles Feedback)
                const questionElement = document.querySelector(`.question-container[data-question-id="${questionId}"]`);
                const saveIndicator = questionElement?.querySelector('.save-indicator');
                
                // Speicherzustand anzeigen
                if (saveIndicator) {
                    saveIndicator.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Speichern...';
                    saveIndicator.classList.add('saving');
                }
                
                // Speichervorgang simulieren (in der realen Anwendung könnte dies ein API-Aufruf sein)
                setTimeout(() => {
                    // Antwort in der Sammlung aktualisieren
                    collection.answers[questionId] = answer;
                    collection.lastUpdateTime = Date.now();
                    
                    // In localStorage speichern
                    app.answerStorage.saveToLocalStorage(collection);
                    
                    // Mit SessionManager synchronisieren
                    app.answerStorage.syncWithSessionManager(sessionId);
                    
                    // Status aktualisieren
                    this.status.lastSaved = new Date();
                    this.status.pendingChanges = false;
                    
                    // Speicherzustand aktualisieren
                    if (saveIndicator) {
                        saveIndicator.innerHTML = '<i class="fa fa-check"></i> Gespeichert';
                        saveIndicator.classList.remove('saving');
                        saveIndicator.classList.add('saved');
                        
                        // Nach einigen Sekunden wieder ausblenden
                        setTimeout(() => {
                            saveIndicator.classList.remove('saved');
                        }, 3000);
                    }
                    
                    // Event auslösen
                    const saveEvent = new CustomEvent('answerSaved', {
                        detail: {
                            sessionId,
                            questionId,
                            timestamp: this.status.lastSaved
                        }
                    });
                    document.dispatchEvent(saveEvent);
                    
                    if (this.config.debug) {
                        console.log(`Antwort für Frage ${questionId} gespeichert:`, answer);
                    }
                    
                    resolve(answer);
                }, 500); // Simulierte Server-Verzögerung von 500ms
            } catch (error) {
                console.error('Fehler beim Speichern der Antwort:', error);
                
                // Fehlerstatus aktualisieren
                this.status.errorCount++;
                
                // Speicherzustand aktualisieren
                const questionElement = document.querySelector(`.question-container[data-question-id="${questionId}"]`);
                const saveIndicator = questionElement?.querySelector('.save-indicator');
                
                if (saveIndicator) {
                    saveIndicator.innerHTML = '<i class="fa fa-exclamation-triangle"></i> Fehler beim Speichern';
                    saveIndicator.classList.remove('saving');
                    saveIndicator.classList.add('error');
                }
                
                // Event auslösen
                const errorEvent = new CustomEvent('answerSaveError', {
                    detail: {
                        sessionId,
                        questionId,
                        error: error.message
                    }
                });
                document.dispatchEvent(errorEvent);
                
                reject(error);
            }
        });
    },
    
    /**
     * Speichert alle ausstehenden Änderungen
     * @returns {Promise} Promise, der nach Abschluss aller Speichervorgänge aufgelöst wird
     */
    saveAllPending: function() {
        return new Promise((resolve, reject) => {
            try {
                if (this.status.savingInProgress) {
                    if (this.config.debug) {
                        console.log('Speichervorgang bereits im Gange, wird übersprungen');
                    }
                    resolve(null);
                    return;
                }
                
                this.status.savingInProgress = true;
                
                // Aktuelle Sitzungs-ID abrufen
                const sessionId = app.testSessionManager.getCurrentSessionId();
                if (!sessionId) {
                    this.status.savingInProgress = false;
                    reject(new Error('Keine aktive Testsitzung gefunden'));
                    return;
                }
                
                // Sammlung abrufen
                const collection = app.answerStorage.getCollection(sessionId);
                if (!collection) {
                    this.status.savingInProgress = false;
                    reject(new Error(`Keine Sammlung für Sitzung ${sessionId} gefunden`));
                    return;
                }
                
                // Speicherindikator für die gesamte Seite anzeigen
                const globalSaveIndicator = document.getElementById('global-save-indicator');
                if (globalSaveIndicator) {
                    globalSaveIndicator.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Speichern...';
                    globalSaveIndicator.classList.add('active');
                }
                
                // Speichervorgang simulieren
                setTimeout(() => {
                    // In localStorage speichern
                    app.answerStorage.saveToLocalStorage(collection);
                    
                    // Mit SessionManager synchronisieren
                    app.answerStorage.syncWithSessionManager(sessionId);
                    
                    // Status aktualisieren
                    this.status.lastSaved = new Date();
                    this.status.pendingChanges = false;
                    this.status.savingInProgress = false;
                    
                    // Speicherindikator aktualisieren
                    if (globalSaveIndicator) {
                        globalSaveIndicator.innerHTML = '<i class="fa fa-check"></i> Alle Änderungen gespeichert';
                        globalSaveIndicator.classList.remove('active');
                        
                        // Nach einigen Sekunden wieder ausblenden
                        setTimeout(() => {
                            globalSaveIndicator.innerHTML = '';
                        }, 3000);
                    }
                    
                    // Event auslösen
                    const saveEvent = new CustomEvent('allAnswersSaved', {
                        detail: {
                            sessionId,
                            timestamp: this.status.lastSaved
                        }
                    });
                    document.dispatchEvent(saveEvent);
                    
                    if (this.config.debug) {
                        console.log(`Alle Antworten für Sitzung ${sessionId} gespeichert:`, collection);
                    }
                    
                    resolve(collection);
                }, 800); // Simulierte Server-Verzögerung von 800ms
            } catch (error) {
                console.error('Fehler beim Speichern aller Antworten:', error);
                
                // Fehlerbehandlung
                this.status.savingInProgress = false;
                this.status.errorCount++;
                
                // Speicherindikator aktualisieren
                const globalSaveIndicator = document.getElementById('global-save-indicator');
                if (globalSaveIndicator) {
                    globalSaveIndicator.innerHTML = '<i class="fa fa-exclamation-triangle"></i> Fehler beim Speichern';
                    globalSaveIndicator.classList.remove('active');
                    globalSaveIndicator.classList.add('error');
                    
                    // Nach einigen Sekunden wieder ausblenden
                    setTimeout(() => {
                        globalSaveIndicator.classList.remove('error');
                    }, 5000);
                }
                
                // Event auslösen
                const errorEvent = new CustomEvent('allAnswersSaveError', {
                    detail: {
                        sessionId,
                        error: error.message
                    }
                });
                document.dispatchEvent(errorEvent);
                
                reject(error);
            }
        });
    },
    
    /**
     * Versucht, Antworten aus dem lokalen Speicher wiederherzustellen
     * @param {string} sessionId - ID der Testsitzung
     * @returns {boolean} true, wenn Antworten wiederhergestellt wurden, sonst false
     */
    recoverAnswers: function(sessionId) {
        try {
            // Versuchen, die Sammlung aus dem lokalen Speicher zu laden
            const storedCollection = app.answerStorage.loadFromLocalStorage(sessionId);
            if (!storedCollection) {
                if (this.config.debug) {
                    console.log(`Keine gespeicherten Antworten für Sitzung ${sessionId} gefunden`);
                }
                return false;
            }
            
            // Aktive Sammlung aus dem In-Memory-Speicher abrufen
            const activeCollection = app.answerStorage.activeCollections[sessionId];
            
            // Wenn keine aktive Sammlung existiert, die gespeicherte direkt verwenden
            if (!activeCollection) {
                app.answerStorage.activeCollections[sessionId] = storedCollection;
                
                // Mit SessionManager synchronisieren
                app.answerStorage.syncWithSessionManager(sessionId);
                
                if (this.config.debug) {
                    console.log(`Antworten für Sitzung ${sessionId} aus localStorage wiederhergestellt:`, storedCollection);
                }
                
                return true;
            }
            
            // Wenn die aktive Sammlung neuer ist als die gespeicherte, nicht wiederherstellen
            if (activeCollection.lastUpdateTime > storedCollection.lastUpdateTime) {
                if (this.config.debug) {
                    console.log(`Aktive Sammlung für Sitzung ${sessionId} ist neuer als die gespeicherte, Wiederherstellung übersprungen`);
                }
                return false;
            }
            
            // Antworten aus der gespeicherten Sammlung in die aktive integrieren
            Object.keys(storedCollection.answers).forEach(questionId => {
                activeCollection.answers[questionId] = storedCollection.answers[questionId];
            });
            
            // Zeitstempel aktualisieren
            activeCollection.lastUpdateTime = Date.now();
            
            // Aktualisierte Sammlung speichern
            app.answerStorage.activeCollections[sessionId] = activeCollection;
            app.answerStorage.saveToLocalStorage(activeCollection);
            
            // Mit SessionManager synchronisieren
            app.answerStorage.syncWithSessionManager(sessionId);
            
            // Event auslösen
            const recoverEvent = new CustomEvent('answersRecovered', {
                detail: {
                    sessionId,
                    answerCount: Object.keys(storedCollection.answers).length
                }
            });
            document.dispatchEvent(recoverEvent);
            
            if (this.config.debug) {
                console.log(`Antworten für Sitzung ${sessionId} wiederhergestellt:`, activeCollection);
            }
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Wiederherstellung der Antworten:', error);
            return false;
        }
    },
    
    /**
     * Integriert einen Fragebogen-Event-Handler für Texteingabe
     * @param {HTMLElement} inputElement - Das Eingabeelement
     * @param {string} sessionId - ID der Testsitzung
     * @param {string} questionId - ID der Frage
     */
    setupInputListener: function(inputElement, sessionId, questionId) {
        if (!inputElement || !sessionId || !questionId) return;
        
        // Für Texteingaben
        if (inputElement.tagName === 'TEXTAREA' || 
            (inputElement.tagName === 'INPUT' && inputElement.type === 'text')) {
            
            let inputTimer;
            
            inputElement.addEventListener('input', () => {
                // Bestehenden Timer löschen
                if (inputTimer) {
                    clearTimeout(inputTimer);
                }
                
                // Antwort sofort aktualisieren, aber verzögert speichern
                const value = inputElement.value;
                app.answerStorage.setAnswer(sessionId, questionId, value);
                
                // Auto-Save triggern
                this.triggerAutoSave(sessionId, questionId);
            });
        }
        // Für Checkboxen (Multiple-Choice)
        else if (inputElement.tagName === 'INPUT' && inputElement.type === 'checkbox') {
            inputElement.addEventListener('change', () => {
                // Alle ausgewählten Optionen sammeln
                const container = inputElement.closest('.question-container');
                const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
                const selectedOptions = Array.from(checkboxes).map(cb => cb.value);
                
                // Antwort aktualisieren
                app.answerStorage.setAnswer(sessionId, questionId, selectedOptions);
                
                // Auto-Save triggern
                this.triggerAutoSave(sessionId, questionId);
            });
        }
        // Für Radio-Buttons (Single-Choice)
        else if (inputElement.tagName === 'INPUT' && inputElement.type === 'radio') {
            inputElement.addEventListener('change', () => {
                // Ausgewählten Wert nehmen
                const selectedOption = inputElement.value;
                
                // Antwort aktualisieren
                app.answerStorage.setAnswer(sessionId, questionId, selectedOption);
                
                // Auto-Save triggern
                this.triggerAutoSave(sessionId, questionId);
            });
        }
        // Für Wahr/Falsch-Buttons
        else if (inputElement.classList.contains('true-false-btn')) {
            inputElement.addEventListener('click', () => {
                // Wert aus Datenattribut nehmen
                const value = inputElement.dataset.value === 'true';
                
                // Antwort aktualisieren
                app.answerStorage.setAnswer(sessionId, questionId, value);
                
                // Auto-Save triggern
                this.triggerAutoSave(sessionId, questionId);
            });
        }
    }
};

/**
 * Erweitert die öffentliche Schnittstelle um die neuen Funktionen
 */
Object.assign(app.answerStorage.interface, {
    // Speichermechanismen
    saveAnswer: app.answerStorage.persistence.saveSpecificAnswer.bind(app.answerStorage.persistence),
    saveAllAnswers: app.answerStorage.persistence.saveAllPending.bind(app.answerStorage.persistence),
    recoverAnswers: app.answerStorage.persistence.recoverAnswers.bind(app.answerStorage.persistence),
    setupInputListener: app.answerStorage.persistence.setupInputListener.bind(app.answerStorage.persistence)
});

// Hilfsfunktionen für die Anzeige des Speicherstatus

/**
 * Erstellt und fügt globale Speicherstatusanzeige hinzu
 */
app.answerStorage.createGlobalSaveIndicator = function() {
    // Prüfen, ob bereits vorhanden
    if (document.getElementById('global-save-indicator')) return;
    
    // Container erstellen
    const indicator = document.createElement('div');
    indicator.id = 'global-save-indicator';
    indicator.className = 'global-save-indicator';
    
    // Styling hinzufügen
    indicator.style.position = 'fixed';
    indicator.style.bottom = '20px';
    indicator.style.right = '20px';
    indicator.style.padding = '10px 15px';
    indicator.style.backgroundColor = '#00FFD0';
    indicator.style.color = '#333';
    indicator.style.borderRadius = '4px';
    indicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
    indicator.style.fontWeight = 'bold';
    indicator.style.zIndex = '9999';
    indicator.style.display = 'none';
    
    // Zum DOM hinzufügen
    document.body.appendChild(indicator);
    
    // CSS-Klassen für verschiedene Zustände
    const style = document.createElement('style');
    style.textContent = `
        .global-save-indicator.active {
            display: block !important;
        }
        .global-save-indicator.error {
            background-color: #ff3b30 !important;
            color: white !important;
        }
    `;
    document.head.appendChild(style);
};

/**
 * Erstellt Speicherstatusanzeigen für eine bestimmte Frage
 * @param {HTMLElement} questionContainer - Der Fragencontainer
 * @param {string} questionId - ID der Frage
 */
app.answerStorage.createQuestionSaveIndicator = function(questionContainer, questionId) {
    // Prüfen, ob Container vorhanden ist
    if (!questionContainer) return;
    
    // Prüfen, ob bereits vorhanden
    if (questionContainer.querySelector('.save-indicator')) return;
    
    // Container erstellen
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator';
    indicator.dataset.questionId = questionId;
    
    // Styling hinzufügen
    indicator.style.marginTop = '10px';
    indicator.style.fontSize = '12px';
    indicator.style.color = '#666';
    
    // In den DOM einfügen (als letztes Kind des Containers)
    questionContainer.appendChild(indicator);
};

// Initialisierung der Speichermechanismen
(function() {
    console.log('Speichermechanismen (Teil 1) initialisiert');
    
    // Globale Speicherstatusanzeige erstellen
    app.answerStorage.createGlobalSaveIndicator();
    
    // Erweiterte Speichermechanismen initialisieren
    app.answerStorage.persistence.initialize();
    
    // Event-Listener für neue Fragen hinzufügen
    document.addEventListener('questionRendered', function(event) {
        const questionId = event.detail.questionId;
        const questionContainer = event.detail.container;
        const sessionId = app.testSessionManager.getCurrentSessionId();
        
        if (questionId && questionContainer && sessionId) {
            // Speicherstatusanzeige erstellen
            app.answerStorage.createQuestionSaveIndicator(questionContainer, questionId);
            
            // Eingabe-Listener für alle relevanten Eingabeelemente einrichten
            const inputElements = questionContainer.querySelectorAll('input, textarea, .true-false-btn');
            inputElements.forEach(element => {
                app.answerStorage.persistence.setupInputListener(element, sessionId, questionId);
            });
            
            // Gespeicherte Antworten wiederherstellen und anzeigen
            const answer = app.answerStorage.getAnswer(sessionId, questionId);
            if (answer) {
                // Typspezifische Wiederherstellung implementieren
                // (wird in part2 implementiert)
            }
        }
    });
})();
/**
 * JS-Block 5.6.2-part2: Speichermechanismen (Teil 2)
 * 
 * Dieser Block implementiert erweiterte Speichermechanismen wie
 * Wiederherstellung von Antworten, Tab-übergreifende Synchronisierung,
 * Offline-Modus und Konfliktlösung.
 */

// Erweiterung des Persistence-Namespaces
app.answerStorage.persistence.recovery = {
    /**
     * Stellt Antworten in der UI wieder her (nach Seitenladung)
     * @param {string} sessionId - ID der Testsitzung
     * @param {HTMLElement} container - Container, in dem die Fragen angezeigt werden
     */
    restoreAnswersToUI: function(sessionId, container) {
        try {
            // Sammlung abrufen
            const collection = app.answerStorage.getCollection(sessionId);
            if (!collection || !container) return;
            
            // Alle Fragencontainer im angegebenen Container durchgehen
            const questionContainers = container.querySelectorAll('.question-container');
            
            questionContainers.forEach(questionContainer => {
                const questionId = questionContainer.dataset.questionId;
                if (!questionId) return;
                
                // Prüfen, ob eine Antwort für diese Frage existiert
                const answer = collection.answers[questionId];
                if (!answer) return;
                
                // Fragetyp bestimmen
                const questionType = answer.questionType;
                
                // Je nach Fragetyp die Werte wiederherstellen
                switch (questionType) {
                    case 'multiple-choice':
                        this.restoreMultipleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'single-choice':
                        this.restoreSingleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'true-false':
                        this.restoreTrueFalseAnswer(answer, questionContainer);
                        break;
                    case 'free-text':
                        this.restoreFreeTextAnswer(answer, questionContainer);
                        break;
                }
                
                // Speicherstatusanzeige aktualisieren
                const saveIndicator = questionContainer.querySelector('.save-indicator');
                if (saveIndicator && answer.metadata.lastModified) {
                    const lastSaved = new Date(answer.metadata.lastModified);
                    saveIndicator.innerHTML = `<i class="fa fa-check"></i> Gespeichert am ${lastSaved.toLocaleTimeString()}`;
                    saveIndicator.classList.add('saved');
                }
            });
            
            console.log(`Antworten für Sitzung ${sessionId} in der UI wiederhergestellt`);
        } catch (error) {
            console.error('Fehler bei der Wiederherstellung der Antworten in der UI:', error);
        }
    },
    
    /**
     * Stellt eine Multiple-Choice-Antwort wieder her
     * @param {Answer} answer - Die Antwort
     * @param {HTMLElement} container - Der Fragencontainer
     */
    restoreMultipleChoiceAnswer: function(answer, container) {
        const selectedOptions = answer.value || [];
        
        // Alle Checkboxen im Container durchgehen
        const checkboxes = container.querySelectorAll('input[type="checkbox"]');
        
        checkboxes.forEach(checkbox => {
            // Checkbox auswählen, wenn der Wert in den ausgewählten Optionen enthalten ist
            checkbox.checked = selectedOptions.includes(checkbox.value);
        });
    },
    
    /**
     * Stellt eine Single-Choice-Antwort wieder her
     * @param {Answer} answer - Die Antwort
     * @param {HTMLElement} container - Der Fragencontainer
     */
    restoreSingleChoiceAnswer: function(answer, container) {
        const selectedOption = answer.value;
        if (selectedOption === null || selectedOption === undefined) return;
        
        // Radio-Button mit dem ausgewählten Wert finden und auswählen
        const radioButton = container.querySelector(`input[type="radio"][value="${selectedOption}"]`);
        if (radioButton) {
            radioButton.checked = true;
        }
    },
    
    /**
     * Stellt eine Wahr/Falsch-Antwort wieder her
     * @param {Answer} answer - Die Antwort
     * @param {HTMLElement} container - Der Fragencontainer
     */
    restoreTrueFalseAnswer: function(answer, container) {
        const selectedValue = answer.value;
        if (selectedValue === null || selectedValue === undefined) return;
        
        // Aktive Klasse von allen Buttons entfernen
        container.querySelectorAll('.true-false-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Button mit dem ausgewählten Wert finden und aktivieren
        const button = container.querySelector(`.true-false-btn[data-value="${selectedValue}"]`);
        if (button) {
            button.classList.add('active');
        }
    },
    
    /**
     * Stellt eine Freitext-Antwort wieder her
     * @param {Answer} answer - Die Antwort
     * @param {HTMLElement} container - Der Fragencontainer
     */
    restoreFreeTextAnswer: function(answer, container) {
        const text = answer.value || '';
        
        // Textarea oder Input-Feld finden und Wert setzen
        const inputField = container.querySelector('textarea, input[type="text"]');
        if (inputField) {
            inputField.value = text;
            
            // Wenn es sich um eine Textarea mit automatischer Höhenanpassung handelt
            if (inputField.tagName === 'TEXTAREA' && inputField.classList.contains('auto-resize')) {
                // Höhe anpassen
                inputField.style.height = 'auto';
                inputField.style.height = `${inputField.scrollHeight}px`;
            }
            
            // Zeichenzähler aktualisieren, falls vorhanden
            const charCounter = container.querySelector('.char-counter');
            if (charCounter) {
                charCounter.textContent = `${text.length} Zeichen`;
                
                // Farbliche Markierung basierend auf Zeichenanzahl
                charCounter.classList.remove('warning', 'error');
                
                // Min/Max-Limits aus Datenattributen auslesen
                const minLength = parseInt(inputField.dataset.minLength || '0', 10);
                const maxLength = parseInt(inputField.dataset.maxLength || '0', 10);
                
                if (maxLength > 0 && text.length > maxLength * 0.9) {
                    charCounter.classList.add('warning');
                }
                
                if (maxLength > 0 && text.length >= maxLength) {
                    charCounter.classList.add('error');
                }
                
                if (minLength > 0 && text.length < minLength) {
                    charCounter.classList.add('warning');
                }
            }
        }
    }
};

// Browser-Tab-übergreifende Synchronisierung
app.answerStorage.persistence.tabSync = {
    // Eindeutige ID für den aktuellen Tab
    tabId: 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
    
    // Zeitstempel der letzten Synchronisierung
    lastSyncTime: null,
    
    // Flag für aktiven Synchronisierungs-Listener
    syncListenerActive: false,
    
    /**
     * Initialisiert die Tab-übergreifende Synchronisierung
     */
    initialize: function() {
        // Listener einrichten, wenn localStorage unterstützt wird
        if (window.localStorage) {
            this.setupStorageListener();
            console.log('Tab-übergreifende Synchronisierung initialisiert');
        } else {
            console.warn('localStorage wird nicht unterstützt, Tab-Synchronisierung deaktiviert');
        }
    },
    
    /**
     * Richtet den Listener für Storage-Ereignisse ein
     */
    setupStorageListener: function() {
        if (this.syncListenerActive) return;
        
        window.addEventListener('storage', (event) => {
            // Nur auf Änderungen an relevanten Schlüsseln reagieren
            if (event.key && event.key.startsWith(app.answerStorage.config.localStorageKey)) {
                // Extrahieren der Sitzungs-ID aus dem Schlüssel
                const sessionIdMatch = event.key.match(/_([a-zA-Z0-9-]+)$/);
                if (!sessionIdMatch) return;
                
                const sessionId = sessionIdMatch[1];
                
                // Überprüfen, ob es sich um die aktuelle Sitzung handelt
                const currentSessionId = app.testSessionManager.getCurrentSessionId();
                if (sessionId !== currentSessionId) return;
                
                // Daten aus dem Event extrahieren
                const newData = event.newValue ? JSON.parse(event.newValue) : null;
                if (!newData) return;
                
                // Aktuelle Sammlung aktualisieren
                this.handleExternalUpdate(sessionId, newData);
            }
        });
        
        this.syncListenerActive = true;
    },
    
    /**
     * Verarbeitet Aktualisierungen aus anderen Tabs
     * @param {string} sessionId - ID der Testsitzung
     * @param {AnswerCollection} externalCollection - Die externe Sammlung
     */
    handleExternalUpdate: function(sessionId, externalCollection) {
        try {
            // Lokale Sammlung abrufen
            const localCollection = app.answerStorage.getCollection(sessionId);
            if (!localCollection) {
                // Wenn keine lokale Sammlung existiert, externe direkt übernehmen
                app.answerStorage.activeCollections[sessionId] = externalCollection;
                console.log(`Externe Sammlung für Sitzung ${sessionId} übernommen`);
                return;
            }
            
            // Letzten Aktualisierungszeitpunkt vergleichen
            if (externalCollection.lastUpdateTime <= localCollection.lastUpdateTime) {
                // Lokale Sammlung ist neuer, keine Aktualisierung notwendig
                return;
            }
            
            // Externe Daten in lokale Sammlung integrieren
            const updatedQuestions = [];
            
            // Iteriere über alle externen Antworten
            Object.keys(externalCollection.answers).forEach(questionId => {
                const externalAnswer = externalCollection.answers[questionId];
                const localAnswer = localCollection.answers[questionId];
                
                // Prüfen, ob die externe Antwort neuer ist
                if (!localAnswer || externalAnswer.timestamp > localAnswer.timestamp) {
                    localCollection.answers[questionId] = externalAnswer;
                    updatedQuestions.push(questionId);
                }
            });
            
            if (updatedQuestions.length > 0) {
                // Aktualisierungszeitstempel anpassen
                localCollection.lastUpdateTime = externalCollection.lastUpdateTime;
                
                // Aktualisierte Sammlung speichern
                app.answerStorage.activeCollections[sessionId] = localCollection;
                
                // UI aktualisieren
                this.updateUIWithExternalChanges(sessionId, updatedQuestions);
                
                console.log(`${updatedQuestions.length} Antworten aus externem Tab in Sitzung ${sessionId} integriert:`, updatedQuestions);
                
                // Event auslösen
                const syncEvent = new CustomEvent('answerSyncFromOtherTab', {
                    detail: {
                        sessionId,
                        updatedQuestions,
                        timestamp: new Date()
                    }
                });
                document.dispatchEvent(syncEvent);
            }
        } catch (error) {
            console.error('Fehler bei der Verarbeitung externer Aktualisierungen:', error);
        }
    },
    
    /**
     * Aktualisiert die UI mit Änderungen aus anderen Tabs
     * @param {string} sessionId - ID der Testsitzung
     * @param {string[]} updatedQuestions - Liste der aktualisierten Fragen-IDs
     */
    updateUIWithExternalChanges: function(sessionId, updatedQuestions) {
        // Aktuelle Frage-ID ermitteln
        const activeQuestionId = document.querySelector('.question-container.active')?.dataset.questionId;
        
        // Fragen-Container
        const testContainer = document.getElementById('test-container');
        if (!testContainer) return;
        
        // Für jede aktualisierte Frage die UI aktualisieren
        updatedQuestions.forEach(questionId => {
            const questionContainer = testContainer.querySelector(`.question-container[data-question-id="${questionId}"]`);
            
            // Nur aktualisieren, wenn die Frage sichtbar ist
            if (questionContainer && questionContainer.classList.contains('active')) {
                // Antwort abrufen
                const answer = app.answerStorage.getAnswer(sessionId, questionId);
                if (!answer) return;
                
                // Je nach Fragetyp die UI aktualisieren
                switch (answer.questionType) {
                    case 'multiple-choice':
                        app.answerStorage.persistence.recovery.restoreMultipleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'single-choice':
                        app.answerStorage.persistence.recovery.restoreSingleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'true-false':
                        app.answerStorage.persistence.recovery.restoreTrueFalseAnswer(answer, questionContainer);
                        break;
                    case 'free-text':
                        app.answerStorage.persistence.recovery.restoreFreeTextAnswer(answer, questionContainer);
                        break;
                }
                
                // Speicherstatusanzeige aktualisieren
                const saveIndicator = questionContainer.querySelector('.save-indicator');
                if (saveIndicator) {
                    saveIndicator.innerHTML = `<i class="fa fa-info-circle"></i> Aus anderem Tab aktualisiert`;
                    saveIndicator.classList.add('synced');
                    
                    // Nach einigen Sekunden zurücksetzen
                    setTimeout(() => {
                        saveIndicator.classList.remove('synced');
                    }, 3000);
                }
            }
        });
    }
};

// Offline-Modus und Netzwerkstatus-Management
app.answerStorage.persistence.offlineMode = {
    // Status des Netzwerks
    isOnline: navigator.onLine,
    
    // Puffer für Änderungen während Offline-Phase
    offlineBuffer: {
        pendingChanges: {}, // Format: {sessionId: {questionId: timestamp}}
        retryQueue: []      // Format: [{sessionId, questionId, timestamp}]
    },
    
    // Konfiguration
    config: {
        // Intervall für Wiederverbindungsversuche (in ms)
        reconnectInterval: 5000,
        
        // Maximale Anzahl an Wiederverbindungsversuchen
        maxReconnectAttempts: 10,
        
        // Aktueller Zähler für Wiederverbindungsversuche
        reconnectAttempts: 0,
        
        // Intervall-ID für den Wiederverbindungstimer
        reconnectTimerId: null
    },
    
    /**
     * Initialisiert das Offline-Modus-Management
     */
    initialize: function() {
        this.setupNetworkListeners();
        this.createOfflineIndicator();
        console.log('Offline-Modus-Management initialisiert, aktueller Status:', this.isOnline ? 'Online' : 'Offline');
    },
    
    /**
     * Erstellt die Offline-Modusanzeige
     */
    createOfflineIndicator: function() {
        // Prüfen, ob bereits vorhanden
        if (document.getElementById('offline-indicator')) return;
        
        // Container erstellen
        const indicator = document.createElement('div');
        indicator.id = 'offline-indicator';
        indicator.className = 'offline-indicator';
        
        // Initialen Text setzen
        indicator.innerHTML = '<i class="fa fa-wifi"></i> Offline-Modus';
        
        // Styling hinzufügen
        indicator.style.position = 'fixed';
        indicator.style.top = '20px';
        indicator.style.right = '20px';
        indicator.style.padding = '8px 12px';
        indicator.style.backgroundColor = '#ff9500';
        indicator.style.color = 'white';
        indicator.style.borderRadius = '4px';
        indicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        indicator.style.fontWeight = 'bold';
        indicator.style.zIndex = '9999';
        indicator.style.display = 'none';
        
        // Zum DOM hinzufügen
        document.body.appendChild(indicator);
        
        // Anfangszustand setzen
        if (!this.isOnline) {
            indicator.style.display = 'block';
        }
    },
    
    /**
     * Richtet Listener für Netzwerkstatuswechsel ein
     */
    setupNetworkListeners: function() {
        // Online-Status-Änderung
        window.addEventListener('online', () => {
            this.handleOnlineStatusChange(true);
        });
        
        window.addEventListener('offline', () => {
            this.handleOnlineStatusChange(false);
        });
    },
    
    /**
     * Verarbeitet Änderungen des Online-Status
     * @param {boolean} isOnline - Neuer Online-Status
     */
    handleOnlineStatusChange: function(isOnline) {
        // Status aktualisieren
        this.isOnline = isOnline;
        
        // Indikator aktualisieren
        const indicator = document.getElementById('offline-indicator');
        if (indicator) {
            if (isOnline) {
                indicator.style.display = 'none';
                
                // Wenn wieder online, Synchronisierung starten
                this.processPendingChanges();
            } else {
                indicator.style.display = 'block';
            }
        }
        
        // Event auslösen
        const event = new CustomEvent('networkStatusChange', {
            detail: {
                isOnline,
                timestamp: new Date()
            }
        });
        document.dispatchEvent(event);
        
        console.log(`Netzwerkstatus geändert: ${isOnline ? 'Online' : 'Offline'}`);
    },
    
    /**
     * Fügt eine Änderung zum Offline-Puffer hinzu
     * @param {string} sessionId - ID der Testsitzung
     * @param {string} questionId - ID der Frage
     */
    addToPendingChanges: function(sessionId, questionId) {
        if (!this.offlineBuffer.pendingChanges[sessionId]) {
            this.offlineBuffer.pendingChanges[sessionId] = {};
        }
        
        this.offlineBuffer.pendingChanges[sessionId][questionId] = Date.now();
    },
    
    /**
     * Verarbeitet ausstehende Änderungen nach Wiederherstellung der Verbindung
     */
    processPendingChanges: function() {
        if (!this.isOnline) return;
        
        const pendingSessions = Object.keys(this.offlineBuffer.pendingChanges);
        
        if (pendingSessions.length === 0) {
            console.log('Keine ausstehenden Änderungen zur Synchronisierung');
            return;
        }
        
        console.log(`Starte Synchronisierung für ${pendingSessions.length} Sitzungen`);
        
        // Globalen Synchronisierungsstatus anzeigen
        const globalSaveIndicator = document.getElementById('global-save-indicator');
        if (globalSaveIndicator) {
            globalSaveIndicator.innerHTML = '<i class="fa fa-sync fa-spin"></i> Synchronisiere Offline-Änderungen...';
            globalSaveIndicator.classList.add('active');
        }
        
        // Für jede Sitzung die Änderungen verarbeiten
        pendingSessions.forEach(sessionId => {
            const pendingQuestions = Object.keys(this.offlineBuffer.pendingChanges[sessionId]);
            
            // Sammlung abrufen
            const collection = app.answerStorage.getCollection(sessionId);
            if (!collection) return;
            
            // In localStorage speichern
            app.answerStorage.saveToLocalStorage(collection);
            
            // Mit SessionManager synchronisieren
            app.answerStorage.syncWithSessionManager(sessionId);
            
            // Aus dem Puffer entfernen
            delete this.offlineBuffer.pendingChanges[sessionId];
            
            console.log(`Sitzung ${sessionId} synchronisiert, ${pendingQuestions.length} Fragen aktualisiert`);
        });
        
        // Synchronisierungsstatus aktualisieren
        if (globalSaveIndicator) {
            globalSaveIndicator.innerHTML = '<i class="fa fa-check"></i> Offline-Änderungen synchronisiert';
            
            // Nach einigen Sekunden ausblenden
            setTimeout(() => {
                globalSaveIndicator.classList.remove('active');
            }, 3000);
        }
        
        // Event auslösen
        const syncEvent = new CustomEvent('offlineChangesSynchronized', {
            detail: {
                timestamp: new Date()
            }
        });
        document.dispatchEvent(syncEvent);
    }
};

// Datenintegritäts- und Validierungsfunktionen
app.answerStorage.persistence.dataIntegrity = {
    /**
     * Prüft die Integrität einer Antwortensammlung
     * @param {string} sessionId - ID der Testsitzung
     * @returns {Object} Ergebnis der Integritätsprüfung
     */
    validateCollection: function(sessionId) {
        try {
            // Sammlung abrufen
            const collection = app.answerStorage.getCollection(sessionId);
            if (!collection) {
                throw new Error(`Keine Sammlung für Sitzung ${sessionId} gefunden`);
            }
            
            // Testsitzung abrufen
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) {
                throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
            }
            
            const result = {
                isValid: true,
                issues: [],
                missingAnswers: [],
                invalidAnswers: [],
                collectionExists: true,
                sessionExists: true
            };
            
            // Liste aller Fragen im Test
            const questions = Object.keys(session.testData.questions || {});
            
            // Prüfen, ob alle erforderlichen Felder in der Sammlung vorhanden sind
            if (!collection.sessionId || collection.sessionId !== sessionId) {
                result.isValid = false;
                result.issues.push('Ungültige oder fehlende sessionId');
            }
            
            if (!collection.testId || collection.testId !== session.testId) {
                result.isValid = false;
                result.issues.push('Ungültige oder fehlende testId');
            }
            
            if (!collection.userId || collection.userId !== session.userId) {
                result.isValid = false;
                result.issues.push('Ungültige oder fehlende userId');
            }
            
            // Fehlende Antworten ermitteln
            questions.forEach(questionId => {
                if (!collection.answers[questionId]) {
                    result.missingAnswers.push(questionId);
                }
            });
            
            // Ungültige Antworten prüfen
            Object.keys(collection.answers).forEach(questionId => {
                const answer = collection.answers[questionId];
                
                // Prüfen, ob die Frage im Test existiert
                if (!session.testData.questions[questionId]) {
                    result.invalidAnswers.push(questionId);
                    result.isValid = false;
                    return;
                }
                
                // Typspezifische Validierung durchführen
                const question = session.testData.questions[questionId];
                const handler = app.answerStorage.typeHandlers[question.type];
                
                if (handler && handler.validate) {
                    const isValid = handler.validate(answer, question);
                    if (!isValid) {
                        result.invalidAnswers.push(questionId);
                        result.isValid = false;
                    }
                }
            });
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Integritätsprüfung:', error);
            return {
                isValid: false,
                issues: [error.message],
                error: error
            };
        }
    },
    
    /**
     * Versucht, Probleme mit einer Antwortensammlung zu beheben
     * @param {string} sessionId - ID der Testsitzung
     * @returns {Object} Ergebnis der Reparatur
     */
    repairCollection: function(sessionId) {
        try {
            // Integrität prüfen
            const validationResult = this.validateCollection(sessionId);
            
            // Wenn keine Probleme gefunden wurden
            if (validationResult.isValid) {
                return {
                    success: true,
                    message: 'Keine Probleme gefunden'
                };
            }
            
            // Sammlung und Sitzung abrufen
            const collection = app.answerStorage.getCollection(sessionId);
            const session = app.testSessionManager.getSession(sessionId);
            
            if (!collection || !session) {
                return {
                    success: false,
                    message: 'Sammlung oder Sitzung nicht gefunden'
                };
            }
            
            // Grundlegende Eigenschaften korrigieren
            if (collection.sessionId !== sessionId) {
                collection.sessionId = sessionId;
            }
            
            if (collection.testId !== session.testId) {
                collection.testId = session.testId;
            }
            
            if (collection.userId !== session.userId) {
                collection.userId = session.userId;
            }
            
            // Ungültige Antworten entfernen
            validationResult.invalidAnswers.forEach(questionId => {
                delete collection.answers[questionId];
            });
            
            // Aktualisierte Sammlung speichern
            app.answerStorage.activeCollections[sessionId] = collection;
            app.answerStorage.saveToLocalStorage(collection);
            
            return {
                success: true,
                message: 'Sammlung repariert',
                removedAnswers: validationResult.invalidAnswers.length,
                issues: validationResult.issues
            };
        } catch (error) {
            console.error('Fehler bei der Reparatur der Sammlung:', error);
            return {
                success: false,
                message: 'Reparatur fehlgeschlagen: ' + error.message
            };
        }
    },
    
    /**
     * Führt regelmäßige Integritätsprüfungen durch
     * @param {number} interval - Intervall für Prüfungen in Millisekunden
     */
    startPeriodicChecks: function(interval = 60000) { // 1 Minute
        // Intervall-ID für spätere Referenz
        this.checkIntervalId = setInterval(() => {
            // Aktuelle Sitzungs-ID abrufen
            const sessionId = app.testSessionManager.getCurrentSessionId();
            if (!sessionId) return;
            
            // Integritätsprüfung durchführen
            const validationResult = this.validateCollection(sessionId);
            
            // Bei Problemen Event auslösen
            if (!validationResult.isValid) {
                console.warn('Integritätsprobleme in Sammlung gefunden:', validationResult);
                
                // Event auslösen
                const integrityEvent = new CustomEvent('dataIntegrityIssue', {
                    detail: {
                        sessionId,
                        validationResult,
                        timestamp: new Date()
                    }
                });
                document.dispatchEvent(integrityEvent);
                
                // Automatische Reparatur versuchen
                this.repairCollection(sessionId);
            }
        }, interval);
    },
    
    /**
     * Stoppt regelmäßige Integritätsprüfungen
     */
    stopPeriodicChecks: function() {
        if (this.checkIntervalId) {
            clearInterval(this.checkIntervalId);
            this.checkIntervalId = null;
        }
    }
};

/**
 * Erweitert die öffentliche Schnittstelle um die neuen Funktionen
 */
Object.assign(app.answerStorage.interface, {
    // Wiederherstellungsfunktionen
    restoreAnswersToUI: app.answerStorage.persistence.recovery.restoreAnswersToUI.bind(app.answerStorage.persistence.recovery),
    
    // Datenintegritätsfunktionen
    validateAnswerCollection: app.answerStorage.persistence.dataIntegrity.validateCollection.bind(app.answerStorage.persistence.dataIntegrity),
    repairAnswerCollection: app.answerStorage.persistence.dataIntegrity.repairCollection.bind(app.answerStorage.persistence.dataIntegrity),
    
    // Offline-Modus
    isOnline: () => app.answerStorage.persistence.offlineMode.isOnline
});

// Anpassung der CSS-Stile für die neuen UI-Elemente
(function() {
    const style = document.createElement('style');
    style.textContent = `
        /* Offline-Indikator */
        .offline-indicator {
            transition: all 0.3s ease;
        }
        
        /* Speicherstatusanzeige */
        .save-indicator {
            transition: opacity 0.3s ease;
        }
        .save-indicator.synced {
            color: #007aff;
        }
        
        /* Speichern-Button */
        .save-answer-btn {
            background-color: #00FFD0;
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }
        .save-answer-btn:hover {
            background-color: #00e6bd;
        }
        .save-answer-btn:active {
            background-color: #00ccaa;
        }
    `;
    document.head.appendChild(style);
})();

// Initialisierung der erweiterten Speichermechanismen
(function() {
    console.log('Speichermechanismen (Teil 2) initialisiert');
    
    // Tab-Synchronisierung initialisieren
    app.answerStorage.persistence.tabSync.initialize();
    
    // Offline-Modus initialisieren
    app.answerStorage.persistence.offlineMode.initialize();
    
    // Regelmäßige Integritätsprüfungen starten
    app.answerStorage.persistence.dataIntegrity.startPeriodicChecks();
    
    // Event-Listener erweitern
    
    // Frage gerendert - Wiederherstellung der Antworten in die UI
    document.addEventListener('questionRendered', function(event) {
        const questionId = event.detail.questionId;
        const questionContainer = event.detail.container;
        const sessionId = app.testSessionManager.getCurrentSessionId();
        
        if (questionId && questionContainer && sessionId) {
            // Gespeicherte Antwort für diese Frage abrufen
            const answer = app.answerStorage.getAnswer(sessionId, questionId);
            
            // Wenn eine Antwort existiert, in der UI wiederherstellen
            if (answer) {
                // Je nach Fragetyp wiederherstellen
                switch (answer.questionType) {
                    case 'multiple-choice':
                        app.answerStorage.persistence.recovery.restoreMultipleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'single-choice':
                        app.answerStorage.persistence.recovery.restoreSingleChoiceAnswer(answer, questionContainer);
                        break;
                    case 'true-false':
                        app.answerStorage.persistence.recovery.restoreTrueFalseAnswer(answer, questionContainer);
                        break;
                    case 'free-text':
                        app.answerStorage.persistence.recovery.restoreFreeTextAnswer(answer, questionContainer);
                        break;
                }
                
                // "Speichern"-Button hinzufügen
                const saveButton = document.createElement('button');
                saveButton.className = 'save-answer-btn';
                saveButton.innerHTML = '<i class="fa fa-save"></i> Antwort speichern';
                saveButton.dataset.questionId = questionId;
                
                // Einfügen nach den Eingabeelementen
                const inputContainer = questionContainer.querySelector('.answer-inputs') || questionContainer;
                inputContainer.appendChild(saveButton);
            }
        }
    });
    
    // Beim Laden der Testseite
    document.addEventListener('testPageLoaded', function(event) {
        const sessionId = event.detail.sessionId;
        const container = document.getElementById('test-container');
        
        if (sessionId && container) {
            // Versuchen, gespeicherte Antworten wiederherzustellen
            const recovered = app.answerStorage.persistence.recoverAnswers(sessionId);
            
            if (recovered) {
                // Wiederhergestellte Antworten in der UI anzeigen
                app.answerStorage.persistence.recovery.restoreAnswersToUI(sessionId, container);
                
                // Erfolgsmeldung anzeigen
                const globalSaveIndicator = document.getElementById('global-save-indicator');
                if (globalSaveIndicator) {
                    globalSaveIndicator.innerHTML = '<i class="fa fa-check"></i> Frühere Antworten wiederhergestellt';
                    globalSaveIndicator.classList.add('active');
                    
                    // Nach einigen Sekunden ausblenden
                    setTimeout(() => {
                        globalSaveIndicator.classList.remove('active');
                    }, 5000);
                }
                
                console.log(`Frühere Antworten für Sitzung ${sessionId} wiederhergestellt`);
            }
        }
    });
})();
/**
 * JS-Block 5.7.1-part1: Testfortschritt - Fortschrittsanzeige (Teil 1)
 * 
 * Dieser Block implementiert die grundlegenden Komponenten zur Visualisierung des Testfortschritts,
 * einschließlich Fortschrittsbalken, Fragenindikatoren und Statusanzeigen.
 */

// Namespace für Testfortschritt
app.testProgress = {
    // Konfiguration
    config: {
        // ImmoScout24-Markenfarben
        colors: {
            primary: '#00FFD0',   // Hauptfarbe
            secondary: '#333333', // Textfarbe
            dark: '#222222',      // Hintergrundfarbe
            light: '#FFFFFF',     // Helle Textfarbe
            warning: '#FF9500',   // Warnfarbe
            success: '#34C759',   // Erfolgsfarbe
            error: '#FF3B30'      // Fehlerfarbe
        },
        
        // Animation und Übergänge
        animations: {
            duration: 400,         // Dauer der Animation in ms
            easing: 'ease-in-out'  // Art der Animation
        },
        
        // Standard-Formatierung für Zeitanzeige
        timeFormat: {
            showHours: true,       // Stunden anzeigen, auch wenn 0
            showMinutes: true,     // Minuten immer anzeigen
            showSeconds: true,     // Sekunden immer anzeigen
            separator: ':'         // Trennzeichen zwischen Zeiteinheiten
        },
        
        // Progress-Bar-Konfiguration
        progressBar: {
            height: 8,             // Höhe in px
            borderRadius: 4,       // Rundung der Ecken
            segments: true,        // Segmentierte Anzeige pro Frage
            showPercentage: true   // Prozentangabe einblenden
        }
    },
    
    // Speichert den aktuellen Zustand des Fortschritts
    state: {
        currentQuestionIndex: 0,   // Index der aktuellen Frage (0-basiert)
        totalQuestions: 0,         // Gesamtzahl der Fragen
        answeredQuestions: 0,      // Anzahl der beantworteten Fragen
        remainingTime: null,       // Verbleibende Zeit (bei zeitlich begrenzten Tests)
        elapsedTime: 0,            // Verstrichene Zeit in Sekunden
        startTime: null,           // Startzeitpunkt des Tests
        percentage: 0,             // Fortschritt in Prozent
        isComplete: false,         // Test abgeschlossen?
        questionStates: [],        // Status jeder Frage: {answered: bool, correct: bool|null}
        currentSessionId: null     // ID der aktuellen Testsitzung
    },
    
    // Timer-Verwaltung
    timers: {
        elapsedTimer: null,       // Intervall für verstrichene Zeit
        remainingTimer: null      // Intervall für verbleibende Zeit
    },
    
    /**
     * Initialisiert die Fortschrittsanzeige für eine Testsitzung
     * @param {string} sessionId - ID der Testsitzung
     * @param {HTMLElement} container - Container für die Fortschrittsanzeige
     */
    initialize: function(sessionId, container) {
        try {
            // Testsitzung abrufen
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) {
                throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
            }
            
            // Testdaten extrahieren
            const testData = session.testData;
            const questionCount = Object.keys(testData.questions || {}).length;
            
            // State zurücksetzen und initialisieren
            this.resetState();
            this.state.totalQuestions = questionCount;
            this.state.currentSessionId = sessionId;
            this.state.startTime = session.startTimestamp || Date.now();
            
            // Zeitlimit übernehmen, falls vorhanden
            if (testData.timeLimit) {
                this.state.remainingTime = testData.timeLimit * 60; // Umrechnung in Sekunden
            }
            
            // Fragen-Status initialisieren
            this.initializeQuestionStates(session);
            
            // UI-Komponenten erstellen
            if (container) {
                this.createProgressUI(container);
                
                // Timer starten
                this.startTimers();
            }
            
            console.log(`Fortschrittsanzeige für Testsitzung ${sessionId} initialisiert`);
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung der Fortschrittsanzeige:', error);
            return false;
        }
    },
    
    /**
     * Setzt den internen Zustand zurück
     */
    resetState: function() {
        // Timer stoppen
        this.stopTimers();
        
        // Status zurücksetzen
        this.state = {
            currentQuestionIndex: 0,
            totalQuestions: 0,
            answeredQuestions: 0,
            remainingTime: null,
            elapsedTime: 0,
            startTime: null,
            percentage: 0,
            isComplete: false,
            questionStates: [],
            currentSessionId: null
        };
    },
    
    /**
     * Initialisiert den Status für jede Frage
     * @param {Object} session - Die Testsitzung
     */
    initializeQuestionStates: function(session) {
        const testData = session.testData;
        const questions = Object.keys(testData.questions || {});
        const answers = session.answers || {};
        
        this.state.questionStates = [];
        let answeredCount = 0;
        
        questions.forEach(questionId => {
            const isAnswered = !!answers[questionId];
            const answer = answers[questionId] || null;
            const correctness = answer ? answer.isCorrect : null;
            
            this.state.questionStates.push({
                questionId: questionId,
                answered: isAnswered,
                correct: correctness
            });
            
            if (isAnswered) answeredCount++;
        });
        
        this.state.answeredQuestions = answeredCount;
        this.updatePercentage();
    },
    
    /**
     * Aktualisiert den Prozentsatz des Fortschritts
     */
    updatePercentage: function() {
        if (this.state.totalQuestions > 0) {
            this.state.percentage = Math.round((this.state.answeredQuestions / this.state.totalQuestions) * 100);
        } else {
            this.state.percentage = 0;
        }
    },
    
    /**
     * Erstellt die UI-Komponenten für die Fortschrittsanzeige
     * @param {HTMLElement} container - Container für die Fortschrittsanzeige
     */
    createProgressUI: function(container) {
        // Container leeren
        container.innerHTML = '';
        
        // Hauptcontainer erstellen
        const progressContainer = document.createElement('div');
        progressContainer.className = 'test-progress-container';
        
        // Fortschrittsbalken erstellen
        const progressBar = this.createProgressBar();
        progressContainer.appendChild(progressBar);
        
        // Fragenindikatoren erstellen
        const questionIndicators = this.createQuestionIndicators();
        progressContainer.appendChild(questionIndicators);
        
        // Informationsbereich erstellen
        const infoSection = this.createInfoSection();
        progressContainer.appendChild(infoSection);
        
        // Zum Haupt-Container hinzufügen
        container.appendChild(progressContainer);
        
        // CSS-Stile hinzufügen
        this.addProgressStyles();
    },
    
    /**
     * Erstellt den Fortschrittsbalken
     * @returns {HTMLElement} Der Fortschrittsbalken
     */
    createProgressBar: function() {
        const progressBarContainer = document.createElement('div');
        progressBarContainer.className = 'progress-bar-container';
        
        // Hintergrund-Balken
        const progressBackground = document.createElement('div');
        progressBackground.className = 'progress-background';
        
        // Fortschrittsbalken
        const progressFill = document.createElement('div');
        progressFill.className = 'progress-fill';
        progressFill.style.width = `${this.state.percentage}%`;
        
        // Prozentanzeige
        const percentageLabel = document.createElement('span');
        percentageLabel.className = 'progress-percentage';
        percentageLabel.textContent = `${this.state.percentage}%`;
        
        // Zusammenfügen
        progressBackground.appendChild(progressFill);
        progressBarContainer.appendChild(progressBackground);
        
        if (this.config.progressBar.showPercentage) {
            progressBarContainer.appendChild(percentageLabel);
        }
        
        return progressBarContainer;
    },
    
    /**
     * Erstellt Indikatoren für jede Frage
     * @returns {HTMLElement} Container mit Fragenindikatoren
     */
    createQuestionIndicators: function() {
        const indicatorsContainer = document.createElement('div');
        indicatorsContainer.className = 'question-indicators-container';
        
        // Für jede Frage einen Indikator erstellen
        this.state.questionStates.forEach((questionState, index) => {
            const indicator = document.createElement('div');
            indicator.className = 'question-indicator';
            indicator.dataset.questionIndex = index;
            indicator.dataset.questionId = questionState.questionId;
            
            // Zusätzliche Klassen basierend auf dem Status
            if (questionState.answered) {
                indicator.classList.add('answered');
                
                if (questionState.correct === true) {
                    indicator.classList.add('correct');
                } else if (questionState.correct === false) {
                    indicator.classList.add('incorrect');
                }
            }
            
            // Aktuelle Frage markieren
            if (index === this.state.currentQuestionIndex) {
                indicator.classList.add('current');
            }
            
            // Event-Listener für Klick (Navigation)
            indicator.addEventListener('click', () => {
                this.navigateToQuestion(questionState.questionId);
            });
            
            // Tooltip mit Fragennummer
            indicator.title = `Frage ${index + 1}`;
            
            indicatorsContainer.appendChild(indicator);
        });
        
        return indicatorsContainer;
    },
    
    /**
     * Erstellt den Informationsbereich mit Test-Fortschritt und Zeit
     * @returns {HTMLElement} Informationsbereich
     */
    createInfoSection: function() {
        const infoSection = document.createElement('div');
        infoSection.className = 'test-info-section';
        
        // Fortschrittsinformation
        const progressInfo = document.createElement('div');
        progressInfo.className = 'progress-info';
        progressInfo.innerHTML = `
            <span class="questions-done">${this.state.answeredQuestions}</span>
            <span class="separator">/</span>
            <span class="questions-total">${this.state.totalQuestions}</span>
            <span class="label">Fragen beantwortet</span>
        `;
        
        // Zeit-Information
        const timeInfo = document.createElement('div');
        timeInfo.className = 'time-info';
        
        // Unterschiedliche Zeitanzeigen je nach Testtyp
        if (this.state.remainingTime !== null) {
            // Verbleibende Zeit für Tests mit Zeitlimit
            timeInfo.innerHTML = `
                <span class="time-label">Verbleibende Zeit:</span>
                <span class="time-value remaining-time">${this.formatTime(this.state.remainingTime)}</span>
            `;
            timeInfo.classList.add('countdown');
        } else {
            // Verstrichene Zeit für Tests ohne Zeitlimit
            timeInfo.innerHTML = `
                <span class="time-label">Verstrichene Zeit:</span>
                <span class="time-value elapsed-time">${this.formatTime(this.state.elapsedTime)}</span>
            `;
            timeInfo.classList.add('stopwatch');
        }
        
        // Zusammenführen
        infoSection.appendChild(progressInfo);
        infoSection.appendChild(timeInfo);
        
        return infoSection;
    },
    
    /**
     * Formatiert eine Zeitangabe in Sekunden in das Format HH:MM:SS
     * @param {number} timeInSeconds - Zeit in Sekunden
     * @returns {string} Formatierte Zeit
     */
    formatTime: function(timeInSeconds) {
        if (timeInSeconds === null || timeInSeconds === undefined) {
            return '--:--';
        }
        
        // Werte extrahieren
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        
        // Komponenten zusammenstellen
        let formattedTime = '';
        
        // Stunden hinzufügen, wenn vorhanden oder konfiguriert
        if (hours > 0 || this.config.timeFormat.showHours) {
            formattedTime += hours.toString().padStart(2, '0');
            formattedTime += this.config.timeFormat.separator;
        }
        
        // Minuten hinzufügen
        formattedTime += minutes.toString().padStart(2, '0');
        formattedTime += this.config.timeFormat.separator;
        
        // Sekunden hinzufügen
        formattedTime += seconds.toString().padStart(2, '0');
        
        return formattedTime;
    },
    
    /**
     * Fügt CSS-Stile für die Fortschrittsanzeige hinzu
     */
    addProgressStyles: function() {
        // Prüfen, ob Stile bereits hinzugefügt wurden
        if (document.getElementById('test-progress-styles')) return;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'test-progress-styles';
        
        styleElement.textContent = `
            /* Hauptcontainer für die Fortschrittsanzeige */
            .test-progress-container {
                background-color: #f5f5f5;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 20px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }
            
            /* Fortschrittsbalken */
            .progress-bar-container {
                position: relative;
                margin-bottom: 15px;
            }
            
            .progress-background {
                height: ${this.config.progressBar.height}px;
                background-color: #e0e0e0;
                border-radius: ${this.config.progressBar.borderRadius}px;
                overflow: hidden;
            }
            
            .progress-fill {
                height: 100%;
                background-color: ${this.config.colors.primary};
                width: 0;
                transition: width ${this.config.animations.duration}ms ${this.config.animations.easing};
            }
            
            .progress-percentage {
                position: absolute;
                right: 0;
                top: -20px;
                font-size: 12px;
                font-weight: bold;
                color: ${this.config.colors.secondary};
            }
            
            /* Fragenindikatoren */
            .question-indicators-container {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin-bottom: 15px;
            }
            
            .question-indicator {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background-color: #e0e0e0;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            
            .question-indicator:hover {
                transform: scale(1.1);
            }
            
            .question-indicator.current {
                border: 2px solid ${this.config.colors.primary};
            }
            
            .question-indicator.answered {
                background-color: ${this.config.colors.primary};
            }
            
            .question-indicator.correct {
                background-color: ${this.config.colors.success};
            }
            
            .question-indicator.incorrect {
                background-color: ${this.config.colors.error};
            }
            
            /* Informationsbereich */
            .test-info-section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 14px;
            }
            
            .progress-info {
                display: flex;
                align-items: baseline;
                flex-wrap: wrap;
            }
            
            .questions-done {
                font-size: 18px;
                font-weight: bold;
                color: ${this.config.colors.primary};
            }
            
            .questions-total {
                font-size: 16px;
                color: ${this.config.colors.secondary};
            }
            
            .separator {
                margin: 0 3px;
                color: ${this.config.colors.secondary};
            }
            
            .label {
                margin-left: 8px;
                color: ${this.config.colors.secondary};
            }
            
            .time-info {
                display: flex;
                align-items: baseline;
                flex-wrap: wrap;
            }
            
            .time-label {
                margin-right: 5px;
                color: ${this.config.colors.secondary};
            }
            
            .time-value {
                font-weight: bold;
                font-family: monospace;
                font-size: 16px;
            }
            
            .countdown .time-value {
                color: ${this.config.colors.warning};
            }
            
            .countdown.urgent .time-value {
                color: ${this.config.colors.error};
                animation: pulse 1s infinite;
            }
            
            .stopwatch .time-value {
                color: ${this.config.colors.secondary};
            }
            
            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.5; }
                100% { opacity: 1; }
            }
            
            /* Responsive Anpassungen */
            @media (max-width: 768px) {
                .test-info-section {
                    flex-direction: column;
                    gap: 10px;
                    align-items: flex-start;
                }
                
                .question-indicators-container {
                    gap: 4px;
                }
                
                .question-indicator {
                    width: 16px;
                    height: 16px;
                }
            }
        `;
        
        document.head.appendChild(styleElement);
    },
    
    /**
     * Startet die Timer für Zeit-Tracking
     */
    startTimers: function() {
        // Stoppen, falls bereits aktiv
        this.stopTimers();
        
        // Timer für verstrichene Zeit
        this.timers.elapsedTimer = setInterval(() => {
            if (this.state.startTime) {
                const now = Date.now();
                this.state.elapsedTime = Math.floor((now - this.state.startTime) / 1000);
                this.updateElapsedTimeDisplay();
            }
        }, 1000);
        
        // Timer für verbleibende Zeit (wenn vorhanden)
        if (this.state.remainingTime !== null) {
            this.timers.remainingTimer = setInterval(() => {
                if (this.state.remainingTime > 0) {
                    this.state.remainingTime--;
                    this.updateRemainingTimeDisplay();
                    
                    // Warnung bei wenig verbleibender Zeit
                    if (this.state.remainingTime <= 60) { // Letzte Minute
                        this.setUrgentTimeWarning(true);
                    }
                    
                    // Zeit abgelaufen
                    if (this.state.remainingTime <= 0) {
                        this.stopTimers();
                        this.handleTimeUp();
                    }
                }
            }, 1000);
        }
    },
    
    /**
     * Stoppt alle laufenden Timer
     */
    stopTimers: function() {
        if (this.timers.elapsedTimer) {
            clearInterval(this.timers.elapsedTimer);
            this.timers.elapsedTimer = null;
        }
        
        if (this.timers.remainingTimer) {
            clearInterval(this.timers.remainingTimer);
            this.timers.remainingTimer = null;
        }
    },
    
    /**
     * Aktualisiert die Anzeige der verstrichenen Zeit
     */
    updateElapsedTimeDisplay: function() {
        const elapsedTimeElement = document.querySelector('.elapsed-time');
        if (elapsedTimeElement) {
            elapsedTimeElement.textContent = this.formatTime(this.state.elapsedTime);
        }
    },
    
    /**
     * Aktualisiert die Anzeige der verbleibenden Zeit
     */
    updateRemainingTimeDisplay: function() {
        const remainingTimeElement = document.querySelector('.remaining-time');
        if (remainingTimeElement) {
            remainingTimeElement.textContent = this.formatTime(this.state.remainingTime);
        }
    },
    
    /**
     * Setzt den Warnmodus für kritisch wenig Zeit
     * @param {boolean} isUrgent - Ob die Zeit kritisch ist
     */
    setUrgentTimeWarning: function(isUrgent) {
        const timeInfo = document.querySelector('.time-info.countdown');
        if (timeInfo) {
            if (isUrgent) {
                timeInfo.classList.add('urgent');
            } else {
                timeInfo.classList.remove('urgent');
            }
        }
    },
    
    /**
     * Behandelt das Ablaufen der Zeit
     */
    handleTimeUp: function() {
        console.log('Zeit abgelaufen!');
        
        // Event auslösen
        const timeUpEvent = new CustomEvent('testTimeUp', {
            detail: {
                sessionId: this.state.currentSessionId,
                elapsedTime: this.state.elapsedTime
            }
        });
        document.dispatchEvent(timeUpEvent);
        
        // Visuelles Feedback
        const timeInfo = document.querySelector('.time-info.countdown');
        if (timeInfo) {
            timeInfo.classList.add('time-up');
            const timeValue = timeInfo.querySelector('.time-value');
            if (timeValue) {
                timeValue.textContent = 'ZEIT ABGELAUFEN';
            }
        }
        
        // Dialog anzeigen
        this.showTimeUpDialog();
    },
    
    /**
     * Zeigt einen Dialog an, wenn die Zeit abgelaufen ist
     */
    showTimeUpDialog: function() {
        // Prüfen, ob bereits ein Dialog angezeigt wird
        if (document.getElementById('time-up-dialog')) return;
        
        // Dialog-Container erstellen
        const dialogOverlay = document.createElement('div');
        dialogOverlay.className = 'dialog-overlay';
        dialogOverlay.id = 'time-up-dialog';
        
        // Dialog-Inhalt
        const dialogContent = document.createElement('div');
        dialogContent.className = 'dialog-content';
        dialogContent.innerHTML = `
            <h2>Zeit abgelaufen!</h2>
            <p>Die für diesen Test vorgesehene Zeit ist abgelaufen.</p>
            <p>Ihre Antworten wurden automatisch gespeichert.</p>
            <button class="primary-button" id="finish-test-btn">Test abschließen</button>
        `;
        
        // Zusammenfügen und zum DOM hinzufügen
        dialogOverlay.appendChild(dialogContent);
        document.body.appendChild(dialogOverlay);
        
        // Event-Listener für den Button
        document.getElementById('finish-test-btn').addEventListener('click', () => {
            // Test beenden
            this.finishTest();
            
            // Dialog entfernen
            dialogOverlay.remove();
        });
        
        // CSS für den Dialog
        const style = document.createElement('style');
        style.textContent = `
            .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }
            
            .dialog-content {
                background-color: white;
                padding: 30px;
                border-radius: 8px;
                max-width: 500px;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            }
            
            .dialog-content h2 {
                color: ${this.config.colors.error};
                margin-top: 0;
            }
            
            .primary-button {
                background-color: ${this.config.colors.primary};
                color: ${this.config.colors.secondary};
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                font-weight: bold;
                cursor: pointer;
                margin-top: 20px;
                transition: background-color 0.2s;
            }
            
            .primary-button:hover {
                background-color: #00E6BD;
            }
        `;
        document.head.appendChild(style);
    },
    
    /**
     * Beendet den Test
     */
    finishTest: function() {
        // Event auslösen
        const finishEvent = new CustomEvent('testFinish', {
            detail: {
                sessionId: this.state.currentSessionId,
                elapsedTime: this.state.elapsedTime,
                reason: 'timeUp'
            }
        });
        document.dispatchEvent(finishEvent);
    },
    
    /**
     * Aktualisiert die Fortschrittsanzeige
     */
    updateProgress: function() {
        // Prozentsatz aktualisieren
        this.updatePercentage();
        
        // Fortschrittsbalken aktualisieren
        const progressFill = document.querySelector('.progress-fill');
        if (progressFill) {
            progressFill.style.width = `${this.state.percentage}%`;
        }
        
        // Prozentanzeige aktualisieren
        const percentageLabel = document.querySelector('.progress-percentage');
        if (percentageLabel) {
            percentageLabel.textContent = `${this.state.percentage}%`;
        }
        
        // Fragenindikatoren aktualisieren
        this.updateQuestionIndicators();
        
        // Fortschrittsinformation aktualisieren
        const questionsDone = document.querySelector('.questions-done');
        if (questionsDone) {
            questionsDone.textContent = this.state.answeredQuestions;
        }
    },
    
    /**
     * Aktualisiert die Fragenindikatoren
     */
    updateQuestionIndicators: function() {
        const indicators = document.querySelectorAll('.question-indicator');
        
        indicators.forEach((indicator, index) => {
            const questionState = this.state.questionStates[index];
            
            // Klassen zurücksetzen
            indicator.classList.remove('answered', 'correct', 'incorrect', 'current');
            
            // Aktuelle Klassen basierend auf Status setzen
            if (questionState.answered) {
                indicator.classList.add('answered');
                
                if (questionState.correct === true) {
                    indicator.classList.add('correct');
                } else if (questionState.correct === false) {
                    indicator.classList.add('incorrect');
                }
            }
            
            // Aktuelle Frage markieren
            if (index === this.state.currentQuestionIndex) {
                indicator.classList.add('current');
            }
        });
    },
    
    /**
     * Navigiert zu einer bestimmten Frage
     * @param {string} questionId - ID der Frage
     */
    navigateToQuestion: function(questionId) {
        // Event auslösen
        const navigationEvent = new CustomEvent('questionNavigationRequest', {
            detail: {
                sessionId: this.state.currentSessionId,
                questionId: questionId
            }
        });
        document.dispatchEvent(navigationEvent);
    },
    
    /**
     * Aktualisiert den Status einer Frage
     * @param {string} questionId - ID der Frage
     * @param {boolean} isAnswered - Ob die Frage beantwortet wurde
     * @param {boolean|null} isCorrect - Ob die Antwort korrekt ist (null für unbekannt/teilweise)
     */
    updateQuestionState: function(questionId, isAnswered, isCorrect) {
        // Fragen-Index finden
        const questionIndex = this.state.questionStates.findIndex(q => q.questionId === questionId);
        
        if (questionIndex === -1) return;
        
        // Status aktualisieren
        const wasAnsweredBefore = this.state.questionStates[questionIndex].answered;
        
        this.state.questionStates[questionIndex] = {
            questionId,
            answered: isAnswered,
            correct: isCorrect
        };
        
        // Zähler für beantwortete Fragen aktualisieren
        if (!wasAnsweredBefore && isAnswered) {
            this.state.answeredQuestions++;
        } else if (wasAnsweredBefore && !isAnswered) {
            this.state.answeredQuestions--;
        }
        
        // Fortschritt aktualisieren
        this.updateProgress();
    },
    
    /**
     * Setzt die aktuelle Frage
     * @param {number} index - Index der aktuellen Frage
     */
    setCurrentQuestion: function(index) {
        if (index >= 0 && index < this.state.totalQuestions) {
            this.state.currentQuestionIndex = index;
            this.updateQuestionIndicators();
        }
    },
    
    /**
     * Setzt die aktuelle Frage anhand der Frage-ID
     * @param {string} questionId - ID der Frage
     */
    setCurrentQuestionById: function(questionId) {
        const index = this.state.questionStates.findIndex(q => q.questionId === questionId);
        
        if (index !== -1) {
            this.setCurrentQuestion(index);
        }
    }
};

// Event-Handler für Test-Ereignisse
(function() {
    // Initialisierung beim Laden der Testseite
    document.addEventListener('testPageLoaded', function(event) {
        const sessionId = event.detail.sessionId;
        const progressContainer = document.getElementById('test-progress-container');
        
        if (sessionId && progressContainer) {
            app.testProgress.initialize(sessionId, progressContainer);
        }
    });
    
    // Aktualisierung bei Beantwortung einer Frage
    document.addEventListener('answerSaved', function(event) {
        const sessionId = event.detail.sessionId;
        const questionId = event.detail.questionId;
        
        if (sessionId === app.testProgress.state.currentSessionId) {
            // Antwort abrufen
            const answer = app.answerStorage.getAnswer(sessionId, questionId);
            
            if (answer) {
                app.testProgress.updateQuestionState(questionId, true, answer.isCorrect);
            }
        }
    });
    
    // Aktualisierung bei Fragewechsel
    document.addEventListener('questionChanged', function(event) {
        const questionId = event.detail.questionId;
        
        if (questionId) {
            app.testProgress.setCurrentQuestionById(questionId);
        }
    });
    
    console.log('Testfortschritt-Modul (Teil 1) initialisiert');
})();

// Öffentliche Schnittstelle exportieren
app.testProgress.interface = {
    initialize: app.testProgress.initialize.bind(app.testProgress),
    updateQuestionState: app.testProgress.updateQuestionState.bind(app.testProgress),
    setCurrentQuestion: app.testProgress.setCurrentQuestionById.bind(app.testProgress)
};
/**
 * JS-Block 5.7.1-part2: Testfortschritt - Fortschrittsanzeige (Teil 2)
 * 
 * Dieser Block erweitert die Fortschrittsanzeige um zusätzliche Funktionen:
 * - Abschnitts-/Kategoriebasierte Fortschrittsanzeige
 * - Fragenübersicht und Navigationspanel
 * - Erweiterte Statusvisualisierungen
 * - Motivationselemente und gamifizierte Aspekte
 */

// Namespace für erweiterte Fortschrittsanzeigefeatures
app.testProgress.extended = {
    // Konfiguration
    config: {
        // Features ein-/ausschalten
        features: {
            categories: true,           // Kategoriebasierte Anzeige
            overview: true,             // Fragenübersicht
            bookmarks: true,            // Lesezeichen für Fragen
            notes: true,                // Fragen-Notizen
            motivation: true,           // Motivierende Elemente
            timeTracking: true          // Detaillierte Zeiterfassung
        },
        
        // Animationen
        animations: {
            enabled: true,              // Animationen aktivieren
            duration: 400,              // Standard-Dauer in ms
            confettiOnMilestone: true   // Konfetti bei Meilensteinen
        },
        
        // Motivierende Nachrichten
        motivationalMessages: [
            "Super! Mach weiter so!",
            "Du machst großartige Fortschritte!",
            "Bleib dran, du schaffst das!",
            "Hervorragende Arbeit!",
            "Jede beantwortete Frage bringt dich dem Ziel näher!",
            "Du bist auf einem guten Weg!",
            "Toll gemacht, weiter so!",
            "Deine Beständigkeit zahlt sich aus!"
        ],
        
        // Meilensteine für Fortschritt (in Prozent)
        milestones: [25, 50, 75, 100],
        
        // Kategorie-Anzeige
        categoryDisplay: {
            showPercentage: true,       // Prozentsatz pro Kategorie anzeigen
            collapsible: true,          // Kategorien ein-/ausklappbar
            colorCoded: true            // Farbkodierung für Kategorien
        }
    },
    
    // Status der erweiterten Funktionen
    state: {
        expandedCategories: {},         // Welche Kategorien sind ausgeklappt
        bookmarkedQuestions: [],        // Lesezeichen für Fragen
        questionNotes: {},              // Notizen zu Fragen
        overviewVisible: false,         // Ist die Übersicht sichtbar
        reachedMilestones: [],          // Bereits erreichte Meilensteine
        questionTimeTracking: {},       // Zeit pro Frage
        categoryData: null,             // Daten zu Kategorien
        categoryProgress: {}            // Fortschritt pro Kategorie
    },
    
    /**
     * Initialisiert die erweiterten Fortschrittsfunktionen
     * @param {string} sessionId - ID der Testsitzung
     */
    initialize: function(sessionId) {
        try {
            // Testsitzung abrufen
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) {
                throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
            }
            
            // Testdaten extrahieren
            const testData = session.testData;
            
            // Status zurücksetzen
            this.resetState();
            
            // Erweiterte UI-Elemente hinzufügen
            this.setupExtendedUI();
            
            // Kategorien analysieren, falls vorhanden
            if (this.config.features.categories) {
                this.analyzeCategoriesData(testData);
            }
            
            // Gespeicherte Benutzereinstellungen laden
            this.loadUserSettings(sessionId);
            
            // Zeiterfassung pro Frage starten
            if (this.config.features.timeTracking) {
                this.initializeTimeTracking();
            }
            
            console.log('Erweiterte Fortschrittsfunktionen initialisiert');
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung der erweiterten Fortschrittsfunktionen:', error);
            return false;
        }
    },
    
    /**
     * Setzt den erweiterten Zustand zurück
     */
    resetState: function() {
        this.state = {
            expandedCategories: {},
            bookmarkedQuestions: [],
            questionNotes: {},
            overviewVisible: false,
            reachedMilestones: [],
            questionTimeTracking: {},
            categoryData: null,
            categoryProgress: {}
        };
    },
    
    /**
     * Fügt erweiterte UI-Elemente hinzu
     */
    setupExtendedUI: function() {
        // Fortschrittscontainer abrufen
        const container = document.querySelector('.test-progress-container');
        if (!container) return;
        
        // Erweiterte Funktionsleiste
        this.createExtendedToolbar(container);
        
        // Fragenübersicht-Panel (anfangs versteckt)
        this.createQuestionsOverview(container);
        
        // CSS für erweiterte Funktionen hinzufügen
        this.addExtendedStyles();
        
        // Event-Listener für UI-Interaktionen einrichten
        this.setupEventListeners();
    },
    
    /**
     * Erstellt die erweiterte Funktionsleiste
     * @param {HTMLElement} container - Container für die Fortschrittsanzeige
     */
    createExtendedToolbar: function(container) {
        const toolbar = document.createElement('div');
        toolbar.className = 'progress-extended-toolbar';
        
        // Übersicht-Button
        if (this.config.features.overview) {
            const overviewBtn = document.createElement('button');
            overviewBtn.className = 'toolbar-btn overview-btn';
            overviewBtn.innerHTML = '<i class="fa fa-list"></i> Fragenübersicht';
            overviewBtn.addEventListener('click', () => this.toggleQuestionsOverview());
            toolbar.appendChild(overviewBtn);
        }
        
        // Button für Kategorienansicht
        if (this.config.features.categories && this.state.categoryData) {
            const categoriesBtn = document.createElement('button');
            categoriesBtn.className = 'toolbar-btn categories-btn';
            categoriesBtn.innerHTML = '<i class="fa fa-folder"></i> Kategorien';
            categoriesBtn.addEventListener('click', () => this.toggleCategoriesView());
            toolbar.appendChild(categoriesBtn);
        }
        
        // Motivationsnachricht-Container
        if (this.config.features.motivation) {
            const motivationContainer = document.createElement('div');
            motivationContainer.className = 'motivation-container';
            motivationContainer.innerHTML = '<span class="motivation-message"></span>';
            toolbar.appendChild(motivationContainer);
        }
        
        container.appendChild(toolbar);
    },
    
    /**
     * Erstellt das Fragenübersichtspanel
     * @param {HTMLElement} container - Container für die Fortschrittsanzeige
     */
    createQuestionsOverview: function(container) {
        // Hauptcontainer für die Übersicht
        const overviewPanel = document.createElement('div');
        overviewPanel.className = 'questions-overview-panel';
        overviewPanel.style.display = 'none'; // Anfangs versteckt
        
        // Header mit Titel und Schließen-Button
        const header = document.createElement('div');
        header.className = 'overview-header';
        header.innerHTML = `
            <h3>Fragenübersicht</h3>
            <button class="close-overview-btn"><i class="fa fa-times"></i></button>
        `;
        
        // Filteroptionen
        const filterOptions = document.createElement('div');
        filterOptions.className = 'filter-options';
        filterOptions.innerHTML = `
            <div class="filter-group">
                <label>
                    <input type="checkbox" class="filter-answered" checked>
                    Beantwortet
                </label>
                <label>
                    <input type="checkbox" class="filter-unanswered" checked>
                    Unbeantwortet
                </label>
            </div>
            <div class="filter-group">
                <label>
                    <input type="checkbox" class="filter-bookmarked">
                    Nur mit Lesezeichen
                </label>
            </div>
        `;
        
        // Container für die Fragenliste
        const questionsList = document.createElement('div');
        questionsList.className = 'questions-list';
        
        // Fragenliste mit allen Fragen befüllen
        this.populateQuestionsList(questionsList);
        
        // Alles zusammenfügen
        overviewPanel.appendChild(header);
        overviewPanel.appendChild(filterOptions);
        overviewPanel.appendChild(questionsList);
        
        // Zum Haupt-Container hinzufügen
        container.appendChild(overviewPanel);
        
        // Event-Listener für Filter
        filterOptions.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => this.applyQuestionFilters());
        });
        
        // Event-Listener für Schließen-Button
        header.querySelector('.close-overview-btn').addEventListener('click', () => {
            this.toggleQuestionsOverview(false);
        });
    },
    
    /**
     * Befüllt die Fragenliste im Übersichtspanel
     * @param {HTMLElement} listContainer - Container für die Fragenliste
     */
    populateQuestionsList: function(listContainer) {
        // Testsitzung abrufen
        const sessionId = app.testProgress.state.currentSessionId;
        const session = app.testSessionManager.getSession(sessionId);
        if (!session) return;
        
        // Alle Fragen aus der Testsitzung
        const questions = Object.entries(session.testData.questions || {});
        
        // Liste leeren
        listContainer.innerHTML = '';
        
        // Jede Frage als Listenelement hinzufügen
        questions.forEach(([questionId, question], index) => {
            const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
            
            const listItem = document.createElement('div');
            listItem.className = 'question-list-item';
            listItem.dataset.questionId = questionId;
            
            // Status-Klassen hinzufügen
            if (questionState && questionState.answered) {
                listItem.classList.add('answered');
                
                if (questionState.correct === true) {
                    listItem.classList.add('correct');
                } else if (questionState.correct === false) {
                    listItem.classList.add('incorrect');
                }
            }
            
            // Aktuelle Frage markieren
            if (index === app.testProgress.state.currentQuestionIndex) {
                listItem.classList.add('current');
            }
            
            // Lesezeichen-Status prüfen und setzen
            const isBookmarked = this.state.bookmarkedQuestions.includes(questionId);
            if (isBookmarked) {
                listItem.classList.add('bookmarked');
            }
            
            // Fragentyp-Icon bestimmen
            let typeIcon = 'fa-question-circle';
            switch (question.type) {
                case 'multiple-choice':
                    typeIcon = 'fa-check-square';
                    break;
                case 'single-choice':
                    typeIcon = 'fa-dot-circle';
                    break;
                case 'true-false':
                    typeIcon = 'fa-toggle-on';
                    break;
                case 'free-text':
                    typeIcon = 'fa-font';
                    break;
            }
            
            // Kategorie-Information
            let categoryInfo = '';
            if (question.category && this.state.categoryData) {
                const category = this.state.categoryData.categories.find(c => c.id === question.category);
                if (category) {
                    categoryInfo = `<span class="question-category" style="color: ${category.color || '#999'}">${category.name}</span>`;
                }
            }
            
            // Inhalt zusammenstellen
            listItem.innerHTML = `
                <div class="question-header">
                    <span class="question-number">${index + 1}</span>
                    <span class="question-type"><i class="fa ${typeIcon}"></i></span>
                    <span class="question-title">${question.text.substring(0, 60)}${question.text.length > 60 ? '...' : ''}</span>
                    ${categoryInfo}
                </div>
                <div class="question-actions">
                    <button class="bookmark-btn ${isBookmarked ? 'active' : ''}" title="Lesezeichen">
                        <i class="fa ${isBookmarked ? 'fa-bookmark' : 'fa-bookmark-o'}"></i>
                    </button>
                    <button class="note-btn" title="Notiz">
                        <i class="fa fa-sticky-note-o"></i>
                    </button>
                    <button class="goto-btn" title="Zu dieser Frage">
                        <i class="fa fa-arrow-right"></i>
                    </button>
                </div>
            `;
            
            // Event-Listener für Aktionen
            listItem.querySelector('.goto-btn').addEventListener('click', (e) => {
                e.stopPropagation(); // Verhindert, dass das Klick-Event an das Listenelement weitergeleitet wird
                this.navigateToQuestion(questionId);
            });
            
            listItem.querySelector('.bookmark-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleBookmark(questionId, listItem);
            });
            
            listItem.querySelector('.note-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                this.showNoteDialog(questionId);
            });
            
            // Klick auf das Listenelement navigiert zur Frage
            listItem.addEventListener('click', () => {
                this.navigateToQuestion(questionId);
            });
            
            listContainer.appendChild(listItem);
        });
    },
    
    /**
     * Wendet Filter auf die Fragenliste an
     */
    applyQuestionFilters: function() {
        const overviewPanel = document.querySelector('.questions-overview-panel');
        if (!overviewPanel) return;
        
        // Filter-Checkboxen abrufen
        const showAnswered = overviewPanel.querySelector('.filter-answered').checked;
        const showUnanswered = overviewPanel.querySelector('.filter-unanswered').checked;
        const showOnlyBookmarked = overviewPanel.querySelector('.filter-bookmarked').checked;
        
        // Alle Fragenelemente durchgehen
        const questionItems = overviewPanel.querySelectorAll('.question-list-item');
        
        questionItems.forEach(item => {
            const isAnswered = item.classList.contains('answered');
            const isBookmarked = item.classList.contains('bookmarked');
            
            // Sichtbarkeit basierend auf Filtern bestimmen
            let isVisible = true;
            
            if (isAnswered && !showAnswered) isVisible = false;
            if (!isAnswered && !showUnanswered) isVisible = false;
            if (showOnlyBookmarked && !isBookmarked) isVisible = false;
            
            // Sichtbarkeit anwenden
            item.style.display = isVisible ? 'flex' : 'none';
        });
    },
    
    /**
     * Wechselt die Sichtbarkeit des Fragenübersichtspanels
     * @param {boolean} [show] - Optional: erzwingt Anzeigen oder Verbergen
     */
    toggleQuestionsOverview: function(show) {
        const overviewPanel = document.querySelector('.questions-overview-panel');
        if (!overviewPanel) return;
        
        // Status bestimmen
        const newState = show !== undefined ? show : !this.state.overviewVisible;
        
        // Sichtbarkeit ändern
        overviewPanel.style.display = newState ? 'flex' : 'none';
        
        // Status aktualisieren
        this.state.overviewVisible = newState;
        
        // Button-Status aktualisieren
        const overviewBtn = document.querySelector('.overview-btn');
        if (overviewBtn) {
            if (newState) {
                overviewBtn.classList.add('active');
            } else {
                overviewBtn.classList.remove('active');
            }
        }
        
        // Bei Anzeigen: Fragenliste aktualisieren
        if (newState) {
            const questionsList = overviewPanel.querySelector('.questions-list');
            if (questionsList) {
                this.populateQuestionsList(questionsList);
                this.applyQuestionFilters();
            }
        }
    },
    
    /**
     * Toggled ein Lesezeichen für eine Frage
     * @param {string} questionId - ID der Frage
     * @param {HTMLElement} listItem - Listenelement (optional)
     */
    toggleBookmark: function(questionId, listItem) {
        // Prüfen, ob bereits ein Lesezeichen gesetzt ist
        const index = this.state.bookmarkedQuestions.indexOf(questionId);
        let isBookmarked;
        
        if (index === -1) {
            // Lesezeichen hinzufügen
            this.state.bookmarkedQuestions.push(questionId);
            isBookmarked = true;
        } else {
            // Lesezeichen entfernen
            this.state.bookmarkedQuestions.splice(index, 1);
            isBookmarked = false;
        }
        
        // Wenn Listenelement vorhanden, aktualisieren
        if (listItem) {
            const bookmarkBtn = listItem.querySelector('.bookmark-btn');
            const bookmarkIcon = bookmarkBtn.querySelector('i');
            
            if (isBookmarked) {
                listItem.classList.add('bookmarked');
                bookmarkBtn.classList.add('active');
                bookmarkIcon.classList.remove('fa-bookmark-o');
                bookmarkIcon.classList.add('fa-bookmark');
            } else {
                listItem.classList.remove('bookmarked');
                bookmarkBtn.classList.remove('active');
                bookmarkIcon.classList.remove('fa-bookmark');
                bookmarkIcon.classList.add('fa-bookmark-o');
            }
        }
        
        // Alle anderen Vorkommen in der UI aktualisieren
        const allListItems = document.querySelectorAll(`.question-list-item[data-question-id="${questionId}"]`);
        allListItems.forEach(item => {
            if (item !== listItem) {
                const bookmarkBtn = item.querySelector('.bookmark-btn');
                if (bookmarkBtn) {
                    const bookmarkIcon = bookmarkBtn.querySelector('i');
                    
                    if (isBookmarked) {
                        item.classList.add('bookmarked');
                        bookmarkBtn.classList.add('active');
                        bookmarkIcon.classList.remove('fa-bookmark-o');
                        bookmarkIcon.classList.add('fa-bookmark');
                    } else {
                        item.classList.remove('bookmarked');
                        bookmarkBtn.classList.remove('active');
                        bookmarkIcon.classList.remove('fa-bookmark');
                        bookmarkIcon.classList.add('fa-bookmark-o');
                    }
                }
            }
        });
        
        // Auch in Fragen-Indikatoren aktualisieren
        this.updateQuestionIndicatorBookmarks();
        
        // Einstellungen speichern
        this.saveUserSettings();
    },
    
    /**
     * Aktualisiert die Bookmark-Anzeige in den Fragenindikatoren
     */
    updateQuestionIndicatorBookmarks: function() {
        const indicators = document.querySelectorAll('.question-indicator');
        
        indicators.forEach((indicator) => {
            const questionId = indicator.dataset.questionId;
            
            // Lesezeichen-Markierung entfernen oder hinzufügen
            if (this.state.bookmarkedQuestions.includes(questionId)) {
                if (!indicator.querySelector('.indicator-bookmark')) {
                    const bookmarkMark = document.createElement('span');
                    bookmarkMark.className = 'indicator-bookmark';
                    bookmarkMark.innerHTML = '<i class="fa fa-bookmark"></i>';
                    indicator.appendChild(bookmarkMark);
                }
            } else {
                const bookmarkMark = indicator.querySelector('.indicator-bookmark');
                if (bookmarkMark) {
                    bookmarkMark.remove();
                }
            }
        });
    },
    
    /**
     * Zeigt den Dialog für Notizen zu einer Frage
     * @param {string} questionId - ID der Frage
     */
    showNoteDialog: function(questionId) {
        // Prüfen, ob bereits ein Dialog geöffnet ist
        if (document.getElementById('note-dialog')) {
            document.getElementById('note-dialog').remove();
        }
        
        // Aktuelle Notiz abrufen
        const currentNote = this.state.questionNotes[questionId] || '';
        
        // Dialog erstellen
        const dialogOverlay = document.createElement('div');
        dialogOverlay.className = 'dialog-overlay';
        dialogOverlay.id = 'note-dialog';
        
        // Dialog-Inhalt
        const dialogContent = document.createElement('div');
        dialogContent.className = 'dialog-content note-dialog-content';
        
        // Fragentext abrufen
        const session = app.testSessionManager.getSession(app.testProgress.state.currentSessionId);
        const question = session?.testData?.questions[questionId];
        const questionTitle = question ? question.text : `Frage ${questionId}`;
        
        dialogContent.innerHTML = `
            <h3>Notiz zu Frage</h3>
            <p class="note-question-title">${questionTitle}</p>
            <textarea class="note-textarea" placeholder="Deine Notiz zu dieser Frage...">${currentNote}</textarea>
            <div class="note-actions">
                <button class="secondary-button cancel-note-btn">Abbrechen</button>
                <button class="primary-button save-note-btn">Speichern</button>
            </div>
        `;
        
        // Zusammenfügen und zum DOM hinzufügen
        dialogOverlay.appendChild(dialogContent);
        document.body.appendChild(dialogOverlay);
        
        // Textarea fokussieren
        setTimeout(() => {
            dialogContent.querySelector('.note-textarea').focus();
        }, 100);
        
        // Event-Listener für Buttons
        dialogContent.querySelector('.cancel-note-btn').addEventListener('click', () => {
            dialogOverlay.remove();
        });
        
        dialogContent.querySelector('.save-note-btn').addEventListener('click', () => {
            const noteText = dialogContent.querySelector('.note-textarea').value.trim();
            
            if (noteText) {
                this.state.questionNotes[questionId] = noteText;
            } else {
                delete this.state.questionNotes[questionId];
            }
            
            // Notiz-Icon in der Fragenübersicht aktualisieren
            this.updateNoteIcons(questionId, !!noteText);
            
            // Einstellungen speichern
            this.saveUserSettings();
            
            // Dialog schließen
            dialogOverlay.remove();
        });
        
        // Schließen mit ESC ermöglichen
        const escKeyHandler = (e) => {
            if (e.key === 'Escape') {
                dialogOverlay.remove();
                document.removeEventListener('keydown', escKeyHandler);
            }
        };
        document.addEventListener('keydown', escKeyHandler);
    },
    
    /**
     * Aktualisiert die Notiz-Icons in der Fragenübersicht
     * @param {string} questionId - ID der Frage
     * @param {boolean} hasNote - Ob eine Notiz vorhanden ist
     */
    updateNoteIcons: function(questionId, hasNote) {
        const noteButtons = document.querySelectorAll(`.question-list-item[data-question-id="${questionId}"] .note-btn`);
        
        noteButtons.forEach(button => {
            if (hasNote) {
                button.classList.add('has-note');
                const icon = button.querySelector('i');
                icon.classList.remove('fa-sticky-note-o');
                icon.classList.add('fa-sticky-note');
            } else {
                button.classList.remove('has-note');
                const icon = button.querySelector('i');
                icon.classList.remove('fa-sticky-note');
                icon.classList.add('fa-sticky-note-o');
            }
        });
    },
    
    /**
     * Navigiert zu einer bestimmten Frage
     * @param {string} questionId - ID der Frage
     */
    navigateToQuestion: function(questionId) {
        // Übersicht schließen
        this.toggleQuestionsOverview(false);
        
        // Navigation-Event auslösen
        const navigationEvent = new CustomEvent('questionNavigationRequest', {
            detail: {
                sessionId: app.testProgress.state.currentSessionId,
                questionId: questionId
            }
        });
        document.dispatchEvent(navigationEvent);
    },
    
    /**
     * Analysiert die Kategoriedaten aus den Testdaten
     * @param {Object} testData - Testdaten
     */
    analyzeCategoriesData: function(testData) {
        // Prüfen, ob Test Kategorien verwendet
        if (!testData.categories || !testData.questions) {
            return;
        }
        
        // Kategorien extrahieren
        const categories = Array.isArray(testData.categories) 
            ? testData.categories 
            : Object.values(testData.categories);
        
        if (categories.length === 0) return;
        
        // Kategorie-ID zu jeder Kategorie hinzufügen, falls nicht vorhanden
        categories.forEach(category => {
            if (!category.id && category.name) {
                category.id = category.name.toLowerCase().replace(/\s+/g, '-');
            }
            
            // Standard-Farbe zuweisen, falls keine vorhanden
            if (!category.color) {
                // Zufällige Farbe aus dem ImmoScout24-Farbschema
                const colorIndex = Math.floor(Math.random() * this.categoryColors.length);
                category.color = this.categoryColors[colorIndex];
            }
        });
        
        // Fragen nach Kategorien gruppieren
        const questionsByCategory = {};
        
        Object.entries(testData.questions).forEach(([questionId, question]) => {
            if (question.category) {
                if (!questionsByCategory[question.category]) {
                    questionsByCategory[question.category] = [];
                }
                questionsByCategory[question.category].push(questionId);
            }
        });
        
        // Fortschritt pro Kategorie initialisieren
        const categoryProgress = {};
        
        categories.forEach(category => {
            const questionIds = questionsByCategory[category.id] || [];
            categoryProgress[category.id] = {
                total: questionIds.length,
                answered: 0,
                correct: 0,
                incorrect: 0,
                percentage: 0
            };
        });
        
        // Kategorie-Daten speichern
        this.state.categoryData = {
            categories: categories,
            questionsByCategory: questionsByCategory
        };
        
        this.state.categoryProgress = categoryProgress;
        
        // Anfänglichen Kategorie-Fortschritt berechnen
        this.updateCategoryProgress();
    },
    
    /**
     * Standard-Farben für Kategorien
     */
    categoryColors: [
        '#00FFD0', // ImmoScout24 Hauptfarbe
        '#00D6B0', // Abgeschwächte Variante
        '#00AD8C', // Dunklere Variante
        '#00847A', // Noch dunklere Variante
        '#33FFDA', // Hellere Variante
        '#66FFE3', // Noch hellere Variante
        '#99FFED', // Sehr helle Variante
        '#00CCFF'  // Blaue Variante
    ],
    
    /**
     * Aktualisiert den Fortschritt pro Kategorie
     */
    updateCategoryProgress: function() {
        if (!this.state.categoryData) return;
        
        // Testsitzung abrufen
        const sessionId = app.testProgress.state.currentSessionId;
        const session = app.testSessionManager.getSession(sessionId);
        if (!session) return;
        
        const answers = session.answers || {};
        
        // Für jede Kategorie den Fortschritt berechnen
        Object.entries(this.state.categoryData.questionsByCategory).forEach(([categoryId, questionIds]) => {
            if (!this.state.categoryProgress[categoryId]) return;
            
            let answered = 0;
            let correct = 0;
            let incorrect = 0;
            
            questionIds.forEach(questionId => {
                if (answers[questionId]) {
                    answered++;
                    
                    if (answers[questionId].isCorrect === true) {
                        correct++;
                    } else if (answers[questionId].isCorrect === false) {
                        incorrect++;
                    }
                }
            });
            
            // Fortschritt aktualisieren
            this.state.categoryProgress[categoryId] = {
                total: questionIds.length,
                answered: answered,
                correct: correct,
                incorrect: incorrect,
                percentage: questionIds.length > 0 ? Math.round((answered / questionIds.length) * 100) : 0
            };
        });
        
        // UI aktualisieren, falls Kategorieansicht aktiv
        this.updateCategoryView();
    },
    
    /**
     * Erstellt oder aktualisiert die Kategorieansicht
     */
    createCategoryView: function(container) {
        if (!this.state.categoryData || !container) return;
        
        // Alte Ansicht entfernen, falls vorhanden
        const existingView = container.querySelector('.categories-view');
        if (existingView) {
            existingView.remove();
        }
        
        // Hauptcontainer für die Kategorieansicht
        const categoriesView = document.createElement('div');
        categoriesView.className = 'categories-view';
        
        // Titel
        const header = document.createElement('h3');
        header.textContent = 'Kategorien';
        categoriesView.appendChild(header);
        
        // Für jede Kategorie einen Abschnitt erstellen
        this.state.categoryData.categories.forEach(category => {
            const progress = this.state.categoryProgress[category.id] || {
                total: 0,
                answered: 0,
                percentage: 0
            };
            
            // Container für die Kategorie
            const categoryContainer = document.createElement('div');
            categoryContainer.className = 'category-container';
            categoryContainer.dataset.categoryId = category.id;
            
            // Prüfen, ob Kategorie ausgeklappt ist
            const isExpanded = this.state.expandedCategories[category.id] || false;
            
            // Überschrift mit Fortschritt
            const categoryHeader = document.createElement('div');
            categoryHeader.className = 'category-header';
            categoryHeader.innerHTML = `
                <div class="category-title" style="color: ${category.color}">
                    <i class="fa ${isExpanded ? 'fa-chevron-down' : 'fa-chevron-right'}"></i>
                    <span>${category.name}</span>
                </div>
                <div class="category-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress.percentage}%; background-color: ${category.color}"></div>
                    </div>
                    <span class="progress-text">${progress.answered}/${progress.total} (${progress.percentage}%)</span>
                </div>
            `;
            
            // Inhalt für die Fragen dieser Kategorie
            const categoryContent = document.createElement('div');
            categoryContent.className = 'category-content';
            categoryContent.style.display = isExpanded ? 'block' : 'none';
            
            // Fragen für diese Kategorie abrufen
            const questionIds = this.state.categoryData.questionsByCategory[category.id] || [];
            
            // Wenn Fragen vorhanden sind
            if (questionIds.length > 0) {
                const session = app.testSessionManager.getSession(app.testProgress.state.currentSessionId);
                
                // Miniaturansicht der Fragenindikatoren erstellen
                const indicatorsContainer = document.createElement('div');
                indicatorsContainer.className = 'category-question-indicators';
                
                questionIds.forEach(questionId => {
                    const question = session?.testData?.questions[questionId];
                    const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
                    
                    if (question && questionState) {
                        // Frageindex ermitteln
                        const questionIndex = app.testProgress.state.questionStates.findIndex(q => q.questionId === questionId);
                        
                        // Indikator erstellen
                        const indicator = document.createElement('div');
                        indicator.className = 'category-question-indicator';
                        indicator.dataset.questionId = questionId;
                        indicator.title = `Frage ${questionIndex + 1}: ${question.text.substring(0, 50)}${question.text.length > 50 ? '...' : ''}`;
                        
                        // Status-Klassen hinzufügen
                        if (questionState.answered) {
                            indicator.classList.add('answered');
                            
                            if (questionState.correct === true) {
                                indicator.classList.add('correct');
                            } else if (questionState.correct === false) {
                                indicator.classList.add('incorrect');
                            }
                        }
                        
                        // Klick-Handler für Navigation
                        indicator.addEventListener('click', () => {
                            this.navigateToQuestion(questionId);
                        });
                        
                        indicatorsContainer.appendChild(indicator);
                    }
                });
                
                categoryContent.appendChild(indicatorsContainer);
            } else {
                // Meldung, wenn keine Fragen vorhanden sind
                categoryContent.innerHTML = '<p class="no-questions-message">Keine Fragen in dieser Kategorie</p>';
            }
            
            // Alles zusammenfügen
            categoryContainer.appendChild(categoryHeader);
            categoryContainer.appendChild(categoryContent);
            categoriesView.appendChild(categoryContainer);
            
            // Event-Listener für Auf-/Zuklappen
            if (this.config.categoryDisplay.collapsible) {
                categoryHeader.addEventListener('click', () => {
                    this.toggleCategoryExpansion(category.id, categoryContainer);
                });
            }
        });
        
        // Zum Haupt-Container hinzufügen
        container.appendChild(categoriesView);
    },
    
    /**
     * Aktualisiert die Kategorieansicht
     */
    updateCategoryView: function() {
        const categoriesView = document.querySelector('.categories-view');
        if (!categoriesView) return;
        
        // Für jede Kategorie den Fortschritt aktualisieren
        Object.entries(this.state.categoryProgress).forEach(([categoryId, progress]) => {
            const categoryContainer = categoriesView.querySelector(`[data-category-id="${categoryId}"]`);
            if (!categoryContainer) return;
            
            // Fortschrittsbalken aktualisieren
            const progressFill = categoryContainer.querySelector('.progress-fill');
            const progressText = categoryContainer.querySelector('.progress-text');
            
            if (progressFill) {
                progressFill.style.width = `${progress.percentage}%`;
            }
            
            if (progressText) {
                progressText.textContent = `${progress.answered}/${progress.total} (${progress.percentage}%)`;
            }
            
            // Fragen-Indikatoren aktualisieren
            const indicators = categoryContainer.querySelectorAll('.category-question-indicator');
            
            indicators.forEach(indicator => {
                const questionId = indicator.dataset.questionId;
                const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
                
                if (questionState) {
                    // Status-Klassen zurücksetzen
                    indicator.classList.remove('answered', 'correct', 'incorrect');
                    
                    // Aktuelle Klassen setzen
                    if (questionState.answered) {
                        indicator.classList.add('answered');
                        
                        if (questionState.correct === true) {
                            indicator.classList.add('correct');
                        } else if (questionState.correct === false) {
                            indicator.classList.add('incorrect');
                        }
                    }
                }
            });
        });
    },
    
    /**
     * Wechselt zwischen Auf- und Zugeklappt-Status einer Kategorie
     * @param {string} categoryId - ID der Kategorie
     * @param {HTMLElement} categoryContainer - Container der Kategorie
     */
    toggleCategoryExpansion: function(categoryId, categoryContainer) {
        // Status umkehren
        this.state.expandedCategories[categoryId] = !this.state.expandedCategories[categoryId];
        const isExpanded = this.state.expandedCategories[categoryId];
        
        // UI aktualisieren
        const content = categoryContainer.querySelector('.category-content');
        const chevronIcon = categoryContainer.querySelector('.category-title i');
        
        if (content) {
            content.style.display = isExpanded ? 'block' : 'none';
        }
        
        if (chevronIcon) {
            chevronIcon.className = `fa ${isExpanded ? 'fa-chevron-down' : 'fa-chevron-right'}`;
        }
        
        // Einstellungen speichern
        this.saveUserSettings();
    },
    
    /**
     * Wechselt die Sichtbarkeit der Kategorieansicht
     */
    toggleCategoriesView: function() {
        // Testsitzung abrufen
        const sessionId = app.testProgress.state.currentSessionId;
        const container = document.querySelector('.test-progress-container');
        
        if (!sessionId || !container || !this.state.categoryData) return;
        
        // Prüfen, ob die Ansicht bereits vorhanden ist
        const categoriesView = container.querySelector('.categories-view');
        
        if (categoriesView) {
            // Ansicht entfernen
            categoriesView.remove();
            document.querySelector('.categories-btn')?.classList.remove('active');
        } else {
            // Ansicht erstellen
            this.createCategoryView(container);
            document.querySelector('.categories-btn')?.classList.add('active');
            
            // Übersicht schließen, falls geöffnet
            this.toggleQuestionsOverview(false);
        }
    },
    
    /**
     * Zeigt eine Motivationsnachricht an
     */
    showMotivationalMessage: function() {
        if (!this.config.features.motivation) return;
        
        // Container für die Nachricht abrufen
        const messageContainer = document.querySelector('.motivation-message');
        if (!messageContainer) return;
        
        // Zufällige Nachricht auswählen
        const messages = this.config.motivationalMessages;
        const randomIndex = Math.floor(Math.random() * messages.length);
        const message = messages[randomIndex];
        
        // Nachricht anzeigen mit Animation
        messageContainer.textContent = message;
        messageContainer.classList.add('show');
        
        // Nach einiger Zeit ausblenden
        setTimeout(() => {
            messageContainer.classList.remove('show');
        }, 5000);
    },
    
    /**
     * Initialisiert die Zeiterfassung pro Frage
     */
    initializeTimeTracking: function() {
        if (!this.config.features.timeTracking) return;
        
        // Event-Listener für Fragewechsel
        document.addEventListener('questionChanged', (event) => {
            const questionId = event.detail.questionId;
            if (!questionId) return;
            
            // Zeit für die vorherige Frage speichern
            if (this.state.currentTrackedQuestionId) {
                this.stopQuestionTimeTracking();
            }
            
            // Neue Frage beginnen zu tracken
            this.startQuestionTimeTracking(questionId);
        });
    },
    
    /**
     * Startet die Zeiterfassung für eine Frage
     * @param {string} questionId - ID der Frage
     */
    startQuestionTimeTracking: function(questionId) {
        // Aktuell getrackte Frage merken
        this.state.currentTrackedQuestionId = questionId;
        
        // Zeit für diese Frage initialisieren, falls noch nicht vorhanden
        if (!this.state.questionTimeTracking[questionId]) {
            this.state.questionTimeTracking[questionId] = {
                totalTime: 0,
                startTime: Date.now(),
                visits: 0
            };
        } else {
            // Neuen Besuch starten
            this.state.questionTimeTracking[questionId].startTime = Date.now();
        }
        
        // Besuchszähler erhöhen
        this.state.questionTimeTracking[questionId].visits++;
    },
    
    /**
     * Stoppt die Zeiterfassung für die aktuelle Frage
     */
    stopQuestionTimeTracking: function() {
        const questionId = this.state.currentTrackedQuestionId;
        if (!questionId || !this.state.questionTimeTracking[questionId]) return;
        
        // Verstrichene Zeit berechnen
        const now = Date.now();
        const startTime = this.state.questionTimeTracking[questionId].startTime;
        const timeSpent = now - startTime;
        
        // Zur Gesamtzeit hinzufügen
        this.state.questionTimeTracking[questionId].totalTime += timeSpent;
        
        // Start-Zeit zurücksetzen
        this.state.questionTimeTracking[questionId].startTime = null;
        
        // Aktuelle Frage zurücksetzen
        this.state.currentTrackedQuestionId = null;
    },
    
    /**
     * Speichert die Benutzereinstellungen
     */
    saveUserSettings: function() {
        const sessionId = app.testProgress.state.currentSessionId;
        if (!sessionId) return;
        
        const settings = {
            bookmarkedQuestions: this.state.bookmarkedQuestions,
            questionNotes: this.state.questionNotes,
            expandedCategories: this.state.expandedCategories,
            questionTimeTracking: this.state.questionTimeTracking
        };
        
        try {
            localStorage.setItem(`immoscout24_test_settings_${sessionId}`, JSON.stringify(settings));
        } catch (error) {
            console.error('Fehler beim Speichern der Benutzereinstellungen:', error);
        }
    },
    
    /**
     * Lädt die Benutzereinstellungen
     * @param {string} sessionId - ID der Testsitzung
     */
    loadUserSettings: function(sessionId) {
        if (!sessionId) return;
        
        try {
            const storedSettings = localStorage.getItem(`immoscout24_test_settings_${sessionId}`);
            
            if (storedSettings) {
                const settings = JSON.parse(storedSettings);
                
                // Einstellungen übernehmen
                if (settings.bookmarkedQuestions) {
                    this.state.bookmarkedQuestions = settings.bookmarkedQuestions;
                }
                
                if (settings.questionNotes) {
                    this.state.questionNotes = settings.questionNotes;
                }
                
                if (settings.expandedCategories) {
                    this.state.expandedCategories = settings.expandedCategories;
                }
                
                if (settings.questionTimeTracking) {
                    this.state.questionTimeTracking = settings.questionTimeTracking;
                }
            }
        } catch (error) {
            console.error('Fehler beim Laden der Benutzereinstellungen:', error);
        }
    },
    
    /**
     * Fügt Stile für die erweiterten Funktionen hinzu
     */
    addExtendedStyles: function() {
        // Prüfen, ob Stile bereits hinzugefügt wurden
        if (document.getElementById('test-progress-extended-styles')) return;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'test-progress-extended-styles';
        
        styleElement.textContent = `
            /* Erweiterte Toolbar */
            .progress-extended-toolbar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 15px;
                padding-top: 10px;
                border-top: 1px solid #e0e0e0;
            }
            
            .toolbar-btn {
                background-color: #f5f5f5;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.2s;
                color: #333;
            }
            
            .toolbar-btn:hover {
                background-color: #e0e0e0;
            }
            
            .toolbar-btn.active {
                background-color: ${app.testProgress.config.colors.primary};
                color: #333;
                border-color: #00e6bd;
            }
            
            .toolbar-btn i {
                margin-right: 5px;
            }
            
            /* Motivation */
            .motivation-container {
                flex-grow: 1;
                text-align: center;
                overflow: hidden;
            }
            
            .motivation-message {
                display: inline-block;
                font-style: italic;
                color: #555;
                max-height: 0;
                opacity: 0;
                transition: all 0.5s ease;
                overflow: hidden;
            }
            
            .motivation-message.show {
                max-height: 50px;
                opacity: 1;
                padding: 5px 10px;
            }
            
            /* Fragenübersicht */
            .questions-overview-panel {
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                background: white;
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                border-radius: 0 0 8px 8px;
                z-index: 100;
                display: flex;
                flex-direction: column;
                max-height: 500px;
                overflow: hidden;
            }
            
            .overview-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 15px;
                border-bottom: 1px solid #e0e0e0;
            }
            
            .overview-header h3 {
                margin: 0;
                color: ${app.testProgress.config.colors.secondary};
            }
            
            .close-overview-btn {
                background: transparent;
                border: none;
                font-size: 18px;
                cursor: pointer;
                color: #999;
            }
            
            .close-overview-btn:hover {
                color: #333;
            }
            
            .filter-options {
                display: flex;
                padding: 10px 15px;
                border-bottom: 1px solid #e0e0e0;
                gap: 20px;
            }
            
            .filter-group {
                display: flex;
                gap: 15px;
            }
            
            .questions-list {
                overflow-y: auto;
                max-height: 400px;
                padding: 10px;
            }
            
            .question-list-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                border-radius: 4px;
                margin-bottom: 5px;
                cursor: pointer;
                border-left: 3px solid transparent;
            }
            
            .question-list-item:hover {
                background-color: #f5f5f5;
            }
            
            .question-list-item.current {
                background-color: rgba(0, 255, 208, 0.1);
                border-left-color: ${app.testProgress.config.colors.primary};
            }
            
            .question-list-item.answered {
                background-color: rgba(0, 255, 208, 0.05);
            }
            
            .question-list-item.correct {
                background-color: rgba(52, 199, 89, 0.05);
                border-left-color: ${app.testProgress.config.colors.success};
            }
            
            .question-list-item.incorrect {
                background-color: rgba(255, 59, 48, 0.05);
                border-left-color: ${app.testProgress.config.colors.error};
            }
            
            .question-list-item.bookmarked {
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .question-header {
                display: flex;
                align-items: center;
                gap: 8px;
                flex: 1;
            }
            
            .question-number {
                min-width: 20px;
                text-align: center;
                font-weight: bold;
                color: #999;
            }
            
            .question-type {
                color: #666;
            }
            
            .question-title {
                font-size: 14px;
                color: #333;
                flex: 1;
            }
            
            .question-category {
                font-size: 12px;
                padding: 2px 6px;
                border-radius: 10px;
                background-color: rgba(0,0,0,0.05);
            }
            
            .question-actions {
                display: flex;
                gap: 5px;
            }
            
            .question-actions button {
                background: transparent;
                border: none;
                color: #999;
                cursor: pointer;
                padding: 2px 5px;
                border-radius: 3px;
                transition: all 0.2s;
            }
            
            .question-actions button:hover {
                background-color: rgba(0,0,0,0.05);
                color: #333;
            }
            
            .bookmark-btn.active {
                color: #FF9500;
            }
            
            .note-btn.has-note {
                color: #00CCFF;
            }
            
            /* Kategorieansicht */
            .categories-view {
                margin-top: 15px;
                padding-top: 10px;
                border-top: 1px solid #e0e0e0;
            }
            
            .categories-view h3 {
                margin: 0 0 10px 0;
                color: ${app.testProgress.config.colors.secondary};
                font-size: 16px;
            }
            
            .category-container {
                margin-bottom: 8px;
                border-radius: 4px;
                overflow: hidden;
                background-color: #f9f9f9;
            }
            
            .category-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                cursor: pointer;
                transition: background-color 0.2s;
            }
            
            .category-header:hover {
                background-color: #f0f0f0;
            }
            
            .category-title {
                display: flex;
                align-items: center;
                gap: 8px;
                font-weight: bold;
            }
            
            .category-title i {
                font-size: 12px;
            }
            
            .category-progress {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .category-progress .progress-bar {
                width: 100px;
                height: 6px;
                background-color: #e0e0e0;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .category-progress .progress-fill {
                height: 100%;
                width: 0%;
                transition: width 0.3s ease;
            }
            
            .progress-text {
                font-size: 12px;
                color: #666;
                white-space: nowrap;
            }
            
            .category-content {
                padding: 10px;
                background-color: white;
                border-top: 1px solid #eee;
            }
            
            .category-question-indicators {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .category-question-indicator {
                width: 16px;
                height: 16px;
                border-radius: 4px;
                background-color: #e0e0e0;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .category-question-indicator:hover {
                transform: scale(1.1);
            }
            
            .category-question-indicator.answered {
                background-color: ${app.testProgress.config.colors.primary};
            }
            
            .category-question-indicator.correct {
                background-color: ${app.testProgress.config.colors.success};
            }
            
            .category-question-indicator.incorrect {
                background-color: ${app.testProgress.config.colors.error};
            }
            
            .no-questions-message {
                color: #999;
                font-style: italic;
                text-align: center;
                margin: 10px 0;
            }
            
            /* Notiz-Dialog */
            .note-dialog-content {
                width: 500px;
                max-width: 90vw;
            }
            
            .note-question-title {
                font-size: 14px;
                color: #666;
                margin-bottom: 10px;
                border-left: 3px solid ${app.testProgress.config.colors.primary};
                padding-left: 10px;
                font-style: italic;
            }
            
            .note-textarea {
                width: 100%;
                min-height: 150px;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-family: inherit;
                resize: vertical;
            }
            
            .note-actions {
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 15px;
            }
            
            .secondary-button {
                background-color: #f5f5f5;
                color: #333;
                border: 1px solid #ddd;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
            }
            
            .secondary-button:hover {
                background-color: #e0e0e0;
            }
            
            /* Lesezeichen-Indikator */
            .indicator-bookmark {
                position: absolute;
                top: -5px;
                right: -3px;
                font-size: 10px;
                color: #FF9500;
            }
            
            /* Responsives Design */
            @media (max-width: 768px) {
                .questions-overview-panel {
                    max-height: 80vh;
                }
                
                .question-header {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 2px;
                }
                
                .category-progress {
                    flex-direction: column;
                    align-items: flex-end;
                }
                
                .category-progress .progress-bar {
                    width: 60px;
                }
            }
        `;
        
        document.head.appendChild(styleElement);
    },
    
    /**
     * Richtet Event-Listener für die erweiterten Funktionen ein
     */
    setupEventListeners: function() {
        // Aktualisierung bei Beantwortung einer Frage
        document.addEventListener('answerSaved', (event) => {
            const sessionId = event.detail.sessionId;
            const questionId = event.detail.questionId;
            
            if (sessionId === app.testProgress.state.currentSessionId) {
                // Kategorie-Fortschritt aktualisieren
                this.updateCategoryProgress();
                
                // Bei bestimmten Meilensteinen motivationale Nachricht anzeigen
                this.checkForMilestones();
            }
        });
        
        // Vollständige Initialisierung, wenn Testseite geladen ist
        document.addEventListener('testPageLoaded', (event) => {
            const sessionId = event.detail.sessionId;
            if (sessionId) {
                this.initialize(sessionId);
            }
        });
    },
    
    /**
     * Prüft, ob ein neuer Meilenstein erreicht wurde
     */
    checkForMilestones: function() {
        if (!this.config.features.motivation) return;
        
        const currentPercentage = app.testProgress.state.percentage;
        
        // Für jeden Meilenstein prüfen
        this.config.milestones.forEach(milestone => {
            // Prüfen, ob der Meilenstein gerade erreicht wurde
            if (currentPercentage >= milestone && !this.state.reachedMilestones.includes(milestone)) {
                // Meilenstein als erreicht markieren
                this.state.reachedMilestones.push(milestone);
                
                // Motivationsnachricht anzeigen
                this.showMotivationalMessage();
                
                // Konfetti-Animation, wenn aktiviert
                if (this.config.animations.confettiOnMilestone) {
                    this.showConfetti();
                }
            }
        });
    },
    
    /**
     * Zeigt eine Konfetti-Animation an
     */
    showConfetti: function() {
        // Konfetti-Container erstellen
        const confettiContainer = document.createElement('div');
        confettiContainer.className = 'confetti-container';
        
        // 30 Konfetti-Elemente erstellen
        for (let i = 0; i < 30; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            
            // Zufällige Größe
            const size = Math.random() * 10 + 5;
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            
            // Zufällige Farbe (aus dem ImmoScout24-Farbschema)
            const colorIndex = Math.floor(Math.random() * this.categoryColors.length);
            confetti.style.backgroundColor = this.categoryColors[colorIndex];
            
            // Zufällige Position und Animation
            confetti.style.left = `${Math.random() * 100}%`;
            confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
            confetti.style.animationDelay = `${Math.random() * 0.5}s`;
            
            confettiContainer.appendChild(confetti);
        }
        
        // Zum DOM hinzufügen
        document.body.appendChild(confettiContainer);
        
        // Nach Animation entfernen
        setTimeout(() => {
            confettiContainer.remove();
        }, 5000);
        
        // Konfetti-Stil hinzufügen, falls noch nicht vorhanden
        if (!document.getElementById('confetti-style')) {
            const style = document.createElement('style');
            style.id = 'confetti-style';
            style.textContent = `
                .confetti-container {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1000;
                }
                
                .confetti {
                    position: absolute;
                    top: -20px;
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    animation: fall linear forwards;
                }
                
                @keyframes fall {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 1;
                    }
                    70% {
                        opacity: 1;
                    }
                    100% {
                        transform: translateY(100vh) rotate(720deg);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
    }
};

// Erweiterung der öffentlichen Schnittstelle
Object.assign(app.testProgress.interface, {
    // Erweiterte Funktionen
    initializeExtended: app.testProgress.extended.initialize.bind(app.testProgress.extended),
    toggleQuestionsOverview: app.testProgress.extended.toggleQuestionsOverview.bind(app.testProgress.extended),
    toggleCategoriesView: app.testProgress.extended.toggleCategoriesView.bind(app.testProgress.extended),
    toggleBookmark: app.testProgress.extended.toggleBookmark.bind(app.testProgress.extended),
    showNoteDialog: app.testProgress.extended.showNoteDialog.bind(app.testProgress.extended)
});

// Initialisierung beim Laden des Moduls
(function() {
    console.log('Testfortschritt-Modul (Teil 2) initialisiert');
})();
/**
 * JS-Block 5.7.2-part1: Testfortschritt - Navigation zwischen Fragen (Teil 1)
 * 
 * Dieser Block implementiert die Navigation zwischen Fragen während eines Tests,
 * einschließlich Vor/Zurück-Navigation, direkte Auswahl, Validierung und Übergangseffekte.
 */

// Namespace für Test-Navigation
app.testNavigation = {
    // Konfiguration
    config: {
        // Animations-Konfiguration
        animations: {
            enabled: true,
            duration: 300, // Dauer in ms
            type: 'slide', // 'slide', 'fade', 'none'
        },
        
        // Validierung beim Navigieren
        validation: {
            validateBeforeNext: false, // Prüfen, ob aktuelle Frage beantwortet ist
            confirmUnanswered: true,   // Bestätigung beim Verlassen unbeantworteter Fragen
            saveOnNavigation: true     // Automatisches Speichern beim Navigieren
        },
        
        // Tastatur-Navigation
        keyboard: {
            enabled: true,
            nextKeys: ['ArrowRight', 'Tab'], // Tasten für nächste Frage
            prevKeys: ['ArrowLeft', 'Shift+Tab'], // Tasten für vorherige Frage
            submitKey: 'Enter'          // Test abschließen
        },
        
        // Design und Verhalten
        ui: {
            showNavButtons: true,          // Navigationsbuttons anzeigen
            showQuestionNumber: true,      // Aktuelle Frage / Gesamtzahl anzeigen
            allowSkip: true,               // Überspringen erlauben
            allowNavigation: true,         // Navigation generell erlauben
            confirmBeforeExit: true,       // Bestätigung vor dem Verlassen des Tests
            markVisitedQuestions: true,    // Besuchte Fragen markieren
            showCompletionProgressButton: true // Button zum nächsten unbeantworteten zeigen
        }
    },
    
    // Status der Navigation
    state: {
        currentQuestionId: null,      // ID der aktuellen Frage
        currentQuestionIndex: 0,      // Index der aktuellen Frage (0-basiert)
        questionIds: [],              // Liste aller Fragen-IDs in Reihenfolge
        visitedQuestions: new Set(),  // Bereits besuchte Fragen
        isNavigating: false,          // Navigation läuft gerade
        navigationHistory: [],        // Verlauf der besuchten Fragen
        lastDirection: null,          // Letzte Navigationsrichtung ('next', 'prev', 'direct')
        isBlocked: false              // Navigation blockiert (z.B. während Speichervorgang)
    },
    
    /**
     * Initialisiert die Navigation für eine Testsitzung
     * @param {string} sessionId - ID der Testsitzung
     * @param {HTMLElement} container - Container für die Navigationssteuerung
     */
    initialize: function(sessionId, container) {
        try {
            // Testsitzung abrufen
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) {
                throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
            }
            
            // Fragen-IDs in Reihenfolge extrahieren
            const questions = session.testData.questions || {};
            this.state.questionIds = Object.keys(questions);
            
            if (this.state.questionIds.length === 0) {
                throw new Error('Keine Fragen im Test gefunden');
            }
            
            // Erste Frage als aktuelle setzen, falls noch nicht geschehen
            if (!this.state.currentQuestionId) {
                this.state.currentQuestionId = this.state.questionIds[0];
                this.state.currentQuestionIndex = 0;
                this.state.visitedQuestions.add(this.state.currentQuestionId);
                this.state.navigationHistory.push(this.state.currentQuestionId);
            }
            
            // Navigations-UI erstellen
            if (container && this.config.ui.showNavButtons) {
                this.createNavigationUI(container);
            }
            
            // Warnungen vor unbeabsichtigtem Verlassen einrichten
            if (this.config.ui.confirmBeforeExit) {
                this.setupExitWarning();
            }
            
            // Tastatur-Navigation einrichten
            if (this.config.keyboard.enabled) {
                this.setupKeyboardNavigation();
            }
            
            console.log('Test-Navigation initialisiert');
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung der Test-Navigation:', error);
            return false;
        }
    },
    
    /**
     * Erstellt die UI-Komponenten für die Navigation
     * @param {HTMLElement} container - Container für die Navigationssteuerung
     */
    createNavigationUI: function(container) {
        // Container leeren
        container.innerHTML = '';
        
        // Navigationsleiste erstellen
        const navigationBar = document.createElement('div');
        navigationBar.className = 'test-navigation-bar';
        
        // Linke Seite - zurück
        const leftSection = document.createElement('div');
        leftSection.className = 'nav-section left';
        
        const backButton = document.createElement('button');
        backButton.className = 'nav-button back-button';
        backButton.innerHTML = '<i class="fa fa-arrow-left"></i> Zurück';
        backButton.setAttribute('aria-label', 'Zur vorherigen Frage');
        
        // Prüfen, ob wir uns bei der ersten Frage befinden
        if (this.state.currentQuestionIndex === 0) {
            backButton.disabled = true;
            backButton.classList.add('disabled');
        }
        
        backButton.addEventListener('click', () => this.navigateToPreviousQuestion());
        leftSection.appendChild(backButton);
        
        // Mittlere Seite - Fragenindikator
        const middleSection = document.createElement('div');
        middleSection.className = 'nav-section middle';
        
        if (this.config.ui.showQuestionNumber) {
            const questionCounter = document.createElement('div');
            questionCounter.className = 'question-counter';
            questionCounter.innerHTML = `
                <span class="current-question">${this.state.currentQuestionIndex + 1}</span>
                <span class="separator">/</span>
                <span class="total-questions">${this.state.questionIds.length}</span>
            `;
            middleSection.appendChild(questionCounter);
        }
        
        // Rechte Seite - weiter und abschließen
        const rightSection = document.createElement('div');
        rightSection.className = 'nav-section right';
        
        // Button für nächste unbeantwortete Frage
        if (this.config.ui.showCompletionProgressButton) {
            const nextUnansweredButton = document.createElement('button');
            nextUnansweredButton.className = 'nav-button next-unanswered-button';
            nextUnansweredButton.innerHTML = '<i class="fa fa-bolt"></i> Nächste unbeantwortete';
            nextUnansweredButton.setAttribute('aria-label', 'Zur nächsten unbeantworteten Frage');
            nextUnansweredButton.addEventListener('click', () => this.navigateToNextUnanswered());
            rightSection.appendChild(nextUnansweredButton);
        }
        
        // Weiter-Button oder Abschließen-Button
        const isLastQuestion = this.state.currentQuestionIndex === this.state.questionIds.length - 1;
        
        if (isLastQuestion) {
            const finishButton = document.createElement('button');
            finishButton.className = 'nav-button finish-button';
            finishButton.innerHTML = 'Test abschließen <i class="fa fa-check"></i>';
            finishButton.setAttribute('aria-label', 'Test abschließen');
            finishButton.addEventListener('click', () => this.finishTest());
            rightSection.appendChild(finishButton);
        } else {
            const nextButton = document.createElement('button');
            nextButton.className = 'nav-button next-button';
            nextButton.innerHTML = 'Weiter <i class="fa fa-arrow-right"></i>';
            nextButton.setAttribute('aria-label', 'Zur nächsten Frage');
            nextButton.addEventListener('click', () => this.navigateToNextQuestion());
            rightSection.appendChild(nextButton);
        }
        
        // Alles zusammenfügen
        navigationBar.appendChild(leftSection);
        navigationBar.appendChild(middleSection);
        navigationBar.appendChild(rightSection);
        
        // Zum Container hinzufügen
        container.appendChild(navigationBar);
        
        // Stile hinzufügen
        this.addNavigationStyles();
    },
    
    /**
     * Fügt CSS-Stile für die Navigationskomponenten hinzu
     */
    addNavigationStyles: function() {
        // Prüfen, ob Stile bereits hinzugefügt wurden
        if (document.getElementById('test-navigation-styles')) return;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'test-navigation-styles';
        
        styleElement.textContent = `
            /* Navigationsleiste */
            .test-navigation-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px 0;
                margin-top: 20px;
                border-top: 1px solid #e0e0e0;
            }
            
            .nav-section {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .nav-section.left {
                justify-content: flex-start;
            }
            
            .nav-section.middle {
                justify-content: center;
                flex-grow: 1;
            }
            
            .nav-section.right {
                justify-content: flex-end;
                gap: 15px;
            }
            
            /* Navigationsbuttons */
            .nav-button {
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                transition: all 0.2s ease;
            }
            
            .back-button {
                background-color: #f5f5f5;
                color: #333;
            }
            
            .back-button:hover:not(.disabled) {
                background-color: #e0e0e0;
            }
            
            .back-button.disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .next-button, .finish-button {
                background-color: #00FFD0;
                color: #333;
            }
            
            .next-button:hover, .finish-button:hover {
                background-color: #00e6bd;
            }
            
            .finish-button {
                background-color: #00FFD0;
                color: #333;
                font-weight: bold;
            }
            
            .next-unanswered-button {
                background-color: #f5f5f5;
                color: #333;
                font-size: 13px;
            }
            
            .next-unanswered-button:hover {
                background-color: #e0e0e0;
            }
            
            /* Fragenzähler */
            .question-counter {
                font-size: 16px;
                color: #666;
            }
            
            .current-question {
                font-weight: bold;
                color: #333;
            }
            
            .separator {
                margin: 0 3px;
                color: #999;
            }
            
            .total-questions {
                color: #999;
            }
            
            /* Animationen für Fragenwechsel */
            .question-container {
                transition: all ${this.config.animations.duration}ms ease;
            }
            
            .question-container.slide-out-left {
                transform: translateX(-100%);
                opacity: 0;
            }
            
            .question-container.slide-in-right {
                transform: translateX(100%);
                opacity: 0;
            }
            
            .question-container.slide-out-right {
                transform: translateX(100%);
                opacity: 0;
            }
            
            .question-container.slide-in-left {
                transform: translateX(-100%);
                opacity: 0;
            }
            
            .question-container.fade-out {
                opacity: 0;
            }
            
            .question-container.fade-in {
                opacity: 0;
            }
            
            /* Responsive Anpassungen */
            @media (max-width: 768px) {
                .nav-button {
                    padding: 8px 15px;
                    font-size: 14px;
                }
                
                .next-unanswered-button {
                    display: none; /* Auf mobilen Geräten ausblenden */
                }
                
                .back-button i, .next-button i, .finish-button i {
                    margin: 0;
                }
                
                .back-button span, .next-button span, .finish-button span {
                    display: none;
                }
            }
        `;
        
        document.head.appendChild(styleElement);
    },
    
    /**
     * Richtet Warnung vor unbeabsichtigtem Verlassen des Tests ein
     */
    setupExitWarning: function() {
        window.addEventListener('beforeunload', (event) => {
            // Nur warnen, wenn Test noch läuft
            const session = app.testSessionManager.getSession(app.testSessionManager.getCurrentSessionId());
            if (session && !session.isCompleted) {
                const message = 'Du verlässt den Test. Nicht gespeicherte Antworten könnten verloren gehen.';
                event.returnValue = message;
                return message;
            }
        });
    },
    
    /**
     * Richtet Tastatur-Navigation ein
     */
    setupKeyboardNavigation: function() {
        // Bestehenden Event-Listener entfernen, falls vorhanden
        if (this._keyboardHandler) {
            document.removeEventListener('keydown', this._keyboardHandler);
        }
        
        // Neuen Event-Listener erstellen
        this._keyboardHandler = (event) => {
            // Ignorieren, wenn in Texteingabefeld oder Navigation blockiert
            if (
                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) ||
                this.state.isNavigating ||
                this.state.isBlocked
            ) {
                return;
            }
            
            // Nächste Frage
            if (this.config.keyboard.nextKeys.includes(event.key)) {
                event.preventDefault();
                this.navigateToNextQuestion();
            }
            // Vorherige Frage
            else if (this.config.keyboard.prevKeys.includes(event.key)) {
                event.preventDefault();
                this.navigateToPreviousQuestion();
            }
            // Test abschließen (nur auf letzter Frage)
            else if (
                event.key === this.config.keyboard.submitKey &&
                this.state.currentQuestionIndex === this.state.questionIds.length - 1
            ) {
                event.preventDefault();
                this.finishTest();
            }
        };
        
        // Event-Listener hinzufügen
        document.addEventListener('keydown', this._keyboardHandler);
    },
    
    /**
     * Navigiert zur nächsten Frage
     * @returns {boolean} Erfolgsstatus der Navigation
     */
    navigateToNextQuestion: function() {
        try {
            // Prüfen, ob Navigation blockiert ist
            if (this.state.isNavigating || this.state.isBlocked) {
                return false;
            }
            
            // Prüfen, ob wir bereits bei der letzten Frage sind
            if (this.state.currentQuestionIndex >= this.state.questionIds.length - 1) {
                return false;
            }
            
            // Aktuelle Antwort speichern, falls konfiguriert
            if (this.config.validation.saveOnNavigation) {
                this.saveCurrentAnswer();
            }
            
            // Validierung vor dem Weitergehen
            if (this.config.validation.validateBeforeNext) {
                const isAnswered = this.isCurrentQuestionAnswered();
                
                if (!isAnswered && this.config.validation.confirmUnanswered) {
                    // Bestätigung für das Verlassen einer unbeantworteten Frage
                    if (!confirm('Diese Frage ist noch nicht beantwortet. Trotzdem fortfahren?')) {
                        return false;
                    }
                }
            }
            
            // Neue Frage bestimmen
            const nextIndex = this.state.currentQuestionIndex + 1;
            const nextQuestionId = this.state.questionIds[nextIndex];
            
            // Zur nächsten Frage navigieren
            return this.navigateToQuestion(nextQuestionId, 'next');
        } catch (error) {
            console.error('Fehler bei der Navigation zur nächsten Frage:', error);
            return false;
        }
    },
    
    /**
     * Navigiert zur vorherigen Frage
     * @returns {boolean} Erfolgsstatus der Navigation
     */
    navigateToPreviousQuestion: function() {
        try {
            // Prüfen, ob Navigation blockiert ist
            if (this.state.isNavigating || this.state.isBlocked) {
                return false;
            }
            
            // Prüfen, ob wir bereits bei der ersten Frage sind
            if (this.state.currentQuestionIndex <= 0) {
                return false;
            }
            
            // Aktuelle Antwort speichern, falls konfiguriert
            if (this.config.validation.saveOnNavigation) {
                this.saveCurrentAnswer();
            }
            
            // Neue Frage bestimmen
            const prevIndex = this.state.currentQuestionIndex - 1;
            const prevQuestionId = this.state.questionIds[prevIndex];
            
            // Zur vorherigen Frage navigieren
            return this.navigateToQuestion(prevQuestionId, 'prev');
        } catch (error) {
            console.error('Fehler bei der Navigation zur vorherigen Frage:', error);
            return false;
        }
    },
    
    /**
     * Navigiert zur nächsten unbeantworteten Frage
     * @returns {boolean} Erfolgsstatus der Navigation
     */
    navigateToNextUnanswered: function() {
        try {
            // Prüfen, ob Navigation blockiert ist
            if (this.state.isNavigating || this.state.isBlocked) {
                return false;
            }
            
            // Aktuelle Antwort speichern, falls konfiguriert
            if (this.config.validation.saveOnNavigation) {
                this.saveCurrentAnswer();
            }
            
            // Testsitzung abrufen
            const sessionId = app.testSessionManager.getCurrentSessionId();
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) return false;
            
            const answers = session.answers || {};
            
            // Nach unbeantworteten Fragen suchen, beginnend nach der aktuellen Frage
            let nextUnansweredIndex = -1;
            
            // Erst nach der aktuellen Frage suchen
            for (let i = this.state.currentQuestionIndex + 1; i < this.state.questionIds.length; i++) {
                const questionId = this.state.questionIds[i];
                if (!answers[questionId]) {
                    nextUnansweredIndex = i;
                    break;
                }
            }
            
            // Wenn nichts gefunden, von Anfang an suchen
            if (nextUnansweredIndex === -1) {
                for (let i = 0; i < this.state.currentQuestionIndex; i++) {
                    const questionId = this.state.questionIds[i];
                    if (!answers[questionId]) {
                        nextUnansweredIndex = i;
                        break;
                    }
                }
            }
            
            // Wenn immer noch nichts gefunden, dann sind alle Fragen beantwortet
            if (nextUnansweredIndex === -1) {
                alert('Alle Fragen wurden bereits beantwortet! Überprüfe deine Antworten oder schließe den Test ab.');
                return false;
            }
            
            // Zur unbeantworteten Frage navigieren
            const nextQuestionId = this.state.questionIds[nextUnansweredIndex];
            return this.navigateToQuestion(nextQuestionId, 'direct');
        } catch (error) {
            console.error('Fehler bei der Navigation zur nächsten unbeantworteten Frage:', error);
            return false;
        }
    },
    
    /**
     * Navigiert zu einer spezifischen Frage
     * @param {string} questionId - ID der Zielfrage
     * @param {string} direction - Richtung der Navigation ('next', 'prev', 'direct')
     * @returns {boolean} Erfolgsstatus der Navigation
     */
    navigateToQuestion: function(questionId, direction = 'direct') {
        try {
            // Prüfen, ob Navigation blockiert ist
            if (this.state.isNavigating || this.state.isBlocked) {
                return false;
            }
            
            // Prüfen, ob Frage existiert
            const questionIndex = this.state.questionIds.indexOf(questionId);
            if (questionIndex === -1) {
                console.error(`Frage mit ID ${questionId} nicht gefunden`);
                return false;
            }
            
            // Navigation als aktiv markieren
            this.state.isNavigating = true;
            this.state.lastDirection = direction;
            
            // Aktuelle Frage ausblenden
            const currentQuestionId = this.state.currentQuestionId;
            this.hideQuestion(currentQuestionId, direction);
            
            // Neue Frage anzeigen
            setTimeout(() => {
                this.showQuestion(questionId, direction);
                
                // Status aktualisieren
                this.state.currentQuestionId = questionId;
                this.state.currentQuestionIndex = questionIndex;
                this.state.visitedQuestions.add(questionId);
                this.state.navigationHistory.push(questionId);
                
                // UI aktualisieren
                this.updateNavigationUI();
                
                // Fortschrittsanzeige aktualisieren
                if (app.testProgress && typeof app.testProgress.setCurrentQuestionById === 'function') {
                    app.testProgress.setCurrentQuestionById(questionId);
                }
                
                // Navigation als abgeschlossen markieren
                this.state.isNavigating = false;
                
                // Event auslösen
                const navigationEvent = new CustomEvent('questionChanged', {
                    detail: {
                        questionId: questionId,
                        previousQuestionId: currentQuestionId,
                        direction: direction
                    }
                });
                document.dispatchEvent(navigationEvent);
            }, this.config.animations.enabled ? this.config.animations.duration : 0);
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Navigation zur Frage:', error);
            this.state.isNavigating = false;
            return false;
        }
    },
    
    /**
     * Blendet eine Frage aus mit Animation
     * @param {string} questionId - ID der auszublendenden Frage
     * @param {string} direction - Richtung der Navigation
     */
    hideQuestion: function(questionId, direction) {
        const questionContainer = document.querySelector(`.question-container[data-question-id="${questionId}"]`);
        if (!questionContainer) return;
        
        if (!this.config.animations.enabled) {
            questionContainer.style.display = 'none';
            return;
        }
        
        // Animation je nach Typ und Richtung
        switch (this.config.animations.type) {
            case 'slide':
                if (direction === 'next') {
                    questionContainer.classList.add('slide-out-left');
                } else if (direction === 'prev') {
                    questionContainer.classList.add('slide-out-right');
                } else {
                    questionContainer.classList.add('fade-out');
                }
                break;
            case 'fade':
            default:
                questionContainer.classList.add('fade-out');
                break;
        }
        
        // Nach Animation verstecken
        setTimeout(() => {
            questionContainer.style.display = 'none';
            
            // Animation-Klassen entfernen
            questionContainer.classList.remove('slide-out-left', 'slide-out-right', 'fade-out');
        }, this.config.animations.duration);
    },
    
    /**
     * Zeigt eine Frage an mit Animation
     * @param {string} questionId - ID der anzuzeigenden Frage
     * @param {string} direction - Richtung der Navigation
     */
    showQuestion: function(questionId, direction) {
        const questionContainer = document.querySelector(`.question-container[data-question-id="${questionId}"]`);
        if (!questionContainer) return;
        
        // Alle Fragen ausblenden
        const allQuestions = document.querySelectorAll('.question-container');
        allQuestions.forEach(container => {
            if (container !== questionContainer) {
                container.style.display = 'none';
            }
        });
        
        if (!this.config.animations.enabled) {
            questionContainer.style.display = 'block';
            return;
        }
        
        // Anfangszustand für Animation
        switch (this.config.animations.type) {
            case 'slide':
                if (direction === 'next') {
                    questionContainer.classList.add('slide-in-right');
                } else if (direction === 'prev') {
                    questionContainer.classList.add('slide-in-left');
                } else {
                    questionContainer.classList.add('fade-in');
                }
                break;
            case 'fade':
            default:
                questionContainer.classList.add('fade-in');
                break;
        }
        
        // Frage anzeigen
        questionContainer.style.display = 'block';
        
        // Animation starten
        setTimeout(() => {
            // Animation-Klassen entfernen
            questionContainer.classList.remove('slide-in-right', 'slide-in-left', 'fade-in');
            
            // Fokus auf die Frage setzen
            questionContainer.setAttribute('tabindex', '-1');
            questionContainer.focus();
        }, 50);
    },
    
    /**
     * Aktualisiert die Navigations-UI
     */
    updateNavigationUI: function() {
        // Zurück-Button
        const backButton = document.querySelector('.back-button');
        if (backButton) {
            if (this.state.currentQuestionIndex === 0) {
                backButton.disabled = true;
                backButton.classList.add('disabled');
            } else {
                backButton.disabled = false;
                backButton.classList.remove('disabled');
            }
        }
        
        // Fragenzähler
        const currentQuestionSpan = document.querySelector('.current-question');
        if (currentQuestionSpan) {
            currentQuestionSpan.textContent = this.state.currentQuestionIndex + 1;
        }
        
        // Weiter-/Abschließen-Button
        const isLastQuestion = this.state.currentQuestionIndex === this.state.questionIds.length - 1;
        const nextButton = document.querySelector('.next-button');
        const finishButton = document.querySelector('.finish-button');
        
        if (nextButton && finishButton) {
            if (isLastQuestion) {
                nextButton.style.display = 'none';
                finishButton.style.display = 'flex';
            } else {
                nextButton.style.display = 'flex';
                finishButton.style.display = 'none';
            }
        } else if (nextButton) {
            // Dynamisches Ersetzen, falls noch kein Finish-Button existiert
            if (isLastQuestion) {
                const rightSection = nextButton.parentNode;
                
                // Weiter-Button entfernen
                nextButton.remove();
                
                // Abschließen-Button erstellen
                const finishButton = document.createElement('button');
                finishButton.className = 'nav-button finish-button';
                finishButton.innerHTML = 'Test abschließen <i class="fa fa-check"></i>';
                finishButton.setAttribute('aria-label', 'Test abschließen');
                finishButton.addEventListener('click', () => this.finishTest());
                
                rightSection.appendChild(finishButton);
            }
        } else if (finishButton) {
            // Dynamisches Ersetzen, falls kein Weiter-Button existiert
            if (!isLastQuestion) {
                const rightSection = finishButton.parentNode;
                
                // Abschließen-Button entfernen
                finishButton.remove();
                
                // Weiter-Button erstellen
                const nextButton = document.createElement('button');
                nextButton.className = 'nav-button next-button';
                nextButton.innerHTML = 'Weiter <i class="fa fa-arrow-right"></i>';
                nextButton.setAttribute('aria-label', 'Zur nächsten Frage');
                nextButton.addEventListener('click', () => this.navigateToNextQuestion());
                
                rightSection.appendChild(nextButton);
            }
        }
    },
    
    /**
     * Speichert die Antwort der aktuellen Frage
     */
    saveCurrentAnswer: function() {
        try {
            const sessionId = app.testSessionManager.getCurrentSessionId();
            const questionId = this.state.currentQuestionId;
            
            if (!sessionId || !questionId) return;
            
            // Speicherfunktion aufrufen, falls vorhanden
            if (app.answerStorage && app.answerStorage.interface && app.answerStorage.interface.saveAnswer) {
                app.answerStorage.interface.saveAnswer(sessionId, questionId);
            } else {
                // Direkt die Antwort aus der DOM extrahieren und speichern
                this.extractAndSaveAnswer(sessionId, questionId);
            }
        } catch (error) {
            console.error('Fehler beim Speichern der aktuellen Antwort:', error);
        }
    },
    
    /**
     * Extrahiert die Antwort aus dem DOM und speichert sie
     * @param {string} sessionId - ID der Testsitzung
     * @param {string} questionId - ID der Frage
     */
    extractAndSaveAnswer: function(sessionId, questionId) {
        const questionContainer = document.querySelector(`.question-container[data-question-id="${questionId}"]`);
        if (!questionContainer) return;
        
        // Fragetyp bestimmen
        const session = app.testSessionManager.getSession(sessionId);
        if (!session || !session.testData || !session.testData.questions[questionId]) return;
        
        const questionType = session.testData.questions[questionId].type;
        let value = null;
        
        // Je nach Fragetyp die Antwort extrahieren
        switch (questionType) {
            case 'multiple-choice':
                // Alle ausgewählten Checkboxen sammeln
                const checkboxes = questionContainer.querySelectorAll('input[type="checkbox"]:checked');
                value = Array.from(checkboxes).map(cb => cb.value);
                break;
                
            case 'single-choice':
                // Ausgewählten Radio-Button finden
                const selectedRadio = questionContainer.querySelector('input[type="radio"]:checked');
                value = selectedRadio ? selectedRadio.value : null;
                break;
                
            case 'true-false':
                // Aktiven Wahr/Falsch-Button finden
                const activeButton = questionContainer.querySelector('.true-false-btn.active');
                value = activeButton ? (activeButton.dataset.value === 'true') : null;
                break;
                
            case 'free-text':
                // Text aus Textarea oder Input-Feld
                const textField = questionContainer.querySelector('textarea, input[type="text"]');
                value = textField ? textField.value : null;
                break;
        }
        
        // Antwort speichern, wenn ein Wert gefunden wurde
        if (value !== null && app.answerStorage && app.answerStorage.interface && app.answerStorage.interface.setAnswer) {
            app.answerStorage.interface.setAnswer(sessionId, questionId, value);
        }
    },
    
    /**
     * Prüft, ob die aktuelle Frage beantwortet wurde
     * @returns {boolean} Ob die Frage beantwortet wurde
     */
    isCurrentQuestionAnswered: function() {
        const sessionId = app.testSessionManager.getCurrentSessionId();
        const questionId = this.state.currentQuestionId;
        
        if (!sessionId || !questionId) return false;
        
        // Prüfen, ob eine Antwort existiert
        const session = app.testSessionManager.getSession(sessionId);
        return session && session.answers && !!session.answers[questionId];
    },
    
    /**
     * Schließt den Test ab
     */
    finishTest: function() {
        try {
            // Aktuelle Antwort speichern
            this.saveCurrentAnswer();
            
            // Bestätigung anfordern
            if (!confirm('Möchtest du den Test wirklich abschließen? Du kannst danach keine Änderungen mehr vornehmen.')) {
                return;
            }
            
            // Navigation blockieren
            this.state.isBlocked = true;
            
            // Alle Antworten speichern
            if (app.answerStorage && app.answerStorage.interface && app.answerStorage.interface.saveAllAnswers) {
                app.answerStorage.interface.saveAllAnswers()
                    .then(() => {
                        // Test-Abschluss-Event auslösen
                        const finishEvent = new CustomEvent('testSubmitted', {
                            detail: {
                                sessionId: app.testSessionManager.getCurrentSessionId()
                            }
                        });
                        document.dispatchEvent(finishEvent);
                        
                        // Navigation wieder freigeben
                        this.state.isBlocked = false;
                    })
                    .catch(error => {
                        console.error('Fehler beim Speichern aller Antworten:', error);
                        alert('Es ist ein Fehler beim Speichern aufgetreten. Bitte versuche es erneut.');
                        
                        // Navigation wieder freigeben
                        this.state.isBlocked = false;
                    });
            } else {
                // Test-Abschluss-Event direkt auslösen
                const finishEvent = new CustomEvent('testSubmitted', {
                    detail: {
                        sessionId: app.testSessionManager.getCurrentSessionId()
                    }
                });
                document.dispatchEvent(finishEvent);
                
                // Navigation wieder freigeben
                this.state.isBlocked = false;
            }
        } catch (error) {
            console.error('Fehler beim Abschließen des Tests:', error);
            
            // Navigation wieder freigeben
            this.state.isBlocked = false;
        }
    }
};

// Event-Handler für Test-Ereignisse
(function() {
    // Initialisierung beim Laden der Testseite
    document.addEventListener('testPageLoaded', function(event) {
        const sessionId = event.detail.sessionId;
        const navContainer = document.getElementById('test-navigation-container');
        
        if (sessionId && navContainer) {
            app.testNavigation.initialize(sessionId, navContainer);
        }
    });
    
    // Wenn eine Frage direkt per ID angesprungen werden soll
    document.addEventListener('questionNavigationRequest', function(event) {
        const questionId = event.detail.questionId;
        
        if (questionId) {
            app.testNavigation.navigateToQuestion(questionId, 'direct');
        }
    });
    
    console.log('Test-Navigations-Modul (Teil 1) initialisiert');
})();

// Öffentliche Schnittstelle exportieren
app.testNavigation.interface = {
    initialize: app.testNavigation.initialize.bind(app.testNavigation),
    navigateToQuestion: app.testNavigation.navigateToQuestion.bind(app.testNavigation),
    navigateToNextQuestion: app.testNavigation.navigateToNextQuestion.bind(app.testNavigation),
    navigateToPreviousQuestion: app.testNavigation.navigateToPreviousQuestion.bind(app.testNavigation),
    navigateToNextUnanswered: app.testNavigation.navigateToNextUnanswered.bind(app.testNavigation),
    finishTest: app.testNavigation.finishTest.bind(app.testNavigation)
};
/**
 * JS-Block 5.7.2-part2: Testfortschritt - Navigation zwischen Fragen (Teil 2)
 * 
 * Dieser Block erweitert die Navigationskomponente um fortgeschrittene Funktionen:
 * - Mini-Map und visuelle Navigation
 * - Verzweigungs- und adaptive Testlogik
 * - A11y (Barrierefreiheit)
 * - Mobile Verbesserungen
 * - Navigationshilfen und Tutorial
 */

// Namespace für erweiterte Navigationsfunktionen
app.testNavigation.advanced = {
    // Konfiguration
    config: {
        // Mini-Map
        miniMap: {
            enabled: true,              // Mini-Map aktivieren
            maxVisibleQuestions: 20,    // Maximale Anzahl gleichzeitig sichtbarer Fragen
            showOnMobile: false,        // Auf mobilen Geräten anzeigen
            position: 'bottom',         // 'top', 'bottom', 'left', 'right'
            expandable: true,           // Erweiterbare Mini-Map
            showAnswerStatus: true,     // Antwortstatus in der Mini-Map anzeigen
            colorCoded: true            // Farbkodierung für verschiedene Fragetypen
        },
        
        // Adaptive Tests und Verzweigungslogik
        adaptive: {
            enabled: false,             // Adaptive Logik aktivieren
            branching: false,           // Verzweigungslogik
            dynamicContent: false,      // Dynamische Inhalte basierend auf Antworten
            conditionalQuestions: false // Bedingte Fragen zeigen/verstecken
        },
        
        // Barrierefreiheit (A11y)
        accessibility: {
            highContrast: false,        // Hoher Kontrast-Modus
            largeText: false,           // Größerer Text
            readAloud: false,           // Text-to-Speech
            keyboardShortcuts: true,    // Erweiterte Tastatur-Shortcuts
            focusMode: false,           // Fokus-Modus (reduzierte UI)
            ariaAnnouncements: true     // ARIA Live-Ankündigungen
        },
        
        // Mobile-Optimierungen
        mobile: {
            swipeNavigation: true,      // Wischgesten für Navigation
            fullscreenMode: false,      // Vollbildmodus auf Mobilgeräten
            optimizedLayout: true,      // Für mobile Geräte optimiertes Layout
            touchTargets: true          // Größere Touch-Ziele
        },
        
        // Navigationshilfen
        navigationHelpers: {
            searchEnabled: false,       // Suche in Fragen
            bookmarksEnabled: true,     // Lesezeichen für Fragen
            highlightsEnabled: false,   // Hervorhebungen in Fragen
            tourEnabled: true,          // Tour/Tutorial für Navigation
            helpButtonEnabled: true     // Hilfebutton anzeigen
        }
    },
    
    // Status der erweiterten Funktionen
    state: {
        miniMapVisible: false,          // Mini-Map sichtbar
        activeFilter: null,             // Aktiver Filter für Fragen
        quickNavActive: false,          // Schnellnavigation aktiv
        tourStep: 0,                    // Aktueller Schritt in der Tour
        touchStartX: 0,                 // Start-X-Position bei Touch
        touchStartY: 0,                 // Start-Y-Position bei Touch
        isMobileDevice: false,          // Ist ein mobiles Gerät
        lastFocusedElement: null,       // Letztes fokussiertes Element
        expandedMiniMap: false,         // Erweiterte Mini-Map
        navigationHistory: []           // Navigationsverlauf (erweitertes Tracking)
    },
    
    /**
     * Initialisiert die erweiterten Navigationsfunktionen
     * @param {string} sessionId - ID der Testsitzung
     */
    initialize: function(sessionId) {
        try {
            // Testsitzung abrufen
            const session = app.testSessionManager.getSession(sessionId);
            if (!session) {
                throw new Error(`Keine Testsitzung mit ID ${sessionId} gefunden`);
            }
            
            // Geräteerkennung
            this.detectDeviceType();
            
            // Erweiterte UI-Komponenten hinzufügen
            this.setupAdvancedUI();
            
            // Erweiterte Event-Listener einrichten
            this.setupAdvancedEventListeners();
            
            console.log('Erweiterte Navigationsfunktionen initialisiert');
            
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung der erweiterten Navigationsfunktionen:', error);
            return false;
        }
    },
    
    /**
     * Erkennt den Gerätetyp und passt Einstellungen an
     */
    detectDeviceType: function() {
        // Mobile-Erkennung
        const userAgent = navigator.userAgent.toLowerCase();
        const isMobile = /iphone|ipad|ipod|android|blackberry|windows phone/g.test(userAgent);
        
        this.state.isMobileDevice = isMobile;
        
        // Einstellungen an Gerät anpassen
        if (isMobile) {
            // Mini-Map auf Mobilgeräten deaktivieren, wenn nicht explizit erlaubt
            if (!this.config.miniMap.showOnMobile) {
                this.config.miniMap.enabled = false;
            }
            
            // Touch-Events aktivieren
            if (this.config.mobile.swipeNavigation) {
                this.setupTouchNavigation();
            }
        }
    },
    
    /**
     * Richtet die erweiterten UI-Komponenten ein
     */
    setupAdvancedUI: function() {
        // Mini-Map hinzufügen
        if (this.config.miniMap.enabled) {
            this.createMiniMap();
        }
        
        // Navigationshilfen hinzufügen
        if (this.config.navigationHelpers.helpButtonEnabled) {
            this.addHelpButton();
        }
        
        // Barrierefreiheits-Einstellungen
        if (this.config.accessibility.keyboardShortcuts) {
            this.setupAdvancedKeyboardNavigation();
        }
        
        // Stile für erweiterte Funktionen hinzufügen
        this.addAdvancedStyles();
    },
    
    /**
     * Erstellt die Mini-Map für die Navigation
     */
    createMiniMap: function() {
        // Bestehende Mini-Map entfernen, falls vorhanden
        const existingMiniMap = document.querySelector('.test-mini-map');
        if (existingMiniMap) {
            existingMiniMap.remove();
        }
        
        // Mini-Map-Container erstellen
        const miniMapContainer = document.createElement('div');
        miniMapContainer.className = `test-mini-map ${this.config.miniMap.position}`;
        
        if (!this.state.miniMapVisible) {
            miniMapContainer.classList.add('minimized');
        }
        
        // Header mit Titel und Toggle-Button
        const header = document.createElement('div');
        header.className = 'mini-map-header';
        header.innerHTML = `
            <h4>Fragenübersicht</h4>
            <button class="toggle-mini-map-btn">
                <i class="fa fa-${this.state.miniMapVisible ? 'chevron-down' : 'chevron-up'}"></i>
            </button>
        `;
        
        // Event-Listener für Toggle-Button
        header.querySelector('.toggle-mini-map-btn').addEventListener('click', () => {
            this.toggleMiniMap();
        });
        
        // Inhalt der Mini-Map erstellen
        const content = document.createElement('div');
        content.className = 'mini-map-content';
        
        // Fragenindikatoren hinzufügen
        const questionList = document.createElement('div');
        questionList.className = 'mini-map-questions';
        
        // Fragen-IDs aus dem Haupt-Navigationsmodul übernehmen
        const questionIds = app.testNavigation.state.questionIds || [];
        
        questionIds.forEach((questionId, index) => {
            // Indikator für jede Frage erstellen
            const indicator = document.createElement('div');
            indicator.className = 'mini-map-indicator';
            indicator.dataset.questionId = questionId;
            indicator.dataset.questionIndex = index;
            
            // Status aus den Testfortschrittsdaten abrufen
            let isAnswered = false;
            let isCorrect = null;
            
            if (app.testProgress && app.testProgress.state.questionStates) {
                const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
                if (questionState) {
                    isAnswered = questionState.answered;
                    isCorrect = questionState.correct;
                }
            }
            
            // Aktuelle Frage markieren
            if (app.testNavigation.state.currentQuestionId === questionId) {
                indicator.classList.add('current');
            }
            
            // Status-Klassen hinzufügen
            if (isAnswered) {
                indicator.classList.add('answered');
                
                if (isCorrect === true) {
                    indicator.classList.add('correct');
                } else if (isCorrect === false) {
                    indicator.classList.add('incorrect');
                }
            }
            
            // Fragenummer als Tooltip
            indicator.title = `Frage ${index + 1}`;
            
            // Text für Fragenummer
            indicator.innerHTML = `
                <span class="indicator-number">${index + 1}</span>
            `;
            
            // Event-Listener für Klick
            indicator.addEventListener('click', () => {
                app.testNavigation.navigateToQuestion(questionId, 'direct');
            });
            
            questionList.appendChild(indicator);
        });
        
        content.appendChild(questionList);
        
        // Filter-Optionen hinzufügen
        if (this.config.miniMap.expandable) {
            const filterOptions = document.createElement('div');
            filterOptions.className = 'mini-map-filters';
            filterOptions.innerHTML = `
                <button class="filter-btn all active" data-filter="all">Alle</button>
                <button class="filter-btn unanswered" data-filter="unanswered">Unbeantwortet</button>
                <button class="filter-btn answered" data-filter="answered">Beantwortet</button>
                <button class="filter-btn bookmarked" data-filter="bookmarked">Lesezeichen</button>
            `;
            
            // Event-Listener für Filter-Buttons
            filterOptions.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const filter = e.target.dataset.filter;
                    this.applyMiniMapFilter(filter);
                    
                    // Aktiven Button markieren
                    filterOptions.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                });
            });
            
            content.appendChild(filterOptions);
        }
        
        // Alles zusammenfügen und zum DOM hinzufügen
        miniMapContainer.appendChild(header);
        miniMapContainer.appendChild(content);
        document.body.appendChild(miniMapContainer);
    },
    
    /**
     * Wechselt die Sichtbarkeit der Mini-Map
     */
    toggleMiniMap: function() {
        this.state.miniMapVisible = !this.state.miniMapVisible;
        
        const miniMap = document.querySelector('.test-mini-map');
        if (!miniMap) return;
        
        if (this.state.miniMapVisible) {
            miniMap.classList.remove('minimized');
            miniMap.querySelector('.toggle-mini-map-btn i').className = 'fa fa-chevron-down';
        } else {
            miniMap.classList.add('minimized');
            miniMap.querySelector('.toggle-mini-map-btn i').className = 'fa fa-chevron-up';
        }
    },
    
    /**
     * Filtert die Anzeige in der Mini-Map
     * @param {string} filter - Name des anzuwendenden Filters
     */
    applyMiniMapFilter: function(filter) {
        this.state.activeFilter = filter;
        
        const indicators = document.querySelectorAll('.mini-map-indicator');
        if (!indicators.length) return;
        
        indicators.forEach(indicator => {
            const questionId = indicator.dataset.questionId;
            
            // Status dieser Frage abrufen
            let isAnswered = false;
            let isBookmarked = false;
            
            // Prüfen, ob beantwortet
            if (app.testProgress && app.testProgress.state.questionStates) {
                const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
                if (questionState) {
                    isAnswered = questionState.answered;
                }
            }
            
            // Prüfen, ob mit Lesezeichen
            if (app.testProgress && app.testProgress.extended && app.testProgress.extended.state) {
                isBookmarked = app.testProgress.extended.state.bookmarkedQuestions.includes(questionId);
            }
            
            // Sichtbarkeit basierend auf Filter setzen
            switch (filter) {
                case 'unanswered':
                    indicator.style.display = !isAnswered ? 'flex' : 'none';
                    break;
                case 'answered':
                    indicator.style.display = isAnswered ? 'flex' : 'none';
                    break;
                case 'bookmarked':
                    indicator.style.display = isBookmarked ? 'flex' : 'none';
                    break;
                case 'all':
                default:
                    indicator.style.display = 'flex';
                    break;
            }
        });
    },
    
    /**
     * Aktualisiert die Mini-Map
     */
    updateMiniMap: function() {
        if (!this.config.miniMap.enabled) return;
        
        const miniMap = document.querySelector('.test-mini-map');
        if (!miniMap) return;
        
        const indicators = miniMap.querySelectorAll('.mini-map-indicator');
        
        indicators.forEach(indicator => {
            const questionId = indicator.dataset.questionId;
            
            // Aktuelle Frage markieren oder Markierung entfernen
            if (app.testNavigation.state.currentQuestionId === questionId) {
                indicator.classList.add('current');
            } else {
                indicator.classList.remove('current');
            }
            
            // Status dieser Frage abrufen und aktualisieren
            if (app.testProgress && app.testProgress.state.questionStates) {
                const questionState = app.testProgress.state.questionStates.find(q => q.questionId === questionId);
                
                if (questionState) {
                    // Antwort-Status
                    if (questionState.answered) {
                        indicator.classList.add('answered');
                        
                        if (questionState.correct === true) {
                            indicator.classList.add('correct');
                            indicator.classList.remove('incorrect');
                        } else if (questionState.correct === false) {
                            indicator.classList.add('incorrect');
                            indicator.classList.remove('correct');
                        } else {
                            indicator.classList.remove('correct', 'incorrect');
                        }
                    } else {
                        indicator.classList.remove('answered', 'correct', 'incorrect');
                    }
                }
            }
            
            // Lesezeichen-Status aktualisieren
            if (app.testProgress && app.testProgress.extended && app.testProgress.extended.state) {
                const isBookmarked = app.testProgress.extended.state.bookmarkedQuestions.includes(questionId);
                
                if (isBookmarked) {
                    if (!indicator.querySelector('.bookmark-indicator')) {
                        const bookmarkIndicator = document.createElement('span');
                        bookmarkIndicator.className = 'bookmark-indicator';
                        bookmarkIndicator.innerHTML = '<i class="fa fa-bookmark"></i>';
                        indicator.appendChild(bookmarkIndicator);
                    }
                } else {
                    const bookmarkIndicator = indicator.querySelector('.bookmark-indicator');
                    if (bookmarkIndicator) {
                        bookmarkIndicator.remove();
                    }
                }
            }
        });
        
        // Filter neu anwenden, falls aktiv
        if (this.state.activeFilter) {
            this.applyMiniMapFilter(this.state.activeFilter);
        }
    },
    
    /**
     * Fügt einen Hilfe-Button hinzu
     */
    addHelpButton: function() {
        // Prüfen, ob der Button bereits existiert
        if (document.querySelector('.nav-help-button')) return;
        
        // Navigationsleiste abrufen
        const navBar = document.querySelector('.test-navigation-bar');
        if (!navBar) return;
        
        // Mittlere Sektion abrufen oder erstellen
        let middleSection = navBar.querySelector('.nav-section.middle');
        
        if (!middleSection) {
            middleSection = document.createElement('div');
            middleSection.className = 'nav-section middle';
            navBar.appendChild(middleSection);
        }
        
        // Hilfe-Button erstellen
        const helpButton = document.createElement('button');
        helpButton.className = 'nav-button nav-help-button';
        helpButton.innerHTML = '<i class="fa fa-question-circle"></i>';
        helpButton.setAttribute('aria-label', 'Hilfe zur Navigation');
        helpButton.title = 'Hilfe zur Navigation';
        
        // Event-Listener hinzufügen
        helpButton.addEventListener('click', () => {
            this.showNavigationHelp();
        });
        
        // Zum DOM hinzufügen
        middleSection.appendChild(helpButton);
    },
    
    /**
     * Zeigt die Navigationshilfe an
     */
    showNavigationHelp: function() {
        // Prüfen, ob bereits ein Dialog angezeigt wird
        if (document.querySelector('.help-dialog')) return;
        
        // Dialog erstellen
        const dialogOverlay = document.createElement('div');
        dialogOverlay.className = 'dialog-overlay help-dialog';
        
        const dialogContent = document.createElement('div');
        dialogContent.className = 'dialog-content';
        
        // Hilfe-Inhalt
        dialogContent.innerHTML = `
            <h3>Navigationshelfer</h3>
            
            <h4>Navigation zwischen Fragen</h4>
            <ul>
                <li><span class="key-shortcut">←</span> oder <span class="key-shortcut">Bild↑</span>: Vorherige Frage</li>
                <li><span class="key-shortcut">→</span> oder <span class="key-shortcut">Bild↓</span>: Nächste Frage</li>
                <li><span class="key-shortcut">Strg+G</span>: Zur Frage springen (Nummer eingeben)</li>
                <li><span class="key-shortcut">Strg+U</span>: Zur nächsten unbeantworteten Frage</li>
            </ul>
            
            <h4>Fragenmarkierungen</h4>
            <ul>
                <li><span class="key-shortcut">Strg+B</span>: Lesezeichen setzen/entfernen</li>
                <li><span class="key-shortcut">Strg+M</span>: Mini-Map ein-/ausblenden</li>
            </ul>
            
            <h4>Abschließen</h4>
            <ul>
                <li><span class="key-shortcut">Strg+Enter</span>: Test abschließen (von der letzten Frage aus)</li>
            </ul>
            
            <div class="dialog-buttons">
                <button class="tour-button primary-button">Tour starten</button>
                <button class="close-button secondary-button">Schließen</button>
            </div>
        `;
        
        // Zum DOM hinzufügen
        dialogOverlay.appendChild(dialogContent);
        document.body.appendChild(dialogOverlay);
        
        // Event-Listener für Buttons
        dialogContent.querySelector('.close-button').addEventListener('click', () => {
            dialogOverlay.remove();
        });
        
        dialogContent.querySelector('.tour-button').addEventListener('click', () => {
            dialogOverlay.remove();
            this.startNavigationTour();
        });
    },
    
    /**
     * Startet eine Tour durch die Navigationsfunktionen
     */
    startNavigationTour: function() {
        if (this.state.tourStep > 0) return; // Tour läuft bereits
        
        // Tour-Container erstellen
        const tourContainer = document.createElement('div');
        tourContainer.className = 'navigation-tour';
        tourContainer.innerHTML = `
            <div class="tour-content">
                <h4 class="tour-title">Willkommen zur Navigation</h4>
                <p class="tour-description">Diese kurze Tour zeigt dir, wie du durch den Test navigieren kannst.</p>
                <div class="tour-buttons">
                    <button class="tour-skip-btn">Überspringen</button>
                    <button class="tour-next-btn">Nächster Tipp</button>
                </div>
            </div>
        `;
        
        // Event-Listener für Buttons
        tourContainer.querySelector('.tour-skip-btn').addEventListener('click', () => {
            this.endNavigationTour();
        });
        
        tourContainer.querySelector('.tour-next-btn').addEventListener('click', () => {
            this.showNextTourStep();
        });
        
        // Zum DOM hinzufügen
        document.body.appendChild(tourContainer);
        
        // Tour starten
        this.state.tourStep = 1;
        this.positionTourElement();
    },
    
    /**
     * Zeigt den nächsten Schritt in der Navigationstour
     */
    showNextTourStep: function() {
        // Nächsten Schritt setzen
        this.state.tourStep++;
        
        // Tour-Elememt abrufen
        const tourContainer = document.querySelector('.navigation-tour');
        if (!tourContainer) return;
        
        const tourTitle = tourContainer.querySelector('.tour-title');
        const tourDescription = tourContainer.querySelector('.tour-description');
        const tourNextBtn = tourContainer.querySelector('.tour-next-btn');
        
        // Inhalt je nach Schritt setzen
        switch (this.state.tourStep) {
            case 2:
                tourTitle.textContent = 'Navigationsleiste';
                tourDescription.textContent = 'Nutze die Buttons "Zurück" und "Weiter", um zwischen Fragen zu navigieren.';
                break;
                
            case 3:
                tourTitle.textContent = 'Fragenindikatoren';
                tourDescription.textContent = 'Die Punkte oben zeigen alle Fragen. Klicke auf einen Punkt, um direkt zu dieser Frage zu springen.';
                break;
                
            case 4:
                tourTitle.textContent = 'Unbeantwortete Fragen';
                tourDescription.textContent = 'Der "Nächste unbeantwortete" Button bringt dich zur nächsten Frage ohne Antwort.';
                break;
                
            case 5:
                tourTitle.textContent = 'Mini-Map';
                tourDescription.textContent = 'Die Mini-Map gibt dir einen Überblick über alle Fragen und deren Status.';
                break;
                
            case 6:
                tourTitle.textContent = 'Tastatur-Navigation';
                tourDescription.textContent = 'Nutze die Pfeiltasten für die Navigation oder öffne die Hilfe für weitere Tastenkombinationen.';
                tourNextBtn.textContent = 'Tour beenden';
                break;
                
            default:
                // Tour beenden
                this.endNavigationTour();
                return;
        }
        
        // Tour-Element positionieren
        this.positionTourElement();
    },
    
    /**
     * Positioniert das Tour-Element je nach aktuellem Schritt
     */
    positionTourElement: function() {
        const tourContainer = document.querySelector('.navigation-tour');
        if (!tourContainer) return;
        
        // Element, das hervorgehoben werden soll
        let targetElement = null;
        
        switch (this.state.tourStep) {
            case 1: // Einführung
                // Mittig positionieren
                tourContainer.style.top = '50%';
                tourContainer.style.left = '50%';
                tourContainer.style.transform = 'translate(-50%, -50%)';
                break;
                
            case 2: // Navigationsleiste
                targetElement = document.querySelector('.test-navigation-bar');
                break;
                
            case 3: // Fragenindikatoren
                targetElement = document.querySelector('.question-indicators-container');
                break;
                
            case 4: // Unbeantwortete Fragen
                targetElement = document.querySelector('.next-unanswered-button');
                break;
                
            case 5: // Mini-Map
                targetElement = document.querySelector('.test-mini-map');
                // Mini-Map einblenden, falls nicht sichtbar
                if (targetElement && !this.state.miniMapVisible) {
                    this.toggleMiniMap();
                }
                break;
                
            case 6: // Tastatur-Navigation
                // Zurück zur Mitte
                tourContainer.style.top = '50%';
                tourContainer.style.left = '50%';
                tourContainer.style.transform = 'translate(-50%, -50%)';
                break;
        }
        
        // Positionierung basierend auf Zielelement
        if (targetElement) {
            const rect = targetElement.getBoundingClientRect();
            
            // Positionierung abhängig vom Zielelement und Platz im Fenster
            if (rect.top > window.innerHeight / 2) {
                // Element ist in der unteren Hälfte - Tour darüber anzeigen
                tourContainer.style.top = `${rect.top - tourContainer.offsetHeight - 10}px`;
                tourContainer.style.left = `${rect.left + rect.width / 2}px`;
                tourContainer.style.transform = 'translateX(-50%)';
            } else {
                // Element ist in der oberen Hälfte - Tour darunter anzeigen
                tourContainer.style.top = `${rect.bottom + 10}px`;
                tourContainer.style.left = `${rect.left + rect.width / 2}px`;
                tourContainer.style.transform = 'translateX(-50%)';
            }
        }
    },
    
    /**
     * Beendet die Navigationstour
     */
    endNavigationTour: function() {
        // Tour-Element entfernen
        const tourContainer = document.querySelector('.navigation-tour');
        if (tourContainer) {
            tourContainer.remove();
        }
        
        // Tour-Status zurücksetzen
        this.state.tourStep = 0;
    },
    
    /**
     * Richtet erweiterte Tastatur-Navigation ein
     */
    setupAdvancedKeyboardNavigation: function() {
        // Bestehenden Listener entfernen, falls vorhanden
        if (this._advancedKeyboardHandler) {
            document.removeEventListener('keydown', this._advancedKeyboardHandler);
        }
        
        // Neuen Listener erstellen
        this._advancedKeyboardHandler = (event) => {
            // Ignorieren, wenn in Texteingabefeld oder Navigation blockiert
            if (
                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) ||
                app.testNavigation.state.isNavigating ||
                app.testNavigation.state.isBlocked
            ) {
                return;
            }
            
            // Strg+M: Mini-Map ein-/ausblenden
            if (event.ctrlKey && event.key === 'm') {
                event.preventDefault();
                this.toggleMiniMap();
            }
            
            // Strg+G: Zu Frage springen
            else if (event.ctrlKey && event.key === 'g') {
                event.preventDefault();
                const input = prompt('Gib die Nummer der Frage ein, zu der du springen möchtest:');
                
                if (input !== null) {
                    const questionNumber = parseInt(input, 10);
                    
                    if (!isNaN(questionNumber) && questionNumber > 0 && questionNumber <= app.testNavigation.state.questionIds.length) {
                        const questionIndex = questionNumber - 1;
                        const questionId = app.testNavigation.state.questionIds[questionIndex];
                        app.testNavigation.navigateToQuestion(questionId, 'direct');
                    } else {
                        alert(`Bitte gib eine Zahl zwischen 1 und ${app.testNavigation.state.questionIds.length} ein.`);
                    }
                }
            }
            
            // Strg+U: Zur nächsten unbeantworteten Frage
            else if (event.ctrlKey && event.key === 'u') {
                event.preventDefault();
                app.testNavigation.navigateToNextUnanswered();
            }
            
            // Strg+B: Lesezeichen setzen/entfernen
            else if (event.ctrlKey && event.key === 'b') {
                event.preventDefault();
                const questionId = app.testNavigation.state.currentQuestionId;
                
                if (questionId && app.testProgress && app.testProgress.extended && 
                    typeof app.testProgress.extended.toggleBookmark === 'function') {
                    app.testProgress.extended.toggleBookmark(questionId);
                }
            }
            
            // Strg+Enter: Test abschließen (von letzter Frage)
            else if (event.ctrlKey && event.key === 'Enter') {
                if (app.testNavigation.state.currentQuestionIndex === app.testNavigation.state.questionIds.length - 1) {
                    event.preventDefault();
                    app.testNavigation.finishTest();
                }
            }
            
            // PageUp: Vorherige Frage
            else if (event.key === 'PageUp') {
                event.preventDefault();
                app.testNavigation.navigateToPreviousQuestion();
            }
            
            // PageDown: Nächste Frage
            else if (event.key === 'PageDown') {
                event.preventDefault();
                app.testNavigation.navigateToNextQuestion();
            }
            
            // F1: Hilfe anzeigen
            else if (event.key === 'F1') {
                event.preventDefault();
                this.showNavigationHelp();
            }
        };
        
        // Event-Listener hinzufügen
        document.addEventListener('keydown', this._advancedKeyboardHandler);
    },
    
    /**
     * Richtet Touch-Navigation für mobile Geräte ein
     */
    setupTouchNavigation: function() {
        // Container für Test-Fragen finden
        const testContainer = document.getElementById('test-container');
        if (!testContainer) return;
        
        // Touch-Events hinzufügen
        testContainer.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                this.state.touchStartX = event.touches[0].clientX;
                this.state.touchStartY = event.touches[0].clientY;
            }
        }, { passive: true });
        
        testContainer.addEventListener('touchend', (event) => {
            if (!this.state.touchStartX || !this.state.touchStartY) return;
            
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            
            const deltaX = touchEndX - this.state.touchStartX;
            const deltaY = touchEndY - this.state.touchStartY;
            
            // Nur horizontale Wischgesten berücksichtigen (vertikal = scrollen)
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                // Nach links wischen = nächste Frage
                if (deltaX < 0) {
                    app.testNavigation.navigateToNextQuestion();
                }
                // Nach rechts wischen = vorherige Frage
                else {
                    app.testNavigation.navigateToPreviousQuestion();
                }
            }
            
            // Touch-Status zurücksetzen
            this.state.touchStartX = 0;
            this.state.touchStartY = 0;
        }, { passive: true });
    },
    
    /**
     * Richtet erweiterte Event-Listener ein
     */
    setupAdvancedEventListeners: function() {
        // Aktualisierung der Mini-Map bei Fragewechsel
        document.addEventListener('questionChanged', (event) => {
            this.updateMiniMap();
        });
        
        // Aktualisierung der Mini-Map bei Speicherung einer Antwort
        document.addEventListener('answerSaved', (event) => {
            this.updateMiniMap();
        });
        
        // Feststellung von Änderungen in Lesezeichen
        document.addEventListener('bookmarkToggled', (event) => {
            this.updateMiniMap();
        });
        
        // Anpassung bei Fenstergrößenänderung
        window.addEventListener('resize', () => {
            // Mini-Map-Position anpassen
            if (this.config.miniMap.enabled && this.state.tourStep > 0) {
                this.positionTourElement();
            }
        });
    },
    
    /**
     * Fügt CSS-Stile für die erweiterten Funktionen hinzu
     */
    addAdvancedStyles: function() {
        // Prüfen, ob Stile bereits hinzugefügt wurden
        if (document.getElementById('test-navigation-advanced-styles')) return;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'test-navigation-advanced-styles';
        
        styleElement.textContent = `
            /* Mini-Map */
            .test-mini-map {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                width: 300px;
                max-height: 400px;
                overflow: hidden;
                transition: all 0.3s ease;
                z-index: 1000;
            }
            
            .test-mini-map.minimized {
                height: 40px;
            }
            
            .test-mini-map.top {
                top: 20px;
                bottom: auto;
            }
            
            .test-mini-map.left {
                left: 20px;
                right: auto;
            }
            
            .mini-map-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                background-color: ${app.testProgress.config.colors.primary};
                color: ${app.testProgress.config.colors.secondary};
                cursor: pointer;
            }
            
            .mini-map-header h4 {
                margin: 0;
                font-size: 14px;
            }
            
            .toggle-mini-map-btn {
                background: none;
                border: none;
                color: ${app.testProgress.config.colors.secondary};
                cursor: pointer;
                font-size: 12px;
            }
            
            .mini-map-content {
                padding: 10px;
                max-height: 350px;
                overflow-y: auto;
            }
            
            .mini-map-questions {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin-bottom: 10px;
            }
            
            .mini-map-indicator {
                position: relative;
                width: 30px;
                height: 30px;
                border-radius: 4px;
                background-color: #f0f0f0;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 12px;
                color: #666;
            }
            
            .mini-map-indicator:hover {
                transform: scale(1.1);
                background-color: #e0e0e0;
            }
            
            .mini-map-indicator.current {
                border: 2px solid ${app.testProgress.config.colors.primary};
            }
            
            .mini-map-indicator.answered {
                background-color: ${app.testProgress.config.colors.primary};
                color: ${app.testProgress.config.colors.secondary};
            }
            
            .mini-map-indicator.correct {
                background-color: ${app.testProgress.config.colors.success};
                color: white;
            }
            
            .mini-map-indicator.incorrect {
                background-color: ${app.testProgress.config.colors.error};
                color: white;
            }
            
            .indicator-number {
                font-weight: bold;
            }
            
            .bookmark-indicator {
                position: absolute;
                top: -5px;
                right: -3px;
                font-size: 10px;
                color: #FF9500;
            }
            
            /* Filter-Buttons */
            .mini-map-filters {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin-top: 10px;
            }
            
            .filter-btn {
                background-color: #f0f0f0;
                border: none;
                border-radius: 4px;
                padding: 5px 8px;
                font-size: 12px;
                cursor: pointer;
                flex-grow: 1;
                transition: all 0.2s ease;
            }
            
            .filter-btn:hover {
                background-color: #e0e0e0;
            }
            
            .filter-btn.active {
                background-color: ${app.testProgress.config.colors.primary};
                color: ${app.testProgress.config.colors.secondary};
            }
            
            /* Hilfebutton */
            .nav-help-button {
                background-color: transparent;
                border: none;
                color: #666;
                font-size: 18px;
                cursor: pointer;
                padding: 5px;
            }
            
            .nav-help-button:hover {
                color: #333;
            }
            
            /* Hilfe-Dialog */
            .help-dialog .dialog-content {
                max-width: 500px;
            }
            
            .help-dialog h3 {
                color: ${app.testProgress.config.colors.secondary};
                border-bottom: 2px solid ${app.testProgress.config.colors.primary};
                padding-bottom: 10px;
                margin-top: 0;
            }
            
            .help-dialog h4 {
                margin-top: 20px;
                margin-bottom: 10px;
                color: ${app.testProgress.config.colors.secondary};
            }
            
            .help-dialog ul {
                list-style: none;
                padding-left: 10px;
            }
            
            .help-dialog li {
                margin-bottom: 8px;
                display: flex;
                align-items: center;
            }
            
            .key-shortcut {
                display: inline-block;
                padding: 2px 6px;
                background-color: #f0f0f0;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-right: 10px;
                font-family: monospace;
                font-size: 12px;
                min-width: 20px;
                text-align: center;
            }
            
            .dialog-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            }
            
            .primary-button, .secondary-button {
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                border: none;
            }
            
            .primary-button {
                background-color: ${app.testProgress.config.colors.primary};
                color: ${app.testProgress.config.colors.secondary};
            }
            
            .secondary-button {
                background-color: #f0f0f0;
                color: #333;
            }
            
            /* Tour-Elemente */
            .navigation-tour {
                position: absolute;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 15px rgba(0,0,0,0.3);
                padding: 15px;
                width: 300px;
                z-index: 1100;
            }
            
            .tour-content {
                display: flex;
                flex-direction: column;
            }
            
            .tour-title {
                margin: 0 0 10px 0;
                color: ${app.testProgress.config.colors.secondary};
            }
            
            .tour-description {
                margin: 0 0 15px 0;
                color: #666;
            }
            
            .tour-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            }
            
            .tour-skip-btn {
                background-color: transparent;
                border: none;
                color: #999;
                cursor: pointer;
                padding: 5px 10px;
            }
            
            .tour-next-btn {
                background-color: ${app.testProgress.config.colors.primary};
                color: ${app.testProgress.config.colors.secondary};
                border: none;
                padding: 5px 15px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            }
            
            /* Mobile Anpassungen */
            @media (max-width: 768px) {
                .test-mini-map {
                    width: calc(100% - 40px);
                    left: 20px;
                    right: 20px;
                }
                
                .mini-map-indicator {
                    width: 25px;
                    height: 25px;
                    font-size: 10px;
                }
                
                .navigation-tour {
                    width: calc(100% - 40px);
                    max-width: 350px;
                    top: 50% !important;
                    left: 50% !important;
                    transform: translate(-50%, -50%) !important;
                }
            }
        `;
        
        document.head.appendChild(styleElement);
    }
};

// Event-Handler für erweiterte Navigationsereignisse
(function() {
    // Initialisierung beim Laden der Testseite
    document.addEventListener('testPageLoaded', function(event) {
        const sessionId = event.detail.sessionId;
        
        if (sessionId) {
            app.testNavigation.advanced.initialize(sessionId);
        }
    });
    
    // Lesezeichen-Ereignisse weiterleiten
    document.addEventListener('bookmarkToggled', function(event) {
        app.testNavigation.advanced.updateMiniMap();
    });
    
    console.log('Erweiterte Test-Navigations-Funktionen initialisiert');
})();

// Erweiterung der öffentlichen Schnittstelle
Object.assign(app.testNavigation.interface, {
    // Erweiterte Navigationsfunktionen
    toggleMiniMap: app.testNavigation.advanced.toggleMiniMap.bind(app.testNavigation.advanced),
    showNavigationHelp: app.testNavigation.advanced.showNavigationHelp.bind(app.testNavigation.advanced),
    startNavigationTour: app.testNavigation.advanced.startNavigationTour.bind(app.testNavigation.advanced)
});

// Reihenfolge der Tab-Navigation verbessern
(function() {
    // Event-Listener für DOM-Änderungen, um Tab-Indices zu optimieren
    document.addEventListener('questionChanged', function(event) {
        // Kurze Verzögerung, um sicherzustellen, dass die Frage vollständig geladen ist
        setTimeout(() => {
            // Aktuelle Frage finden
            const currentQuestionId = app.testNavigation.state.currentQuestionId;
            if (!currentQuestionId) return;
            
            const questionContainer = document.querySelector(`.question-container[data-question-id="${currentQuestionId}"]`);
            if (!questionContainer) return;
            
            // Fokussierbare Elemente innerhalb der Frage finden und Tab-Indizes setzen
            const focusableElements = questionContainer.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            
            // Tab-Indizes neu setzen
            focusableElements.forEach((element, index) => {
                element.tabIndex = index + 1;
            });
            
            // Navigationsbuttons in die Tab-Reihenfolge einbeziehen
            const navButtons = document.querySelectorAll('.nav-button');
            navButtons.forEach((button, index) => {
                button.tabIndex = focusableElements.length + index + 1;
            });
            
            // Ersten Input fokussieren, falls vorhanden
            if (focusableElements.length > 0) {
                focusableElements[0].focus();
            }
        }, 100);
    });
})();
/**
 * JS-Block 5.8.1-part1: Testabschluss - Abschlussverarbeitung (Teil 1)
 * 
 * Dieser Block implementiert den ersten Teil der Testabschlussverarbeitung:
 * - Validierung vor Abschluss
 * - Test-Submission
 * - Datenaufbereitung für Ergebnisanzeige
 * - Übergang zum Ergebnisbildschirm
 */

// Namespace für den Testabschluss
app.testCompletion = {
    // Konfiguration
    config: {
        // Validierungseinstellungen
        validation: {
            requireAllQuestions: false,     // Alle Fragen müssen beantwortet sein
            warnAboutUnanswered: true,      // Warnung, wenn nicht alle Fragen beantwortet wurden
            checkInconsistencies: true,     // Prüfung auf widersprüchliche Antworten
            finalConfirmation: true         // Abschließende Bestätigung
        },
        
        // Abschluss-Prozess
        submission: {
            showLoadingIndicator: true,      // Ladeanzeige während des Abschlusses
            autoSave: true,                  // Automatisches Speichern aller Antworten
            saveOnSubmit: true,              // Speichern beim Abschließen
            preventMultipleSubmission: true, // Mehrfach-Abschluss verhindern
            submissionTimeout: 10000         // Zeitlimit für Abschluss in ms (10 Sekunden)
        },
        
        // Ergebnis-Feedback
        results: {
            showImmediately: true,           // Ergebnisse sofort anzeigen
            redirectAfterSubmission: false,  // Nach Abschluss weiterleiten
            redirectUrl: '',                 // Weiterleitungs-URL
            redirectDelay: 3000,             // Verzögerung vor Weiterleitung in ms
            animateTransition: true,         // Übergangsanimation aktivieren
            printOption: true                // Druckoption anbieten
        },
        
        // UI-Konfiguration
        ui: {
            completionButtonText: 'Test abschließen',   // Text für Abschluss-Button
            confirmationMessage: 'Möchtest du den Test wirklich abschließen? Du kannst danach keine Änderungen mehr vornehmen.',  // Bestätigungsnachricht
            loadingText: 'Dein Test wird ausgewertet...',  // Text während Ladeanzeige
            errorHeading: 'Entschuldigung, ein Fehler ist aufgetreten:',  // Überschrift bei Fehler
            retryButtonText: 'Erneut versuchen',  // Text für Wiederholungs-Button
            continueButtonText: 'Zu den Ergebnissen',  // Text für Weiter-Button
            unansweredQuestionsMessage: 'Achtung: Du hast nicht alle Fragen beantwortet. Möchtest du trotzdem fortfahren?'  // Nachricht bei unbeantworteten Fragen
        }
    },
    
    // Status des Abschlussprozesses
    state: {
        isSubmitting: false,             // Abschluss läuft
        hasBeenSubmitted: false,         // Test wurde abgeschlossen
        submissionStartTime: null,       // Startzeitpunkt des Abschlusses
        submissionError: null,           // Fehler beim Abschluss
        validationResults: null,         // Validierungsergebnisse
        testResults: null,               // Testergebnisse
        submissionAttempts: 0,           // Anzahl der Abschlussversuche
        currentSessionId: null,          // Aktuelle Sitzungs-ID
        isRedirecting: false,            // Weiterleitung aktiv
        timeSpent: 0,                    // Gesamtzeit im Test in Sekunden
        interactionsCount: 0,            // Anzahl der Interaktionen
        completedSteps: []               // Abgeschlossene Schritte des Abschlussprozesses
    },
    
    /**
     * Initialisiert den Testabschluss-Prozess
     * @param {string} sessionId - ID der Testsitzung
     */
    initialize: function(sessionId) {
        this.state.currentSessionId = sessionId;
        this.state.hasBeenSubmitted = false;
        this.state.submissionError = null;
        
        // Event-Listener für den Abschluss-Button einrichten
        this.setupSubmitButtonListeners();
        
        console.log('Testabschluss-Prozess initialisiert');
    },
    
    /**
     * Richtet Event-Listener für den Abschluss-Button ein
     */
    setupSubmitButtonListeners: function() {
        // Bestehenden Button finden oder neu erstellen
        let submitButton = document.querySelector('.finish-button');
        
        if (!submitButton) {
            // Falls Button noch nicht im DOM vorhanden
            submitButton = document.querySelector('.next-button');
            
            if (submitButton && app.testNavigation.state.currentQuestionIndex === app.testNavigation.state.questionIds.length - 1) {
                // Weiter-Button durch Abschluss-Button ersetzen
                const rightSection = submitButton.parentNode;
                
                // Weiter-Button entfernen
                submitButton.remove();
                
                // Abschluss-Button erstellen
                submitButton = document.createElement('button');
                submitButton.className = 'nav-button finish-button';
                submitButton.innerHTML = `${this.config.ui.completionButtonText} <i class="fa fa-check"></i>`;
                submitButton.setAttribute('aria-label', this.config.ui.completionButtonText);
                
                rightSection.appendChild(submitButton);
            }
        }
        
        if (submitButton) {
            // Event-Listener hinzufügen, falls noch nicht vorhanden
            if (!submitButton.hasSubmitListener) {
                submitButton.addEventListener('click', () => {
                    this.initiateTestSubmission();
                });
                submitButton.hasSubmitListener = true;
            }
        }
    },
    
    /**
     * Startet den Abschlussprozess
     */
    initiateTestSubmission: function() {
        // Prüfen, ob der Test bereits abgeschlossen wurde
        if (this.state.hasBeenSubmitted) {
            console.warn('Der Test wurde bereits abgeschlossen');
            return;
        }
        
        // Prüfen, ob bereits ein Abschluss läuft
        if (this.state.isSubmitting) {
            console.warn('Abschlussprozess läuft bereits');
            return;
        }
        
        // Validierung durchführen
        const validationResults = this.validateBeforeSubmission();
        this.state.validationResults = validationResults;
        
        // Bei schwerwiegenden Validierungsproblemen abbrechen
        if (validationResults.criticalErrors.length > 0) {
            this.handleValidationErrors(validationResults.criticalErrors);
            return;
        }
        
        // Warnung bei unbeantworteten Fragen, falls konfiguriert
        if (validationResults.unansweredQuestions.length > 0 && this.config.validation.warnAboutUnanswered) {
            const confirmContinue = confirm(this.config.ui.unansweredQuestionsMessage);
            if (!confirmContinue) {
                return;
            }
        }
        
        // Abschließende Bestätigung
        if (this.config.validation.finalConfirmation) {
            const confirmSubmission = confirm(this.config.ui.confirmationMessage);
            if (!confirmSubmission) {
                return;
            }
        }
        
        // Abschluss starten
        this.submitTest();
    },
    
    /**
     * Validiert den Test vor dem Abschluss
     * @returns {Object} Validierungsergebnisse
     */
    validateBeforeSubmission: function() {
        const sessionId = this.state.currentSessionId;
        if (!sessionId) {
            return {
                isValid: false,
                criticalErrors: ['Keine aktive Testsitzung gefunden'],
                unansweredQuestions: [],
                warnings: []
            };
        }
        
        // Session und Fragen abrufen
        const session = app.testSessionManager.getSession(sessionId);
        if (!session) {
            return {
                isValid: false,
                criticalErrors: [`Keine Testsitzung mit ID ${sessionId} gefunden`],
                unansweredQuestions: [],
                warnings: []
            };
        }
        
        const questions = session.testData.questions || {};
        const questionIds = Object.keys(questions);
        const answers = session.answers || {};
        
        // Ergebnisstruktur initialisieren
        const results = {
            isValid: true,
            criticalErrors: [],
            unansweredQuestions: [],
            warnings: []
        };
        
        // Kritische Fehler prüfen
        if (questionIds.length === 0) {
            results.criticalErrors.push('Keine Fragen im Test gefunden');
            results.isValid = false;
        }
        
        if (this.config.validation.requireAllQuestions) {
            // Prüfen, ob alle Fragen beantwortet wurden
            questionIds.forEach(questionId => {
                if (!answers[questionId]) {
                    results.unansweredQuestions.push(questionId);
                }
            });
            
            if (results.unansweredQuestions.length > 0) {
                if (this.config.validation.requireAllQuestions) {
                    results.criticalErrors.push(`Es müssen alle Fragen beantwortet werden. Noch ${results.unansweredQuestions.length} Fragen offen.`);
                    results.isValid = false;
                }
            }
        } else {
            // Nur zählen, welche Fragen unbeantwortet sind
            questionIds.forEach(questionId => {
                if (!answers[questionId]) {
                    results.unansweredQuestions.push(questionId);
                }
            });
        }
        
        // Auf Inkonsistenzen prüfen
        if (this.config.validation.checkInconsistencies) {
            // Prüfen, ob die Antworten den Fragetypen entsprechen
            Object.entries(answers).forEach(([questionId, answer]) => {
                const question = questions[questionId];
                
                // Prüfen, ob die Frage existiert
                if (!question) {
                    results.warnings.push(`Antwort für nicht existierende Frage ${questionId} gefunden`);
                    return;
                }
                
                // Typvalidierung
                const isValid = this.validateAnswerType(answer, question.type);
                if (!isValid) {
                    results.warnings.push(`Ungültiger Antworttyp für Frage ${questionId}`);
                }
            });
        }
        
        return results;
    },
    
    /**
     * Validiert den Typ einer Antwort
     * @param {Object} answer - Antwort-Objekt
     * @param {string} questionType - Fragetyp
     * @returns {boolean} Ob der Antworttyp gültig ist
     */
    validateAnswerType: function(answer, questionType) {
        if (!answer || !answer.value) return false;
        
        switch (questionType) {
            case 'multiple-choice':
                return Array.isArray(answer.value);
                
            case 'single-choice':
                return typeof answer.value === 'string' || typeof answer.value === 'number';
                
            case 'true-false':
                return typeof answer.value === 'boolean';
                
            case 'free-text':
                return typeof answer.value === 'string';
                
            default:
                return true; // Unbekannte Typen durchlassen
        }
    },
    
    /**
     * Zeigt Validierungsfehler an und bietet Lösungswege
     * @param {string[]} errors - Liste der Fehlermeldungen
     */
    handleValidationErrors: function(errors) {
        // Prüfen, ob Fehler vorhanden sind
        if (!errors || errors.length === 0) return;
        
        // Fehlertext vorbereiten
        let errorMessage = `${this.config.ui.errorHeading}\n\n`;
        errorMessage += errors.join('\n');
        
        // Fehlermeldung anzeigen
        alert(errorMessage);
        
        // Wenn unbearbeitete Fragen das Problem sind, Optionen anbieten
        if (errors.some(error => error.includes('Fragen'))) {
            // Optional: Zur ersten unbeantworteten Frage navigieren
            const firstUnanswered = this.state.validationResults.unansweredQuestions[0];
            if (firstUnanswered) {
                const confirmNavigation = confirm('Möchtest du zur ersten unbeantworteten Frage navigieren?');
                if (confirmNavigation) {
                    app.testNavigation.navigateToQuestion(firstUnanswered, 'direct');
                }
            }
        }
    },
    
    /**
     * Schließt den Test ab
     */
    submitTest: function() {
        try {
            // Abschlussstatus setzen
            this.state.isSubmitting = true;
            this.state.submissionStartTime = Date.now();
            this.state.submissionAttempts++;
            
            // Ladeanzeige anzeigen
            if (this.config.submission.showLoadingIndicator) {
                this.showLoadingIndicator();
            }
            
            // Automatisches Speichern aller Antworten
            if (this.config.submission.autoSave && app.answerStorage && app.answerStorage.interface && app.answerStorage.interface.saveAllAnswers) {
                app.answerStorage.interface.saveAllAnswers()
                    .then(() => {
                        this.processSubmission();
                    })
                    .catch(error => {
                        console.error('Fehler beim Speichern aller Antworten:', error);
                        this.handleSubmissionError(error);
                    });
            } else {
                // Direkt weiter, wenn kein Auto-Save
                this.processSubmission();
            }
        } catch (error) {
            console.error('Fehler beim Testabschluss:', error);
            this.handleSubmissionError(error);
        }
    },
    
    /**
     * Verarbeitet den eigentlichen Abschluss nach dem Speichern
     */
    processSubmission: function() {
        const sessionId = this.state.currentSessionId;
        
        // Test als abgeschlossen markieren
        app.testSessionManager.completeSession(sessionId);
        
        // Test-Abschluss-Event auslösen
        const submitEvent = new CustomEvent('testSubmitted', {
            detail: {
                sessionId: sessionId,
                timestamp: Date.now()
            }
        });
        document.dispatchEvent(submitEvent);
        
        // Statistik-Informationen sammeln
        this.collectTestStatistics();
        
        // Auf Ergebnisse warten
        this.waitForTestResults();
    },
    
    /**
     * Sammelt statistische Informationen über den Test
     */
    collectTestStatistics: function() {
        try {
            const sessionId = this.state.currentSessionId;
            const session = app.testSessionManager.getSession(sessionId);
            
            if (!session) return;
            
            // Verbrachte Zeit berechnen
            const startTime = session.startTimestamp || 0;
            const endTime = Date.now();
            this.state.timeSpent = Math.floor((endTime - startTime) / 1000); // in Sekunden
            
            // Interaktionen zählen, falls Fragenbesuche getrackt wurden
            if (app.testNavigation && app.testNavigation.state) {
                this.state.interactionsCount = app.testNavigation.state.navigationHistory.length || 0;
            }
            
            // Weitere Statistiken könnten hier gesammelt werden, z.B. aus dem answerStorage
            
            console.log('Teststatistiken gesammelt:', {
                timeSpent: this.state.timeSpent,
                interactionsCount: this.state.interactionsCount
            });
        } catch (error) {
            console.error('Fehler beim Sammeln der Teststatistiken:', error);
        }
    },
    
    /**
     * Wartet auf die Ergebnisse des Tests
     */
    waitForTestResults: function() {
        // Timeout für den Fall, dass keine Ergebnisse kommen
        const timeout = setTimeout(() => {
            if (this.state.isSubmitting && !this.state.testResults) {
                console.warn('Zeitüberschreitung beim Warten auf Testergebnisse');
                this.handleSubmissionError(new Error('Zeitüberschreitung beim Warten auf Testergebnisse'));
            }
        }, this.config.submission.submissionTimeout);
        
        // Event-Listener für Ergebnisse
        const resultListener = (event) => {
            clearTimeout(timeout);
            
            const results = event.detail;
            this.state.testResults = results;
            this.state.isSubmitting = false;
            this.state.hasBeenSubmitted = true;
            this.state.completedSteps.push('resultsReceived');
            
            // Ergebnisse verarbeiten
            this.processTestResults(results);
            
            // Listener entfernen
            document.removeEventListener('testResultsReady', resultListener);
        };
        
        // Auf Ergebnis-Event warten
        document.addEventListener('testResultsReady', resultListener);
    },
    
    /**
     * Verarbeitet die Testergebnisse
     * @param {Object} results - Ergebnisse des Tests
     */
    processTestResults: function(results) {
        try {
            // Ladeanzeige entfernen
            this.hideLoadingIndicator();
            
            // Ergebnisse formatieren und aufbereiten
            const formattedResults = this.formatTestResults(results);
            
            // Ergebnisanzeige starten
            if (this.config.results.showImmediately) {
                this.transitionToResultsScreen(formattedResults);
            } else if (this.config.results.redirectAfterSubmission && this.config.results.redirectUrl) {
                // Weiterleitung vorbereiten
                this.prepareRedirect();
            }
            
            // Abschluss-Event auslösen
            const completionEvent = new CustomEvent('testCompleted', {
                detail: {
                    sessionId: this.state.currentSessionId,
                    results: formattedResults,
                    statistics: {
                        timeSpent: this.state.timeSpent,
                        interactionsCount: this.state.interactionsCount
                    }
                }
            });
            document.dispatchEvent(completionEvent);
            
            console.log('Test erfolgreich abgeschlossen:', formattedResults);
        } catch (error) {
            console.error('Fehler bei der Verarbeitung der Testergebnisse:', error);
            this.handleSubmissionError(error);
        }
    },
    
    /**
     * Formatiert die Testergebnisse für die Anzeige
     * @param {Object} results - Rohergebnisse
     * @returns {Object} Formatierte Ergebnisse
     */
    formatTestResults: function(results) {
        // Basis-Ergebnisstruktur
        const formattedResults = {
            summary: {
                totalQuestions: results.totalQuestions || 0,
                answeredQuestions: results.answeredQuestions || 0,
                correctAnswers: results.correctAnswers || 0,
                incorrectAnswers: results.incorrectAnswers || 0,
                partiallyCorrectAnswers: results.partiallyCorrectAnswers || 0,
                totalScore: results.totalScore || 0,
                maxPossibleScore: results.maxPossibleScore || 0,
                percentageScore: results.percentageScore || 0,
                isPassed: results.isPassed || false,
                timeSpent: this.formatTimeSpent(this.state.timeSpent)
            },
            details: {},
            feedback: this.generateFeedback(results)
        };
        
        // Detaillierte Ergebnisse je nach Verfügbarkeit hinzufügen
        if (results.questionResults) {
            formattedResults.details.questions = results.questionResults;
        }
        
        if (results.categoryResults) {
            formattedResults.details.categories = results.categoryResults;
        }
        
        return formattedResults;
    },
    
    /**
     * Formatiert die verbrachte Zeit in ein lesbares Format
     * @param {number} timeInSeconds - Zeit in Sekunden
     * @returns {string} Formatierte Zeit
     */
    formatTimeSpent: function(timeInSeconds) {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        const seconds = timeInSeconds % 60;
        
        let formattedTime = '';
        
        if (hours > 0) {
            formattedTime += `${hours} Std. `;
        }
        
        if (minutes > 0 || hours > 0) {
            formattedTime += `${minutes} Min. `;
        }
        
        formattedTime += `${seconds} Sek.`;
        
        return formattedTime;
    },
    
    /**
     * Generiert Feedback basierend auf den Testergebnissen
     * @param {Object} results - Testergebnisse
     * @returns {Object} Feedback
     */
    generateFeedback: function(results) {
        const feedback = {
            overallFeedback: '',
            strengthsAndWeaknesses: [],
            recommendations: []
        };
        
        // Gesamtbewertung basierend auf Punktzahl
        const percentageScore = results.percentageScore || 0;
        
        if (percentageScore >= 90) {
            feedback.overallFeedback = 'Hervorragend! Du beherrscht diesen Themenbereich ausgezeichnet.';
            feedback.recommendations.push('Betrachte fortgeschrittene Konzepte in diesem Bereich.');
            feedback.recommendations.push('Versuche, dein Wissen in der Praxis anzuwenden.');
        } else if (percentageScore >= 80) {
            feedback.overallFeedback = 'Sehr gut! Du hast ein solides Verständnis gezeigt.';
            feedback.recommendations.push('Konzentriere dich auf die wenigen Bereiche, in denen du noch Fehler gemacht hast.');
        } else if (percentageScore >= 70) {
            feedback.overallFeedback = 'Gut! Du hast die meisten Konzepte gut verstanden.';
            feedback.recommendations.push('Vertiefe dein Wissen in den Bereichen, wo du unsicher warst.');
        } else if (percentageScore >= 60) {
            feedback.overallFeedback = 'Okay. Du hast ein grundlegendes Verständnis gezeigt, aber es gibt noch Raum für Verbesserung.';
            feedback.recommendations.push('Wiederhole die Kernkonzepte und übe mehr.');
        } else if (percentageScore >= 50) {
            feedback.overallFeedback = 'Du hast bestanden, aber es gibt noch viel Verbesserungspotential.';
            feedback.recommendations.push('Arbeite an deinem grundlegenden Verständnis und versuche, die Kernkonzepte zu festigen.');
        } else {
            feedback.overallFeedback = 'Du solltest diesen Themenbereich nochmals vertiefen.';
            feedback.recommendations.push('Versuche, die Grundlagen besser zu verstehen, bevor du fortfährst.');
            feedback.recommendations.push('Nimm dir mehr Zeit zum Lernen und versuche es erneut.');
        }
        
        // Stärken und Schwächen basierend auf Kategorien identifizieren
        if (results.categoryResults) {
            const categories = Object.entries(results.categoryResults);
            
            // Stärken (Kategorien mit höchster Punktzahl)
            categories.sort((a, b) => b[1].percentageScore - a[1].percentageScore);
            
            if (categories.length > 0 && categories[0][1].percentageScore > 70) {
                feedback.strengthsAndWeaknesses.push(`Stärke: ${categories[0][0]} (${categories[0][1].percentageScore}%)`);
            }
            
            // Schwächen (Kategorien mit niedrigster Punktzahl)
            categories.sort((a, b) => a[1].percentageScore - b[1].percentageScore);
            
            if (categories.length > 0 && categories[0][1].percentageScore < 70) {
                feedback.strengthsAndWeaknesses.push(`Verbesserungsbedarf: ${categories[0][0]} (${categories[0][1].percentageScore}%)`);
            }
        }
        
        return feedback;
    },
    
    /**
     * Zeigt eine Ladeanzeige während des Abschlusses an
     */
    showLoadingIndicator: function() {
        // Prüfen, ob bereits eine Ladeanzeige vorhanden ist
        if (document.getElementById('test-completion-overlay')) return;
        
        // Overlay erstellen
        const overlay = document.createElement('div');
        overlay.id = 'test-completion-overlay';
        overlay.className = 'test-completion-overlay';
        
        // Inhalt mit Ladeanimation
        overlay.innerHTML = `
            <div class="completion-loading-container">
                <div class="completion-spinner"></div>
                <h3>${this.config.ui.loadingText}</h3>
                <p class="completion-status">Deine Antworten werden ausgewertet...</p>
            </div>
        `;
        
        // Zum DOM hinzufügen
        document.body.appendChild(overlay);
        
        // CSS für die Ladeanzeige
        const style = document.createElement('style');
        style.textContent = `
            .test-completion-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }
            
            .completion-loading-container {
                background-color: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
                text-align: center;
                max-width: 80%;
            }
            
            .completion-loading-container h3 {
                margin-top: 20px;
                color: #333;
            }
            
            .completion-status {
                color: #666;
                margin-top: 10px;
            }
            
            .completion-spinner {
                display: inline-block;
                width: 50px;
                height: 50px;
                border: 5px solid rgba(0, 255, 208, 0.3);
                border-radius: 50%;
                border-top-color: #00FFD0;
                animation: spin 1s ease-in-out infinite;
            }
            
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
        `;
        
        document.head.appendChild(style);
        
        // Status-Updates für längere Ladezeiten
        let statusElement = overlay.querySelector('.completion-status');
        if (statusElement) {
            let statusMessages = [
                'Deine Antworten werden analysiert...',
                'Punktzahl wird berechnet...',
                'Feedback wird erstellt...',
                'Fast fertig...'
            ];
            
            let messageIndex = 0;
            this.loadingStatusInterval = setInterval(() => {
                messageIndex = (messageIndex + 1) % statusMessages.length;
                statusElement.textContent = statusMessages[messageIndex];
            }, 3000);
        }
    },
    
    /**
     * Entfernt die Ladeanzeige
     */
    hideLoadingIndicator: function() {
        const overlay = document.getElementById('test-completion-overlay');
        if (overlay) {
            // Animation zum Ausblenden
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 0.5s ease';
            
            // Nach Animation entfernen
            setTimeout(() => {
                overlay.remove();
            }, 500);
        }
        
        // Status-Update-Interval stoppen
        if (this.loadingStatusInterval) {
            clearInterval(this.loadingStatusInterval);
            this.loadingStatusInterval = null;
        }
    },
    
    /**
     * Behandelt Fehler beim Abschluss
     * @param {Error} error - Aufgetretener Fehler
     */
    handleSubmissionError: function(error) {
        // Ladeanzeige entfernen
        this.hideLoadingIndicator();
        
        // Fehler speichern
        this.state.submissionError = error;
        this.state.isSubmitting = false;
        
        // Fehlermeldung im Dialog anzeigen
        const errorDialog = document.createElement('div');
        errorDialog.className = 'error-dialog-overlay';
        
        errorDialog.innerHTML = `
            <div class="error-dialog">
                <h3>${this.config.ui.errorHeading}</h3>
                <p class="error-message">${error.message || 'Unbekannter Fehler beim Abschließen des Tests'}</p>
                <div class="error-buttons">
                    <button class="secondary-button retry-button">${this.config.ui.retryButtonText}</button>
                    <button class="primary-button continue-button">${this.config.ui.continueButtonText}</button>
                </div>
            </div>
        `;
        
        // Zum DOM hinzufügen
        document.body.appendChild(errorDialog);
        
        // CSS für den Fehlerdialog
        const style = document.createElement('style');
        style.textContent = `
            .error-dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }
            
            .error-dialog {
                background-color: white;
                padding: 20px 30px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                max-width: 80%;
                text-align: center;
            }
            
            .error-dialog h3 {
                color: #ff3b30;
                margin-top: 0;
            }
            
            .error-message {
                margin: 20px 0;
                color: #333;
            }
            
            .error-buttons {
                display: flex;
                justify-content: center;
                gap: 15px;
                margin-top: 20px;
            }
            
            .primary-button, .secondary-button {
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                border: none;
            }
            
            .primary-button {
                background-color: #00FFD0;
                color: #333;
            }
            
            .secondary-button {
                background-color: #f0f0f0;
                color: #333;
            }
        `;
        
        document.head.appendChild(style);
        
        // Event-Listener für Buttons
        const retryButton = errorDialog.querySelector('.retry-button');
        if (retryButton) {
            retryButton.addEventListener('click', () => {
                errorDialog.remove();
                this.submitTest(); // Erneut versuchen
            });
        }
        
        const continueButton = errorDialog.querySelector('.continue-button');
        if (continueButton) {
            continueButton.addEventListener('click', () => {
                errorDialog.remove();
                // Trotz Fehler zu den Ergebnissen (falls vorhanden)
                if (this.state.testResults) {
                    this.transitionToResultsScreen(this.formatTestResults(this.state.testResults));
                } else {
                    // Fallback: leere Ergebnisse anzeigen
                    const emptyResults = {
                        summary: {
                            totalQuestions: 0,
                            answeredQuestions: 0,
                            correctAnswers: 0,
                            incorrectAnswers: 0,
                            totalScore: 0,
                            maxPossibleScore: 0,
                            percentageScore: 0,
                            isPassed: false,
                            timeSpent: this.formatTimeSpent(this.state.timeSpent)
                        },
                        details: {},
                        feedback: {
                            overallFeedback: 'Aufgrund eines Fehlers konnten deine Ergebnisse nicht vollständig ausgewertet werden.'
                        }
                    };
                    this.transitionToResultsScreen(emptyResults);
                }
            });
        }
        
        // Fehlerereignis auslösen
        const errorEvent = new CustomEvent('testSubmissionError', {
            detail: {
                error: error,
                sessionId: this.state.currentSessionId,
                attempts: this.state.submissionAttempts
            }
        });
        document.dispatchEvent(errorEvent);
    },
    
    /**
     * Bereitet die Weiterleitung nach dem Abschluss vor
     */
    prepareRedirect: function() {
        if (!this.config.results.redirectUrl) return;
        
        // Status setzen
        this.state.isRedirecting = true;
        
        // Weiterleitungshinweis anzeigen
        const redirectNotice = document.createElement('div');
        redirectNotice.className = 'redirect-notice';
        redirectNotice.innerHTML = `
            <p>Du wirst in <span class="redirect-countdown">3</span> Sekunden weitergeleitet...</p>
            <button class="redirect-now-btn">Jetzt weiterleiten</button>
        `;
        
        // Zum DOM hinzufügen
        document.body.appendChild(redirectNotice);
        
        // CSS für den Hinweis
        const style = document.createElement('style');
        style.textContent = `
            .redirect-notice {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background-color: #333;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                display: flex;
                align-items: center;
                gap: 15px;
                z-index: 1000;
            }
            
            .redirect-notice p {
                margin: 0;
            }
            
            .redirect-countdown {
                font-weight: bold;
            }
            
            .redirect-now-btn {
                background-color: #00FFD0;
                color: #333;
                border: none;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            }
        `;
        
        document.head.appendChild(style);
        
        // Countdown starten
        let secondsLeft = 3;
        const countdownElement = redirectNotice.querySelector('.redirect-countdown');
        
        const countdownInterval = setInterval(() => {
            secondsLeft--;
            if (countdownElement) {
                countdownElement.textContent = secondsLeft;
            }
            
            if (secondsLeft <= 0) {
                clearInterval(countdownInterval);
                this.redirectToResultsPage();
            }
        }, 1000);
        
        // Event-Listener für sofortige Weiterleitung
        const redirectButton = redirectNotice.querySelector('.redirect-now-btn');
        if (redirectButton) {
            redirectButton.addEventListener('click', () => {
                clearInterval(countdownInterval);
                this.redirectToResultsPage();
            });
        }
    },
    
    /**
     * Leitet zur Ergebnisseite weiter
     */
    redirectToResultsPage: function() {
        if (!this.config.results.redirectUrl) return;
        
        // Umleiten zur Ergebnisseite
        window.location.href = this.config.results.redirectUrl;
    },
    
    /**
     * Wechselt zur Ergebnisanzeige
     * @param {Object} results - Formatierte Ergebnisse
     */
    transitionToResultsScreen: function(results) {
        try {
            // Testumgebung-Container abrufen
            const testContainer = document.getElementById('test-container');
            if (!testContainer) return;
            
            // Navigationsleiste ausblenden
            const navBar = document.querySelector('.test-navigation-bar');
            if (navBar) {
                navBar.style.display = 'none';
            }
            
            // Fortschrittsanzeige ausblenden
            const progressContainer = document.getElementById('test-progress-container');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
            
            // Fragen ausblenden
            const questionContainers = document.querySelectorAll('.question-container');
            questionContainers.forEach(container => {
                container.style.display = 'none';
            });
            
            // Ergebnisanzeige erstellen und anzeigen
            this.renderResultsScreen(testContainer, results);
            
            // Event auslösen
            const event = new CustomEvent('resultsScreenRendered', {
                detail: {
                    results: results
                }
            });
            document.dispatchEvent(event);
        } catch (error) {
            console.error('Fehler beim Übergang zur Ergebnisanzeige:', error);
        }
    },
    
    /**
     * Rendert die Ergebnisanzeige
     * @param {HTMLElement} container - Container für die Ergebnisanzeige
     * @param {Object} results - Formatierte Ergebnisse
     */
    renderResultsScreen: function(container, results) {
        // Vorhandene Inhalte entfernen
        container.innerHTML = '';
        
        // Ergebnis-Container erstellen
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'test-results-container';
        
        // Header mit Zusammenfassung
        const header = document.createElement('div');
        header.className = 'results-header';
        
        // Text für Bestanden/Nicht-Bestanden
        const passStatus = results.summary.isPassed 
            ? '<span class="pass-status pass">Bestanden</span>' 
            : '<span class="pass-status fail">Nicht bestanden</span>';
        
        header.innerHTML = `
            <h2>Deine Testergebnisse ${passStatus}</h2>
            <div class="score-summary">
                <div class="score-circle">
                    <svg viewBox="0 0 100 100" class="score-circle-svg">
                        <circle cx="50" cy="50" r="45" fill="none" stroke="#eee" stroke-width="5" />
                        <circle cx="50" cy="50" r="45" fill="none" stroke="#00FFD0" stroke-width="5" 
                                stroke-dasharray="${2 * Math.PI * 45}" 
                                stroke-dashoffset="${2 * Math.PI * 45 * (1 - results.summary.percentageScore / 100)}" 
                                transform="rotate(-90 50 50)" />
                    </svg>
                    <div class="score-text">
                        <span class="score-percentage">${Math.round(results.summary.percentageScore)}%</span>
                    </div>
                </div>
                <div class="score-details">
                    <div class="score-item">
                        <span class="score-label">Punktzahl:</span>
                        <span class="score-value">${results.summary.totalScore} / ${results.summary.maxPossibleScore}</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Richtige Antworten:</span>
                        <span class="score-value">${results.summary.correctAnswers} von ${results.summary.totalQuestions}</span>
                    </div>
                    <div class="score-item">
                        <span class="score-label">Benötigte Zeit:</span>
                        <span class="score-value">${results.summary.timeSpent}</span>
                    </div>
                </div>
            </div>
        `;
        
        // Feedback-Sektion
        const feedback = document.createElement('div');
        feedback.className = 'results-feedback';
        feedback.innerHTML = `
            <h3>Dein persönliches Feedback</h3>
            <p class="overall-feedback">${results.feedback.overallFeedback}</p>
        `;
        
        // Stärken und Schwächen hinzufügen, falls vorhanden
        if (results.feedback.strengthsAndWeaknesses && results.feedback.strengthsAndWeaknesses.length > 0) {
            const strengthsWeaknessesList = document.createElement('ul');
            strengthsWeaknessesList.className = 'strengths-weaknesses-list';
            
            results.feedback.strengthsAndWeaknesses.forEach(item => {
                const listItem = document.createElement('li');
                listItem.textContent = item;
                strengthsWeaknessesList.appendChild(listItem);
            });
            
            feedback.appendChild(strengthsWeaknessesList);
        }
        
        // Empfehlungen hinzufügen, falls vorhanden
        if (results.feedback.recommendations && results.feedback.recommendations.length > 0) {
            const recommendationsSection = document.createElement('div');
            recommendationsSection.className = 'recommendations-section';
            recommendationsSection.innerHTML = `<h4>Empfehlungen:</h4>`;
            
            const recommendationsList = document.createElement('ul');
            recommendationsList.className = 'recommendations-list';
            
            results.feedback.recommendations.forEach(item => {
                const listItem = document.createElement('li');
                listItem.textContent = item;
                recommendationsList.appendChild(listItem);
            });
            
            recommendationsSection.appendChild(recommendationsList);
            feedback.appendChild(recommendationsSection);
        }
        
        // Aktionen-Bereich
        const actions = document.createElement('div');
        actions.className = 'results-actions';
        actions.innerHTML = `
            <button class="print-results-btn"><i class="fa fa-print"></i> Ergebnisse drucken</button>
            <a href="#" class="return-btn"><i class="fa fa-home"></i> Zurück zum Dashboard</a>
        `;
        
        // Alles zusammenfügen
        resultsContainer.appendChild(header);
        resultsContainer.appendChild(feedback);
        resultsContainer.appendChild(actions);
        container.appendChild(resultsContainer);
        
        // Event-Listener für Buttons
        const printButton = actions.querySelector('.print-results-btn');
        if (printButton) {
            printButton.addEventListener('click', () => {
                window.print();
            });
        }
        
        const returnButton = actions.querySelector('.return-btn');
        if (returnButton) {
            returnButton.addEventListener('click', (e) => {
                e.preventDefault();
                window.location.href = 'dashboard.html'; // Oder eine andere geeignete URL
            });
        }
        
        // CSS für die Ergebnisanzeige
        this.addResultsStyles();
    },
    
    /**
     * Fügt CSS-Stile für die Ergebnisanzeige hinzu
     */
    addResultsStyles: function() {
        // Prüfen, ob Stile bereits hinzugefügt wurden
        if (document.getElementById('test-results-styles')) return;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'test-results-styles';
        
        styleElement.textContent = `
            .test-results-container {
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            }
            
            .results-header {
                text-align: center;
                margin-bottom: 30px;
            }
            
            .results-header h2 {
                color: #333;
                margin-bottom: 20px;
            }
            
            .pass-status {
                display: inline-block;
                padding: 3px 10px;
                border-radius: 15px;
                font-size: 0.8em;
                margin-left: 10px;
            }
            
            .pass-status.pass {
                background-color: #34C759;
                color: white;
            }
            
            .pass-status.fail {
                background-color: #FF3B30;
                color: white;
            }
            
            .score-summary {
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 30px;
                flex-wrap: wrap;
                gap: 30px;
            }
            
            .score-circle {
                position: relative;
                width: 150px;
                height: 150px;
            }
            
            .score-circle-svg {
                width: 100%;
                height: 100%;
                transform: rotate(-90deg);
            }
            
            .score-text {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            
            .score-percentage {
                font-size: 2.5em;
                font-weight: bold;
                color: #333;
            }
            
            .score-details {
                min-width: 250px;
            }
            
            .score-item {
                display: flex;
                justify-content: space-between;
                margin-bottom: 10px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }
            
            .score-label {
                color: #666;
            }
            
            .score-value {
                font-weight: bold;
                color: #333;
            }
            
            .results-feedback {
                margin-bottom: 30px;
                padding: 20px;
                background-color: #f9f9f9;
                border-radius: 8px;
            }
            
            .results-feedback h3 {
                color: #333;
                margin-top: 0;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #00FFD0;
            }
            
            .overall-feedback {
                font-size: 1.1em;
                margin-bottom: 20px;
            }
            
            .strengths-weaknesses-list, .recommendations-list {
                padding-left: 20px;
            }
            
            .strengths-weaknesses-list li, .recommendations-list li {
                margin-bottom: 8px;
            }
            
            .recommendations-section h4 {
                margin-bottom: 10px;
                color: #333;
            }
            
            .results-actions {
                display: flex;
                justify-content: space-around;
                margin-top: 30px;
                flex-wrap: wrap;
                gap: 15px;
            }
            
            .print-results-btn, .return-btn {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
                font-weight: bold;
                cursor: pointer;
                text-decoration: none;
                transition: background-color 0.2s;
            }
            
            .print-results-btn {
                background-color: #00FFD0;
                color: #333;
            }
            
            .print-results-btn:hover {
                background-color: #00e6bd;
            }
            
            .return-btn {
                background-color: #f0f0f0;
                color: #333;
            }
            
            .return-btn:hover {
                background-color: #e0e0e0;
            }
            
            /* Print-Optimierungen */
            @media print {
                body * {
                    visibility: hidden;
                }
                
                .test-results-container, .test-results-container * {
                    visibility: visible;
                }
                
                .test-results-container {
                    position: absolute;
                    left: 0;
                    top: 0;
                    width: 100%;
                    box-shadow: none;
                }
                
                .results-actions {
                    display: none;
                }
            }
            
            /* Responsive Anpassungen */
            @media (max-width: 768px) {
                .score-summary {
                    flex-direction: column;
                }
                
                .score-details {
                    width: 100%;
                }
                
                .results-actions {
                    flex-direction: column;
                    align-items: center;
                }
                
                .print-results-btn, .return-btn {
                    width: 100%;
                    justify-content: center;
                }
            }
        `;
        
        document.head.appendChild(styleElement);
    }
};

// Event-Handler für Testabschluss-Ereignisse
(function() {
    // Initialisierung beim Laden der Testseite
    document.addEventListener('testPageLoaded', function(event) {
        const sessionId = event.detail.sessionId;
        
        if (sessionId) {
            app.testCompletion.initialize(sessionId);
        }
    });
    
    // Abschluss-Button aktualisieren, wenn die letzte Frage erreicht wird
    document.addEventListener('questionChanged', function(event) {
        // Abschluss-Button aktualisieren, falls letzte Frage
        if (app.testNavigation && 
            app.testNavigation.state.currentQuestionIndex === app.testNavigation.state.questionIds.length - 1) {
            app.testCompletion.setupSubmitButtonListeners();
        }
    });
    
    console.log('Testabschluss-Prozess (Teil 1) initialisiert');
})();

// Öffentliche Schnittstelle exportieren
app.testCompletion.interface = {
    initialize: app.testCompletion.initialize.bind(app.testCompletion),
    initiateTestSubmission: app.testCompletion.initiateTestSubmission.bind(app.testCompletion)
};
/**
 * JS-Block 5.8.1-part2: Abschlussverarbeitung (Teil 2)
 * Erweiterte Funktionen für die Testabschlussverarbeitung
 */
(function() {
    // Namespace sicherstellen
    if (!app.testCompletion) {
        app.testCompletion = {};
    }

    // Ergebnisverarbeitung und erweiterte Funktionalitäten
    
    /**
     * Generiert detaillierte Leistungsstatistiken aus Testdaten
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     * @return {Object} - Aufbereitete Statistiken
     */
    app.testCompletion.generatePerformanceStatistics = function(testData) {
        console.log('Generiere Leistungsstatistiken aus Testdaten:', testData);
        
        const statistics = {
            timePerQuestion: {},
            categoryPerformance: {},
            difficultyDistribution: {},
            answeredCorrectly: 0,
            answeredIncorrectly: 0,
            skipped: 0,
            changeCount: {} // Wie oft wurde die Antwort geändert?
        };
        
        try {
            // Verarbeite die Testdaten für jede Frage
            Object.keys(testData.answers || {}).forEach(questionId => {
                const questionData = app.testSession.getQuestionById(questionId);
                const answerData = testData.answers[questionId];
                
                if (!questionData) {
                    console.warn(`Keine Fragendaten für ID ${questionId} gefunden.`);
                    return;
                }
                
                // Zeit pro Frage berechnen
                if (answerData.timeSpent) {
                    statistics.timePerQuestion[questionId] = answerData.timeSpent;
                }
                
                // Kategorie-Performance aktualisieren
                const category = questionData.category || 'Allgemein';
                if (!statistics.categoryPerformance[category]) {
                    statistics.categoryPerformance[category] = {
                        total: 0,
                        correct: 0,
                        score: 0
                    };
                }
                statistics.categoryPerformance[category].total++;
                
                // Schwierigkeitsverteilung aktualisieren
                const difficulty = questionData.difficulty || 'Mittel';
                if (!statistics.difficultyDistribution[difficulty]) {
                    statistics.difficultyDistribution[difficulty] = {
                        total: 0,
                        correct: 0
                    };
                }
                statistics.difficultyDistribution[difficulty].total++;
                
                // Korrekte/Inkorrekte Antworten zählen
                if (answerData.isCorrect === true) {
                    statistics.answeredCorrectly++;
                    statistics.categoryPerformance[category].correct++;
                    statistics.difficultyDistribution[difficulty].correct++;
                } else if (answerData.isCorrect === false) {
                    statistics.answeredIncorrectly++;
                } else if (answerData.skipped) {
                    statistics.skipped++;
                }
                
                // Antwortänderungen zählen
                if (answerData.changeHistory && answerData.changeHistory.length) {
                    statistics.changeCount[questionId] = answerData.changeHistory.length;
                }
            });
            
            // Prozentsatz für jede Kategorie berechnen
            Object.keys(statistics.categoryPerformance).forEach(category => {
                const catData = statistics.categoryPerformance[category];
                catData.score = catData.total > 0 ? Math.round((catData.correct / catData.total) * 100) : 0;
            });
            
            console.log('Generierte Statistiken:', statistics);
            return statistics;
        } catch (error) {
            console.error('Fehler bei der Generierung von Statistiken:', error);
            return statistics;
        }
    };
	/**
     * Generiert personalisiertes Feedback basierend auf der Testleistung
     * @param {Object} result - Testergebnis und Statistiken
     * @return {Object} - Personalisiertes Feedback mit Tipps
     */
    app.testCompletion.generatePersonalizedFeedback = function(result) {
        console.log('Generiere personalisiertes Feedback basierend auf:', result);
        
        const feedback = {
            general: '',
            strengths: [],
            weaknesses: [],
            recommendations: []
        };
        
        try {
            const statistics = result.statistics || {};
            const scorePercentage = result.scorePercentage || 0;
            
            // Allgemeines Feedback basierend auf Gesamtpunktzahl
            if (scorePercentage >= 90) {
                feedback.general = 'Hervorragende Leistung! Sie beherrschen die Inhalte ausgezeichnet.';
            } else if (scorePercentage >= 75) {
                feedback.general = 'Sehr gute Leistung! Sie haben ein solides Verständnis der Inhalte.';
            } else if (scorePercentage >= 60) {
                feedback.general = 'Gute Leistung! Es gibt noch einige Bereiche, die Sie verbessern können.';
            } else if (scorePercentage >= 40) {
                feedback.general = 'Ausreichende Leistung. Es wird empfohlen, die schwächeren Bereiche zu wiederholen.';
            } else {
                feedback.general = 'Es besteht noch Verbesserungsbedarf. Eine Wiederholung der Inhalte wird dringend empfohlen.';
            }
            
            // Stärken und Schwächen basierend auf Kategorien identifizieren
            if (statistics.categoryPerformance) {
                const categories = Object.keys(statistics.categoryPerformance);
                
                // Stärken identifizieren (Kategorien mit >=75% Erfolg)
                categories.forEach(category => {
                    const catData = statistics.categoryPerformance[category];
                    if (catData.score >= 75 && catData.total >= 2) {
                        feedback.strengths.push({
                            category: category,
                            score: catData.score
                        });
                    }
                });
                
                // Schwächen identifizieren (Kategorien mit <60% Erfolg)
                categories.forEach(category => {
                    const catData = statistics.categoryPerformance[category];
                    if (catData.score < 60 && catData.total >= 2) {
                        feedback.weaknesses.push({
                            category: category,
                            score: catData.score
                        });
                    }
                });
            }
            
            // Empfehlungen basierend auf Schwächen generieren
            if (feedback.weaknesses.length > 0) {
                feedback.weaknesses.forEach(weakness => {
                    feedback.recommendations.push({
                        text: `Wiederholen Sie die Inhalte zum Thema "${weakness.category}" (${weakness.score}% korrekt).`,
                        category: weakness.category
                    });
                });
            } else if (scorePercentage < 75) {
                feedback.recommendations.push({
                    text: 'Wiederholen Sie die Inhalte zu den Fragen, die Sie falsch beantwortet haben.',
                    category: 'Allgemein'
                });
            }
            
            // Zeitmanagement-Feedback hinzufügen, falls verfügbar
            if (statistics.timePerQuestion && Object.keys(statistics.timePerQuestion).length > 0) {
                const times = Object.values(statistics.timePerQuestion);
                const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                
                if (maxTime > avgTime * 2) {
                    feedback.recommendations.push({
                        text: 'Bei einigen Fragen haben Sie überdurchschnittlich viel Zeit benötigt. Überlegen Sie, diese Themen zu wiederholen.',
                        category: 'Zeitmanagement'
                    });
                }
                
                if (minTime < avgTime * 0.3 && statistics.answeredIncorrectly > 0) {
                    feedback.recommendations.push({
                        text: 'Bei einigen Fragen haben Sie möglicherweise zu schnell geantwortet. Nehmen Sie sich bei schwierigen Fragen mehr Zeit.',
                        category: 'Zeitmanagement'
                    });
                }
            }
            
            console.log('Generiertes Feedback:', feedback);
            return feedback;
        } catch (error) {
            console.error('Fehler bei der Generierung des Feedbacks:', error);
            return feedback;
        }
    };
	/**
     * Rendert die Ergebnisansicht mit Statistiken und Feedback
     * @param {Object} result - Vollständiges Testergebnis mit Statistik und Feedback
     */
    app.testCompletion.renderDetailedResults = function(result) {
        console.log('Rendere detaillierte Ergebnisansicht:', result);
        
        const resultContainer = document.getElementById('test-results-detailed');
        if (!resultContainer) {
            console.error('Container für detaillierte Ergebnisse nicht gefunden.');
            return;
        }
        
        try {
            // Leere den Container
            resultContainer.innerHTML = '';
            
            // Hauptergebnisbereich erstellen
            const resultWrapper = document.createElement('div');
            resultWrapper.className = 'result-detailed-wrapper';
            
            // Überschrift hinzufügen
            const resultHeader = document.createElement('div');
            resultHeader.className = 'result-header';
            resultHeader.innerHTML = `
                <h2>Detaillierte Testergebnisse</h2>
                <p class="test-title">${result.testTitle || 'Test'}</p>
                <div class="result-summary">
                    <div class="result-score">${result.score} / ${result.maxScore} Punkte</div>
                    <div class="result-percentage">${result.scorePercentage}%</div>
                    <div class="result-status ${result.passed ? 'passed' : 'failed'}">
                        ${result.passed ? 'Bestanden' : 'Nicht bestanden'}
                    </div>
                </div>
            `;
            resultWrapper.appendChild(resultHeader);
            
            // Abschnitt für personalisiertes Feedback
            if (result.feedback) {
                const feedbackSection = document.createElement('div');
                feedbackSection.className = 'result-feedback-section';
                
                // Allgemeines Feedback
                const generalFeedback = document.createElement('div');
                generalFeedback.className = 'general-feedback';
                generalFeedback.innerHTML = `
                    <h3>Feedback</h3>
                    <p>${result.feedback.general}</p>
                `;
                feedbackSection.appendChild(generalFeedback);
                
                // Stärken auflisten, falls vorhanden
                if (result.feedback.strengths && result.feedback.strengths.length > 0) {
                    const strengthsEl = document.createElement('div');
                    strengthsEl.className = 'strengths-section';
                    strengthsEl.innerHTML = '<h3>Ihre Stärken</h3><ul></ul>';
                    
                    const strengthsList = strengthsEl.querySelector('ul');
                    result.feedback.strengths.forEach(strength => {
                        const li = document.createElement('li');
                        li.textContent = `${strength.category} (${strength.score}% korrekt)`;
                        strengthsList.appendChild(li);
                    });
                    
                    feedbackSection.appendChild(strengthsEl);
                }
                
                // Verbesserungspotentiale auflisten, falls vorhanden
                if (result.feedback.weaknesses && result.feedback.weaknesses.length > 0) {
                    const weaknessesEl = document.createElement('div');
                    weaknessesEl.className = 'weaknesses-section';
                    weaknessesEl.innerHTML = '<h3>Verbesserungspotential</h3><ul></ul>';
                    
                    const weaknessesList = weaknessesEl.querySelector('ul');
                    result.feedback.weaknesses.forEach(weakness => {
                        const li = document.createElement('li');
                        li.textContent = `${weakness.category} (${weakness.score}% korrekt)`;
                        weaknessesList.appendChild(li);
                    });
                    
                    feedbackSection.appendChild(weaknessesEl);
                }
                
                // Empfehlungen auflisten, falls vorhanden
                if (result.feedback.recommendations && result.feedback.recommendations.length > 0) {
                    const recommendationsEl = document.createElement('div');
                    recommendationsEl.className = 'recommendations-section';
                    recommendationsEl.innerHTML = '<h3>Empfehlungen</h3><ul></ul>';
                    
                    const recommendationsList = recommendationsEl.querySelector('ul');
                    result.feedback.recommendations.forEach(recommendation => {
                        const li = document.createElement('li');
                        li.textContent = recommendation.text;
                        recommendationsList.appendChild(li);
                    });
                    
                    feedbackSection.appendChild(recommendationsEl);
                }
                
                resultWrapper.appendChild(feedbackSection);
            }
			// Abschnitt für Statistiken hinzufügen
            if (result.statistics) {
                const statsSection = document.createElement('div');
                statsSection.className = 'result-statistics-section';
                statsSection.innerHTML = '<h3>Detaillierte Statistiken</h3>';
                
                // Kategorie-Performance als Tabelle darstellen
                if (result.statistics.categoryPerformance && Object.keys(result.statistics.categoryPerformance).length > 0) {
                    const categoryTable = document.createElement('div');
                    categoryTable.className = 'statistics-table';
                    categoryTable.innerHTML = `
                        <h4>Leistung nach Kategorie</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Kategorie</th>
                                    <th>Korrekt</th>
                                    <th>Gesamt</th>
                                    <th>Erfolgsrate</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    `;
                    
                    const tbody = categoryTable.querySelector('tbody');
                    Object.keys(result.statistics.categoryPerformance).forEach(category => {
                        const data = result.statistics.categoryPerformance[category];
                        const tr = document.createElement('tr');
                        
                        // Farbliche Hervorhebung basierend auf Erfolgsrate
                        let rateClass = '';
                        if (data.score >= 75) rateClass = 'high-score';
                        else if (data.score >= 60) rateClass = 'medium-score';
                        else rateClass = 'low-score';
                        
                        tr.innerHTML = `
                            <td>${category}</td>
                            <td>${data.correct}</td>
                            <td>${data.total}</td>
                            <td class="${rateClass}">${data.score}%</td>
                        `;
                        tbody.appendChild(tr);
                    });
                    
                    statsSection.appendChild(categoryTable);
                }
                
                // Zeitstatistiken hinzufügen, falls verfügbar
                if (result.statistics.timePerQuestion && Object.keys(result.statistics.timePerQuestion).length > 0) {
                    const timeStats = document.createElement('div');
                    timeStats.className = 'time-statistics';
                    
                    const times = Object.values(result.statistics.timePerQuestion);
                    const avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                    const totalTime = times.reduce((a, b) => a + b, 0);
                    const formattedTotalTime = app.utils.formatTime(totalTime);
                    
                    timeStats.innerHTML = `
                        <h4>Zeitstatistiken</h4>
                        <div class="time-stats-grid">
                            <div class="time-stat">
                                <span class="stat-label">Gesamtzeit:</span>
                                <span class="stat-value">${formattedTotalTime}</span>
                            </div>
                            <div class="time-stat">
                                <span class="stat-label">Durchschnittliche Zeit pro Frage:</span>
                                <span class="stat-value">${app.utils.formatTime(avgTime)}</span>
                            </div>
                        </div>
                    `;
                    
                    statsSection.appendChild(timeStats);
                }
                
                // Antwortverteilung hinzufügen
                const answerDistribution = document.createElement('div');
                answerDistribution.className = 'answer-distribution';
                answerDistribution.innerHTML = `
                    <h4>Antwortverteilung</h4>
                    <div class="distribution-grid">
                        <div class="distribution-item correct">
                            <span class="dist-value">${result.statistics.answeredCorrectly || 0}</span>
                            <span class="dist-label">Korrekt</span>
                        </div>
                        <div class="distribution-item incorrect">
                            <span class="dist-value">${result.statistics.answeredIncorrectly || 0}</span>
                            <span class="dist-label">Inkorrekt</span>
                        </div>
                        <div class="distribution-item skipped">
                            <span class="dist-value">${result.statistics.skipped || 0}</span>
                            <span class="dist-label">Übersprungen</span>
                        </div>
                    </div>
                `;
                
                statsSection.appendChild(answerDistribution);
                resultWrapper.appendChild(statsSection);
            }
			// Aktionsbuttons hinzufügen
            const actionButtons = document.createElement('div');
            actionButtons.className = 'result-actions';
            actionButtons.innerHTML = `
                <button id="print-results" class="action-button">Ergebnisse drucken</button>
                <button id="back-to-dashboard" class="action-button primary">Zurück zum Dashboard</button>
                ${result.passed ? '<button id="next-recommended-test" class="action-button highlight">Nächster empfohlener Test</button>' : 
                                '<button id="retry-test" class="action-button highlight">Test wiederholen</button>'}
            `;
            resultWrapper.appendChild(actionButtons);
            
            // Zum Hauptcontainer hinzufügen
            resultContainer.appendChild(resultWrapper);
            
            // Event-Listener für die Aktionsbuttons
            document.getElementById('print-results').addEventListener('click', function() {
                app.testCompletion.printResults(result);
            });
            
            document.getElementById('back-to-dashboard').addEventListener('click', function() {
                // Zum Dashboard zurückkehren
                app.navigation.navigateTo('dashboard');
            });
            
            if (result.passed) {
                document.getElementById('next-recommended-test').addEventListener('click', function() {
                    app.testCompletion.findNextRecommendedTest(result);
                });
            } else {
                document.getElementById('retry-test').addEventListener('click', function() {
                    // Test neu starten
                    app.testSession.restartTest(result.testId);
                });
            }
            
            // Stelle sicher, dass der Ergebnisbereich sichtbar ist
            resultContainer.style.display = 'block';
            
            console.log('Detaillierte Ergebnisansicht erfolgreich gerendert');
        } catch (error) {
            console.error('Fehler beim Rendern der detaillierten Ergebnisse:', error);
            // Fallback: Zeige einfache Ergebnisanzeige
            resultContainer.innerHTML = `
                <div class="error-result">
                    <h2>Ergebnis-Zusammenfassung</h2>
                    <p>Es ist ein Fehler aufgetreten. Hier ist eine vereinfachte Zusammenfassung:</p>
                    <p><strong>Punkte:</strong> ${result.score} / ${result.maxScore}</p>
                    <p><strong>Prozent:</strong> ${result.scorePercentage}%</p>
                    <p><strong>Status:</strong> ${result.passed ? 'Bestanden' : 'Nicht bestanden'}</p>
                    <button id="back-to-dashboard-error" class="action-button primary">Zurück zum Dashboard</button>
                </div>
            `;
            
            document.getElementById('back-to-dashboard-error').addEventListener('click', function() {
                app.navigation.navigateTo('dashboard');
            });
        }
    };
	/**
     * Druckt die Testergebnisse in einer druckfreundlichen Ansicht
     * @param {Object} result - Testergebnis und Statistiken
     */
    app.testCompletion.printResults = function(result) {
        console.log('Drucke Testergebnisse:', result);
        
        try {
            // Erstelle ein neues Fenster für die Druckansicht
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Bitte erlauben Sie Popup-Fenster für diese Seite, um die Druckfunktion zu nutzen.');
                return;
            }
            
            // Basis-CSS für die Druckansicht
            const printCSS = `
                body {
                    font-family: Arial, sans-serif;
                    line-height: 1.5;
                    margin: 20px;
                    color: #333;
                }
                .header {
                    text-align: center;
                    margin-bottom: 30px;
                    padding-bottom: 20px;
                    border-bottom: 1px solid #ccc;
                }
                .header img {
                    max-width: 200px;
                    margin-bottom: 10px;
                }
                .result-summary {
                    display: flex;
                    justify-content: space-between;
                    margin: 20px 0;
                    padding: 15px;
                    background-color: #f8f8f8;
                    border-radius: 5px;
                }
                .result-summary > div {
                    flex: 1;
                    text-align: center;
                }
                .result-score {
                    font-size: 1.2em;
                    font-weight: bold;
                }
                .result-status {
                    font-weight: bold;
                }
                .passed {
                    color: #00a86b;
                }
                .failed {
                    color: #d9534f;
                }
                h2, h3, h4 {
                    color: #2c3e50;
                }
                section {
                    margin-bottom: 25px;
                }
                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 15px 0;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #f2f2f2;
                }
                .footer {
                    margin-top: 40px;
                    text-align: center;
                    font-size: 0.8em;
                    color: #777;
                }
                .high-score {
                    color: #00a86b;
                }
                .medium-score {
                    color: #ff9800;
                }
                .low-score {
                    color: #d9534f;
                }
                @media print {
                    body {
                        margin: 0;
                        padding: 15px;
                    }
                    button {
                        display: none;
                    }
                }
            `;
            
            // Basisdaten für den Ausdruck
            const currentDate = new Date().toLocaleDateString('de-DE');
            const userName = app.authentication.getCurrentUser() ? 
                             app.authentication.getCurrentUser().fullName : 'Teilnehmer';
            
            // HTML-Inhalt für die Druckansicht generieren
            let printContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Testergebnisse - ${result.testTitle || 'Test'}</title>
                    <meta charset="utf-8">
                    <style>${printCSS}</style>
                </head>
                <body>
                    <div class="header">
                        <img src="assets/immoscout24-logo.png" alt="ImmoScout24 Logo">
                        <h1>Testergebnisse</h1>
                        <p>${result.testTitle || 'Test'}</p>
                    </div>
                    
                    <div class="participant-info">
                        <p><strong>Teilnehmer:</strong> ${userName}</p>
                        <p><strong>Datum:</strong> ${currentDate}</p>
                    </div>
                    
                    <div class="result-summary">
                        <div class="result-score">
                            <div>Punkte</div>
                            <div>${result.score} / ${result.maxScore}</div>
                        </div>
                        <div class="result-percentage">
                            <div>Prozent</div>
                            <div>${result.scorePercentage}%</div>
                        </div>
                        <div class="result-status ${result.passed ? 'passed' : 'failed'}">
                            <div>Status</div>
                            <div>${result.passed ? 'Bestanden' : 'Nicht bestanden'}</div>
                        </div>
                    </div>
            `;
			// Feedback hinzufügen, falls vorhanden
            if (result.feedback) {
                printContent += `
                    <section class="feedback-section">
                        <h2>Feedback</h2>
                        <p>${result.feedback.general}</p>
                `;
                
                // Stärken hinzufügen
                if (result.feedback.strengths && result.feedback.strengths.length > 0) {
                    printContent += `
                        <h3>Stärken</h3>
                        <ul>
                    `;
                    
                    result.feedback.strengths.forEach(strength => {
                        printContent += `<li>${strength.category} (${strength.score}% korrekt)</li>`;
                    });
                    
                    printContent += `</ul>`;
                }
                
                // Verbesserungspotential hinzufügen
                if (result.feedback.weaknesses && result.feedback.weaknesses.length > 0) {
                    printContent += `
                        <h3>Verbesserungspotential</h3>
                        <ul>
                    `;
                    
                    result.feedback.weaknesses.forEach(weakness => {
                        printContent += `<li>${weakness.category} (${weakness.score}% korrekt)</li>`;
                    });
                    
                    printContent += `</ul>`;
                }
                
                // Empfehlungen hinzufügen
                if (result.feedback.recommendations && result.feedback.recommendations.length > 0) {
                    printContent += `
                        <h3>Empfehlungen</h3>
                        <ul>
                    `;
                    
                    result.feedback.recommendations.forEach(recommendation => {
                        printContent += `<li>${recommendation.text}</li>`;
                    });
                    
                    printContent += `</ul>`;
                }
                
                printContent += `</section>`;
            }
            
            // Statistiken hinzufügen
            if (result.statistics) {
                printContent += `
                    <section class="statistics-section">
                        <h2>Statistiken</h2>
                `;
                
                // Antwortverteilung
                printContent += `
                    <h3>Antwortverteilung</h3>
                    <table>
                        <tr>
                            <th>Korrekt</th>
                            <th>Inkorrekt</th>
                            <th>Übersprungen</th>
                        </tr>
                        <tr>
                            <td>${result.statistics.answeredCorrectly || 0}</td>
                            <td>${result.statistics.answeredIncorrectly || 0}</td>
                            <td>${result.statistics.skipped || 0}</td>
                        </tr>
                    </table>
                `;
                
                // Kategorie-Performance
                if (result.statistics.categoryPerformance && Object.keys(result.statistics.categoryPerformance).length > 0) {
                    printContent += `
                        <h3>Leistung nach Kategorie</h3>
                        <table>
                            <tr>
                                <th>Kategorie</th>
                                <th>Korrekt</th>
                                <th>Gesamt</th>
                                <th>Erfolgsrate</th>
                            </tr>
                    `;
                    
                    Object.keys(result.statistics.categoryPerformance).forEach(category => {
                        const data = result.statistics.categoryPerformance[category];
                        let rateClass = '';
                        if (data.score >= 75) rateClass = 'high-score';
                        else if (data.score >= 60) rateClass = 'medium-score';
                        else rateClass = 'low-score';
                        
                        printContent += `
                            <tr>
                                <td>${category}</td>
                                <td>${data.correct}</td>
                                <td>${data.total}</td>
                                <td class="${rateClass}">${data.score}%</td>
                            </tr>
                        `;
                    });
                    
                    printContent += `</table>`;
                }
                
                // Zeitstatistik
                if (result.statistics.timePerQuestion && Object.keys(result.statistics.timePerQuestion).length > 0) {
                    const times = Object.values(result.statistics.timePerQuestion);
                    const avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
                    const totalTime = times.reduce((a, b) => a + b, 0);
                    const formattedTotalTime = app.utils.formatTime(totalTime);
                    
                    printContent += `
                        <h3>Zeitstatistik</h3>
                        <table>
                            <tr>
                                <th>Gesamtzeit</th>
                                <th>Durchschnittliche Zeit pro Frage</th>
                            </tr>
                            <tr>
                                <td>${formattedTotalTime}</td>
                                <td>${app.utils.formatTime(avgTime)}</td>
                            </tr>
                        </table>
                    `;
                }
                
                printContent += `</section>`;
            }
			// Abschluss der Druckansicht
            printContent += `
                    <div class="footer">
                        <p>Dieses Dokument wurde automatisch generiert am ${currentDate}.</p>
                        <p>© ${new Date().getFullYear()} ImmoScout24 - E-Learning-Plattform</p>
                    </div>
                    
                    <div class="print-controls" style="text-align: center; margin-top: 30px;">
                        <button onclick="window.print()" style="padding: 10px 20px; background-color: #00FFD0; border: none; border-radius: 4px; cursor: pointer;">Drucken</button>
                        <button onclick="window.close()" style="padding: 10px 20px; background-color: #f0f0f0; border: none; border-radius: 4px; margin-left: 10px; cursor: pointer;">Schließen</button>
                    </div>
                </body>
                </html>
            `;
            
            // Inhalt ins neue Fenster schreiben und öffnen
            printWindow.document.open();
            printWindow.document.write(printContent);
            printWindow.document.close();
            
            console.log('Druckansicht erfolgreich erstellt');
        } catch (error) {
            console.error('Fehler beim Erstellen der Druckansicht:', error);
            alert('Es ist ein Fehler beim Erstellen der Druckansicht aufgetreten. Bitte versuchen Sie es später erneut.');
        }
    };
    
    /**
     * Findet den nächsten empfohlenen Test basierend auf den aktuellen Ergebnissen
     * @param {Object} result - Testergebnis mit Statistiken
     */
    app.testCompletion.findNextRecommendedTest = function(result) {
        console.log('Suche nach nächstem empfohlenen Test basierend auf:', result);
        
        try {
            // Aktuellen Benutzer abrufen
            const currentUser = app.authentication.getCurrentUser();
            if (!currentUser) {
                console.error('Kein Benutzer angemeldet.');
                alert('Bitte melden Sie sich an, um Empfehlungen zu erhalten.');
                return;
            }
            
            // Alle verfügbaren Tests abrufen
            const allTests = app.dataManager.getAllTests();
            if (!allTests || allTests.length === 0) {
                console.warn('Keine Tests gefunden.');
                alert('Es sind keine weiteren Tests verfügbar.');
                return;
            }
            
            // Finde Schwachstellen in den Kategorien
            let weakCategories = [];
            if (result.feedback && result.feedback.weaknesses) {
                weakCategories = result.feedback.weaknesses.map(w => w.category);
            }
            
            // Bereits absolvierte Tests identifizieren
            const completedTestIds = app.dataManager.getUserCompletedTests(currentUser.id) || [];
            
            // Finde Tests, die die schwachen Kategorien abdecken und noch nicht abgeschlossen wurden
            let recommendedTests = allTests.filter(test => {
                // Überspringe den gerade absolvierten Test
                if (test.id === result.testId) return false;
                
                // Überspringe bereits abgeschlossene Tests
                if (completedTestIds.includes(test.id)) return false;
                
                // Überprüfe, ob der Test relevante Kategorien enthält
                if (weakCategories.length > 0) {
                    // Extrahiere Kategorien aus dem Test
                    const testCategories = app.testCompletion.extractTestCategories(test);
                    
                    // Prüfe, ob es eine Überschneidung mit den schwachen Kategorien gibt
                    return weakCategories.some(category => testCategories.includes(category));
                }
                
                return true; // Falls keine schwachen Kategorien gefunden wurden, alle verbleibenden Tests einbeziehen
            });
            
            // Sortiere nach Relevanz (Anzahl der übereinstimmenden schwachen Kategorien)
            if (weakCategories.length > 0) {
                recommendedTests.sort((a, b) => {
                    const aCats = app.testCompletion.extractTestCategories(a);
                    const bCats = app.testCompletion.extractTestCategories(b);
                    
                    const aMatches = weakCategories.filter(cat => aCats.includes(cat)).length;
                    const bMatches = weakCategories.filter(cat => bCats.includes(cat)).length;
                    
                    return bMatches - aMatches; // Absteigend nach Anzahl der Übereinstimmungen
                });
            }
            
            if (recommendedTests.length === 0) {
                console.log('Keine passenden Tests gefunden.');
                alert('Herzlichen Glückwunsch! Sie haben alle verfügbaren Tests zu Ihren Lernbereichen abgeschlossen.');
                return;
            }
            
            // Zum ersten empfohlenen Test navigieren
            const nextTest = recommendedTests[0];
            console.log('Nächster empfohlener Test:', nextTest);
            
            // Zum Test navigieren
            app.navigation.navigateTo('test-start', { testId: nextTest.id });
        } catch (error) {
            console.error('Fehler bei der Suche nach dem nächsten empfohlenen Test:', error);
            alert('Es ist ein Fehler bei der Suche nach dem nächsten Test aufgetreten.');
        }
    };
	/**
     * Extrahiert alle Kategorien aus einem Test
     * @param {Object} test - Testobjekt
     * @return {Array} - Liste der Kategorien im Test
     */
    app.testCompletion.extractTestCategories = function(test) {
        if (!test || !test.questions) return [];
        
        // Sammle alle Kategorien aus den Fragen
        const categories = new Set();
        
        // Durchlaufe alle Fragen-IDs
        Object.keys(test.questions).forEach(questionId => {
            const question = app.dataManager.getQuestionById(questionId);
            if (question && question.category) {
                categories.add(question.category);
            }
        });
        
        return Array.from(categories);
    };
    
    /**
     * Erweiterung der initialize-Methode um neue Funktionalitäten
     * Erweitert die bestehende Methode aus Teil 1
     */
    const originalInitialize = app.testCompletion.initialize;
    app.testCompletion.initialize = function(options) {
        // Rufe die ursprüngliche Initialisierungsmethode auf
        originalInitialize.call(this, options);
        
        console.log('Erweiterte Testabschluss-Funktionalitäten werden initialisiert');
        
        // Erweitere die Oberfläche für detaillierte Ergebnisse
        const testContainer = document.getElementById('test-container');
        if (testContainer) {
            // Prüfe, ob der detaillierte Ergebnisbereich bereits existiert
            let detailedResults = document.getElementById('test-results-detailed');
            if (!detailedResults) {
                // Erstelle den Container für detaillierte Ergebnisse
                detailedResults = document.createElement('div');
                detailedResults.id = 'test-results-detailed';
                detailedResults.className = 'test-results-detailed';
                detailedResults.style.display = 'none';
                testContainer.appendChild(detailedResults);
            }
        }
        
        // Erweitere die öffentliche Schnittstelle
        Object.assign(app.testCompletion.interface, {
            generatePerformanceStatistics: app.testCompletion.generatePerformanceStatistics.bind(app.testCompletion),
            generatePersonalizedFeedback: app.testCompletion.generatePersonalizedFeedback.bind(app.testCompletion),
            renderDetailedResults: app.testCompletion.renderDetailedResults.bind(app.testCompletion),
            printResults: app.testCompletion.printResults.bind(app.testCompletion),
            findNextRecommendedTest: app.testCompletion.findNextRecommendedTest.bind(app.testCompletion)
        });
        
        console.log('Testabschluss-Prozess (Teil 2) erfolgreich initialisiert');
    };
    
    // Ereignis-Listener für die Anzeige detaillierter Ergebnisse
    document.addEventListener('testProcessed', function(event) {
        const result = event.detail;
        if (result) {
            console.log('Test-Verarbeitung abgeschlossen, zeige detaillierte Ergebnisse:', result);
            
            // Generiere erweiterte Statistiken
            result.statistics = app.testCompletion.generatePerformanceStatistics(result.testData);
            
            // Generiere personalisiertes Feedback
            result.feedback = app.testCompletion.generatePersonalizedFeedback(result);
            
            // Rendere die detaillierte Ergebnisansicht
            app.testCompletion.renderDetailedResults(result);
        }
    });
    
    console.log('Testabschluss-Prozess (Teil 2) initialisiert');
})();

// Öffentliche Schnittstelle aktualisieren (wird von Teil 1 exportiert)
// Keine Änderung notwendig, da die Schnittstelle in der initialize-Methode erweitert wird
/**
 * JS-Block 5.8.2-part1: Ergebnisübermittlung (Teil 1)
 * Funktionen zum Übermitteln und Verwalten von Testergebnissen
 */
(function() {
    // Namespace sicherstellen
    if (!app.testCompletion) {
        app.testCompletion = {};
    }
    
    // Ergebnisübermittlung und Datenverwaltung
    
    /**
     * Namespace für die Ergebnisübermittlung
     */
    app.testCompletion.results = {
        // Speichert temporäre Ergebnisdaten während der Verarbeitung
        processingQueue: [],
        
        // Konfigurations- und Statusdaten
        config: {
            autoSave: true,            // Automatisches Speichern nach Abschluss
            sendToDashboard: true,     // Automatische Übermittlung ans Dashboard
            generateReport: true,      // Automatische Berichtgenerierung
            retryAttempts: 3,          // Wiederholungsversuche bei Fehlern
            notifyTrainer: true        // Trainer über abgeschlossene Tests informieren
        },
        
        // Status der Ergebnisverarbeitung
        status: {
            processing: false,
            lastProcessed: null,
            errors: []
        }
    };
    
    /**
     * Initialisiert das Ergebnisübermittlungssystem
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testCompletion.results.initialize = function(options) {
        console.log('Initialisiere Ergebnisübermittlung mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            Object.assign(this.config, options);
        }
        
        // Event-Listener für die Ergebnisverarbeitung 
        document.addEventListener('testCompleted', function(event) {
            if (!event.detail) {
                console.error('Keine Testdaten im Event erhalten');
                return;
            }
            
            console.log('Test abgeschlossen, starte Ergebnisverarbeitung:', event.detail);
            app.testCompletion.results.processResult(event.detail);
        });
        
        // Event-Listener für manuelle Bewertungen
        document.addEventListener('manualEvaluation', function(event) {
            if (!event.detail) {
                console.error('Keine Bewertungsdaten im Event erhalten');
                return;
            }
            
            console.log('Manuelle Bewertung empfangen:', event.detail);
            app.testCompletion.results.updateWithManualEvaluation(event.detail);
        });
        
        // Initialisiere Zwischenspeicher für ausstehende Übermittlungen
        this.loadPendingSubmissions();
        
        console.log('Ergebnisübermittlung initialisiert');
    };
    
    /**
     * Lädt ausstehende Ergebnisübermittlungen aus dem lokalen Speicher
     */
    app.testCompletion.results.loadPendingSubmissions = function() {
        try {
            const pendingData = localStorage.getItem('pendingTestResults');
            if (pendingData) {
                const pendingResults = JSON.parse(pendingData);
                if (Array.isArray(pendingResults) && pendingResults.length > 0) {
                    console.log(`${pendingResults.length} ausstehende Ergebnisübermittlungen geladen`);
                    this.processingQueue = pendingResults;
                    
                    // Automatische Verarbeitung ausstehender Ergebnisse
                    this.processPendingResults();
                }
            }
        } catch (error) {
            console.error('Fehler beim Laden ausstehender Ergebnisse:', error);
        }
    };
    
    /**
     * Verarbeitet ausstehende Ergebnisse in der Warteschlange
     */
    app.testCompletion.results.processPendingResults = function() {
        if (this.status.processing || this.processingQueue.length === 0) {
            return;
        }
        
        this.status.processing = true;
        console.log(`Verarbeite ${this.processingQueue.length} ausstehende Ergebnisse`);
        
        // Verarbeite jedes Ergebnis in der Warteschlange
        const processNext = () => {
            if (this.processingQueue.length === 0) {
                this.status.processing = false;
                console.log('Alle ausstehenden Ergebnisse verarbeitet');
                return;
            }
            
            const nextResult = this.processingQueue.shift();
            this.saveResult(nextResult)
                .then(() => {
                    console.log('Austehendes Ergebnis erfolgreich gespeichert:', nextResult.id);
                    // Warteschlange aktualisieren
                    localStorage.setItem('pendingTestResults', JSON.stringify(this.processingQueue));
                    // Nächstes Ergebnis verarbeiten
                    processNext();
                })
                .catch(error => {
                    console.error('Fehler bei der Verarbeitung des ausstehenden Ergebnisses:', error);
                    // Ergebnis wieder in die Warteschlange einfügen, wenn es Wiederholungsversuche geben soll
                    if (!nextResult.retryCount || nextResult.retryCount < this.config.retryAttempts) {
                        nextResult.retryCount = (nextResult.retryCount || 0) + 1;
                        this.processingQueue.push(nextResult);
                    } else {
                        // Maximale Anzahl an Wiederholungsversuchen erreicht
                        this.status.errors.push({
                            resultId: nextResult.id,
                            error: error.message || 'Unbekannter Fehler',
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // Warteschlange aktualisieren
                    localStorage.setItem('pendingTestResults', JSON.stringify(this.processingQueue));
                    
                    // Nächstes Ergebnis verarbeiten
                    processNext();
                });
        };
        
        // Starte die Verarbeitung
        processNext();
    };
    
    /**
     * Verarbeitet ein neues Testergebnis
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     */
    app.testCompletion.results.processResult = function(testData) {
        console.log('Verarbeite neues Testergebnis:', testData);
        
        if (!testData || !testData.testId) {
            console.error('Ungültige Testdaten für die Verarbeitung');
            return Promise.reject(new Error('Ungültige Testdaten'));
        }
        
        try {
            // Bereite das Ergebnisobjekt vor
            const resultObject = this.prepareResultObject(testData);
            
            // Event auslösen, um andere Module über das neue Ergebnis zu informieren
            const resultEvent = new CustomEvent('testProcessed', {
                detail: resultObject
            });
            document.dispatchEvent(resultEvent);
            
            // Speichere das Ergebnis, wenn automatisches Speichern aktiviert ist
            if (this.config.autoSave) {
                return this.saveResult(resultObject)
                    .then(savedResult => {
                        console.log('Testergebnis erfolgreich gespeichert:', savedResult);
                        
                        // Benachrichtige Trainer, falls aktiviert
                        if (this.config.notifyTrainer) {
                            this.notifyTrainer(savedResult);
                        }
                        
                        // Generiere Bericht, falls aktiviert
                        if (this.config.generateReport) {
                            this.generateResultReport(savedResult);
                        }
                        
                        return savedResult;
                    })
                    .catch(error => {
                        console.error('Fehler beim Speichern des Ergebnisses:', error);
                        
                        // Füge das Ergebnis zur Warteschlange hinzu für spätere Verarbeitung
                        resultObject.retryCount = 0;
                        this.processingQueue.push(resultObject);
                        localStorage.setItem('pendingTestResults', JSON.stringify(this.processingQueue));
                        
                        throw error;
                    });
            } else {
                return Promise.resolve(resultObject);
            }
        } catch (error) {
            console.error('Fehler bei der Ergebnisverarbeitung:', error);
            return Promise.reject(error);
        }
    };
    
    /**
     * Bereitet das Ergebnisobjekt zur Speicherung vor
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     * @return {Object} - Vorbereitetes Ergebnisobjekt
     */
    app.testCompletion.results.prepareResultObject = function(testData) {
        console.log('Bereite Ergebnisobjekt vor für:', testData);
        
        // Hole Testinformationen
        const test = app.dataManager.getTestById(testData.testId);
        if (!test) {
            throw new Error(`Test mit ID ${testData.testId} nicht gefunden`);
        }
        
        // Aktueller Benutzer
        const currentUser = app.authentication.getCurrentUser();
        if (!currentUser) {
            throw new Error('Kein Benutzer angemeldet');
        }
        
        // Berechne die Gesamtpunktzahl
        const scoreCalculation = this.calculateScore(testData);
        
        // Ergebnisobjekt erstellen
        const resultObject = {
            id: `result_${Date.now()}_${currentUser.id.substring(0, 6)}`,
            testId: testData.testId,
            testTitle: test.title,
            userId: currentUser.id,
            userName: currentUser.fullName,
            userRole: currentUser.role,
            teamId: currentUser.teamId,
            timestamp: new Date().toISOString(),
            duration: testData.duration || 0,
            score: scoreCalculation.score,
            maxScore: scoreCalculation.maxScore,
            scorePercentage: scoreCalculation.percentage,
            passed: scoreCalculation.passed,
            requiredScore: test.passingScore || 60,
            testData: testData, // Vollständige Testdaten für detaillierte Auswertungen
            answers: this.prepareAnswersSummary(testData), // Vereinfachte Antwortübersicht
            manualEvaluation: false, // Flag für Fragen, die manuelle Bewertung benötigen
            evaluationStatus: this.checkEvaluationStatus(testData), // Status der Bewertung
            statistics: null, // Wird später gefüllt
            feedback: null, // Wird später gefüllt
            reviewedBy: null, // Bei manueller Prüfung: ID des Prüfers
            reviewDate: null, // Bei manueller Prüfung: Datum der Prüfung
            comments: [] // Kommentare von Trainern/Prüfern
        };
        
        // Generiere zusätzliche Statistiken
        resultObject.statistics = app.testCompletion.generatePerformanceStatistics(testData);
        
        // Generiere personalisiertes Feedback
        resultObject.feedback = app.testCompletion.generatePersonalizedFeedback(resultObject);
        
        console.log('Ergebnisobjekt erstellt:', resultObject);
        return resultObject;
    };
    
    /**
     * Berechnet die Punktzahl für einen abgeschlossenen Test
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     * @return {Object} - Berechnete Punktzahlen und Status
     */
    app.testCompletion.results.calculateScore = function(testData) {
        console.log('Berechne Punktzahl für:', testData);
        
        const result = {
            score: 0,
            maxScore: 0,
            percentage: 0,
            passed: false,
            requiresManualEvaluation: false,
            questionScores: {}
        };
        
        try {
            // Hole Testinformationen
            const test = app.dataManager.getTestById(testData.testId);
            if (!test) {
                throw new Error(`Test mit ID ${testData.testId} nicht gefunden`);
            }
            
            const passingPercentage = test.passingScore || 60;
            const answers = testData.answers || {};
            
            // Durchlaufe alle Fragen und berechne Punkte
            Object.keys(answers).forEach(questionId => {
                const questionData = app.testSession.getQuestionById(questionId);
                const answerData = answers[questionId];
                
                if (!questionData) {
                    console.warn(`Frage mit ID ${questionId} nicht gefunden`);
                    return;
                }
                
                // Maximale Punktzahl für diese Frage
                const maxQuestionScore = questionData.points || 1;
                result.maxScore += maxQuestionScore;
                
                // Prüfe, ob diese Frage automatisch bewertet werden kann
                if (questionData.type === 'free_text' && !questionData.autoEvaluate) {
                    // Freitext-Fragen benötigen möglicherweise manuelle Bewertung
                    result.requiresManualEvaluation = true;
                    
                    // Wenn bereits manuell bewertet, verwende diese Bewertung
                    if (answerData.manualScore !== undefined) {
                        result.score += answerData.manualScore;
                        result.questionScores[questionId] = answerData.manualScore;
                    } else {
                        // Andernfalls als unbewertete Frage markieren
                        result.questionScores[questionId] = 0;
                    }
                } else {
                    // Bei allen anderen Fragetypen: Punkte basierend auf Korrektheit
                    if (answerData.isCorrect === true) {
                        result.score += maxQuestionScore;
                        result.questionScores[questionId] = maxQuestionScore;
                    } else if (answerData.isCorrect === false) {
                        // Keine Punkte für falsche Antworten
                        result.questionScores[questionId] = 0;
                    } else if (answerData.partialScore !== undefined) {
                        // Bei Teilpunkten (z.B. bei Multiple-Choice mit mehreren korrekten Antworten)
                        const partialScore = answerData.partialScore * maxQuestionScore;
                        result.score += partialScore;
                        result.questionScores[questionId] = partialScore;
                    } else {
                        // Wenn keine Bewertung vorhanden, 0 Punkte
                        result.questionScores[questionId] = 0;
                    }
                }
            });
            
            // Prozentsatz berechnen
            result.percentage = result.maxScore > 0 ? 
                Math.round((result.score / result.maxScore) * 100) : 0;
            
            // Bestanden/Nicht bestanden bestimmen
            result.passed = result.percentage >= passingPercentage;
            
            // Wenn manuelle Bewertung benötigt wird, setze den Status entsprechend
            if (result.requiresManualEvaluation) {
                result.passed = false; // Nicht bestanden bis manuelle Bewertung abgeschlossen
            }
            
            console.log('Punktzahlberechnung abgeschlossen:', result);
            return result;
        } catch (error) {
            console.error('Fehler bei der Punktzahlberechnung:', error);
            return result;
        }
    };
    
    /**
     * Erstellt eine vereinfachte Übersicht der Antworten
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     * @return {Object} - Vereinfachte Antwortübersicht
     */
    app.testCompletion.results.prepareAnswersSummary = function(testData) {
        const answersSummary = {};
        const answers = testData.answers || {};
        
        Object.keys(answers).forEach(questionId => {
            const answerData = answers[questionId];
            const questionData = app.testSession.getQuestionById(questionId);
            
            if (!questionData) {
                console.warn(`Frage mit ID ${questionId} nicht gefunden`);
                return;
            }
            
            // Erstelle eine vereinfachte Antwortdarstellung
            const summary = {
                questionType: questionData.type,
                questionText: questionData.text,
                isCorrect: answerData.isCorrect,
                points: answerData.points || 0,
                maxPoints: questionData.points || 1,
                timeSpent: answerData.timeSpent || 0
            };
            
            // Je nach Fragetyp spezifische Informationen hinzufügen
            switch (questionData.type) {
                case 'multiple_choice':
                case 'single_choice':
                    summary.selectedOptions = answerData.selectedOptions || [];
                    summary.correctOptions = questionData.correctOptions || [];
                    break;
                case 'true_false':
                    summary.selectedAnswer = answerData.selectedAnswer;
                    summary.correctAnswer = questionData.correctAnswer;
                    break;
                case 'free_text':
                    summary.userAnswer = answerData.text || '';
                    summary.requiresManualEvaluation = !questionData.autoEvaluate;
                    
                    if (questionData.autoEvaluate) {
                        summary.correctAnswer = questionData.correctAnswer || '';
                    }
                    
                    if (answerData.manualScore !== undefined) {
                        summary.manualScore = answerData.manualScore;
                        summary.manualComment = answerData.manualComment;
                    }
                    break;
            }
            
            answersSummary[questionId] = summary;
        });
        
        return answersSummary;
    };
    
    /**
     * Prüft, ob der Test manuelle Bewertung benötigt
     * @param {Object} testData - Alle Testdaten inkl. Antworten
     * @return {string} - Status der Bewertung ('complete', 'partial', 'pending')
     */
    app.testCompletion.results.checkEvaluationStatus = function(testData) {
        const answers = testData.answers || {};
        let needsEvaluation = false;
        let hasUnevaluated = false;
        
        Object.keys(answers).forEach(questionId => {
            const questionData = app.testSession.getQuestionById(questionId);
            const answerData = answers[questionId];
            
            if (!questionData) return;
            
            // Prüfe, ob es sich um eine Freitext-Frage handelt, die manuelle Bewertung erfordert
            if (questionData.type === 'free_text' && !questionData.autoEvaluate) {
                needsEvaluation = true;
                
                // Prüfe, ob diese Frage bereits manuell bewertet wurde
                if (answerData.manualScore === undefined) {
                    hasUnevaluated = true;
                }
            }
        });
        
        if (!needsEvaluation) {
            return 'complete'; // Vollständig automatisch bewertet
        } else if (hasUnevaluated) {
            return 'pending'; // Noch nicht alle manuell bewerteten Fragen wurden bewertet
        } else {
            return 'complete'; // Alle manuell zu bewertenden Fragen wurden bewertet
        }
    };
    
    /**
     * Speichert das Ergebnis in der Datenbank
     * @param {Object} resultObject - Das zu speichernde Ergebnisobjekt
     * @return {Promise} - Promise mit dem gespeicherten Ergebnis
     */
    app.testCompletion.results.saveResult = function(resultObject) {
        console.log('Speichere Testergebnis:', resultObject);
        
        return new Promise((resolve, reject) => {
            try {
                // Speichere das Ergebnis in der Datenbank
                const savedResult = app.dataManager.saveTestResult(resultObject);
                
                if (!savedResult) {
                    throw new Error('Fehler beim Speichern des Ergebnisses in der Datenbank');
                }
                
                // Ergebnis dem Benutzer zuordnen
                app.dataManager.addUserCompletedTest(resultObject.userId, resultObject.testId, resultObject.id);
                
                // Aktualisiere die Benutzerstatistiken
                this.updateUserStatistics(resultObject);
                
                // Update letzter verarbeiteter Status
                this.status.lastProcessed = {
                    resultId: resultObject.id,
                    timestamp: new Date().toISOString(),
                    success: true
                };
                
                console.log('Testergebnis erfolgreich gespeichert:', savedResult);
                resolve(savedResult);
            } catch (error) {
                console.error('Fehler beim Speichern des Testergebnisses:', error);
                
                // Fehler in den Status aufnehmen
                this.status.errors.push({
                    resultId: resultObject.id,
                    error: error.message || 'Unbekannter Fehler',
                    timestamp: new Date().toISOString()
                });
                
                reject(error);
            }
        });
    };
    
    /**
     * Aktualisiert die Benutzerstatistiken mit dem neuen Testergebnis
     * @param {Object} result - Das Ergebnisobjekt
     */
    app.testCompletion.results.updateUserStatistics = function(result) {
        console.log('Aktualisiere Benutzerstatistiken mit neuem Ergebnis:', result);
        
        try {
            const userId = result.userId;
            
            // Benutzerstatistiken abrufen oder initialisieren
            let userStats = app.dataManager.getUserStatistics(userId);
            if (!userStats) {
                userStats = {
                    userId: userId,
                    testsCompleted: 0,
                    testsPassed: 0,
                    totalScore: 0,
                    totalMaxScore: 0,
                    averageScore: 0,
                    categories: {},
                    lastUpdated: new Date().toISOString()
                };
            }
            
            // Statistiken aktualisieren
            userStats.testsCompleted++;
            if (result.passed) {
                userStats.testsPassed++;
            }
            
            userStats.totalScore += result.score;
            userStats.totalMaxScore += result.maxScore;
            userStats.averageScore = Math.round((userStats.totalScore / userStats.totalMaxScore) * 100);
            userStats.lastUpdated = new Date().toISOString();
            
            // Kategoriestatistiken aktualisieren
            if (result.statistics && result.statistics.categoryPerformance) {
                Object.keys(result.statistics.categoryPerformance).forEach(category => {
                    const catPerf = result.statistics.categoryPerformance[category];
                    
                    if (!userStats.categories[category]) {
                        userStats.categories[category] = {
                            total: 0,
                            correct: 0,
                            score: 0
                        };
                    }
                    
                    userStats.categories[category].total += catPerf.total;
                    userStats.categories[category].correct += catPerf.correct;
                    userStats.categories[category].score = Math.round(
                        (userStats.categories[category].correct / userStats.categories[category].total) * 100
                    );
                });
            }
            
            // Speichere aktualisierte Statistiken
            app.dataManager.saveUserStatistics(userId, userStats);
            console.log('Benutzerstatistiken aktualisiert:', userStats);
        } catch (error) {
            console.error('Fehler bei der Aktualisierung der Benutzerstatistiken:', error);
        }
    };
    
    /**
     * Benachrichtigt Trainer über einen abgeschlossenen Test
     * @param {Object} result - Das Ergebnisobjekt
     */
    app.testCompletion.results.notifyTrainer = function(result) {
        console.log('Benachrichtige Trainer über abgeschlossenen Test:', result);
        
        try {
            // Benachrichtigung nur senden, wenn manuelle Bewertung erforderlich ist oder der Test nicht bestanden wurde
            const needsNotification = 
                result.evaluationStatus === 'pending' || 
                !result.passed || 
                result.scorePercentage < 70; // Auch benachrichtigen bei < 70%
                
            if (!needsNotification) {
                console.log('Keine Benachrichtigung erforderlich');
                return;
            }
            
            // Hole Team-ID des Benutzers
            const teamId = result.teamId;
            if (!teamId) {
                console.warn('Keine Team-ID für Benutzer gefunden');
                return;
            }
            
            // Finde Trainer für dieses Team
            const trainers = app.dataManager.getTrainersByTeamId(teamId);
            if (!trainers || trainers.length === 0) {
                console.warn('Keine Trainer für Team gefunden');
                return;
            }
            
            // Erstelle die Benachrichtigung
            const notification = {
                id: `notification_${Date.now()}_${result.id}`,
                type: 'test_completion',
                title: 'Test abgeschlossen',
                message: `${result.userName} hat den Test "${result.testTitle}" abgeschlossen.`,
                details: {
                    resultId: result.id,
                    testId: result.testId,
                    userId: result.userId,
                    score: `${result.score}/${result.maxScore} (${result.scorePercentage}%)`,
                    passed: result.passed,
                    requiresAction: result.evaluationStatus === 'pending',
                    timestamp: result.timestamp
                },
                status: 'unread',
                timestamp: new Date().toISOString(),
                priority: result.evaluationStatus === 'pending' ? 'high' : 'normal'
            };
            
            // Benachrichtigung an alle Trainer des Teams senden
            trainers.forEach(trainer => {
                app.dataManager.addNotification(trainer.id, notification);
                console.log(`Benachrichtigung an Trainer ${trainer.fullName} gesendet`);
            });
            
            // Event auslösen, um die UI zu aktualisieren, falls der Trainer eingeloggt ist
            const notificationEvent = new CustomEvent('newNotification', {
                detail: {
                    notification: notification
                }
            });
            document.dispatchEvent(notificationEvent);
            
            console.log('Trainer-Benachrichtigung erfolgreich gesendet');
        } catch (error) {
            console.error('Fehler beim Benachrichtigen der Trainer:', error);
        }
    };
    
    /**
     * Generiert einen Ergebnisbericht für das Dashboard
     * @param {Object} result - Das Ergebnisobjekt
     */
    app.testCompletion.results.generateResultReport = function(result) {
        console.log('Generiere Ergebnisbericht für Dashboard:', result);
        
        try {
            // Erstelle einen vereinfachten Bericht für das Dashboard
            const reportData = {
                id: `report_${result.id}`,
                type: 'test_result',
                title: `Testergebnis: ${result.testTitle}`,
                userId: result.userId,
                userName: result.userName,
                teamId: result.teamId,
                testId: result.testId,
                resultId: result.id,
                timestamp: result.timestamp,
                score: result.score,
                maxScore: result.maxScore,
                percentage: result.scorePercentage,
                passed: result.passed,
                summary: {
                    strengths: result.feedback && result.feedback.strengths ? 
                        result.feedback.strengths.map(s => s.category) : [],
                    weaknesses: result.feedback && result.feedback.weaknesses ? 
                        result.feedback.weaknesses.map(w => w.category) : [],
                    recommendations: result.feedback && result.feedback.recommendations ? 
                        result.feedback.recommendations.map(r => r.text) : []
                },
                charts: {
                    categoryPerformance: result.statistics && result.statistics.categoryPerformance ? 
                        Object.keys(result.statistics.categoryPerformance).map(cat => ({
                            category: cat,
                            score: result.statistics.categoryPerformance[cat].score
                        })) : []
                }
            };
            
            // Speichere den Bericht
            app.dataManager.saveResultReport(reportData);
            
            // Füge den Bericht zum Benutzer-Dashboard hinzu
            app.dataManager.addReportToUserDashboard(result.userId, reportData.id);
            
            // Füge den Bericht zum Team-Dashboard hinzu, falls ein Team existiert
            if (result.teamId) {
                app.dataManager.addReportToTeamDashboard(result.teamId, reportData.id);
            }
            
            console.log('Ergebnisbericht erfolgreich generiert und gespeichert');
            
            // Event auslösen, um das Dashboard zu aktualisieren
            const reportEvent = new CustomEvent('newReport', {
                detail: {
                    report: reportData
                }
            });
            document.dispatchEvent(reportEvent);
        } catch (error) {
            console.error('Fehler bei der Generierung des Ergebnisberichts:', error);
        }
    };
    
    /**
     * Aktualisiert ein Ergebnis mit manueller Bewertung
     * @param {Object} evaluationData - Daten der manuellen Bewertung
     * @return {Promise} - Promise mit dem aktualisierten Ergebnis
     */
    app.testCompletion.results.updateWithManualEvaluation = function(evaluationData) {
        console.log('Aktualisiere Ergebnis mit manueller Bewertung:', evaluationData);
        
        return new Promise((resolve, reject) => {
            try {
                if (!evaluationData || !evaluationData.resultId || !evaluationData.questionId) {
                    throw new Error('Unvollständige Bewertungsdaten');
                }
                
                // Lade das Ergebnis
                const result = app.dataManager.getTestResultById(evaluationData.resultId);
                if (!result) {
                    throw new Error(`Ergebnis mit ID ${evaluationData.resultId} nicht gefunden`);
                }
                
                // Aktueller Benutzer für die Prüfer-Informationen
                const currentUser = app.authentication.getCurrentUser();
                if (!currentUser || !app.permissions.hasPermission(currentUser.role, 'evaluate_tests')) {
                    throw new Error('Keine Berechtigung zur Bewertung von Tests');
                }
                
                // Aktualisiere die Antwortdaten im Ergebnis
                if (result.testData && result.testData.answers && result.testData.answers[evaluationData.questionId]) {
                    const answer = result.testData.answers[evaluationData.questionId];
                    answer.manualScore = evaluationData.score;
                    answer.manualComment = evaluationData.comment;
                    answer.evaluatedBy = currentUser.id;
                    answer.evaluationTimestamp = new Date().toISOString();
                }
                
                // Aktualisiere die Antwortübersicht
                if (result.answers && result.answers[evaluationData.questionId]) {
                    result.answers[evaluationData.questionId].manualScore = evaluationData.score;
                    result.answers[evaluationData.questionId].manualComment = evaluationData.comment;
                }
                
                // Aktualisiere die Gesamtpunktzahl
                const updatedScore = this.recalculateScore(result);
                result.score = updatedScore.score;
                result.scorePercentage = updatedScore.percentage;
                result.passed = updatedScore.passed;
                
                // Prüfe, ob alle manuellen Bewertungen abgeschlossen sind
                result.evaluationStatus = this.checkEvaluationStatus(result.testData);
                
                // Füge Informationen zum Prüfer hinzu, wenn die Bewertung vollständig ist
                if (result.evaluationStatus === 'complete') {
                    result.reviewedBy = currentUser.id;
                    result.reviewDate = new Date().toISOString();
                    
                    // Füge einen Kommentar hinzu, falls vorhanden
                    if (evaluationData.overallComment) {
                        result.comments.push({
                            userId: currentUser.id,
                            userName: currentUser.fullName,
                            timestamp: new Date().toISOString(),
                            text: evaluationData.overallComment
                        });
                    }
                }
                
                // Speichere das aktualisierte Ergebnis
                const updatedResult = app.dataManager.saveTestResult(result);
                
                // Aktualisiere die Benutzerstatistiken
                this.updateUserStatistics(updatedResult);
                
                // Sende eine Benachrichtigung an den Benutzer
                this.notifyUserAboutEvaluation(updatedResult, evaluationData);
                
                console.log('Manuelle Bewertung erfolgreich verarbeitet:', updatedResult);
                resolve(updatedResult);
            } catch (error) {
                console.error('Fehler bei der Verarbeitung der manuellen Bewertung:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Berechnet die Punktzahl eines Ergebnisses neu
     * @param {Object} result - Das zu aktualisierende Ergebnisobjekt
     * @return {Object} - Aktualisierte Punktzahlberechnung
     */
    app.testCompletion.results.recalculateScore = function(result) {
        let score = 0;
        const maxScore = result.maxScore;
        
        // Durchlaufe alle Antworten und sammle Punkte
        Object.keys(result.testData.answers).forEach(questionId => {
            const questionData = app.testSession.getQuestionById(questionId);
            const answerData = result.testData.answers[questionId];
            
            if (!questionData) return;
            
            const maxQuestionScore = questionData.points || 1;
            
            if (questionData.type === 'free_text' && !questionData.autoEvaluate) {
                // Bei manuell bewerteten Fragen: Verwende die manuelle Bewertung, falls vorhanden
                if (answerData.manualScore !== undefined) {
                    score += answerData.manualScore;
                }
            } else {
                // Bei automatisch bewerteten Fragen
                if (answerData.isCorrect === true) {
                    score += maxQuestionScore;
                } else if (answerData.partialScore !== undefined) {
                    score += answerData.partialScore * maxQuestionScore;
                }
            }
        });
        
        // Prozentsatz berechnen
        const percentage = maxScore > 0 ? Math.round((score / maxScore) * 100) : 0;
        
        // Bestanden/Nicht bestanden bestimmen
        const test = app.dataManager.getTestById(result.testId);
        const passingPercentage = test ? (test.passingScore || 60) : 60;
        const passed = percentage >= passingPercentage;
        
        return {
            score: score,
            maxScore: maxScore,
            percentage: percentage,
            passed: passed
        };
    };
    
    /**
     * Benachrichtigt den Benutzer über die Bewertung seines Tests
     * @param {Object} result - Das aktualisierte Ergebnisobjekt
     * @param {Object} evaluationData - Daten der manuellen Bewertung
     */
    app.testCompletion.results.notifyUserAboutEvaluation = function(result, evaluationData) {
        console.log('Benachrichtige Benutzer über Testbewertung:', result);
        
        try {
            // Erstelle eine Benachrichtigung für den Benutzer
            const notification = {
                id: `notification_eval_${Date.now()}_${result.id}`,
                type: 'test_evaluation',
                title: 'Test bewertet',
                message: `Ihr Test "${result.testTitle}" wurde bewertet.`,
                details: {
                    resultId: result.id,
                    testId: result.testId,
                    score: `${result.score}/${result.maxScore} (${result.scorePercentage}%)`,
                    passed: result.passed,
                    hasComment: evaluationData.comment ? true : false,
                    hasOverallComment: evaluationData.overallComment ? true : false
                },
                status: 'unread',
                timestamp: new Date().toISOString(),
                priority: 'normal'
            };
            
            // Benachrichtigung an den Benutzer senden
            app.dataManager.addNotification(result.userId, notification);
            
            // Event auslösen, um die UI zu aktualisieren, falls der Benutzer eingeloggt ist
            const notificationEvent = new CustomEvent('newNotification', {
                detail: {
                    notification: notification
                }
            });
            document.dispatchEvent(notificationEvent);
            
            console.log('Benutzer-Benachrichtigung erfolgreich gesendet');
        } catch (error) {
            console.error('Fehler beim Benachrichtigen des Benutzers:', error);
        }
    };
    
    // Füge die initialize-Methode zur öffentlichen Schnittstelle hinzu
    if (!app.testCompletion.interface) {
        app.testCompletion.interface = {};
    }
    
    app.testCompletion.interface.initializeResults = app.testCompletion.results.initialize.bind(app.testCompletion.results);
    
    console.log('Ergebnisübermittlung (Teil 1) initialisiert');
})();
/**
 * JS-Block 5.8.2-part2: Ergebnisübermittlung (Teil 2)
 * Erweiterte Funktionen für die Ergebnisverarbeitung, -analyse und -visualisierung
 */
(function() {
    // Namespace sicherstellen
    if (!app.testCompletion) {
        app.testCompletion = {};
    }
    
    if (!app.testCompletion.results) {
        app.testCompletion.results = {};
    }
    
    /**
     * Namespace für erweiterte Ergebnisanalyse und Berichtsfunktionen
     */
    app.testCompletion.results.analytics = {
        // Speichert berechnete Analysedaten
        cache: {},
        
        // Standardeinstellungen für die Datenanalyse
        settings: {
            trendPeriod: 90, // Tage für Trendanalyse
            minimumDataPoints: 3, // Mindestanzahl an Datenpunkten für valide Analysen
            comparisonThreshold: 5, // Prozent-Schwelle für signifikante Änderungen
            smoothingFactor: 0.2, // Glättungsfaktor für Zeitreihendaten
            excludeIncomplete: true // Unvollständige Tests von der Analyse ausschließen
        }
    };
    
    /**
     * Initialisiert die erweiterten Analysefunktionen
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testCompletion.results.analytics.initialize = function(options) {
        console.log('Initialisiere erweiterte Ergebnisanalyse mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            Object.assign(this.settings, options);
        }
        
        // Cache leeren
        this.cache = {};
        
        // Event-Listener für neue Ergebnisse
        document.addEventListener('testProcessed', (event) => {
            if (event.detail && event.detail.id) {
                console.log('Neues Testergebnis für Analyse erkannt:', event.detail.id);
                // Cache für diesen Nutzer zurücksetzen
                if (event.detail.userId) {
                    delete this.cache[`user_${event.detail.userId}`];
                }
                
                // Cache für das Team zurücksetzen, falls vorhanden
                if (event.detail.teamId) {
                    delete this.cache[`team_${event.detail.teamId}`];
                }
            }
        });
        
        console.log('Erweiterte Ergebnisanalyse initialisiert');
    };
    
    /**
     * Generiert eine Leistungsübersicht für einen Benutzer über mehrere Tests hinweg
     * @param {string} userId - Benutzer-ID
     * @param {Object} options - Filteroptionen (testTypes, categories, timeFrame)
     * @return {Object} - Übersicht über die Leistungstrends
     */
    app.testCompletion.results.analytics.getUserPerformanceOverview = function(userId, options = {}) {
        console.log(`Generiere Leistungsübersicht für Benutzer ${userId}:`, options);
        
        const cacheKey = `user_${userId}_overview_${JSON.stringify(options)}`;
        
        // Prüfe, ob Daten im Cache sind
        if (this.cache[cacheKey]) {
            console.log('Verwende gecachte Leistungsübersicht');
            return this.cache[cacheKey];
        }
        
        try {
            // Holen aller Testergebnisse des Benutzers
            const userResults = app.dataManager.getUserTestResults(userId);
            if (!userResults || userResults.length === 0) {
                throw new Error('Keine Testergebnisse für diesen Benutzer gefunden');
            }
            
            // Sortierte und gefilterte Ergebnisse
            let filteredResults = userResults.filter(result => {
                // Filtere nach Testart, falls angegeben
                if (options.testTypes && options.testTypes.length > 0) {
                    const test = app.dataManager.getTestById(result.testId);
                    if (!test || !options.testTypes.includes(test.type)) {
                        return false;
                    }
                }
                
                // Filtere nach Zeitraum, falls angegeben
                if (options.timeFrame) {
                    const resultDate = new Date(result.timestamp);
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - options.timeFrame);
                    
                    if (resultDate < startDate) {
                        return false;
                    }
                }
                
                // Filtere unvollständige Tests, falls eingestellt
                if (this.settings.excludeIncomplete && result.evaluationStatus === 'pending') {
                    return false;
                }
                
                return true;
            });
            
            filteredResults.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Basisstatistiken
            const overview = {
                userId: userId,
                userName: filteredResults[0]?.userName || 'Unbekannt',
                testsCompleted: filteredResults.length,
                testsPassed: filteredResults.filter(r => r.passed).length,
                averageScore: this._calculateAverage(filteredResults.map(r => r.scorePercentage)),
                bestScore: Math.max(...filteredResults.map(r => r.scorePercentage)),
                worstScore: Math.min(...filteredResults.map(r => r.scorePercentage)),
                improvement: 0, // Wird unten berechnet
                trend: 'stable', // Wird unten berechnet
                recentTests: filteredResults.slice(-5).map(r => ({
                    id: r.id,
                    testId: r.testId,
                    testTitle: r.testTitle,
                    timestamp: r.timestamp,
                    score: r.scorePercentage,
                    passed: r.passed
                })),
                categories: this._analyzeCategories(filteredResults),
                timeTrend: this._calculateTimeTrend(filteredResults),
                strengths: [],
                weaknesses: [],
                recommendations: []
            };
            
            // Berechne Verbesserung/Verschlechterung
            if (filteredResults.length >= 2) {
                const firstTests = filteredResults.slice(0, Math.min(3, Math.ceil(filteredResults.length / 3)));
                const lastTests = filteredResults.slice(-Math.min(3, Math.ceil(filteredResults.length / 3)));
                
                const firstAvg = this._calculateAverage(firstTests.map(r => r.scorePercentage));
                const lastAvg = this._calculateAverage(lastTests.map(r => r.scorePercentage));
                
                overview.improvement = Math.round(lastAvg - firstAvg);
                
                // Trend bestimmen
                if (overview.improvement > this.settings.comparisonThreshold) {
                    overview.trend = 'improving';
                } else if (overview.improvement < -this.settings.comparisonThreshold) {
                    overview.trend = 'declining';
                } else {
                    overview.trend = 'stable';
                }
            }
            
            // Stärken und Schwächen identifizieren
            const categories = overview.categories;
            const categoryNames = Object.keys(categories);
            
            // Sortiere Kategorien nach Leistung
            categoryNames.sort((a, b) => categories[b].averageScore - categories[a].averageScore);
            
            // Top 3 Stärken
            overview.strengths = categoryNames.slice(0, 3)
                .filter(cat => categories[cat].averageScore >= 70)
                .map(cat => ({
                    category: cat,
                    score: categories[cat].averageScore,
                    tests: categories[cat].tests
                }));
            
            // Bottom 3 Schwächen
            const reversedCategories = [...categoryNames].reverse();
            overview.weaknesses = reversedCategories.slice(0, 3)
                .filter(cat => categories[cat].averageScore < 70)
                .map(cat => ({
                    category: cat,
                    score: categories[cat].averageScore,
                    tests: categories[cat].tests
                }));
            
            // Empfehlungen generieren
            overview.recommendations = this._generateRecommendations(overview);
            
            // Speichere im Cache
            this.cache[cacheKey] = overview;
            console.log('Leistungsübersicht erfolgreich generiert:', overview);
            return overview;
        } catch (error) {
            console.error('Fehler bei der Generierung der Leistungsübersicht:', error);
            return {
                userId: userId,
                error: error.message,
                testsCompleted: 0,
                testsPassed: 0,
                averageScore: 0,
                trend: 'unknown',
                recentTests: []
            };
        }
    };
    
    /**
     * Berechnet einen Durchschnittswert für ein Array von Zahlen
     * @param {Array} values - Array von Zahlenwerten
     * @return {number} - Durchschnitt
     * @private
     */
    app.testCompletion.results.analytics._calculateAverage = function(values) {
        if (!values || values.length === 0) return 0;
        return Math.round(values.reduce((sum, val) => sum + val, 0) / values.length);
    };
    
    /**
     * Analysiert die Leistung nach Kategorien
     * @param {Array} results - Array von Testergebnissen
     * @return {Object} - Kategoriebasierte Leistungsanalyse
     * @private
     */
    app.testCompletion.results.analytics._analyzeCategories = function(results) {
        const categories = {};
        
        results.forEach(result => {
            if (result.statistics && result.statistics.categoryPerformance) {
                Object.keys(result.statistics.categoryPerformance).forEach(category => {
                    if (!categories[category]) {
                        categories[category] = {
                            tests: 0,
                            totalScore: 0,
                            averageScore: 0,
                            trend: 'stable',
                            recentScores: []
                        };
                    }
                    
                    const catPerf = result.statistics.categoryPerformance[category];
                    categories[category].tests++;
                    categories[category].totalScore += catPerf.score;
                    categories[category].recentScores.push({
                        timestamp: result.timestamp,
                        score: catPerf.score,
                        testId: result.testId
                    });
                });
            }
        });
        
        // Berechne Durchschnitt und Trend für jede Kategorie
        Object.keys(categories).forEach(category => {
            const cat = categories[category];
            cat.averageScore = Math.round(cat.totalScore / cat.tests);
            
            // Sortiere Scores nach Datum
            cat.recentScores.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Berechne Trend, wenn genügend Datenpunkte vorhanden sind
            if (cat.recentScores.length >= this.settings.minimumDataPoints) {
                const firstScores = cat.recentScores.slice(0, Math.min(2, Math.floor(cat.recentScores.length / 3)));
                const lastScores = cat.recentScores.slice(-Math.min(2, Math.floor(cat.recentScores.length / 3)));
                
                const firstAvg = this._calculateAverage(firstScores.map(s => s.score));
                const lastAvg = this._calculateAverage(lastScores.map(s => s.score));
                
                const improvement = lastAvg - firstAvg;
                
                if (improvement > this.settings.comparisonThreshold) {
                    cat.trend = 'improving';
                } else if (improvement < -this.settings.comparisonThreshold) {
                    cat.trend = 'declining';
                } else {
                    cat.trend = 'stable';
                }
            }
        });
        
        return categories;
    };
    
    /**
     * Berechnet den zeitlichen Trend der Leistung
     * @param {Array} results - Array von Testergebnissen
     * @return {Array} - Zeittrenddaten
     * @private
     */
    app.testCompletion.results.analytics._calculateTimeTrend = function(results) {
        if (results.length < 2) return [];
        
        // Sortiere Ergebnisse nach Datum
        const sortedResults = [...results].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Erstelle Datenpunkte für den Trend
        const trendData = sortedResults.map(result => ({
            timestamp: result.timestamp,
            formattedDate: new Date(result.timestamp).toLocaleDateString('de-DE'),
            score: result.scorePercentage,
            testTitle: result.testTitle,
            passed: result.passed
        }));
        
        // Wende exponentielles Glätten an, wenn mehr als 3 Datenpunkte vorhanden sind
        if (trendData.length > 3) {
            let smoothedScore = trendData[0].score;
            for (let i = 1; i < trendData.length; i++) {
                smoothedScore = this.settings.smoothingFactor * trendData[i].score + 
                                (1 - this.settings.smoothingFactor) * smoothedScore;
                trendData[i].smoothedScore = Math.round(smoothedScore);
            }
        }
        
        return trendData;
    };
    
    /**
     * Generiert personalisierte Empfehlungen basierend auf der Leistungsübersicht
     * @param {Object} overview - Leistungsübersicht
     * @return {Array} - Personalisierte Empfehlungen
     * @private
     */
    app.testCompletion.results.analytics._generateRecommendations = function(overview) {
        const recommendations = [];
        
        // Empfehlungen basierend auf Schwächen
        if (overview.weaknesses.length > 0) {
            overview.weaknesses.forEach(weakness => {
                // Suche nach Tests, die diese Kategorie abdecken und noch nicht absolviert wurden
                const testsInCategory = app.dataManager.getTestsByCategory(weakness.category) || [];
                const completedTestIds = overview.recentTests.map(test => test.testId);
                
                const recommendedTests = testsInCategory.filter(test => 
                    !completedTestIds.includes(test.id)
                ).slice(0, 2);
                
                if (recommendedTests.length > 0) {
                    recommendations.push({
                        type: 'category_improvement',
                        category: weakness.category,
                        currentScore: weakness.score,
                        message: `Verbessern Sie Ihre Kenntnisse in "${weakness.category}" (aktuell ${weakness.score}%).`,
                        recommendedTests: recommendedTests.map(test => ({
                            id: test.id,
                            title: test.title
                        }))
                    });
                }
            });
        }
        
        // Wiederholungsempfehlung, wenn Trend negativ ist
        if (overview.trend === 'declining') {
            recommendations.push({
                type: 'trend_reversal',
                message: 'Ihre Leistung hat in letzter Zeit abgenommen. Wir empfehlen eine Wiederholung der Grundlagen.'
            });
        }
        
        // Empfehlung zum Üben, wenn die Bestehensquote niedrig ist
        if (overview.testsCompleted > 3 && overview.testsPassed / overview.testsCompleted < 0.6) {
            recommendations.push({
                type: 'practice_more',
                message: 'Ihre Bestehensquote ist unter 60%. Regelmäßigeres Üben könnte Ihre Erfolgsquote verbessern.'
            });
        }
        
        // Empfehlung für nächsten Lernschritt, wenn Leistung gut ist
        if (overview.trend === 'improving' && overview.averageScore > 80) {
            recommendations.push({
                type: 'next_level',
                message: 'Großartige Fortschritte! Sie sind bereit für fortgeschrittenere Themen.'
            });
        }
        
        return recommendations;
    };
    
    /**
     * Generiert eine Teamleistungsanalyse
     * @param {string} teamId - Team-ID
     * @param {Object} options - Filteroptionen
     * @return {Object} - Teamleistungsanalyse
     */
    app.testCompletion.results.analytics.getTeamPerformanceAnalysis = function(teamId, options = {}) {
        console.log(`Generiere Teamleistungsanalyse für Team ${teamId}:`, options);
        
        const cacheKey = `team_${teamId}_analysis_${JSON.stringify(options)}`;
        
        // Prüfe, ob Daten im Cache sind
        if (this.cache[cacheKey]) {
            console.log('Verwende gecachte Teamleistungsanalyse');
            return this.cache[cacheKey];
        }
        
        try {
            // Hole alle Teammitglieder
            const teamMembers = app.dataManager.getTeamMembers(teamId);
            if (!teamMembers || teamMembers.length === 0) {
                throw new Error('Keine Teammitglieder gefunden');
            }
            
            // Sammle alle Ergebnisse aller Teammitglieder
            const allTeamResults = [];
            teamMembers.forEach(member => {
                const memberResults = app.dataManager.getUserTestResults(member.id);
                if (memberResults && memberResults.length > 0) {
                    allTeamResults.push(...memberResults);
                }
            });
            
            if (allTeamResults.length === 0) {
                throw new Error('Keine Testergebnisse für dieses Team gefunden');
            }
            
            // Filtere Ergebnisse basierend auf Optionen
            let filteredResults = allTeamResults.filter(result => {
                // Filtere nach Testart, falls angegeben
                if (options.testTypes && options.testTypes.length > 0) {
                    const test = app.dataManager.getTestById(result.testId);
                    if (!test || !options.testTypes.includes(test.type)) {
                        return false;
                    }
                }
                
                // Filtere nach Zeitraum, falls angegeben
                if (options.timeFrame) {
                    const resultDate = new Date(result.timestamp);
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - options.timeFrame);
                    
                    if (resultDate < startDate) {
                        return false;
                    }
                }
                
                // Filtere unvollständige Tests, falls eingestellt
                if (this.settings.excludeIncomplete && result.evaluationStatus === 'pending') {
                    return false;
                }
                
                return true;
            });
            
            // Sortiere nach Datum
            filteredResults.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Initialstruktur für die Analyse
            const analysis = {
                teamId: teamId,
                teamName: app.dataManager.getTeamById(teamId)?.name || 'Unbekanntes Team',
                memberCount: teamMembers.length,
                activeMembers: this._countActiveMembers(teamMembers, filteredResults),
                testsCompleted: filteredResults.length,
                averageScore: this._calculateAverage(filteredResults.map(r => r.scorePercentage)),
                passRate: filteredResults.filter(r => r.passed).length / filteredResults.length,
                memberPerformance: this._analyzeMemberPerformance(teamMembers, filteredResults),
                categoryPerformance: this._analyzeTeamCategories(filteredResults),
                timeTrend: this._calculateTeamTimeTrend(filteredResults),
                strengthAreas: [],
                improvementAreas: [],
                homogeneity: 0, // Wird unten berechnet
                recommendations: []
            };
            
            // Berechne Teamhomogenität (wie ähnlich sind die Leistungen der Mitglieder)
            if (analysis.memberPerformance.length > 1) {
                const scores = analysis.memberPerformance.map(m => m.averageScore);
                const variance = this._calculateVariance(scores);
                // Normalisierte Homogenität: 100 (perfekt homogen) bis 0 (sehr ungleich)
                analysis.homogeneity = Math.max(0, 100 - Math.sqrt(variance) / 1.5);
            }
            
            // Identifiziere Stärken und Schwächen des Teams
            const categories = analysis.categoryPerformance;
            const categoryNames = Object.keys(categories);
            
            // Sortiere Kategorien nach Leistung
            categoryNames.sort((a, b) => categories[b].averageScore - categories[a].averageScore);
            
            // Top 3 Stärken
            analysis.strengthAreas = categoryNames.slice(0, 3)
                .filter(cat => categories[cat].averageScore >= 70)
                .map(cat => ({
                    category: cat,
                    score: categories[cat].averageScore,
                    tests: categories[cat].tests
                }));
            
            // Bottom 3 Verbesserungsbereiche
            const reversedCategories = [...categoryNames].reverse();
            analysis.improvementAreas = reversedCategories.slice(0, 3)
                .filter(cat => categories[cat].averageScore < 70)
                .map(cat => ({
                    category: cat,
                    score: categories[cat].averageScore,
                    tests: categories[cat].tests
                }));
            
            // Generiere Teamempfehlungen
            analysis.recommendations = this._generateTeamRecommendations(analysis);
            
            // Speichere im Cache
            this.cache[cacheKey] = analysis;
            console.log('Teamleistungsanalyse erfolgreich generiert:', analysis);
            return analysis;
        } catch (error) {
            console.error('Fehler bei der Generierung der Teamleistungsanalyse:', error);
            return {
                teamId: teamId,
                error: error.message,
                memberCount: 0,
                activeMembers: 0,
                testsCompleted: 0,
                averageScore: 0,
                passRate: 0,
                memberPerformance: []
            };
        }
    };
    
    /**
     * Zählt die aktiven Teammitglieder (mit mindestens einem Testergebnis)
     * @param {Array} members - Teammitglieder
     * @param {Array} results - Testergebnisse
     * @return {number} - Anzahl aktiver Mitglieder
     * @private
     */
    app.testCompletion.results.analytics._countActiveMembers = function(members, results) {
        if (!members || !results) return 0;
        
        const activeUserIds = new Set();
        results.forEach(result => {
            activeUserIds.add(result.userId);
        });
        
        return activeUserIds.size;
    };
    
    /**
     * Berechnet die Varianz einer Reihe von Werten
     * @param {Array} values - Array von Zahlenwerten
     * @return {number} - Varianz
     * @private
     */
    app.testCompletion.results.analytics._calculateVariance = function(values) {
        if (!values || values.length < 2) return 0;
        
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const squareDiffs = values.map(value => {
            const diff = value - mean;
            return diff * diff;
        });
        
        return squareDiffs.reduce((sum, val) => sum + val, 0) / values.length;
    };
    
    /**
     * Analysiert die Leistung der einzelnen Teammitglieder
     * @param {Array} members - Teammitglieder
     * @param {Array} results - Testergebnisse
     * @return {Array} - Leistungsdaten pro Mitglied
     * @private
     */
    app.testCompletion.results.analytics._analyzeMemberPerformance = function(members, results) {
        const memberAnalysis = [];
        
        members.forEach(member => {
            const memberResults = results.filter(r => r.userId === member.id);
            
            if (memberResults.length > 0) {
                const recentResults = memberResults.slice(-5);
                
                memberAnalysis.push({
                    userId: member.id,
                    userName: member.fullName,
                    testsCompleted: memberResults.length,
                    testsPassed: memberResults.filter(r => r.passed).length,
                    averageScore: this._calculateAverage(memberResults.map(r => r.scorePercentage)),
                    trend: this._calculateMemberTrend(memberResults),
                    recentActivity: recentResults.map(r => ({
                        timestamp: r.timestamp,
                        testTitle: r.testTitle,
                        score: r.scorePercentage,
                        passed: r.passed
                    }))
                });
            }
        });
        
        // Sortiere nach Durchschnittspunktzahl (absteigend)
        memberAnalysis.sort((a, b) => b.averageScore - a.averageScore);
        
        return memberAnalysis;
    };
    
    /**
     * Berechnet den Trend für ein einzelnes Teammitglied
     * @param {Array} results - Testergebnisse des Mitglieds
     * @return {string} - Trendrichtung ('improving', 'declining', 'stable')
     * @private
     */
    app.testCompletion.results.analytics._calculateMemberTrend = function(results) {
        if (results.length < this.settings.minimumDataPoints) return 'stable';
        
        // Sortiere nach Datum
        const sortedResults = [...results].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Vergleiche erste und letzte Ergebnisse
        const firstTests = sortedResults.slice(0, Math.min(3, Math.ceil(sortedResults.length / 3)));
        const lastTests = sortedResults.slice(-Math.min(3, Math.ceil(sortedResults.length / 3)));
        
        const firstAvg = this._calculateAverage(firstTests.map(r => r.scorePercentage));
        const lastAvg = this._calculateAverage(lastTests.map(r => r.scorePercentage));
        
        const improvement = lastAvg - firstAvg;
        
        if (improvement > this.settings.comparisonThreshold) {
            return 'improving';
        } else if (improvement < -this.settings.comparisonThreshold) {
            return 'declining';
        } else {
            return 'stable';
        }
    };
    
    /**
     * Analysiert die Teamleistung nach Kategorien
     * @param {Array} results - Testergebnisse
     * @return {Object} - Kategoriebasierte Teamleistung
     * @private
     */
    app.testCompletion.results.analytics._analyzeTeamCategories = function(results) {
        const categories = {};
        
        results.forEach(result => {
            if (result.statistics && result.statistics.categoryPerformance) {
                Object.keys(result.statistics.categoryPerformance).forEach(category => {
                    if (!categories[category]) {
                        categories[category] = {
                            tests: 0,
                            totalScore: 0,
                            averageScore: 0,
                            memberCount: 0,
                            memberIds: new Set(),
                            trend: 'stable',
                            scores: []
                        };
                    }
                    
                    const catPerf = result.statistics.categoryPerformance[category];
                    categories[category].tests++;
                    categories[category].totalScore += catPerf.score;
                    categories[category].memberIds.add(result.userId);
                    categories[category].scores.push({
                        timestamp: result.timestamp,
                        score: catPerf.score,
                        userId: result.userId
                    });
                });
            }
        });
        
        // Finalisiere Berechnungen für jede Kategorie
        Object.keys(categories).forEach(category => {
            const cat = categories[category];
            cat.averageScore = Math.round(cat.totalScore / cat.tests);
            cat.memberCount = cat.memberIds.size;
            cat.memberIds = Array.from(cat.memberIds); // Konvertiere Set zurück zu Array
            
            // Sortiere Scores nach Datum
            cat.scores.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Berechne Trend, wenn genügend Datenpunkte vorhanden sind
            if (cat.scores.length >= this.settings.minimumDataPoints) {
                const firstScores = cat.scores.slice(0, Math.min(3, Math.floor(cat.scores.length / 3)));
                const lastScores = cat.scores.slice(-Math.min(3, Math.floor(cat.scores.length / 3)));
                
                const firstAvg = this._calculateAverage(firstScores.map(s => s.score));
                const lastAvg = this._calculateAverage(lastScores.map(s => s.score));
                
                const improvement = lastAvg - firstAvg;
                
                if (improvement > this.settings.comparisonThreshold) {
                    cat.trend = 'improving';
                } else if (improvement < -this.settings.comparisonThreshold) {
                    cat.trend = 'declining';
                } else {
                    cat.trend = 'stable';
                }
            }
        });
        
        return categories;
    };
    
    /**
     * Berechnet den zeitlichen Trend der Teamleistung
     * @param {Array} results - Testergebnisse
     * @return {Array} - Zeittrenddaten
     * @private
     */
    app.testCompletion.results.analytics._calculateTeamTimeTrend = function(results) {
        if (results.length < 2) return [];
        
        // Gruppiere Ergebnisse nach Woche
        const weeklyData = {};
        
        results.forEach(result => {
            const date = new Date(result.timestamp);
            const weekKey = `${date.getFullYear()}-W${this._getWeekNumber(date)}`;
            
            if (!weeklyData[weekKey]) {
                weeklyData[weekKey] = {
                    weekLabel: this._formatWeekLabel(date),
                    scores: [],
                    tests: 0,
                    uniqueUsers: new Set()
                };
            }
            
            weeklyData[weekKey].scores.push(result.scorePercentage);
            weeklyData[weekKey].tests++;
            weeklyData[weekKey].uniqueUsers.add(result.userId);
        });
        
        // Konvertiere in Array und berechne Durchschnitte
        const trendData = Object.keys(weeklyData)
            .sort() // Sortiere nach Woche
            .map(week => {
                const data = weeklyData[week];
                return {
                    weekLabel: data.weekLabel,
                    averageScore: this._calculateAverage(data.scores),
                    testsCount: data.tests,
                    activeUsers: data.uniqueUsers.size
                };
            });
        
        return trendData;
    };
    
    /**
     * Ermittelt die Kalenderwoche für ein Datum
     * @param {Date} date - Datumsobjekt
     * @return {number} - Kalenderwoche
     * @private
     */
    app.testCompletion.results.analytics._getWeekNumber = function(date) {
        const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
        const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
        return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
    };
    
    /**
     * Formatiert ein Wochenlabel für die Anzeige
     * @param {Date} date - Datumsobjekt innerhalb der Woche
     * @return {string} - Formatiertes Wochenlabel
     * @private
     */
    app.testCompletion.results.analytics._formatWeekLabel = function(date) {
        // Finde den ersten Tag der Woche (Montag)
        const dayOfWeek = date.getDay() || 7; // Konvertiert 0 (Sonntag) zu 7
        const mondayDate = new Date(date);
        mondayDate.setDate(date.getDate() - dayOfWeek + 1);
        
        // Finde den letzten Tag der Woche (Sonntag)
        const sundayDate = new Date(mondayDate);
        sundayDate.setDate(mondayDate.getDate() + 6);
        
        // Formatiere das Label
        const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
        
        if (mondayDate.getMonth() === sundayDate.getMonth()) {
            // Gleicher Monat
            return `${mondayDate.getDate()}-${sundayDate.getDate()}. ${monthNames[mondayDate.getMonth()]}`;
        } else {
            // Unterschiedliche Monate
            return `${mondayDate.getDate()}. ${monthNames[mondayDate.getMonth()]} - ${sundayDate.getDate()}. ${monthNames[sundayDate.getMonth()]}`;
        }
    };
    
    /**
     * Generiert Empfehlungen für das Team
     * @param {Object} analysis - Teamanalyse
     * @return {Array} - Teamempfehlungen
     * @private
     */
    app.testCompletion.results.analytics._generateTeamRecommendations = function(analysis) {
        const recommendations = [];
        
        // Empfehlungen basierend auf Verbesserungsbereichen
        if (analysis.improvementAreas.length > 0) {
            analysis.improvementAreas.forEach(area => {
                recommendations.push({
                    type: 'team_improvement',
                    category: area.category,
                    message: `Das Team sollte gemeinsam an "${area.category}" arbeiten (aktuell ${area.score}%).`,
                    priority: area.score < 60 ? 'high' : 'medium'
                });
            });
        }
        
        // Homogenitätsempfehlungen
        if (analysis.homogeneity < 60) {
            recommendations.push({
                type: 'team_homogeneity',
                message: 'Die Leistungsunterschiede im Team sind signifikant. Peer-Learning könnte allen Teammitgliedern helfen.',
                priority: 'medium'
            });
            
            // Identifiziere Teammitglieder mit niedrigen Ergebnissen
            const lowPerformers = analysis.memberPerformance.filter(m => m.averageScore < 60);
            if (lowPerformers.length > 0) {
                recommendations.push({
                    type: 'low_performers',
                    message: `${lowPerformers.length} Teammitglieder benötigen zusätzliche Unterstützung, um den Anschluss nicht zu verlieren.`,
                    memberCount: lowPerformers.length,
                    priority: 'high'
                });
            }
        }
        
        // Empfehlung zur Aktivierung inaktiver Mitglieder
        if (analysis.activeMembers < analysis.memberCount) {
            const inactiveCount = analysis.memberCount - analysis.activeMembers;
            recommendations.push({
                type: 'inactive_members',
                message: `${inactiveCount} Teammitglieder haben noch keine Tests abgeschlossen.`,
                inactiveCount: inactiveCount,
                priority: 'medium'
            });
        }
        
        // Empfehlung für fortgeschrittene Themen, wenn die Teamleistung hoch ist
        if (analysis.averageScore > 80 && analysis.passRate > 0.8) {
            recommendations.push({
                type: 'advanced_topics',
                message: 'Das Team ist bereit für fortgeschrittenere Themen und Herausforderungen.',
                priority: 'low'
            });
        }
        
        return recommendations;
    };
    
    /**
     * Generiert Visualisierungsdaten für die UI
     * @param {string} resultId - ID des Ergebnisses
     * @return {Object} - Visualisierungsdaten
     */
    app.testCompletion.results.analytics.generateVisualizationData = function(resultId) {
        console.log(`Generiere Visualisierungsdaten für Ergebnis ${resultId}`);
        
        try {
            // Lade das Ergebnis
            const result = app.dataManager.getTestResultById(resultId);
            if (!result) {
                throw new Error(`Ergebnis mit ID ${resultId} nicht gefunden`);
            }
            
            // Basis-Visualisierungsdaten
            const visualData = {
                testId: result.testId,
                testTitle: result.testTitle,
                userId: result.userId,
                userName: result.userName,
                timestamp: result.timestamp,
                score: result.score,
                maxScore: result.maxScore,
                percentage: result.scorePercentage,
                passed: result.passed,
                requiredScore: result.requiredScore,
                charts: {}
            };
            
            // Kreisdiagramm: Korrekt vs. Inkorrekt vs. Übersprungen
            if (result.statistics) {
                visualData.charts.answerDistribution = {
                    type: 'pie',
                    data: [
                        { label: 'Korrekt', value: result.statistics.answeredCorrectly || 0, color: '#4CAF50' },
                        { label: 'Inkorrekt', value: result.statistics.answeredIncorrectly || 0, color: '#F44336' },
                        { label: 'Übersprungen', value: result.statistics.skipped || 0, color: '#9E9E9E' }
                    ]
                };
            }
            
            // Balkendiagramm: Kategorieperformance
            if (result.statistics && result.statistics.categoryPerformance) {
                const categoryData = [];
                
                Object.keys(result.statistics.categoryPerformance).forEach(category => {
                    const catPerf = result.statistics.categoryPerformance[category];
                    categoryData.push({
                        category: category,
                        score: catPerf.score,
                        color: this._getColorForScore(catPerf.score)
                    });
                });
                
                // Sortiere nach Punktzahl
                categoryData.sort((a, b) => b.score - a.score);
                
                visualData.charts.categoryPerformance = {
                    type: 'bar',
                    data: categoryData
                };
            }
            
            // Radarchart: Stärken und Schwächen
            if (result.statistics && result.statistics.categoryPerformance) {
                const radarData = {
                    labels: [],
                    values: [],
                    colors: []
                };
                
                Object.keys(result.statistics.categoryPerformance).forEach(category => {
                    const catPerf = result.statistics.categoryPerformance[category];
                    radarData.labels.push(category);
                    radarData.values.push(catPerf.score);
                    radarData.colors.push(this._getColorForScore(catPerf.score));
                });
                
                visualData.charts.strengthsWeaknesses = {
                    type: 'radar',
                    data: radarData
                };
            }
            
            // Liniendiagramm: Vergleich mit früheren Tests
            const userResults = app.dataManager.getUserTestResults(result.userId) || [];
            if (userResults.length > 1) {
                const timelineData = userResults
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                    .map(r => ({
                        date: new Date(r.timestamp).toLocaleDateString('de-DE'),
                        score: r.scorePercentage,
                        testTitle: r.testTitle.substring(0, 20) + (r.testTitle.length > 20 ? '...' : ''),
                        current: r.id === resultId
                    }));
                
                visualData.charts.performanceTimeline = {
                    type: 'line',
                    data: timelineData
                };
            }
            
            console.log('Visualisierungsdaten erfolgreich generiert:', visualData);
            return visualData;
        } catch (error) {
            console.error('Fehler bei der Generierung der Visualisierungsdaten:', error);
            return {
                error: error.message,
                charts: {}
            };
        }
    };
    
    /**
     * Bestimmt eine Farbe basierend auf der Punktzahl
     * @param {number} score - Punktzahl (0-100)
     * @return {string} - HEX-Farbcode
     * @private
     */
    app.testCompletion.results.analytics._getColorForScore = function(score) {
        if (score >= 90) return '#00C853'; // A - Grün
        if (score >= 80) return '#00E676'; // B - Hellgrün
        if (score >= 70) return '#FFCA28'; // C - Gelb
        if (score >= 60) return '#FFA726'; // D - Orange
        return '#EF5350'; // F - Rot
    };
    
    /**
     * Exportiert Ergebnisdaten in verschiedene Formate
     * @param {string} resultId - ID des Ergebnisses
     * @param {string} format - Exportformat ('json', 'csv', 'pdf')
     * @return {Promise<string|Blob>} - Exportierte Daten als String oder Blob
     */
    app.testCompletion.results.exportResult = function(resultId, format = 'json') {
        console.log(`Exportiere Ergebnis ${resultId} im Format ${format}`);
        
        return new Promise((resolve, reject) => {
            try {
                // Lade das Ergebnis
                const result = app.dataManager.getTestResultById(resultId);
                if (!result) {
                    throw new Error(`Ergebnis mit ID ${resultId} nicht gefunden`);
                }
                
                switch (format.toLowerCase()) {
                    case 'json':
                        // JSON-Export
                        const jsonData = JSON.stringify(result, null, 2);
                        resolve(jsonData);
                        break;
                        
                    case 'csv':
                        // CSV-Export (Vereinfachte Daten)
                        const csvData = this._resultToCSV(result);
                        resolve(csvData);
                        break;
                        
                    case 'pdf':
                        // PDF ist in der aktuellen Implementierung nicht unterstützt
                        // Verwenden wir stattdessen die Druckfunktion
                        throw new Error('PDF-Export wird nicht unterstützt. Bitte verwenden Sie die Druckfunktion.');
                        
                    default:
                        throw new Error(`Unbekanntes Exportformat: ${format}`);
                }
            } catch (error) {
                console.error('Fehler beim Exportieren des Ergebnisses:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Konvertiert ein Ergebnisobjekt in CSV-Format
     * @param {Object} result - Ergebnisobjekt
     * @return {string} - CSV-Daten
     * @private
     */
    app.testCompletion.results._resultToCSV = function(result) {
        // Basisinformationen
        let csv = `Kategorie,Wert\n`;
        csv += `Test,${this._escapeCSV(result.testTitle)}\n`;
        csv += `Benutzer,${this._escapeCSV(result.userName)}\n`;
        csv += `Datum,${new Date(result.timestamp).toLocaleDateString('de-DE')}\n`;
        csv += `Punktzahl,${result.score} / ${result.maxScore}\n`;
        csv += `Prozent,${result.scorePercentage}%\n`;
        csv += `Status,${result.passed ? 'Bestanden' : 'Nicht bestanden'}\n\n`;
        
        // Kategoriedaten, falls vorhanden
        if (result.statistics && result.statistics.categoryPerformance) {
            csv += `Kategorie,Korrekt,Gesamt,Prozent\n`;
            
            Object.keys(result.statistics.categoryPerformance).forEach(category => {
                const catPerf = result.statistics.categoryPerformance[category];
                csv += `${this._escapeCSV(category)},${catPerf.correct},${catPerf.total},${catPerf.score}%\n`;
            });
            
            csv += `\n`;
        }
        
        // Fragen und Antworten, falls vorhanden
        if (result.answers) {
            csv += `Frage,Typ,Korrekt,Punkte,Max. Punkte\n`;
            
            Object.keys(result.answers).forEach(questionId => {
                const answer = result.answers[questionId];
                csv += `${this._escapeCSV(answer.questionText)},${answer.questionType},`;
                csv += `${answer.isCorrect ? 'Ja' : 'Nein'},${answer.points},${answer.maxPoints}\n`;
            });
        }
        
        return csv;
    };
    
    /**
     * Escaped einen String für CSV-Format
     * @param {string} str - Zu escapender String
     * @return {string} - Escapeted String
     * @private
     */
    app.testCompletion.results._escapeCSV = function(str) {
        if (typeof str !== 'string') return str;
        
        // Wenn der String Kommas, Anführungszeichen oder Zeilenumbrüche enthält, in Anführungszeichen einschließen
        // und enthaltene Anführungszeichen verdoppeln
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    };
    
    /**
     * Erweitert die initialize-Methode der Ergebnisübermittlung
     */
    const originalInitialize = app.testCompletion.results.initialize || function() {};
    app.testCompletion.results.initialize = function(options) {
        // Rufe die ursprüngliche Initialisierungsmethode auf
        originalInitialize.call(this, options);
        
        // Initialisiere die Analysekomponente
        this.analytics.initialize(options);
        
        console.log('Erweiterte Ergebnisübermittlung initialisiert');
        
        // Erweitere die Event-Listener für den Export
        document.addEventListener('exportResult', function(event) {
            if (event.detail && event.detail.resultId) {
                console.log('Export-Event empfangen:', event.detail);
                
                app.testCompletion.results.exportResult(event.detail.resultId, event.detail.format || 'json')
                    .then(data => {
                        // Benachrichtige den Aufrufer über erfolgreichen Export
                        const exportCompletedEvent = new CustomEvent('exportCompleted', {
                            detail: {
                                resultId: event.detail.resultId,
                                format: event.detail.format || 'json',
                                data: data
                            }
                        });
                        document.dispatchEvent(exportCompletedEvent);
                    })
                    .catch(error => {
                        console.error('Fehler beim Export:', error);
                        // Benachrichtige den Aufrufer über fehlgeschlagenen Export
                        const exportErrorEvent = new CustomEvent('exportError', {
                            detail: {
                                resultId: event.detail.resultId,
                                format: event.detail.format || 'json',
                                error: error.message
                            }
                        });
                        document.dispatchEvent(exportErrorEvent);
                    });
            }
        });
    };
    
    // Öffentliche Schnittstelle erweitern
    if (!app.testCompletion.interface) {
        app.testCompletion.interface = {};
    }
    
    // Füge die neuen Funktionen zur öffentlichen Schnittstelle hinzu
    Object.assign(app.testCompletion.interface, {
        getUserPerformanceOverview: app.testCompletion.results.analytics.getUserPerformanceOverview.bind(app.testCompletion.results.analytics),
        getTeamPerformanceAnalysis: app.testCompletion.results.analytics.getTeamPerformanceAnalysis.bind(app.testCompletion.results.analytics),
        generateVisualizationData: app.testCompletion.results.analytics.generateVisualizationData.bind(app.testCompletion.results.analytics),
        exportResult: app.testCompletion.results.exportResult.bind(app.testCompletion.results)
    });
    
    console.log('Ergebnisübermittlung (Teil 2) initialisiert');
})();

/**
 * JS-Block 6.1.1-part1: Auswertungsalgorithmen (Teil 1.1)
 * 
 * Dieser Block implementiert die Algorithmen zur automatischen Auswertung von Testantworten.
 * Er enthält Funktionen zur Bewertung verschiedener Fragetypen, zur Berechnung von Punkten
 * und zur Erstellung von detaillierten Auswertungsberichten.
 */
(function() {
    // Namespace sicherstellen
    if (!app.testEvaluation) {
        app.testEvaluation = {};
    }
    
    // Konfiguration für die Auswertung
    app.testEvaluation.config = {
        // Minimale Ähnlichkeit für Freitext-Antworten (0 bis 1)
        textSimilarityThreshold: 0.75,
        
        // Ob Teilpunkte für teilweise korrekte Antworten vergeben werden sollen
        allowPartialScoring: true,
        
        // Anzahl der Nachkommastellen für Punktewerte
        scoreDecimalPlaces: 2,
        
        // Ob die Groß- und Kleinschreibung bei der Auswertung berücksichtigt werden soll
        caseSensitiveEvaluation: false,
        
        // Ob Leerzeichen bei der Auswertung von Freitext-Antworten ignoriert werden sollen
        ignoreWhitespaceInText: true,
        
        // Ob die Interpunktion bei der Auswertung von Freitext-Antworten ignoriert werden soll
        ignoreInterpunctionInText: true,
        
        // Toleranz für numerische Antworten (in Prozent, z.B. 0.05 für 5%)
        numericTolerance: 0.05
    };
    
    /**
     * Initialisiert das Auswertungsmodul
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testEvaluation.initialize = function(options) {
        console.log('Initialisiere automatische Testauswertung mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            Object.assign(this.config, options);
        }
        
        // Event-Listener für abgeschlossene Tests
        document.addEventListener('testSubmitted', (event) => {
            if (event.detail && event.detail.testId) {
                console.log('Test eingereicht, starte automatische Auswertung:', event.detail.testId);
                this.evaluateTest(event.detail.testId, event.detail.userId);
            }
        });
        
        console.log('Automatische Testauswertung initialisiert');
    };
    
    /**
     * Führt die automatische Auswertung für einen abgeschlossenen Test durch
     * @param {string} testId - ID des auszuwertenden Tests
     * @param {string} userId - ID des Benutzers, der den Test durchgeführt hat
     * @return {Promise<Object>} - Promise mit dem Auswertungsergebnis
     */
    app.testEvaluation.evaluateTest = function(testId, userId) {
        console.log(`Werte Test ${testId} für Benutzer ${userId} aus`);
        
        return new Promise((resolve, reject) => {
            try {
                // Lade Testdaten und Antworten
                const testSession = app.testSession.getSession(testId, userId);
                if (!testSession) {
                    throw new Error(`Keine Testsitzung für Test ${testId} und Benutzer ${userId} gefunden`);
                }
                
                // Lade Test-Informationen
                const test = app.dataManager.getTestById(testId);
                if (!test) {
                    throw new Error(`Test mit ID ${testId} nicht gefunden`);
                }
                
                // Vorbereitung des Ergebnisobjekts
                const evaluationResult = {
                    testId: testId,
                    userId: userId,
                    timestamp: new Date().toISOString(),
                    totalScore: 0,
                    maxScore: 0,
                    percentageScore: 0,
                    passed: false,
                    passingThreshold: test.passingScore || 60,
                    duration: testSession.duration || 0,
                    questionResults: {},
                    needsManualEvaluation: false,
                    statistics: {
                        correctAnswers: 0,
                        partiallyCorrectAnswers: 0,
                        incorrectAnswers: 0,
                        unansweredQuestions: 0,
                        categoriesPerformance: {}
                    }
                };
                
                // Extrahiere Antworten aus der Testsitzung
                const answers = testSession.answers || {};
                
                // Zähle die Gesamtzahl der Fragen
                const totalQuestions = Object.keys(test.questions || {}).length;
                const answeredQuestions = Object.keys(answers).length;
                
                // Überprüfe auf unbeantwortete Fragen
                if (answeredQuestions < totalQuestions) {
                    evaluationResult.statistics.unansweredQuestions = totalQuestions - answeredQuestions;
                }
                
                // Jede Antwort auswerten
                const evaluationPromises = [];
                
                Object.keys(test.questions || {}).forEach(questionId => {
                    // Frage abrufen
                    const question = app.dataManager.getQuestionById(questionId);
                    if (!question) {
                        console.warn(`Frage mit ID ${questionId} nicht gefunden`);
                        return;
                    }
                    
                    // Maximale Punktzahl zur Gesamtpunktzahl hinzufügen
                    const maxPoints = question.points || 1;
                    evaluationResult.maxScore += maxPoints;
                    
                    // Antwort abrufen
                    const userAnswer = answers[questionId];
                    
                    if (!userAnswer) {
                        // Keine Antwort gegeben
                        evaluationResult.questionResults[questionId] = {
                            questionId: questionId,
                            questionType: question.type,
                            answered: false,
                            score: 0,
                            maxScore: maxPoints,
                            isCorrect: false,
                            autoEvaluated: true
                        };
                        return;
                    }
                    
                    // Erstelle ein Promise für die Auswertung dieser Frage
                    const evaluationPromise = this.evaluateQuestion(question, userAnswer)
                        .then(result => {
                            // Speichere das Ergebnis dieser Frage
                            evaluationResult.questionResults[questionId] = {
                                questionId: questionId,
                                questionType: question.type,
                                answered: true,
                                score: result.score,
                                maxScore: maxPoints,
                                isCorrect: result.isCorrect,
                                autoEvaluated: result.autoEvaluated,
                                needsManualEvaluation: result.needsManualEvaluation,
                                feedback: result.feedback
                            };
                            
                            // Aktualisiere Gesamtpunktzahl und Statistiken
                            evaluationResult.totalScore += result.score;
                            
                            // Aktualisiere Kategorie-Statistiken
                            if (question.category) {
                                if (!evaluationResult.statistics.categoriesPerformance[question.category]) {
                                    evaluationResult.statistics.categoriesPerformance[question.category] = {
                                        total: 0,
                                        score: 0,
                                        maxScore: 0
                                    };
                                }
                                
                                const catStat = evaluationResult.statistics.categoriesPerformance[question.category];
                                catStat.total++;
                                catStat.score += result.score;
                                catStat.maxScore += maxPoints;
                            }
                            
                            // Aktualisiere allgemeine Statistiken
                            if (result.isCorrect === true) {
                                evaluationResult.statistics.correctAnswers++;
                            } else if (result.score > 0) {
                                evaluationResult.statistics.partiallyCorrectAnswers++;
                            } else {
                                evaluationResult.statistics.incorrectAnswers++;
                            }
                            
                            // Prüfe, ob manuelle Auswertung nötig ist
                            if (result.needsManualEvaluation) {
                                evaluationResult.needsManualEvaluation = true;
                            }
                            
                            return result;
                        });
                    
                    evaluationPromises.push(evaluationPromise);
                });
                
                // Warte, bis alle Fragen ausgewertet wurden
                Promise.all(evaluationPromises)
                    .then(() => {
                        // Berechne Prozentsatz und Bestanden/Nicht bestanden
                        if (evaluationResult.maxScore > 0) {
                            evaluationResult.percentageScore = Number(
                                (evaluationResult.totalScore / evaluationResult.maxScore * 100).toFixed(2)
                            );
                        }
                        
                        evaluationResult.passed = evaluationResult.percentageScore >= evaluationResult.passingThreshold;
                        
                        // Berechne Prozentsätze für jede Kategorie
                        Object.keys(evaluationResult.statistics.categoriesPerformance).forEach(category => {
                            const catStat = evaluationResult.statistics.categoriesPerformance[category];
                            if (catStat.maxScore > 0) {
                                catStat.percentage = Number(
                                    (catStat.score / catStat.maxScore * 100).toFixed(2)
                                );
                            } else {
                                catStat.percentage = 0;
                            }
                        });
                        
                        // Ergebnisverarbeitung abschließen
                        this.finalizeEvaluation(evaluationResult)
                            .then(finalResult => {
                                // Event für abgeschlossene Auswertung auslösen
                                const evaluationEvent = new CustomEvent('testEvaluated', {
                                    detail: finalResult
                                });
                                document.dispatchEvent(evaluationEvent);
                                
                                console.log('Automatische Auswertung abgeschlossen:', finalResult);
                                resolve(finalResult);
                            })
                            .catch(error => {
                                console.error('Fehler bei der Fertigstellung der Auswertung:', error);
                                reject(error);
                            });
                    })
                    .catch(error => {
                        console.error('Fehler bei der Auswertung der Fragen:', error);
                        reject(error);
                    });
            } catch (error) {
                console.error('Fehler bei der Testauswertung:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Wertet eine einzelne Frage aus
     * @param {Object} question - Die Fragedaten
     * @param {Object|Array} userAnswer - Die Antwort des Benutzers
     * @return {Promise<Object>} - Promise mit dem Auswertungsergebnis
     */
    app.testEvaluation.evaluateQuestion = function(question, userAnswer) {
        console.log(`Werte Frage ${question.id} aus, Typ: ${question.type}`);
        
        return new Promise((resolve) => {
            try {
                // Standardergebnis für den Fall, dass keine spezifische Auswertungsmethode gefunden wird
                const defaultResult = {
                    score: 0,
                    maxScore: question.points || 1,
                    isCorrect: false,
                    autoEvaluated: false,
                    needsManualEvaluation: true,
                    feedback: 'Keine passende Auswertungsmethode gefunden'
                };
                
                // Je nach Fragetyp die entsprechende Auswertungsmethode wählen
                switch (question.type) {
                    case 'multiple-choice':
                        resolve(this.evaluateMultipleChoice(question, userAnswer));
                        break;
                        
                    case 'single-choice':
                        resolve(this.evaluateSingleChoice(question, userAnswer));
                        break;
                        
                    case 'true-false':
                        resolve(this.evaluateTrueFalse(question, userAnswer));
                        break;
                        
                    case 'free-text':
                        // Prüfen, ob automatische Auswertung für Freitext aktiviert ist
                        if (question.autoEvaluate) {
                            resolve(this.evaluateFreeText(question, userAnswer));
                        } else {
                            // Freitext-Frage, die manuelle Bewertung erfordert
                            resolve({
                                score: 0,
                                maxScore: question.points || 1,
                                isCorrect: null, // Unbekannt, bis manuell bewertet
                                autoEvaluated: false,
                                needsManualEvaluation: true,
                                feedback: 'Diese Antwort erfordert eine manuelle Bewertung'
                            });
                        }
                        break;
                        
                    default:
                        console.warn(`Unbekannter Fragetyp für Auswertung: ${question.type}`);
                        resolve(defaultResult);
                }
            } catch (error) {
                console.error(`Fehler bei der Auswertung der Frage ${question.id}:`, error);
                
                // Bei Fehlern ein Ergebnis mit 0 Punkten zurückgeben
                resolve({
                    score: 0,
                    maxScore: question.points || 1,
                    isCorrect: false,
                    autoEvaluated: false,
                    needsManualEvaluation: true,
                    feedback: `Fehler bei der Auswertung: ${error.message}`
                });
            }
        });
    };
    
    /**
     * Wertet eine Multiple-Choice-Frage aus
     * @param {Object} question - Die Fragedaten
     * @param {Array} userAnswer - Die Antwort des Benutzers (Array von Optionsindizes)
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateMultipleChoice = function(question, userAnswer) {
        console.log('Werte Multiple-Choice-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Sicherstellen, dass userAnswer ein Array ist
            if (!Array.isArray(userAnswer)) {
                console.warn('Multiple-Choice-Antwort ist kein Array:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Keine Antwort ausgewählt
            if (userAnswer.length === 0) {
                result.feedback = 'Keine Antwort ausgewählt';
                return result;
            }
            
            // Korrekte Antwortoptionen bestimmen
            const correctOptionIndices = question.options
                .map((option, index) => option.isCorrect ? index : -1)
                .filter(index => index !== -1);
            
            // Alle korrekten Optionen müssen ausgewählt sein
            const allCorrectOptionsSelected = correctOptionIndices.every(index => 
                userAnswer.includes(index));
                
            // Keine falschen Optionen dürfen ausgewählt sein
            const noIncorrectOptionsSelected = userAnswer.every(index => 
                correctOptionIndices.includes(index));
            
            // Vollständig korrekt: Alle richtigen Optionen ausgewählt und keine falschen
            if (allCorrectOptionsSelected && noIncorrectOptionsSelected) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Vollständig korrekt';
            }
            // Teilweise korrekt: Einige richtige Optionen ausgewählt oder einige falsche
            else if (this.config.allowPartialScoring) {
                // Berechne den Anteil der korrekten Antworten
                const totalOptions = question.options.length;
                const selectedCorrectOptions = userAnswer.filter(index => correctOptionIndices.includes(index)).length;
                const selectedIncorrectOptions = userAnswer.length - selectedCorrectOptions;
                
                // Basiere die Punktzahl auf dem Verhältnis von korrekten zu falschen Optionen
                // Formel: (Korrekt ausgewählte - Falsch ausgewählte) / Gesamtzahl korrekter Optionen
                let partialScore = (selectedCorrectOptions - selectedIncorrectOptions) / correctOptionIndices.length;
                
                // Begrenze Punktzahl zwischen 0 und maxScore
                partialScore = Math.max(0, Math.min(1, partialScore));
                
                result.score = Number((partialScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                result.isCorrect = false; // Nur teilweise korrekt
                result.feedback = 'Teilweise korrekt';
                
                // Zusätzliche Details für das Feedback
                if (selectedCorrectOptions > 0 && selectedIncorrectOptions > 0) {
                    result.feedback += `: ${selectedCorrectOptions} korrekte und ${selectedIncorrectOptions} falsche Optionen ausgewählt`;
                } else if (selectedCorrectOptions === 0) {
                    result.feedback += ': Keine korrekten Optionen ausgewählt';
                } else if (selectedIncorrectOptions === 0) {
                    result.feedback += ': Nicht alle korrekten Optionen ausgewählt';
                }
            }
            // Ohne Teilpunkte: Komplett falsch
            else {
                result.score = 0;
                result.isCorrect = false;
                result.feedback = 'Falsch: Antwort stimmt nicht vollständig mit den korrekten Optionen überein';
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Multiple-Choice-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Wertet eine Single-Choice-Frage aus
     * @param {Object} question - Die Fragedaten
     * @param {number|Array} userAnswer - Die Antwort des Benutzers (Index der ausgewählten Option oder Array mit einem Element)
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateSingleChoice = function(question, userAnswer) {
        console.log('Werte Single-Choice-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Konvertiere userAnswer in einen einzelnen Index, falls es ein Array ist
            let selectedIndex;
            if (Array.isArray(userAnswer)) {
                if (userAnswer.length === 0) {
                    result.feedback = 'Keine Antwort ausgewählt';
                    return result;
                }
                selectedIndex = userAnswer[0]; // Nur den ersten Index verwenden
            } else if (typeof userAnswer === 'number') {
                selectedIndex = userAnswer;
            } else {
                console.warn('Single-Choice-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Korrekte Antwortoption bestimmen
            const correctOptionIndex = question.options.findIndex(option => option.isCorrect);
            
            // Prüfen, ob die ausgewählte Option korrekt ist
            if (selectedIndex === correctOptionIndex) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Korrekt';
            } else {
                result.score = 0;
                result.isCorrect = false;
                
                // Zusätzliches Feedback
                if (correctOptionIndex === -1) {
                    result.feedback = 'Keine korrekte Option definiert';
                } else {
                    const correctOptionText = question.options[correctOptionIndex].text;
                    result.feedback = `Falsch. Die korrekte Antwort ist: "${correctOptionText}"`;
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Single-Choice-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Wertet eine Wahr/Falsch-Frage aus
     * @param {Object} question - Die Fragedaten
     * @param {boolean|string} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateTrueFalse = function(question, userAnswer) {
        console.log('Werte Wahr/Falsch-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Normalisiere userAnswer zu einem Boolean
            let userBoolAnswer;
            if (typeof userAnswer === 'boolean') {
                userBoolAnswer = userAnswer;
            } else if (userAnswer === 'true' || userAnswer === 'false') {
                userBoolAnswer = userAnswer === 'true';
            } else if (userAnswer === true || userAnswer === false) {
                userBoolAnswer = userAnswer;
            } else {
                console.warn('Wahr/Falsch-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Korrekte Antwort aus der Frage entnehmen
            const correctAnswer = question.correctAnswer === true || question.correctAnswer === 'true';
            
            // Prüfen, ob die Antwort korrekt ist
            if (userBoolAnswer === correctAnswer) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Korrekt';
            } else {
                result.score = 0;
                result.isCorrect = false;
                result.feedback = `Falsch. Die korrekte Antwort ist: ${correctAnswer ? 'Wahr' : 'Falsch'}`;
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Wahr/Falsch-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Wertet eine Freitext-Frage automatisch aus
     * @param {Object} question - Die Fragedaten
     * @param {string|Object} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateFreeText = function(question, userAnswer) {
        console.log('Werte Freitext-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Extrahiere den Antworttext
            let userTextAnswer;
            if (typeof userAnswer === 'string') {
                userTextAnswer = userAnswer;
            } else if (userAnswer && typeof userAnswer.text === 'string') {
                userTextAnswer = userAnswer.text;
            } else {
                console.warn('Freitext-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Keine Antwort gegeben
            if (!userTextAnswer.trim()) {
                result.feedback = 'Keine Antwort eingegeben';
                return result;
            }
            
            // Korrekte Antworten aus der Frage extrahieren
            let correctAnswers = [];
            if (typeof question.correctAnswer === 'string') {
                correctAnswers = [question.correctAnswer];
            } else if (Array.isArray(question.correctAnswers)) {
                correctAnswers = question.correctAnswers;
            } else if (question.keywords && Array.isArray(question.keywords)) {
                // Auswertung basierend auf Keywords
                return this.evaluateFreeTextByKeywords(question, userTextAnswer);
            } else {
                console.warn('Keine korrekten Antworten für Freitext-Frage definiert:', question.id);
                result.feedback = 'Keine korrekten Antworten definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Normalisiere die Benutzereingabe
            let normalizedUserAnswer = userTextAnswer;
            
            // Optionale Normalisierungen anwenden
            if (!this.config.caseSensitiveEvaluation) {
                normalizedUserAnswer = normalizedUserAnswer.toLowerCase();
                correctAnswers = correctAnswers.map(answer => answer.toLowerCase());
            }
            
            if (this.config.ignoreWhitespaceInText) {
                normalizedUserAnswer = normalizedUserAnswer.replace(/\s+/g, ' ').trim();
                correctAnswers = correctAnswers.map(answer => answer.replace(/\s+/g, ' ').trim());
            }
            
            if (this.config.ignoreInterpunctionInText) {
                const interpunctionRegex = /[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g;
                normalizedUserAnswer = normalizedUserAnswer.replace(interpunctionRegex, '');
                correctAnswers = correctAnswers.map(answer => answer.replace(interpunctionRegex, ''));
            }
            
            // Prüfen auf exakte Übereinstimmung
            if (correctAnswers.includes(normalizedUserAnswer)) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Korrekt';
                return result;
            }
            
            // Prüfen auf Ähnlichkeit, wenn keine exakte Übereinstimmung gefunden wurde
            const similarityResults = correctAnswers.map(correctAnswer => {
                return {
                    answer: correctAnswer,
                    similarity: this.calculateTextSimilarity(normalizedUserAnswer, correctAnswer)
                };
            });
            
            // Beste Übereinstimmung finden
            const bestMatch = similarityResults.reduce((best, current) => {
                return current.similarity > best.similarity ? current : best;
            }, { similarity: 0 });
            
            // Wenn die Ähnlichkeit über dem Schwellwert liegt, teilweise Punkte vergeben
            if (bestMatch.similarity >= this.config.textSimilarityThreshold) {
                const partialScore = bestMatch.similarity;
                result.score = Number((partialScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                result.isCorrect = partialScore >= 0.95; // Ab 95% Ähnlichkeit als korrekt werten
                result.feedback = result.isCorrect ? 
                    'Korrekt (Übereinstimmung mit erwarteter Antwort)' : 
                    `Teilweise korrekt (${Math.round(partialScore * 100)}% Übereinstimmung)`;
            } else {
                result.score = 0;
                result.isCorrect = false;
                result.feedback = 'Falsch. Die Antwort weicht zu stark von der erwarteten Antwort ab.';
                
                // Hinweis auf korrekte Antwort, wenn weniger als 50% Übereinstimmung
                if (bestMatch.similarity < 0.5) {
                    result.feedback += ` Erwartete Antwort: "${correctAnswers[0]}"`;
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Freitext-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            result.needsManualEvaluation = true;
            return result;
        }
    };
    
    /**
     * Berechnet die Ähnlichkeit zwischen zwei Texten (Levenshtein-Distanz-basiert)
     * @param {string} text1 - Erster Text
     * @param {string} text2 - Zweiter Text
     * @return {number} - Ähnlichkeitswert zwischen 0 und 1
     */
    app.testEvaluation.calculateTextSimilarity = function(text1, text2) {
        if (text1 === text2) return 1.0;
        if (!text1 || !text2) return 0.0;
        
        // Levenshtein-Distanz berechnen
        const len1 = text1.length;
        const len2 = text2.length;
        const maxLen = Math.max(len1, len2);
        
        if (maxLen === 0) return 1.0;
        
        // Matrix für die dynamische Programmierung
        const matrix = [];
        
        // Initialisierung
        for (let i = 0; i <= len1; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= len2; j++) {
            matrix[0][j] = j;
        }
        
        // Berechnung der Distanz
        for (let i = 1; i <= len1; i++) {
            for (let j = 1; j <= len2; j++) {
                const cost = text1.charAt(i - 1) === text2.charAt(j - 1) ? 0 : 1;
                matrix[i][j] = Math.min(
                    matrix[i - 1][j] + 1,     // Löschung
                    matrix[i][j - 1] + 1,     // Einfügung
                    matrix[i - 1][j - 1] + cost // Ersetzung
                );
            }
        }
        
        // Distanz normalisieren zu einer Ähnlichkeit zwischen 0 und 1
        const distance = matrix[len1][len2];
        return 1 - (distance / maxLen);
    };
    
    /**
     * Wertet eine Freitext-Frage basierend auf Keywords aus
     * @param {Object} question - Die Fragedaten
     * @param {string} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateFreeTextByKeywords = function(question, userAnswer) {
        console.log('Werte Freitext-Frage anhand von Keywords aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            if (!question.keywords || !Array.isArray(question.keywords) || question.keywords.length === 0) {
                console.warn('Keine Keywords für Freitext-Auswertung definiert:', question.id);
                result.feedback = 'Keine Keywords definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Normalisiere die Benutzereingabe
            let normalizedUserAnswer = userAnswer;
            
            // Optionale Normalisierungen anwenden
            if (!this.config.caseSensitiveEvaluation) {
                normalizedUserAnswer = normalizedUserAnswer.toLowerCase();
            }
            
            if (this.config.ignoreWhitespaceInText) {
                normalizedUserAnswer = normalizedUserAnswer.replace(/\s+/g, ' ').trim();
            }
            
            if (this.config.ignoreInterpunctionInText) {
                const interpunctionRegex = /[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g;
                normalizedUserAnswer = normalizedUserAnswer.replace(interpunctionRegex, '');
            }
            
            // Zähle die gefundenen Keywords
            let foundKeywords = 0;
            let requiredKeywords = 0;
            const foundKeywordsList = [];
            const missingKeywordsList = [];
            
            for (const keyword of question.keywords) {
                // Keyword normalisieren
                let normalizedKeyword = keyword.text || keyword;
                let isRequired = keyword.required !== undefined ? keyword.required : true;
                let weight = keyword.weight || 1;
                
                if (!this.config.caseSensitiveEvaluation) {
                    normalizedKeyword = normalizedKeyword.toLowerCase();
                }
                
                if (this.config.ignoreWhitespaceInText) {
                    normalizedKeyword = normalizedKeyword.replace(/\s+/g, ' ').trim();
                }
                
                if (this.config.ignoreInterpunctionInText) {
                    const interpunctionRegex = /[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g;
                    normalizedKeyword = normalizedKeyword.replace(interpunctionRegex, '');
                }
                
                if (isRequired) {
                    requiredKeywords++;
                }
                
                // Prüfen, ob das Keyword enthalten ist
                if (normalizedUserAnswer.includes(normalizedKeyword)) {
                    foundKeywords += weight;
                    foundKeywordsList.push(normalizedKeyword);
                } else if (isRequired) {
                    missingKeywordsList.push(normalizedKeyword);
                }
            }
            
            // Berechne die Punktzahl basierend auf den gefundenen Keywords
            const totalKeywordWeight = question.keywords.reduce((sum, k) => sum + (k.weight || 1), 0);
            const keywordScore = totalKeywordWeight > 0 ? foundKeywords / totalKeywordWeight : 0;
            
            result.score = Number((keywordScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
            
            // Antwort ist korrekt, wenn alle erforderlichen Keywords gefunden wurden
            result.isCorrect = missingKeywordsList.length === 0 && (requiredKeywords > 0);
            
            // Feedback basierend auf gefundenen Keywords
            if (result.isCorrect) {
                result.feedback = 'Korrekt. Alle erforderlichen Schlüsselwörter wurden gefunden.';
            } else if (foundKeywordsList.length > 0) {
                result.feedback = `Teilweise korrekt. Gefunden: ${foundKeywordsList.join(', ')}`;
                
                if (missingKeywordsList.length > 0) {
                    result.feedback += `. Fehlend: ${missingKeywordsList.join(', ')}`;
                }
            } else {
                result.feedback = 'Falsch. Keine Schlüsselwörter gefunden.';
                
                if (missingKeywordsList.length > 0) {
                    result.feedback += ` Erforderliche Begriffe: ${missingKeywordsList.join(', ')}`;
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Keyword-basierten Auswertung:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            result.needsManualEvaluation = true;
            return result;
        }
    };
    
    /**
     * Finalisiert die Auswertung und speichert das Ergebnis
     * @param {Object} evaluationResult - Das zu finalisierende Auswertungsergebnis
     * @return {Promise<Object>} - Promise mit dem finalisierten Auswertungsergebnis
     */
    app.testEvaluation.finalizeEvaluation = function(evaluationResult) {
        console.log('Finalisiere Auswertungsergebnis:', evaluationResult);
        
        return new Promise((resolve, reject) => {
            try {
                // Speichere das Ergebnis in der Datenbank
                const savedResult = app.dataManager.saveTestEvaluation(evaluationResult);
                
                if (!savedResult) {
                    throw new Error('Fehler beim Speichern des Auswertungsergebnisses');
                }
                
                // Wenn manuelle Auswertung erforderlich ist, entsprechenden Status setzen
                if (evaluationResult.needsManualEvaluation) {
                    app.dataManager.setTestNeedsManualEvaluation(
                        evaluationResult.testId,
                        evaluationResult.userId
                    );
                }
                
                console.log('Auswertungsergebnis erfolgreich finalisiert:', savedResult);
                resolve(savedResult);
            } catch (error) {
                console.error('Fehler bei der Finalisierung der Auswertung:', error);
                reject(error);
            }
        });
    };
    
    // Öffentliche Schnittstelle
    app.testEvaluation.interface = {
        initialize: app.testEvaluation.initialize.bind(app.testEvaluation),
        evaluateTest: app.testEvaluation.evaluateTest.bind(app.testEvaluation),
        evaluateQuestion: app.testEvaluation.evaluateQuestion.bind(app.testEvaluation)
    };
    
    console.log('Auswertungsalgorithmen (Teil 1.1) initialisiert');
})();
/**
 * JS-Block 6.1.1-part2: Auswertungsalgorithmen (Teil 1.2)
 * 
 * Dieser Block erweitert die Auswertungsalgorithmen um fortgeschrittene Funktionen,
 * wie numerische Antwortauswertung, Pattern-Matching, erweiterte Textanalyse
 * und Mustererkennung für komplexere Szenarien.
 */
(function() {
    // Erweiterte Konfiguration für spezielle Auswertungsfälle
    if (!app.testEvaluation.advancedConfig) {
        app.testEvaluation.advancedConfig = {
            // Numerische Auswertungsparameter
            numeric: {
                // Absoluter Toleranzwert für exakte Zahlen (z.B. 0.001)
                absoluteTolerance: 0.001,
                
                // Relative Toleranz für Prozentwerte oder große Zahlen
                relativeTolerance: 0.05,
                
                // Einheiten, die bei der Auswertung ignoriert werden sollen
                ignoredUnits: ['€', '$', '€/m²', 'm²', 'qm', 'kg', 'm', 'km', 'l', 'ml'],
                
                // Tausender- und Dezimaltrennzeichen
                thousandsSeparator: '.',
                decimalSeparator: ','
            },
            
            // Erweiterte Textanalyse
            textAnalysis: {
                // Stopwörter, die bei der Ähnlichkeitsberechnung ignoriert werden
                stopWords: ['der', 'die', 'das', 'und', 'oder', 'in', 'im', 'an', 'auf', 'mit', 'für', 'bei'],
                
                // Gewichtung für Wortübereinstimmungen
                wordMatchWeight: 1.5,
                
                // Gewichtung für Phrasenübereinstimmungen
                phraseMatchWeight: 2.0,
                
                // Maximale Wortdistanz für Phrasenähnlichkeit
                maxWordDistance: 3,
                
                // Minimale Wortlänge für Berücksichtigung im Vergleich
                minWordLength: 3
            },
            
            // RegEx-Pattern-Matching
            patternMatching: {
                // Voreingestellte Patterns für häufige Datenformate
                predefinedPatterns: {
                    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
                    url: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
                    date: /^(0?[1-9]|[12][0-9]|3[01])\.(0?[1-9]|1[012])\.\d{4}$/,
                    phoneNumber: /^(\+\d{1,3}[- ]?)?\d{2,6}[- ]?\d{2,6}[- ]?\d{2,6}$/,
                    postalCode: /^\d{5}$/,
                    ipAddress: /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/
                },
                
                // Teilweise Übereinstimmung erlauben
                allowPartialMatch: true,
                
                // Ob Groß-/Kleinschreibung bei Patterns berücksichtigt werden soll
                caseSensitive: false
            },
            
            // Fortgeschrittene Scoring-Optionen
            scoring: {
                // Basisgewichtungen für verschiedene Fragetypen
                typeWeights: {
                    'multiple-choice': 1.0,
                    'single-choice': 1.0,
                    'true-false': 0.8,
                    'free-text': 1.2,
                    'numeric': 1.0,
                    'matching': 1.2
                },
                
                // Strafpunkte für falsche Antworten (negatives Scoring)
                incorrectPenalty: 0,
                
                // Bonuspunkte für schnelle Antworten
                timeBonus: {
                    enabled: false,
                    maxBonus: 0.1, // max 10% Bonus
                    thresholdPercentage: 0.5 // Bonus wenn < 50% der durchschnittlichen Zeit
                },
                
                // Progressives Scoring (spätere Fragen sind mehr wert)
                progressive: {
                    enabled: false,
                    factor: 1.05, // 5% Steigerung pro Frage
                    maxFactor: 1.5 // Maximal 50% mehr Punkte
                }
            }
        };
    }
    
    /**
     * Initialisiert die erweiterten Auswertungsalgorithmen
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testEvaluation.initializeAdvanced = function(options) {
        console.log('Initialisiere erweiterte Auswertungsalgorithmen mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            // Rekursives Zusammenführen der Konfigurationsobjekte
            this.advancedConfig = this.mergeConfigurations(this.advancedConfig, options);
        }
        
        // Event-Listener für manuelle Bewertungen
        document.addEventListener('manualEvaluationSubmitted', (event) => {
            if (event.detail) {
                console.log('Manuelle Bewertung eingereicht, aktualisiere Gesamtauswertung:', event.detail);
                this.updateEvaluationWithManualScores(event.detail);
            }
        });
        
        console.log('Erweiterte Auswertungsalgorithmen initialisiert');
    };
    
    /**
     * Führt eine rekursive Zusammenführung von Konfigurationsobjekten durch
     * @param {Object} target - Zielobjekt
     * @param {Object} source - Quellobjekt mit zu übernehmenden Eigenschaften
     * @return {Object} - Zusammengeführtes Konfigurationsobjekt
     */
    app.testEvaluation.mergeConfigurations = function(target, source) {
        const result = Object.assign({}, target);
        
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                if (source[key] instanceof Object && key in target && target[key] instanceof Object) {
                    result[key] = this.mergeConfigurations(target[key], source[key]);
                } else {
                    result[key] = source[key];
                }
            }
        }
        
        return result;
    };
    
    /**
     * Aktualisiert eine Testauswertung mit manuellen Bewertungen
     * @param {Object} manualEvaluation - Die manuelle Bewertungsdaten
     * @return {Promise<Object>} - Promise mit der aktualisierten Auswertung
     */
    app.testEvaluation.updateEvaluationWithManualScores = function(manualEvaluation) {
        console.log('Aktualisiere Auswertung mit manuellen Bewertungen:', manualEvaluation);
        
        return new Promise((resolve, reject) => {
            try {
                const { testId, userId, evaluations } = manualEvaluation;
                
                if (!testId || !userId || !evaluations || !Array.isArray(evaluations)) {
                    throw new Error('Ungültige Daten für manuelle Bewertung');
                }
                
                // Lade die vorhandene Auswertung
                const existingEvaluation = app.dataManager.getTestEvaluation(testId, userId);
                if (!existingEvaluation) {
                    throw new Error('Keine vorhandene Auswertung gefunden');
                }
                
                // Kopie der vorhandenen Auswertung erstellen
                const updatedEvaluation = JSON.parse(JSON.stringify(existingEvaluation));
                
                // Statistiken zurücksetzen
                updatedEvaluation.totalScore = 0;
                updatedEvaluation.statistics.correctAnswers = 0;
                updatedEvaluation.statistics.partiallyCorrectAnswers = 0;
                updatedEvaluation.statistics.incorrectAnswers = 0;
                
                // Kategoriestatistiken zurücksetzen
                Object.keys(updatedEvaluation.statistics.categoriesPerformance || {}).forEach(category => {
                    updatedEvaluation.statistics.categoriesPerformance[category].score = 0;
                });
                
                // Jede manuelle Bewertung verarbeiten
                for (const evaluation of evaluations) {
                    const { questionId, score, feedback, isCorrect } = evaluation;
                    
                    if (!questionId || score === undefined) {
                        console.warn('Unvollständige Bewertungsdaten übersprungen:', evaluation);
                        continue;
                    }
                    
                    // Frage abrufen
                    const question = app.dataManager.getQuestionById(questionId);
                    if (!question) {
                        console.warn(`Frage mit ID ${questionId} nicht gefunden`);
                        continue;
                    }
                    
                    // Vorhandenes Fragen-Ergebnis abrufen
                    const questionResult = updatedEvaluation.questionResults[questionId];
                    if (!questionResult) {
                        console.warn(`Kein Ergebnis für Frage ${questionId} gefunden`);
                        continue;
                    }
                    
                    // Ergebnis aktualisieren
                    questionResult.score = score;
                    questionResult.isCorrect = isCorrect !== undefined ? isCorrect : (score >= questionResult.maxScore);
                    questionResult.autoEvaluated = false;
                    questionResult.needsManualEvaluation = false;
                    
                    if (feedback) {
                        questionResult.feedback = feedback;
                    }
                    
                    // Statistiken aktualisieren
                    updatedEvaluation.totalScore += score;
                    
                    if (questionResult.isCorrect) {
                        updatedEvaluation.statistics.correctAnswers++;
                    } else if (score > 0) {
                        updatedEvaluation.statistics.partiallyCorrectAnswers++;
                    } else {
                        updatedEvaluation.statistics.incorrectAnswers++;
                    }
                    
                    // Kategoriestatistiken aktualisieren
                    if (question.category && updatedEvaluation.statistics.categoriesPerformance && 
                        updatedEvaluation.statistics.categoriesPerformance[question.category]) {
                        updatedEvaluation.statistics.categoriesPerformance[question.category].score += score;
                    }
                }
                
                // Gesamtstatistiken aktualisieren
                if (updatedEvaluation.maxScore > 0) {
                    updatedEvaluation.percentageScore = Number(
                        (updatedEvaluation.totalScore / updatedEvaluation.maxScore * 100).toFixed(2)
                    );
                }
                
                updatedEvaluation.passed = updatedEvaluation.percentageScore >= updatedEvaluation.passingThreshold;
                
                // Prüfen, ob noch manuelle Bewertungen ausstehen
                updatedEvaluation.needsManualEvaluation = Object.values(updatedEvaluation.questionResults)
                    .some(result => result.needsManualEvaluation);
                
                // Aktualisierungsinformationen hinzufügen
                updatedEvaluation.lastUpdated = new Date().toISOString();
                updatedEvaluation.manuallyEvaluated = true;
                updatedEvaluation.evaluatedBy = manualEvaluation.evaluatorId;
                
                // Speichern der aktualisierten Auswertung
                const savedEvaluation = app.dataManager.saveTestEvaluation(updatedEvaluation);
                
                if (!savedEvaluation) {
                    throw new Error('Fehler beim Speichern der aktualisierten Auswertung');
                }
                
                // Event für aktualisierte Auswertung auslösen
                const updateEvent = new CustomEvent('evaluationUpdated', {
                    detail: savedEvaluation
                });
                document.dispatchEvent(updateEvent);
                
                console.log('Auswertung erfolgreich aktualisiert:', savedEvaluation);
                resolve(savedEvaluation);
            } catch (error) {
                console.error('Fehler bei der Aktualisierung der Auswertung:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Wertet eine numerische Antwort aus
     * @param {Object} question - Die Fragedaten
     * @param {string|number} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateNumeric = function(question, userAnswer) {
        console.log('Werte numerische Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Extrahiere die numerische Antwort des Benutzers
            let userNumericValue;
            
            if (typeof userAnswer === 'number') {
                userNumericValue = userAnswer;
            } else if (typeof userAnswer === 'string') {
                userNumericValue = this.parseNumericInput(userAnswer);
            } else {
                console.warn('Numerische Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Keine Antwort gegeben oder keine Zahl
            if (userNumericValue === null || isNaN(userNumericValue)) {
                result.feedback = 'Keine gültige Zahl eingegeben';
                return result;
            }
            
            // Korrekte Antwort aus der Frage extrahieren
            let correctValue;
            
            if (typeof question.correctAnswer === 'number') {
                correctValue = question.correctAnswer;
            } else if (typeof question.correctAnswer === 'string') {
                correctValue = this.parseNumericInput(question.correctAnswer);
                
                if (correctValue === null || isNaN(correctValue)) {
                    console.warn('Korrekte Antwort ist keine gültige Zahl:', question.correctAnswer);
                    result.feedback = 'Korrekte Antwort ist nicht definiert';
                    result.needsManualEvaluation = true;
                    return result;
                }
            } else {
                console.warn('Keine korrekte Antwort für numerische Frage definiert:', question.id);
                result.feedback = 'Keine korrekte Antwort definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Toleranzbereiche aus der Frage oder der Konfiguration entnehmen
            const absoluteTolerance = question.absoluteTolerance !== undefined ? 
                question.absoluteTolerance : 
                this.advancedConfig.numeric.absoluteTolerance;
                
            const relativeTolerance = question.relativeTolerance !== undefined ? 
                question.relativeTolerance : 
                this.advancedConfig.numeric.relativeTolerance;
            
            // Berechne den Bereich für eine korrekte Antwort
            const absoluteDeviation = Math.abs(userNumericValue - correctValue);
            const relativeDeviation = correctValue !== 0 ? absoluteDeviation / Math.abs(correctValue) : absoluteDeviation;
            
            // Prüfen, ob die Antwort innerhalb der Toleranzbereiche liegt
            const withinAbsoluteTolerance = absoluteDeviation <= absoluteTolerance;
            const withinRelativeTolerance = relativeDeviation <= relativeTolerance;
            
            if (withinAbsoluteTolerance || withinRelativeTolerance) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Korrekt';
                
                // Hinzufügen des genauen Wertes im Feedback
                if (!withinAbsoluteTolerance && withinRelativeTolerance) {
                    result.feedback += ` (innerhalb der ${relativeTolerance * 100}% Toleranz)`;
                }
            } else {
                // Berechne partielle Punktzahl basierend auf der Nähe zur korrekten Antwort
                if (this.config.allowPartialScoring) {
                    // Berechnung: Je näher an der korrekten Antwort, desto mehr Punkte
                    // Maximal 100% Abweichung (0 Punkte), minimal 0% Abweichung (volle Punktzahl)
                    let deviation = Math.min(1, relativeDeviation / (relativeTolerance * 4));
                    let partialScore = Math.max(0, 1 - deviation);
                    
                    // Nur Teilpunkte vergeben, wenn die Abweichung nicht zu groß ist
                    if (partialScore > 0.2) {
                        result.score = Number((partialScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                        result.isCorrect = false;
                        result.feedback = `Teilweise korrekt (${Math.round(partialScore * 100)}% der Punkte)`;
                    } else {
                        result.score = 0;
                        result.isCorrect = false;
                        result.feedback = `Falsch. Die korrekte Antwort ist: ${correctValue}`;
                    }
                } else {
                    result.score = 0;
                    result.isCorrect = false;
                    result.feedback = `Falsch. Die korrekte Antwort ist: ${correctValue}`;
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der numerischen Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Parst eine Benutzereingabe in einen numerischen Wert
     * @param {string} input - Die zu parsende Eingabe
     * @return {number|null} - Der geparste numerische Wert oder null bei Fehler
     */
    app.testEvaluation.parseNumericInput = function(input) {
        if (!input || typeof input !== 'string') {
            return null;
        }
        
        // Text normalisieren und vorbereiten
        let normalizedInput = input.trim();
        
        // Einheiten entfernen
        for (const unit of this.advancedConfig.numeric.ignoredUnits) {
            if (normalizedInput.endsWith(unit)) {
                normalizedInput = normalizedInput.substring(0, normalizedInput.length - unit.length).trim();
                break;
            }
        }
        
        // Tausendertrennzeichen entfernen und Dezimalpunkt normalisieren
        const thousandsSeparator = this.advancedConfig.numeric.thousandsSeparator;
        const decimalSeparator = this.advancedConfig.numeric.decimalSeparator;
        
        // Entferne alle Tausendertrennzeichen
        normalizedInput = normalizedInput.replace(new RegExp(`\\${thousandsSeparator}`, 'g'), '');
        
        // Ersetze Dezimaltrennzeichen durch Punkt für die Parsierung
        if (decimalSeparator !== '.') {
            normalizedInput = normalizedInput.replace(new RegExp(`\\${decimalSeparator}`, 'g'), '.');
        }
        
        // Versuche, den Wert als Zahl zu parsen
        const parsedValue = parseFloat(normalizedInput);
        
        return isNaN(parsedValue) ? null : parsedValue;
    };
    
    /**
     * Wertet eine Antwort basierend auf einem regulären Ausdruck aus
     * @param {Object} question - Die Fragedaten
     * @param {string} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluatePattern = function(question, userAnswer) {
        console.log('Werte Pattern-basierte Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Extrahiere die Antwort des Benutzers
            let userTextAnswer;
            
            if (typeof userAnswer === 'string') {
                userTextAnswer = userAnswer.trim();
            } else if (userAnswer && typeof userAnswer.text === 'string') {
                userTextAnswer = userAnswer.text.trim();
            } else {
                console.warn('Pattern-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Keine Antwort gegeben
            if (!userTextAnswer) {
                result.feedback = 'Keine Antwort eingegeben';
                return result;
            }
            
            // Pattern aus der Frage extrahieren
            let pattern;
            
            if (question.pattern) {
                // Direktes Pattern aus der Frage verwenden
                pattern = question.pattern;
            } else if (question.patternType && this.advancedConfig.patternMatching.predefinedPatterns[question.patternType]) {
                // Vordefiniertes Pattern aus der Konfiguration verwenden
                pattern = this.advancedConfig.patternMatching.predefinedPatterns[question.patternType];
            } else {
                console.warn('Kein Pattern für Pattern-basierte Frage definiert:', question.id);
                result.feedback = 'Kein Pattern definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Konvertiere String-Pattern in RegExp-Objekt
            let regexPattern;
            if (typeof pattern === 'string') {
                try {
                    // String-Pattern in RegExp konvertieren
                    const patternParts = pattern.match(/^\/(.*?)\/([gimsuy]*)$/);
                    if (patternParts) {
                        // Gültiges RegExp-Format mit Flags
                        regexPattern = new RegExp(patternParts[1], patternParts[2]);
                    } else {
                        // Einfacher String, als exaktes Pattern behandeln
                        regexPattern = new RegExp('^' + pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$', 
                            this.advancedConfig.patternMatching.caseSensitive ? '' : 'i');
                    }
                } catch (regexError) {
                    console.warn('Ungültiges RegExp-Pattern:', pattern, regexError);
                    result.feedback = 'Ungültiges Pattern definiert';
                    result.needsManualEvaluation = true;
                    return result;
                }
            } else if (pattern instanceof RegExp) {
                regexPattern = pattern;
            } else {
                console.warn('Pattern hat ungültiges Format:', pattern);
                result.feedback = 'Ungültiges Pattern-Format';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Prüfe, ob die Antwort dem Pattern entspricht
            const patternMatch = regexPattern.test(userTextAnswer);
            
            if (patternMatch) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Korrekt';
            } else if (this.advancedConfig.patternMatching.allowPartialMatch) {
                // Versuche, eine teilweise Übereinstimmung zu finden
                const partialMatch = this.evaluatePartialPatternMatch(userTextAnswer, regexPattern);
                
                if (partialMatch.matched) {
                    const partialScore = partialMatch.similarity;
                    result.score = Number((partialScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                    result.isCorrect = false;
                    result.feedback = `Teilweise korrekt (${Math.round(partialScore * 100)}% Übereinstimmung)`;
                } else {
                    result.score = 0;
                    result.isCorrect = false;
                    result.feedback = 'Falsch: Die Antwort entspricht nicht dem erwarteten Format';
                    
                    // Beispiel für korrektes Format hinzufügen, falls vorhanden
                    if (question.example) {
                        result.feedback += `. Beispiel: ${question.example}`;
                    }
                }
            } else {
                result.score = 0;
                result.isCorrect = false;
                result.feedback = 'Falsch: Die Antwort entspricht nicht dem erwarteten Format';
                
                // Beispiel für korrektes Format hinzufügen, falls vorhanden
                if (question.example) {
                    result.feedback += `. Beispiel: ${question.example}`;
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Pattern-basierten Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Bewertet eine teilweise Übereinstimmung mit einem Pattern
     * @param {string} input - Die Benutzereingabe
     * @param {RegExp} pattern - Das zu prüfende Pattern
     * @return {Object} - Ergebnis mit Übereinstimmungsinformationen
     */
    app.testEvaluation.evaluatePartialPatternMatch = function(input, pattern) {
        // Basisergebnis, falls keine Übereinstimmung gefunden wird
        const result = {
            matched: false,
            similarity: 0
        };
        
        // Ein paar gängige Fehler prüfen und korrigieren
        let modifiedInput = input;
        
        // Versuche verschiedene Varianten des Inputs
        const variations = [
            input, // Original
            input.replace(/\s+/g, ''), // Leerzeichen entfernen
            input.replace(/[\.\,\-\_]/g, ''), // Satzzeichen entfernen
            input.toLowerCase(), // Kleinbuchstaben
            input.toUpperCase(), // Großbuchstaben
            input.replace(/\s+/g, '').toLowerCase(), // Kombiniert
        ];
        
        // Prüfe alle Varianten
        for (const variant of variations) {
            if (pattern.test(variant)) {
                // Eine Variante passt, berechne Ähnlichkeit zum Original
                const similarity = this.calculateTextSimilarity(input, variant);
                return {
                    matched: true,
                    similarity: Math.max(0.6, similarity) // Mindestens 60% Übereinstimmung
                };
            }
        }
        
        // Wenn Email-Pattern, prüfe typische Fehler
        if (pattern.toString().includes('@')) {
            // Prüfe auf fehlende @-Zeichen oder Domains
            if (!input.includes('@')) {
                const parts = input.split(/[\s\.,;]+/);
                for (const part of parts) {
                    if (part.length > 3 && /^[a-zA-Z0-9._-]+$/.test(part)) {
                        // Könnte ein Benutzername sein, versuche mit gmail.com
                        const testMail = `${part}@gmail.com`;
                        if (pattern.test(testMail)) {
                            return {
                                matched: true,
                                similarity: 0.4 // 40% Übereinstimmung (fehlt @domain)
                            };
                        }
                    }
                }
            } else {
                // @ vorhanden, aber anderer Fehler
                return {
                    matched: true,
                    similarity: 0.5 // 50% Übereinstimmung
                };
            }
        }
        
        // Bei URL-Pattern, prüfe typische Fehler
        if (pattern.toString().includes('http')) {
            // Prüfe, ob http:// oder https:// fehlt
            if (!input.startsWith('http://') && !input.startsWith('https://')) {
                const testUrl = `https://${input}`;
                if (pattern.test(testUrl)) {
                    return {
                        matched: true,
                        similarity: 0.8 // 80% Übereinstimmung (nur Protokoll fehlt)
                    };
                }
            }
        }
        
        // Bei Datumsformat, prüfe auf falsche Trennzeichen
        if (pattern.toString().includes('\\.') && (input.includes('/') || input.includes('-'))) {
            // Ersetze Trennzeichen und prüfe erneut
            const testDate = input.replace(/[\/\-]/g, '.');
            if (pattern.test(testDate)) {
                return {
                    matched: true,
                    similarity: 0.9 // 90% Übereinstimmung (nur Trennzeichen falsch)
                };
            }
        }
        
        return result;
    };
    
    /**
     * Erweiterte Textähnlichkeitsberechnung für Freitext-Antworten
     * @param {string} text1 - Erster Text
     * @param {string} text2 - Zweiter Text
     * @return {number} - Ähnlichkeitswert zwischen 0 und 1
     */
    app.testEvaluation.calculateAdvancedTextSimilarity = function(text1, text2) {
        if (text1 === text2) return 1.0;
        if (!text1 || !text2) return 0.0;
        
        // Normalisierung der Texte
        let normalizedText1 = text1.trim();
        let normalizedText2 = text2.trim();
        
        if (!this.config.caseSensitiveEvaluation) {
            normalizedText1 = normalizedText1.toLowerCase();
            normalizedText2 = normalizedText2.toLowerCase();
        }
        
        if (this.config.ignoreWhitespaceInText) {
            normalizedText1 = normalizedText1.replace(/\s+/g, ' ');
            normalizedText2 = normalizedText2.replace(/\s+/g, ' ');
        }
        
        if (this.config.ignoreInterpunctionInText) {
            const interpunctionRegex = /[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g;
            normalizedText1 = normalizedText1.replace(interpunctionRegex, '');
            normalizedText2 = normalizedText2.replace(interpunctionRegex, '');
        }
        
        // Nach Normalisierung identisch?
        if (normalizedText1 === normalizedText2) return 1.0;
        
        // Texte in Wörter aufteilen
        const words1 = normalizedText1.split(/\s+/).filter(w => w.length >= this.advancedConfig.textAnalysis.minWordLength);
        const words2 = normalizedText2.split(/\s+/).filter(w => w.length >= this.advancedConfig.textAnalysis.minWordLength);
        
        // Stopwörter entfernen
        const stopWords = new Set(this.advancedConfig.textAnalysis.stopWords);
        const filteredWords1 = words1.filter(word => !stopWords.has(word));
        const filteredWords2 = words2.filter(word => !stopWords.has(word));
        
        // Keine verarbeitbaren Wörter?
        if (filteredWords1.length === 0 || filteredWords2.length === 0) {
            // Fallback auf einfache Levenshtein-Distanz
            return this.calculateTextSimilarity(normalizedText1, normalizedText2);
        }
        
        // Wort-Übereinstimmungen zählen
        const wordSet1 = new Set(filteredWords1);
        const wordSet2 = new Set(filteredWords2);
        
        const commonWords = filteredWords1.filter(word => wordSet2.has(word));
        const wordMatchScore = commonWords.length / Math.max(filteredWords1.length, filteredWords2.length);
        
        // Phrasen-Übereinstimmungen suchen (2+ aufeinanderfolgende Wörter)
        let phraseMatchScore = 0;
        const maxPhraseLength = Math.min(filteredWords1.length, filteredWords2.length);
        
        // Suche nach gemeinsamen Phrasen verschiedener Länge
        for (let phraseLength = 2; phraseLength <= maxPhraseLength; phraseLength++) {
            const phrases1 = this.extractPhrases(filteredWords1, phraseLength);
            const phrases2 = this.extractPhrases(filteredWords2, phraseLength);
            
            const commonPhrases = phrases1.filter(phrase => phrases2.includes(phrase));
            
            if (commonPhrases.length > 0) {
                // Längere Phrasen höher gewichten
                const weightedScore = (commonPhrases.length * phraseLength) / 
                    (Math.max(phrases1.length, phrases2.length) * phraseLength);
                
                // Die beste Phrasenübereinstimmung verwenden
                phraseMatchScore = Math.max(phraseMatchScore, weightedScore);
            }
        }
        
        // Kombinierte Ähnlichkeitsberechnung
        const wordWeight = this.advancedConfig.textAnalysis.wordMatchWeight;
        const phraseWeight = this.advancedConfig.textAnalysis.phraseMatchWeight;
        
        const combinedScore = (wordMatchScore * wordWeight + phraseMatchScore * phraseWeight) / 
            (wordWeight + phraseWeight);
        
        // Für kurze Texte: Zusätzlich Levenshtein-Distanz berücksichtigen
        if (filteredWords1.length <= 5 && filteredWords2.length <= 5) {
            const levenshteinSimilarity = this.calculateTextSimilarity(normalizedText1, normalizedText2);
            return 0.7 * combinedScore + 0.3 * levenshteinSimilarity;
        }
        
        return combinedScore;
    };
    
    /**
     * Extrahiert Phrasen einer bestimmten Länge aus einem Array von Wörtern
     * @param {Array<string>} words - Array von Wörtern
     * @param {number} length - Länge der zu extrahierenden Phrasen
     * @return {Array<string>} - Array von Phrasen
     */
    app.testEvaluation.extractPhrases = function(words, length) {
        const phrases = [];
        
        for (let i = 0; i <= words.length - length; i++) {
            phrases.push(words.slice(i, i + length).join(' '));
        }
        
        return phrases;
    };
    
    /**
     * Generiert einen detaillierten Auswertungsbericht
     * @param {string} testId - ID des Tests
     * @param {string} userId - ID des Benutzers
     * @return {Object} - Detaillierter Auswertungsbericht
     */
    app.testEvaluation.generateDetailedReport = function(testId, userId) {
        console.log(`Generiere detaillierten Auswertungsbericht für Test ${testId}, Benutzer ${userId}`);
        
        try {
            // Lade die Auswertung
            const evaluation = app.dataManager.getTestEvaluation(testId, userId);
            if (!evaluation) {
                throw new Error('Keine Auswertung gefunden');
            }
            
            // Lade Test- und Benutzerdaten
            const test = app.dataManager.getTestById(testId);
            const user = app.dataManager.getUserById(userId);
            
            if (!test || !user) {
                throw new Error('Test oder Benutzer nicht gefunden');
            }
            
            // Basisinformationen für den Bericht
            const report = {
                id: `report_${testId}_${userId}_${Date.now()}`,
                testId: testId,
                testTitle: test.title,
                userId: userId,
                userName: user.fullName,
                generatedAt: new Date().toISOString(),
                evaluationId: evaluation.id,
                summary: {
                    score: evaluation.totalScore,
                    maxScore: evaluation.maxScore,
                    percentage: evaluation.percentageScore,
                    passed: evaluation.passed,
                    passingThreshold: evaluation.passingThreshold,
                    duration: evaluation.duration,
                    questions: Object.keys(evaluation.questionResults).length,
                    correctAnswers: evaluation.statistics.correctAnswers,
                    partiallyCorrectAnswers: evaluation.statistics.partiallyCorrectAnswers,
                    incorrectAnswers: evaluation.statistics.incorrectAnswers,
                    unansweredQuestions: evaluation.statistics.unansweredQuestions
                },
                categoryAnalysis: [],
                strengthsWeaknesses: {
                    strengths: [],
                    weaknesses: [],
                    improvementAreas: []
                },
                questionDetails: [],
                recommendations: []
            };
            
            // Kategorieanalyse
            if (evaluation.statistics.categoriesPerformance) {
                Object.keys(evaluation.statistics.categoriesPerformance).forEach(category => {
                    const catPerf = evaluation.statistics.categoriesPerformance[category];
                    
                    report.categoryAnalysis.push({
                        category: category,
                        score: catPerf.score,
                        maxScore: catPerf.maxScore,
                        percentage: catPerf.percentage,
                        questions: catPerf.total
                    });
                });
                
                // Sortiere nach Leistung (absteigend)
                report.categoryAnalysis.sort((a, b) => b.percentage - a.percentage);
            }
            
            // Stärken und Schwächen identifizieren
            const categoriesByPerformance = [...report.categoryAnalysis];
            
            // Top 3 Stärken (Kategorien mit Leistung >= 75%)
            report.strengthsWeaknesses.strengths = categoriesByPerformance
                .filter(cat => cat.percentage >= 75)
                .slice(0, 3)
                .map(cat => ({
                    category: cat.category,
                    percentage: cat.percentage,
                    questions: cat.questions
                }));
                
            // Top 3 Schwächen (Kategorien mit Leistung < 60%)
            report.strengthsWeaknesses.weaknesses = categoriesByPerformance
                .filter(cat => cat.percentage < 60)
                .slice(0, 3)
                .map(cat => ({
                    category: cat.category,
                    percentage: cat.percentage,
                    questions: cat.questions
                }));
                
            // Mittlere Bereiche, die verbessert werden können (60-75%)
            report.strengthsWeaknesses.improvementAreas = categoriesByPerformance
                .filter(cat => cat.percentage >= 60 && cat.percentage < 75)
                .slice(0, 3)
                .map(cat => ({
                    category: cat.category,
                    percentage: cat.percentage,
                    questions: cat.questions
                }));
            
            // Detaillierte Fragenanalyse
            const questionResults = evaluation.questionResults;
            
            for (const questionId in questionResults) {
                if (questionResults.hasOwnProperty(questionId)) {
                    const question = app.dataManager.getQuestionById(questionId);
                    const result = questionResults[questionId];
                    
                    // Nur Fragen mit vollständigen Daten aufnehmen
                    if (!question) continue;
                    
                    report.questionDetails.push({
                        questionId: questionId,
                        questionType: result.questionType,
                        questionText: question.text,
                        category: question.category,
                        difficulty: question.difficulty || 'Mittel',
                        answered: result.answered,
                        score: result.score,
                        maxScore: result.maxScore,
                        percentage: result.maxScore > 0 ? (result.score / result.maxScore * 100) : 0,
                        isCorrect: result.isCorrect,
                        feedback: result.feedback
                    });
                }
            }
            
            // Sortiere Fragen nach Kategorien und Leistung
            report.questionDetails.sort((a, b) => {
                if (a.category === b.category) {
                    return a.percentage - b.percentage; // Aufsteigend nach Leistung innerhalb einer Kategorie
                }
                return a.category.localeCompare(b.category); // Alphabetisch nach Kategorie
            });
            
            // Empfehlungen generieren
            // 1. Basierend auf Schwächen
            if (report.strengthsWeaknesses.weaknesses.length > 0) {
                report.strengthsWeaknesses.weaknesses.forEach(weakness => {
                    report.recommendations.push({
                        type: 'weakness',
                        category: weakness.category,
                        message: `Wiederholen Sie die Inhalte zum Thema "${weakness.category}" (${weakness.percentage.toFixed(1)}%).`,
                        priority: 'hoch'
                    });
                });
            }
            
            // 2. Basierend auf Verbesserungsbereichen
            if (report.strengthsWeaknesses.improvementAreas.length > 0) {
                report.strengthsWeaknesses.improvementAreas.forEach(area => {
                    report.recommendations.push({
                        type: 'improvement',
                        category: area.category,
                        message: `Vertiefen Sie Ihr Wissen zum Thema "${area.category}" (${area.percentage.toFixed(1)}%).`,
                        priority: 'mittel'
                    });
                });
            }
            
            // 3. Allgemeine Empfehlungen basierend auf der Gesamtleistung
            if (report.summary.percentage < 50) {
                report.recommendations.push({
                    type: 'general',
                    message: 'Die Grundlagen der Inhalte sollten wiederholt werden, bevor fortgeschrittene Themen bearbeitet werden.',
                    priority: 'hoch'
                });
            } else if (report.summary.percentage >= 50 && report.summary.percentage < report.summary.passingThreshold) {
                report.recommendations.push({
                    type: 'general',
                    message: 'Sie sind auf einem guten Weg! Konzentrieren Sie sich auf die Verbesserung in den schwächeren Bereichen.',
                    priority: 'mittel'
                });
            } else if (report.summary.percentage >= 90) {
                report.recommendations.push({
                    type: 'general',
                    message: 'Ausgezeichnete Leistung! Sie können sich fortgeschrittenen Themen zuwenden.',
                    priority: 'niedrig'
                });
            }
            
            console.log('Detaillierter Auswertungsbericht generiert:', report);
            return report;
        } catch (error) {
            console.error('Fehler bei der Generierung des Auswertungsberichts:', error);
            throw error;
        }
    };
    
    // Erweitere die initialize-Methode, um auch die erweiterten Funktionen zu initialisieren
    const originalInitialize = app.testEvaluation.initialize;
    app.testEvaluation.initialize = function(options) {
        // Rufe die ursprüngliche Methode auf
        originalInitialize.call(this, options);
        
        // Initialisiere die erweiterten Funktionen
        this.initializeAdvanced(options);
    };
    
    // Erweitere die öffentliche Schnittstelle um die neuen Funktionen
    Object.assign(app.testEvaluation.interface, {
        evaluateNumeric: app.testEvaluation.evaluateNumeric.bind(app.testEvaluation),
        evaluatePattern: app.testEvaluation.evaluatePattern.bind(app.testEvaluation),
        calculateAdvancedTextSimilarity: app.testEvaluation.calculateAdvancedTextSimilarity.bind(app.testEvaluation),
        generateDetailedReport: app.testEvaluation.generateDetailedReport.bind(app.testEvaluation),
        updateEvaluationWithManualScores: app.testEvaluation.updateEvaluationWithManualScores.bind(app.testEvaluation)
    });
    
    // Erweitere die evaluateQuestion-Methode, um die neuen Fragentypen zu unterstützen
    const originalEvaluateQuestion = app.testEvaluation.evaluateQuestion;
    app.testEvaluation.evaluateQuestion = function(question, userAnswer) {
        // Erweiterte Fragetypen abfangen
        if (question.type === 'numeric') {
            return this.evaluateNumeric(question, userAnswer);
        } else if (question.type === 'pattern' || (question.type === 'free-text' && question.pattern)) {
            return this.evaluatePattern(question, userAnswer);
        } else if (question.type === 'free-text' && question.evaluationMode === 'advanced') {
            // Freitext mit erweiterter Textanalyse
            const result = originalEvaluateQuestion.call(this, question, userAnswer);
            
            // Ersetze die Ähnlichkeitsberechnung durch die erweiterte Version
            if (typeof userAnswer === 'string' && (typeof question.correctAnswer === 'string' || Array.isArray(question.correctAnswers))) {
                const userText = userAnswer;
                const correctText = typeof question.correctAnswer === 'string' ? 
                    question.correctAnswer : 
                    question.correctAnswers[0];
                
                const similarity = this.calculateAdvancedTextSimilarity(userText, correctText);
                
                // Aktualisiere die Punktzahl basierend auf der erweiterten Ähnlichkeit
                if (similarity >= this.config.textSimilarityThreshold) {
                    const partialScore = similarity;
                    result.score = Number((partialScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                    result.isCorrect = partialScore >= 0.95;
                    result.feedback = result.isCorrect ? 
                        'Korrekt (Erweiterte Textanalyse)' : 
                        `Teilweise korrekt (${Math.round(partialScore * 100)}% Übereinstimmung, erweiterte Analyse)`;
                }
            }
            
            return result;
        } else {
            // Standardfälle an die ursprüngliche Methode delegieren
            return originalEvaluateQuestion.call(this, question, userAnswer);
        }
    };
    
    console.log('Erweiterte Auswertungsalgorithmen (Teil 1.2) initialisiert');
})();
/**
 * JS-Block 6.1.2-part1: Auswertungsalgorithmen (Teil 2.1)
 * 
 * Dieser Block ergänzt die Auswertungsalgorithmen um zusätzliche Fragetypen,
 * Gruppenauswertungen, adaptive Bewertung und leistungsbasierte Metriken.
 */
(function() {
    // Erweiterte Konfiguration für spezielle Bewertungsszenarien
    if (!app.testEvaluation.scoringConfig) {
        app.testEvaluation.scoringConfig = {
            // Konfiguration für adaptive Bewertung
            adaptive: {
                // Ob adaptive Bewertung aktiviert ist
                enabled: false,
                
                // Maximaler Gewichtungsfaktor für schwierige Fragen
                maxDifficultyWeight: 1.5,
                
                // Minimaler Gewichtungsfaktor für einfache Fragen
                minDifficultyWeight: 0.8,
                
                // Ob die adaptive Bewertung dem Benutzer angezeigt werden soll
                showToUser: true,
                
                // Ob vorherige Leistung bei der Bewertung berücksichtigt werden soll
                considerPriorPerformance: false
            },
            
            // Konfiguration für Zeitbonus/Malus
            timeScoring: {
                // Ob zeitbasierte Bewertung aktiviert ist
                enabled: false,
                
                // Maximaler Zeitbonus (in % der Fragenpunkte)
                maxTimeBonus: 0.1,
                
                // Zeitlimit, unter dem der maximale Bonus gewährt wird (in % der durchschnittlichen Zeit)
                timeBonusThreshold: 0.5,
                
                // Ob Malus für langsame Antworten vergeben werden soll
                applyTimePenalty: false,
                
                // Maximaler Zeitmalus (in % der Fragenpunkte)
                maxTimePenalty: 0.05
            },
            
            // Konfiguration für sequenzabhängige Bewertung
            sequential: {
                // Ob sequenzabhängige Bewertung aktiviert ist
                enabled: false,
                
                // Gewichtungsfaktor für die erste Frage in einer Sequenz
                firstQuestionWeight: 1.2,
                
                // Gewichtungsfaktor für Fragen in der Mitte einer Sequenz
                middleQuestionWeight: 1.0,
                
                // Gewichtungsfaktor für die letzte Frage in einer Sequenz
                lastQuestionWeight: 1.5
            },
            
            // Konfiguration für gruppierte Fragen
            groupScoring: {
                // Ob Gruppenbewertung aktiviert ist
                enabled: false,
                
                // Wie Gruppenergebnisse berechnet werden sollen ('all', 'majority', 'weighted')
                groupScoringMode: 'weighted',
                
                // Ob Gruppen unterschiedlich gewichtet werden sollen
                applyGroupWeights: false
            }
        };
    }
    
    /**
     * Initialisiert die erweiterten Bewertungsfunktionen
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testEvaluation.initializeAdvancedScoring = function(options) {
        console.log('Initialisiere erweiterte Bewertungsfunktionen mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            // Rekursives Zusammenführen der Konfigurationsobjekte
            this.scoringConfig = this.mergeConfigurations(this.scoringConfig, options);
        }
        
        // Event-Listener für adaptive Testauswertungen
        document.addEventListener('adaptiveTestCompleted', (event) => {
            if (event.detail && event.detail.testId) {
                console.log('Adaptiver Test abgeschlossen, wende spezielle Auswertungsfunktionen an:', event.detail);
                this.applyAdaptiveScoring(event.detail.testId, event.detail.userId);
            }
        });
        
        console.log('Erweiterte Bewertungsfunktionen initialisiert');
    };
    
    /**
     * Wertet eine Zuordnungsfrage aus
     * @param {Object} question - Die Fragedaten
     * @param {Object} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateMatching = function(question, userAnswer) {
        console.log('Werte Zuordnungsfrage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Überprüfe das Antwortformat
            if (!userAnswer || typeof userAnswer !== 'object' || Array.isArray(userAnswer)) {
                console.warn('Zuordnungsfrage-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Extrahiere die korrekten Zuordnungen aus der Frage
            if (!question.matches || !Array.isArray(question.matches) || question.matches.length === 0) {
                console.warn('Keine Zuordnungen für die Frage definiert:', question.id);
                result.feedback = 'Keine korrekten Zuordnungen definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Berechne die maximale Punktzahl basierend auf der Anzahl der Zuordnungen
            const totalMatches = question.matches.length;
            const pointsPerMatch = result.maxScore / totalMatches;
            
            // Zähle korrekte Zuordnungen
            let correctMatches = 0;
            const incorrectMatchings = [];
            
            for (const match of question.matches) {
                const { left, right } = match;
                
                // Überprüfe, ob die Benutzerzuordnung korrekt ist
                if (userAnswer[left] === right) {
                    correctMatches++;
                } else {
                    incorrectMatchings.push({
                        item: left,
                        userMatch: userAnswer[left],
                        correctMatch: right
                    });
                }
            }
            
            // Berechne die Punktzahl basierend auf korrekten Zuordnungen
            result.score = Number((correctMatches * pointsPerMatch).toFixed(this.config.scoreDecimalPlaces));
            result.isCorrect = correctMatches === totalMatches;
            
            // Generiere Feedback
            if (result.isCorrect) {
                result.feedback = 'Alle Zuordnungen sind korrekt.';
            } else {
                result.feedback = `${correctMatches} von ${totalMatches} Zuordnungen sind korrekt.`;
                
                // Füge Details zu falschen Zuordnungen hinzu, wenn nicht zu viele vorhanden sind
                if (incorrectMatchings.length <= 3) {
                    result.feedback += ' Falsche Zuordnungen:';
                    
                    for (const incorrect of incorrectMatchings) {
                        result.feedback += ` "${incorrect.item}" wurde "${incorrect.userMatch}" zugeordnet, korrekt wäre "${incorrect.correctMatch}".`;
                    }
                }
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Zuordnungsfrage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Wertet eine Reihenfolge-Frage aus
     * @param {Object} question - Die Fragedaten
     * @param {Array} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateSequence = function(question, userAnswer) {
        console.log('Werte Reihenfolge-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Überprüfe das Antwortformat
            if (!Array.isArray(userAnswer)) {
                console.warn('Reihenfolge-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Extrahiere die korrekte Reihenfolge aus der Frage
            if (!question.correctSequence || !Array.isArray(question.correctSequence) || question.correctSequence.length === 0) {
                console.warn('Keine korrekte Reihenfolge für die Frage definiert:', question.id);
                result.feedback = 'Keine korrekte Reihenfolge definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            const correctSequence = question.correctSequence;
            
            // Überprüfe, ob die Antwort die richtige Anzahl von Elementen enthält
            if (userAnswer.length !== correctSequence.length) {
                result.feedback = `Die Antwort enthält ${userAnswer.length} Elemente, erwartet werden ${correctSequence.length}.`;
                return result;
            }
            
            // Exakte Übereinstimmung prüfen
            const isExactMatch = JSON.stringify(userAnswer) === JSON.stringify(correctSequence);
            
            if (isExactMatch) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Die Reihenfolge ist korrekt.';
                return result;
            }
            
            // Wenn keine exakte Übereinstimmung, prüfe auf Teilübereinstimmungen
            if (this.config.allowPartialScoring) {
                // Berechne Levenshtein-Distanz für Sequenzen
                const distance = this.calculateSequenceDistance(userAnswer, correctSequence);
                const maxDistance = Math.max(userAnswer.length, correctSequence.length);
                
                // Normalisierte Ähnlichkeit (1 = identisch, 0 = komplett verschieden)
                const similarity = 1 - (distance / maxDistance);
                
                // Partial LCS Score (Longest Common Subsequence)
                const lcsScore = this.calculateLCS(userAnswer, correctSequence) / correctSequence.length;
                
                // Kombinierte Bewertung (Gewichtung von Ähnlichkeit und LCS)
                const combinedScore = (similarity * 0.6) + (lcsScore * 0.4);
                
                // Berechne Punkte basierend auf der kombinierten Bewertung
                result.score = Number((combinedScore * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                
                // Generiere detailliertes Feedback
                if (combinedScore >= 0.8) {
                    result.feedback = `Die Reihenfolge ist fast korrekt (${Math.round(combinedScore * 100)}% Übereinstimmung).`;
                } else if (combinedScore >= 0.5) {
                    result.feedback = `Die Reihenfolge ist teilweise korrekt (${Math.round(combinedScore * 100)}% Übereinstimmung).`;
                    
                    // Füge Hinweise zu den korrekten Positionen hinzu
                    const correctPositions = [];
                    for (let i = 0; i < userAnswer.length; i++) {
                        if (userAnswer[i] === correctSequence[i]) {
                            correctPositions.push(i + 1);
                        }
                    }
                    
                    if (correctPositions.length > 0) {
                        result.feedback += ` Korrekte Positionen: ${correctPositions.join(', ')}.`;
                    }
                } else {
                    result.feedback = `Die Reihenfolge weicht stark von der korrekten Reihenfolge ab (${Math.round(combinedScore * 100)}% Übereinstimmung).`;
                }
            } else {
                // Keine Teilpunkte, komplett falsch
                result.score = 0;
                result.isCorrect = false;
                result.feedback = 'Die Reihenfolge ist nicht korrekt.';
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Reihenfolge-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Berechnet die Levenshtein-Distanz zwischen zwei Sequenzen
     * @param {Array} seq1 - Erste Sequenz
     * @param {Array} seq2 - Zweite Sequenz
     * @return {number} - Distanz zwischen den Sequenzen
     */
    app.testEvaluation.calculateSequenceDistance = function(seq1, seq2) {
        const m = seq1.length;
        const n = seq2.length;
        
        // Matrix für dynamische Programmierung
        const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
        
        // Initialisierung
        for (let i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        
        for (let j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        // Berechnung der Distanz
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                const cost = seq1[i - 1] === seq2[j - 1] ? 0 : 1;
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,      // Löschung
                    dp[i][j - 1] + 1,      // Einfügung
                    dp[i - 1][j - 1] + cost // Ersetzung
                );
            }
        }
        
        return dp[m][n];
    };
    
    /**
     * Berechnet die Länge der längsten gemeinsamen Teilsequenz
     * @param {Array} seq1 - Erste Sequenz
     * @param {Array} seq2 - Zweite Sequenz
     * @return {number} - Länge der längsten gemeinsamen Teilsequenz
     */
    app.testEvaluation.calculateLCS = function(seq1, seq2) {
        const m = seq1.length;
        const n = seq2.length;
        
        // Matrix für dynamische Programmierung
        const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
        
        // Berechnung der LCS-Länge
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (seq1[i - 1] === seq2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    };
    
    /**
     * Wertet eine Hotspot-Frage (Bildbereich-Auswahl) aus
     * @param {Object} question - Die Fragedaten
     * @param {Object} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateHotspot = function(question, userAnswer) {
        console.log('Werte Hotspot-Frage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: ''
        };
        
        try {
            // Überprüfe das Antwortformat
            if (!userAnswer || typeof userAnswer !== 'object' || 
                !('x' in userAnswer) || !('y' in userAnswer)) {
                console.warn('Hotspot-Antwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            // Extrahiere die korrekten Hotspot-Bereiche aus der Frage
            if (!question.correctAreas || !Array.isArray(question.correctAreas) || question.correctAreas.length === 0) {
                console.warn('Keine korrekten Bereiche für die Hotspot-Frage definiert:', question.id);
                result.feedback = 'Keine korrekten Bereiche definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Prüfe, ob der Klick in einem der korrekten Bereiche liegt
            const userClick = { x: userAnswer.x, y: userAnswer.y };
            let isInAnyCorrectArea = false;
            
            for (const area of question.correctAreas) {
                if (this.isPointInArea(userClick, area)) {
                    isInAnyCorrectArea = true;
                    break;
                }
            }
            
            if (isInAnyCorrectArea) {
                result.score = result.maxScore;
                result.isCorrect = true;
                result.feedback = 'Der ausgewählte Bereich ist korrekt.';
            } else {
                // Bei Hotspot-Fragen gibt es in der Regel keine Teilpunkte
                result.score = 0;
                result.isCorrect = false;
                result.feedback = 'Der ausgewählte Bereich ist nicht korrekt.';
            }
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Hotspot-Frage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Prüft, ob ein Punkt innerhalb eines definierten Bereichs liegt
     * @param {Object} point - Der zu prüfende Punkt (x, y)
     * @param {Object} area - Der definierte Bereich
     * @return {boolean} - Ob der Punkt im Bereich liegt
     */
    app.testEvaluation.isPointInArea = function(point, area) {
        // Rechteckiger Bereich
        if (area.type === 'rectangle') {
            return point.x >= area.x &&
                   point.x <= area.x + area.width &&
                   point.y >= area.y &&
                   point.y <= area.y + area.height;
        }
        // Kreisförmiger Bereich
        else if (area.type === 'circle') {
            const dx = point.x - area.centerX;
            const dy = point.y - area.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= area.radius;
        }
        // Polygonaler Bereich
        else if (area.type === 'polygon' && Array.isArray(area.points) && area.points.length >= 3) {
            return this.isPointInPolygon(point, area.points);
        }
        
        return false;
    };
    
    /**
     * Prüft, ob ein Punkt innerhalb eines Polygons liegt (Ray Casting Algorithmus)
     * @param {Object} point - Der zu prüfende Punkt (x, y)
     * @param {Array} polygon - Array von Punkten des Polygons
     * @return {boolean} - Ob der Punkt im Polygon liegt
     */
    app.testEvaluation.isPointInPolygon = function(point, polygon) {
        let inside = false;
        const x = point.x;
        const y = point.y;
        
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x;
            const yi = polygon[i].y;
            const xj = polygon[j].x;
            const yj = polygon[j].y;
            
            const intersect = ((yi > y) !== (yj > y)) && 
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
            if (intersect) {
                inside = !inside;
            }
        }
        
        return inside;
    };
    
    /**
     * Wertet eine Frage mit Gruppenauswertung aus
     * @param {Object} question - Die Fragedaten
     * @param {Object} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateGroup = function(question, userAnswer) {
        console.log('Werte Gruppenfrage aus:', question.id);
        
        const result = {
            score: 0,
            maxScore: question.points || 1,
            isCorrect: false,
            autoEvaluated: true,
            needsManualEvaluation: false,
            feedback: '',
            subResults: [] // Ergebnisse der Unterfragen
        };
        
        try {
            // Überprüfe, ob die Frage tatsächlich eine Gruppe ist
            if (!question.subQuestions || !Array.isArray(question.subQuestions) || question.subQuestions.length === 0) {
                console.warn('Keine Unterfragen für die Gruppenfrage definiert:', question.id);
                result.feedback = 'Keine Unterfragen definiert';
                result.needsManualEvaluation = true;
                return result;
            }
            
            // Überprüfe das Antwortformat
            if (!userAnswer || typeof userAnswer !== 'object') {
                console.warn('Gruppenantwort hat ungültiges Format:', userAnswer);
                result.feedback = 'Ungültiges Antwortformat';
                return result;
            }
            
            const subQuestions = question.subQuestions;
            let totalSubScore = 0;
            let totalSubMaxScore = 0;
            let correctSubQuestions = 0;
            
            // Werte jede Unterfrage separat aus
            for (const subQuestion of subQuestions) {
                const subId = subQuestion.id;
                const subUserAnswer = userAnswer[subId];
                
                if (subUserAnswer === undefined) {
                    // Keine Antwort für diese Unterfrage
                    result.subResults.push({
                        questionId: subId,
                        score: 0,
                        maxScore: subQuestion.points || 1,
                        isCorrect: false,
                        answered: false,
                        feedback: 'Keine Antwort gegeben'
                    });
                    
                    totalSubMaxScore += subQuestion.points || 1;
                    continue;
                }
                
                // Werte die Unterfrage entsprechend ihres Typs aus
                const subResult = this.evaluateSubQuestion(subQuestion, subUserAnswer);
                
                // Füge das Ergebnis der Unterfrage zu den Unterergebnissen hinzu
                result.subResults.push({
                    questionId: subId,
                    score: subResult.score,
                    maxScore: subResult.maxScore,
                    isCorrect: subResult.isCorrect,
                    answered: true,
                    feedback: subResult.feedback
                });
                
                // Aktualisiere die Gesamtstatistik
                totalSubScore += subResult.score;
                totalSubMaxScore += subResult.maxScore;
                
                if (subResult.isCorrect) {
                    correctSubQuestions++;
                }
            }
            
            // Berechne die Gesamtpunktzahl basierend auf dem Gruppenmodus
            const groupMode = question.groupScoringMode || this.scoringConfig.groupScoring.groupScoringMode;
            
            switch (groupMode) {
                case 'all': // Alle Unterfragen müssen korrekt sein
                    if (correctSubQuestions === subQuestions.length) {
                        result.score = result.maxScore;
                        result.isCorrect = true;
                    } else {
                        result.score = 0;
                        result.isCorrect = false;
                    }
                    break;
                    
                case 'majority': // Mehrheit der Unterfragen muss korrekt sein
                    if (correctSubQuestions > subQuestions.length / 2) {
                        result.score = result.maxScore;
                        result.isCorrect = true;
                    } else {
                        result.score = 0;
                        result.isCorrect = false;
                    }
                    break;
                    
                case 'weighted': // Gewichtete Punktzahl basierend auf Unterfragenergebnissen
                default:
                    if (totalSubMaxScore > 0) {
                        const percentage = totalSubScore / totalSubMaxScore;
                        result.score = Number((percentage * result.maxScore).toFixed(this.config.scoreDecimalPlaces));
                        result.isCorrect = percentage >= 0.99; // 99% oder mehr wird als vollständig korrekt betrachtet
                    }
                    break;
            }
            
            // Generiere Feedback basierend auf den Ergebnissen
            result.feedback = `${correctSubQuestions} von ${subQuestions.length} Unterfragen korrekt beantwortet.`;
            
            return result;
        } catch (error) {
            console.error('Fehler bei der Auswertung der Gruppenfrage:', error);
            result.feedback = `Fehler bei der Auswertung: ${error.message}`;
            return result;
        }
    };
    
    /**
     * Wertet eine Unterfrage aus
     * @param {Object} subQuestion - Die Unterfragedaten
     * @param {any} userAnswer - Die Antwort des Benutzers
     * @return {Object} - Das Auswertungsergebnis
     */
    app.testEvaluation.evaluateSubQuestion = function(subQuestion, userAnswer) {
        // Delegiere die Auswertung an die entsprechende Methode basierend auf dem Typ
        switch (subQuestion.type) {
            case 'multiple-choice':
                return this.evaluateMultipleChoice(subQuestion, userAnswer);
                
            case 'single-choice':
                return this.evaluateSingleChoice(subQuestion, userAnswer);
                
            case 'true-false':
                return this.evaluateTrueFalse(subQuestion, userAnswer);
                
            case 'free-text':
                return this.evaluateFreeText(subQuestion, userAnswer);
                
            case 'numeric':
                return this.evaluateNumeric(subQuestion, userAnswer);
                
            case 'matching':
                return this.evaluateMatching(subQuestion, userAnswer);
                
            case 'sequence':
                return this.evaluateSequence(subQuestion, userAnswer);
                
            case 'hotspot':
                return this.evaluateHotspot(subQuestion, userAnswer);
                
            default:
                console.warn(`Unbekannter Unterfragetyp: ${subQuestion.type}`);
                return {
                    score: 0,
                    maxScore: subQuestion.points || 1,
                    isCorrect: false,
                    autoEvaluated: false,
                    needsManualEvaluation: true,
                    feedback: `Unterstützung für Fragetyp ${subQuestion.type} nicht implementiert`
                };
        }
    };
    
    /**
     * Wendet adaptive Bewertung auf ein Testergebnis an
     * @param {string} testId - ID des Tests
     * @param {string} userId - ID des Benutzers
     * @return {Promise<Object>} - Promise mit dem aktualisierten Auswertungsergebnis
     */
    app.testEvaluation.applyAdaptiveScoring = function(testId, userId) {
        console.log(`Wende adaptive Bewertung auf Test ${testId} für Benutzer ${userId} an`);
        
        return new Promise((resolve, reject) => {
            try {
                // Prüfe, ob adaptive Bewertung aktiviert ist
                if (!this.scoringConfig.adaptive.enabled) {
                    console.log('Adaptive Bewertung ist deaktiviert.');
                    resolve(null);
                    return;
                }
                
                // Lade die vorhandene Auswertung
                const evaluation = app.dataManager.getTestEvaluation(testId, userId);
                if (!evaluation) {
                    throw new Error('Keine Auswertung gefunden');
                }
                
                // Lade Test-Informationen
                const test = app.dataManager.getTestById(testId);
                if (!test) {
                    throw new Error('Test nicht gefunden');
                }
                
                // Benutzerinformationen und frühere Leistungen laden, falls konfiguriert
                let userPriorPerformance = null;
                if (this.scoringConfig.adaptive.considerPriorPerformance) {
                    userPriorPerformance = app.dataManager.getUserPerformanceHistory(userId);
                }
                
                // Kopie der vorhandenen Auswertung erstellen
                const adaptedEvaluation = JSON.parse(JSON.stringify(evaluation));
                
                // Metadaten für die adaptive Bewertung hinzufügen
                adaptedEvaluation.adaptiveScoring = {
                    applied: true,
                    originalScore: evaluation.totalScore,
                    originalPercentage: evaluation.percentageScore,
                    adaptiveFactors: {}
                };
                
                // Gesamtpunktzahl zurücksetzen
                adaptedEvaluation.totalScore = 0;
                
                // Jede Frage mit adaptiver Bewertung neu bewerten
                const questionResults = adaptedEvaluation.questionResults;
                
                for (const questionId in questionResults) {
                    if (questionResults.hasOwnProperty(questionId)) {
                        const result = questionResults[questionId];
                        const question = app.dataManager.getQuestionById(questionId);
                        
                        if (!question) continue;
                        
                        // Adaptive Faktoren berechnen
                        const adaptiveFactors = this.calculateAdaptiveFactors(question, userPriorPerformance);
                        
                        // Ursprüngliche Punktzahl und Faktoren speichern
                        const originalScore = result.score;
                        adaptedEvaluation.adaptiveScoring.adaptiveFactors[questionId] = adaptiveFactors;
                        
                        // Angepasste Punktzahl berechnen
                        const adaptedScore = originalScore * adaptiveFactors.totalFactor;
                        
                        // Punktzahl auf maximale Punktzahl begrenzen
                        result.adaptedScore = Math.min(
                            Number(adaptedScore.toFixed(this.config.scoreDecimalPlaces)),
                            result.maxScore
                        );
                        
                        // Gesamtpunktzahl aktualisieren
                        adaptedEvaluation.totalScore += result.adaptedScore;
                    }
                }
                
                // Prozentsatz und Bestanden/Nicht bestanden aktualisieren
                if (adaptedEvaluation.maxScore > 0) {
                    adaptedEvaluation.percentageScore = Number(
                        (adaptedEvaluation.totalScore / adaptedEvaluation.maxScore * 100).toFixed(2)
                    );
                }
                
                adaptedEvaluation.passed = adaptedEvaluation.percentageScore >= adaptedEvaluation.passingThreshold;
                
                // Speichern der aktualisierten Auswertung
                const savedEvaluation = app.dataManager.saveTestEvaluation(adaptedEvaluation);
                
                if (!savedEvaluation) {
                    throw new Error('Fehler beim Speichern der adaptierten Auswertung');
                }
                
                // Event für aktualisierte Auswertung auslösen
                const updateEvent = new CustomEvent('adaptiveScoringApplied', {
                    detail: savedEvaluation
                });
                document.dispatchEvent(updateEvent);
                
                console.log('Adaptive Bewertung erfolgreich angewendet:', savedEvaluation);
                resolve(savedEvaluation);
            } catch (error) {
                console.error('Fehler bei der Anwendung der adaptiven Bewertung:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Berechnet adaptive Faktoren für eine Frage
     * @param {Object} question - Die Fragedaten
     * @param {Object} userPerformance - Frühere Leistungsdaten des Benutzers
     * @return {Object} - Berechnete adaptive Faktoren
     */
    app.testEvaluation.calculateAdaptiveFactors = function(question, userPerformance) {
        const factors = {
            difficultyFactor: 1.0,
            categoryFactor: 1.0,
            timeBasedFactor: 1.0,
            personalizedFactor: 1.0,
            totalFactor: 1.0
        };
        
        // Faktor basierend auf Schwierigkeit
        if (question.difficulty) {
            switch (question.difficulty.toLowerCase()) {
                case 'leicht':
                case 'easy':
                case 'low':
                    factors.difficultyFactor = this.scoringConfig.adaptive.minDifficultyWeight;
                    break;
                    
                case 'schwer':
                case 'hard':
                case 'high':
                    factors.difficultyFactor = this.scoringConfig.adaptive.maxDifficultyWeight;
                    break;
                    
                case 'mittel':
                case 'medium':
                default:
                    factors.difficultyFactor = 1.0;
                    break;
            }
        }
        
        // Faktor basierend auf vorheriger Leistung in dieser Kategorie
        if (userPerformance && question.category && 
            userPerformance.categories && userPerformance.categories[question.category]) {
            
            const categoryPerformance = userPerformance.categories[question.category];
            
            // Wenn die Kategorie eine Schwäche ist, höher gewichten
            if (categoryPerformance.score < 60 && categoryPerformance.total >= 3) {
                factors.categoryFactor = 1.2; // 20% mehr Punkte für Schwachstellenkategorien
            }
        }
        
        // Gesamt-Anpassungsfaktor berechnen
        factors.totalFactor = factors.difficultyFactor * 
                             factors.categoryFactor * 
                             factors.timeBasedFactor * 
                             factors.personalizedFactor;
        
        return factors;
    };
    
    // Erweitere die testEvaluation.interface mit den neuen Funktionen
    Object.assign(app.testEvaluation.interface, {
        evaluateMatching: app.testEvaluation.evaluateMatching.bind(app.testEvaluation),
        evaluateSequence: app.testEvaluation.evaluateSequence.bind(app.testEvaluation),
        evaluateHotspot: app.testEvaluation.evaluateHotspot.bind(app.testEvaluation),
        evaluateGroup: app.testEvaluation.evaluateGroup.bind(app.testEvaluation),
        applyAdaptiveScoring: app.testEvaluation.applyAdaptiveScoring.bind(app.testEvaluation),
        initializeAdvancedScoring: app.testEvaluation.initializeAdvancedScoring.bind(app.testEvaluation)
    });
    
    // Erweitere die evaluateQuestion-Methode um die neuen Fragentypen
    const originalEvaluateQuestion = app.testEvaluation.evaluateQuestion;
    app.testEvaluation.evaluateQuestion = function(question, userAnswer) {
        // Erweiterte Fragetypen abfangen
        switch (question.type) {
            case 'matching':
                return this.evaluateMatching(question, userAnswer);
                
            case 'sequence':
                return this.evaluateSequence(question, userAnswer);
                
            case 'hotspot':
                return this.evaluateHotspot(question, userAnswer);
                
            case 'group':
                return this.evaluateGroup(question, userAnswer);
                
            default:
                // Standardfälle an die ursprüngliche Methode delegieren
                return originalEvaluateQuestion.call(this, question, userAnswer);
        }
    };
    
    // Erweitere die initialize-Methode, um auch die erweiterten Bewertungsfunktionen zu initialisieren
    const initializeOriginal = app.testEvaluation.initialize;
    app.testEvaluation.initialize = function(options) {
        // Rufe die ursprüngliche Methode auf
        initializeOriginal.call(this, options);
        
        // Initialisiere die erweiterten Bewertungsfunktionen
        this.initializeAdvancedScoring(options);
    };
    
    console.log('Auswertungsalgorithmen (Teil 2.1) initialisiert');
})();
/**
 * JS-Block 6.1.2-part2: Auswertungsalgorithmen (Teil 2.2)
 * 
 * Dieser Block ergänzt die Auswertungsalgorithmen um statistische Auswertungen,
 * vergleichende Analysen, Kompetenzmodellierung und erweiterte Berichtsfunktionen.
 */
(function() {
    // Konfiguration für statistische Auswertungen und Analysen
    if (!app.testEvaluation.analysisConfig) {
        app.testEvaluation.analysisConfig = {
            // Konfiguration für statistische Berechnungen
            statistics: {
                // Minimale Stichprobengröße für valide statistische Auswertungen
                minSampleSize: 5,
                
                // Signifikanzniveau für statistische Tests
                significanceLevel: 0.05,
                
                // Standardabweichungen für die Klassifizierung von Ausreißern
                outlierThreshold: 2.0,
                
                // Vertrauensintervall für Mittelwerte (in Prozent)
                confidenceInterval: 0.95
            },
            
            // Konfiguration für vergleichende Analysen
            comparative: {
                // Schwellenwert für signifikante Unterschiede (in Prozentpunkten)
                significantDifference: 5.0,
                
                // Anzahl der Top/Bottom-Performer für Detailanalysen
                topPerformerCount: 10,
                
                // Ob Vergleiche mit früheren Tests des gleichen Benutzers durchgeführt werden sollen
                compareToPreviousTests: true,
                
                // Maximalzahl der zu vergleichenden vorherigen Tests
                maxPreviousTestsCount: 3
            },
            
            // Konfiguration für Kompetenzmodellierung
            competencyModel: {
                // Ob Kompetenzmodellierung aktiviert ist
                enabled: true,
                
                // Standardkompetenzlevel und deren Schwellenwerte (in Prozent)
                levels: [
                    { id: 'beginner', name: 'Anfänger', threshold: 0 },
                    { id: 'basic', name: 'Grundkenntnisse', threshold: 40 },
                    { id: 'intermediate', name: 'Fortgeschritten', threshold: 65 },
                    { id: 'advanced', name: 'Experte', threshold: 85 }
                ],
                
                // Mindestanzahl an Testdurchführungen für zuverlässige Kompetenzeinschätzung
                minTestsForReliability: 2
            },
            
            // Konfiguration für Berichte und Visualisierungen
            reporting: {
                // Maximale Anzahl an Detailelementen in Berichten
                maxDetailItems: 20,
                
                // Ob Empfehlungen in Berichten enthalten sein sollen
                includeRecommendations: true,
                
                // Anzahl der zu inkludierenden Empfehlungen
                maxRecommendations: 5,
                
                // Standardfarben für Visualisierungen
                colors: {
                    correct: '#4CAF50',    // Grün
                    incorrect: '#F44336',  // Rot
                    partial: '#FF9800',    // Orange
                    neutral: '#9E9E9E'     // Grau
                }
            }
        };
    }
    
    /**
     * Initialisiert die statistischen Auswertungsalgorithmen
     * @param {Object} options - Konfigurationsoptionen
     */
    app.testEvaluation.initializeAnalysis = function(options) {
        console.log('Initialisiere statistische Auswertungsalgorithmen mit Optionen:', options);
        
        // Konfiguration mit übergebenen Optionen überschreiben
        if (options) {
            // Rekursives Zusammenführen der Konfigurationsobjekte
            this.analysisConfig = this.mergeConfigurations(this.analysisConfig, options);
        }
        
        // Event-Listener für abgeschlossene Auswertungen
        document.addEventListener('testEvaluated', (event) => {
            if (event.detail) {
                console.log('Test ausgewertet, starte erweiterte Analysen:', event.detail);
                this.performAdvancedAnalysis(event.detail);
            }
        });
        
        console.log('Statistische Auswertungsalgorithmen initialisiert');
    };
    
    /**
     * Führt erweiterte Analysen für ein ausgewertetes Testergebnis durch
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @return {Promise<Object>} - Promise mit den erweiterten Analysen
     */
    app.testEvaluation.performAdvancedAnalysis = function(evaluation) {
        console.log('Führe erweiterte Analysen durch für:', evaluation);
        
        return new Promise((resolve, reject) => {
            try {
                const { testId, userId } = evaluation;
                
                if (!testId || !userId) {
                    throw new Error('Ungültige Auswertungsdaten');
                }
                
                // Erstelle Basisdatenstruktur für erweiterte Analysen
                const advancedAnalysis = {
                    testId: testId,
                    userId: userId,
                    timestamp: new Date().toISOString(),
                    statistics: {},
                    comparisons: {},
                    competency: {},
                    insights: [],
                    recommendations: []
                };
                
                // Sammle zusätzliche Daten für die Analyse
                Promise.all([
                    this.computeStatistics(evaluation),
                    this.performComparativeAnalysis(evaluation),
                    this.assessCompetencyLevels(evaluation),
                    this.generateInsights(evaluation)
                ])
                .then(([statistics, comparisons, competency, insights]) => {
                    // Daten in die Analyse-Struktur einfügen
                    advancedAnalysis.statistics = statistics;
                    advancedAnalysis.comparisons = comparisons;
                    advancedAnalysis.competency = competency;
                    advancedAnalysis.insights = insights;
                    
                    // Generiere Empfehlungen basierend auf den Analyseergebnissen
                    return this.generateRecommendations(evaluation, advancedAnalysis);
                })
                .then(recommendations => {
                    advancedAnalysis.recommendations = recommendations;
                    
                    // Speichere die erweiterten Analysen
                    const savedAnalysis = app.dataManager.saveTestAnalysis(testId, userId, advancedAnalysis);
                    
                    // Event für abgeschlossene Analyse auslösen
                    const analysisEvent = new CustomEvent('testAnalysisCompleted', {
                        detail: savedAnalysis
                    });
                    document.dispatchEvent(analysisEvent);
                    
                    console.log('Erweiterte Analysen abgeschlossen:', savedAnalysis);
                    resolve(savedAnalysis);
                })
                .catch(error => {
                    console.error('Fehler bei der Durchführung erweiterter Analysen:', error);
                    reject(error);
                });
            } catch (error) {
                console.error('Fehler bei der Initialisierung erweiterter Analysen:', error);
                reject(error);
            }
        });
    };
    
    /**
     * Berechnet statistische Kennzahlen für die Auswertung
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @return {Promise<Object>} - Promise mit statistischen Kennzahlen
     */
    app.testEvaluation.computeStatistics = function(evaluation) {
        console.log('Berechne statistische Kennzahlen für:', evaluation.testId);
        
        return new Promise((resolve) => {
            try {
                const { testId, userId } = evaluation;
                
                // Basisstatistiken
                const statistics = {
                    score: {
                        absolute: evaluation.totalScore,
                        percentage: evaluation.percentageScore,
                        zscore: 0, // Wird später berechnet
                        percentile: 0, // Wird später berechnet
                        standardError: 0 // Wird später berechnet
                    },
                    reliability: {
                        confidence: 0, // Wird später berechnet
                        margin: 0 // Wird später berechnet
                    },
                    timeAnalysis: {
                        totalTime: evaluation.duration || 0,
                        averageTimePerQuestion: 0, // Wird später berechnet
                        timeDistribution: {} // Wird später berechnet
                    },
                    questionDistribution: {
                        correct: evaluation.statistics.correctAnswers || 0,
                        partially: evaluation.statistics.partiallyCorrectAnswers || 0,
                        incorrect: evaluation.statistics.incorrectAnswers || 0,
                        unanswered: evaluation.statistics.unansweredQuestions || 0
                    },
                    categoryAnalysis: {},
                    strengths: [],
                    weaknesses: []
                };
                
                // Berechne durchschnittliche Zeit pro Frage
                const totalQuestions = Object.keys(evaluation.questionResults || {}).length;
                if (totalQuestions > 0 && evaluation.duration) {
                    statistics.timeAnalysis.averageTimePerQuestion = evaluation.duration / totalQuestions;
                }
                
                // Analysiere Fragen nach Kategorien
                if (evaluation.statistics.categoriesPerformance) {
                    const catPerformance = evaluation.statistics.categoriesPerformance;
                    statistics.categoryAnalysis = Object.keys(catPerformance).map(category => ({
                        category: category,
                        score: catPerformance[category].score,
                        maxScore: catPerformance[category].maxScore,
                        percentage: catPerformance[category].percentage,
                        questions: catPerformance[category].total
                    }));
                    
                    // Sortiere nach Leistung
                    statistics.categoryAnalysis.sort((a, b) => b.percentage - a.percentage);
                    
                    // Identifiziere Stärken und Schwächen
                    statistics.strengths = statistics.categoryAnalysis
                        .filter(cat => cat.percentage >= 75 && cat.questions >= 2)
                        .slice(0, 3)
                        .map(cat => ({
                            category: cat.category,
                            score: cat.percentage,
                            questionCount: cat.questions
                        }));
                        
                    statistics.weaknesses = statistics.categoryAnalysis
                        .filter(cat => cat.percentage < 60 && cat.questions >= 2)
                        .slice(0, 3)
                        .map(cat => ({
                            category: cat.category,
                            score: cat.percentage,
                            questionCount: cat.questions
                        }));
                }
                
                // Lade vorherige Testergebnisse für erweiterte Statistiken
                app.dataManager.getTestResults(testId)
                    .then(testResults => {
                        // Filtere nach abgeschlossenen Tests (ohne den aktuellen)
                        const otherResults = testResults.filter(result => 
                            result.userId !== userId && result.totalScore !== undefined);
                        
                        // Berechne Z-Score und Perzentil nur, wenn genügend andere Ergebnisse vorhanden sind
                        if (otherResults.length >= this.analysisConfig.statistics.minSampleSize) {
                            // Berechne Mittelwert und Standardabweichung
                            const scores = otherResults.map(result => result.percentageScore);
                            const mean = this.calculateMean(scores);
                            const stdDev = this.calculateStandardDeviation(scores, mean);
                            
                            // Z-Score berechnen
                            if (stdDev > 0) {
                                statistics.score.zscore = (evaluation.percentageScore - mean) / stdDev;
                            }
                            
                            // Perzentil berechnen
                            const belowCount = otherResults.filter(result => 
                                result.percentageScore < evaluation.percentageScore).length;
                            statistics.score.percentile = (belowCount / otherResults.length) * 100;
                            
                            // Standardfehler und Konfidenzintervall berechnen
                            statistics.reliability.standardError = stdDev / Math.sqrt(otherResults.length + 1);
                            
                            const zScore = this.getZScoreForConfidence(
                                this.analysisConfig.statistics.confidenceInterval);
                            statistics.reliability.margin = zScore * statistics.reliability.standardError;
                            statistics.reliability.confidence = this.analysisConfig.statistics.confidenceInterval * 100;
                        }
                        
                        // Zeitverteilung analysieren
                        if (otherResults.length > 0) {
                            const allDurations = otherResults.map(result => result.duration || 0);
                            allDurations.push(evaluation.duration || 0);
                            
                            const timeStats = this.calculateTimeStatistics(allDurations);
                            
                            statistics.timeAnalysis.timeDistribution = {
                                min: timeStats.min,
                                max: timeStats.max,
                                mean: timeStats.mean,
                                median: timeStats.median,
                                percentile: this.calculatePercentile(allDurations, evaluation.duration || 0)
                            };
                        }
                        
                        resolve(statistics);
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Testergebnisse für Statistiken:', error);
                        // Auch bei Fehlern die vorhandenen Statistiken zurückgeben
                        resolve(statistics);
                    });
            } catch (error) {
                console.error('Fehler bei der Berechnung statistischer Kennzahlen:', error);
                resolve({
                    error: error.message,
                    score: {
                        absolute: evaluation.totalScore,
                        percentage: evaluation.percentageScore
                    }
                });
            }
        });
    };
    
    /**
     * Führt vergleichende Analysen für die Auswertung durch
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @return {Promise<Object>} - Promise mit vergleichenden Analysen
     */
    app.testEvaluation.performComparativeAnalysis = function(evaluation) {
        console.log('Führe vergleichende Analysen durch für:', evaluation.testId);
        
        return new Promise((resolve) => {
            try {
                const { testId, userId } = evaluation;
                
                // Basisstruktur für vergleichende Analysen
                const comparisons = {
                    userHistory: {
                        previous: [],
                        trend: 'stable',
                        improvement: 0
                    },
                    groupComparison: {
                        position: 0,
                        totalUsers: 0,
                        aboveAverage: false,
                        difference: 0
                    },
                    categoryComparisons: [],
                    similarUsers: []
                };
                
                // Vorbereitung der Promises für parallele Ausführung
                const promises = [];
                
                // Vergleich mit früheren Tests des Benutzers
                if (this.analysisConfig.comparative.compareToPreviousTests) {
                    const historyPromise = app.dataManager.getUserTestResults(userId)
                        .then(userResults => {
                            // Filtere nach abgeschlossenen Tests desselben Typs (ohne den aktuellen)
                            const previousResults = userResults.filter(result => 
                                result.testId !== testId && 
                                result.percentageScore !== undefined);
                            
                            // Sortiere nach Datum (neueste zuerst)
                            previousResults.sort((a, b) => 
                                new Date(b.timestamp) - new Date(a.timestamp));
                            
                            // Begrenzen auf die konfigurierte maximale Anzahl
                            const limitedResults = previousResults.slice(
                                0, this.analysisConfig.comparative.maxPreviousTestsCount);
                            
                            // Füge die vorherigen Ergebnisse zur Vergleichsanalyse hinzu
                            comparisons.userHistory.previous = limitedResults.map(result => ({
                                testId: result.testId,
                                testTitle: result.testTitle,
                                timestamp: result.timestamp,
                                score: result.percentageScore,
                                passed: result.passed
                            }));
                            
                            // Berechne Trend und Verbesserung
                            if (limitedResults.length > 0) {
                                // Vergleiche mit dem letzten Test
                                const latestScore = limitedResults[0].percentageScore;
                                const scoreDifference = evaluation.percentageScore - latestScore;
                                
                                comparisons.userHistory.improvement = scoreDifference;
                                
                                // Bestimme Trend
                                const significantDifference = this.analysisConfig.comparative.significantDifference;
                                
                                if (scoreDifference >= significantDifference) {
                                    comparisons.userHistory.trend = 'improving';
                                } else if (scoreDifference <= -significantDifference) {
                                    comparisons.userHistory.trend = 'declining';
                                } else {
                                    comparisons.userHistory.trend = 'stable';
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Fehler beim Laden der Benutzerhistorie:', error);
                        });
                    
                    promises.push(historyPromise);
                }
                
                // Vergleich mit anderen Benutzern, die denselben Test absolviert haben
                const groupPromise = app.dataManager.getTestResults(testId)
                    .then(testResults => {
                        // Filtere nach abgeschlossenen Tests
                        const allResults = testResults.filter(result => 
                            result.percentageScore !== undefined);
                        
                        const totalUsers = allResults.length;
                        comparisons.groupComparison.totalUsers = totalUsers;
                        
                        if (totalUsers > 0) {
                            // Berechne Durchschnitt
                            const scores = allResults.map(result => result.percentageScore);
                            const mean = this.calculateMean(scores);
                            
                            // Vergleich mit dem Durchschnitt
                            comparisons.groupComparison.difference = evaluation.percentageScore - mean;
                            comparisons.groupComparison.aboveAverage = comparisons.groupComparison.difference > 0;
                            
                            // Berechne Position im Ranking
                            const betterResults = allResults.filter(result => 
                                result.percentageScore > evaluation.percentageScore);
                            comparisons.groupComparison.position = betterResults.length + 1;
                            
                            // Finde ähnliche Benutzer (mit ähnlicher Leistung)
                            const tolerance = 5; // 5 Prozentpunkte Toleranz
                            const similarResults = allResults.filter(result => 
                                result.userId !== userId && 
                                Math.abs(result.percentageScore - evaluation.percentageScore) <= tolerance);
                            
                            // Limitiere auf eine sinnvolle Anzahl
                            const limitedSimilarResults = similarResults.slice(0, 5);
                            
                            comparisons.similarUsers = limitedSimilarResults.map(result => ({
                                userId: result.userId,
                                userName: result.userName,
                                score: result.percentageScore,
                                timestamp: result.timestamp
                            }));
                        }
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Gruppenergebnisse:', error);
                    });
                
                promises.push(groupPromise);
                
                // Vergleiche nach Kategorien
                if (evaluation.statistics.categoriesPerformance) {
                    const categoryPromise = app.dataManager.getTestResults(testId)
                        .then(testResults => {
                            // Filtere nach abgeschlossenen Tests (ohne den aktuellen)
                            const otherResults = testResults.filter(result => 
                                result.userId !== userId && 
                                result.statistics && 
                                result.statistics.categoriesPerformance);
                            
                            if (otherResults.length >= this.analysisConfig.statistics.minSampleSize) {
                                const catPerformance = evaluation.statistics.categoriesPerformance;
                                
                                // Vergleiche jede Kategorie
                                comparisons.categoryComparisons = Object.keys(catPerformance).map(category => {
                                    const userCatScore = catPerformance[category].percentage;
                                    
                                    // Sammle Ergebnisse für diese Kategorie von anderen Benutzern
                                    const allCatScores = otherResults
                                        .filter(result => 
                                            result.statistics.categoriesPerformance[category] !== undefined)
                                        .map(result => 
                                            result.statistics.categoriesPerformance[category].percentage);
                                    
                                    // Berechne Durchschnitt
                                    const catAvg = this.calculateMean(allCatScores);
                                    const catDiff = userCatScore - catAvg;
                                    
                                    return {
                                        category: category,
                                        userScore: userCatScore,
                                        averageScore: catAvg,
                                        difference: catDiff,
                                        aboveAverage: catDiff > 0,
                                        percentile: this.calculatePercentile(allCatScores, userCatScore)
                                    };
                                });
                                
                                // Sortiere nach größtem Unterschied (absolut)
                                comparisons.categoryComparisons.sort((a, b) => 
                                    Math.abs(b.difference) - Math.abs(a.difference));
                            }
                        })
                        .catch(error => {
                            console.error('Fehler beim Laden der Kategoriedaten:', error);
                        });
                    
                    promises.push(categoryPromise);
                }
                
                // Warte, bis alle Vergleichsanalysen abgeschlossen sind
                Promise.all(promises)
                    .then(() => {
                        resolve(comparisons);
                    })
                    .catch(error => {
                        console.error('Fehler bei den vergleichenden Analysen:', error);
                        resolve(comparisons);
                    });
            } catch (error) {
                console.error('Fehler bei der Initialisierung vergleichender Analysen:', error);
                resolve({
                    error: error.message,
                    userHistory: { previous: [], trend: 'unknown' },
                    groupComparison: { position: 0, totalUsers: 0 }
                });
            }
        });
    };
    
    /**
     * Bewertet die Kompetenzlevel basierend auf der Auswertung
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @return {Promise<Object>} - Promise mit Kompetenzlevelbewertungen
     */
    app.testEvaluation.assessCompetencyLevels = function(evaluation) {
        console.log('Bewerte Kompetenzlevel für:', evaluation.testId);
        
        return new Promise((resolve) => {
            try {
                // Prüfe, ob Kompetenzmodellierung aktiviert ist
                if (!this.analysisConfig.competencyModel.enabled) {
                    resolve({});
                    return;
                }
                
                const { testId, userId } = evaluation;
                
                // Basisstruktur für Kompetenzlevel
                const competency = {
                    overall: {
                        level: '',
                        percentage: evaluation.percentageScore,
                        nextLevel: '',
                        pointsToNextLevel: 0
                    },
                    categories: {},
                    skills: {},
                    progress: {
                        previous: 0,
                        current: 0,
                        improvement: 0
                    }
                };
                
                // Lade Test-Informationen
                app.dataManager.getTestById(testId)
                    .then(test => {
                        if (!test) {
                            throw new Error('Test nicht gefunden');
                        }
                        
                        // Bestimme das Gesamtkompetenzlevel
                        const score = evaluation.percentageScore;
                        const levels = this.analysisConfig.competencyModel.levels;
                        
                        // Sortiere Level nach aufsteigendem Schwellenwert
                        const sortedLevels = [...levels].sort((a, b) => a.threshold - b.threshold);
                        
                        // Finde das höchste Level, dessen Schwellenwert erreicht wurde
                        let currentLevel = sortedLevels[0];
                        let nextLevel = null;
                        
                        for (let i = 0; i < sortedLevels.length; i++) {
                            if (score >= sortedLevels[i].threshold) {
                                currentLevel = sortedLevels[i];
                                nextLevel = sortedLevels[i + 1] || null;
                            } else {
                                break;
                            }
                        }
                        
                        // Setze Gesamtkompetenzlevel
                        competency.overall.level = currentLevel.name;
                        
                        // Berechne Informationen zum nächsten Level
                        if (nextLevel) {
                            competency.overall.nextLevel = nextLevel.name;
                            competency.overall.pointsToNextLevel = nextLevel.threshold - score;
                        }
                        
                        // Kategoriebasierte Kompetenzlevel
                        if (evaluation.statistics && evaluation.statistics.categoriesPerformance) {
                            const catPerformance = evaluation.statistics.categoriesPerformance;
                            
                            Object.keys(catPerformance).forEach(category => {
                                const catScore = catPerformance[category].percentage;
                                
                                // Finde Level für diese Kategorie
                                let categoryLevel = sortedLevels[0];
                                let nextCategoryLevel = null;
                                
                                for (let i = 0; i < sortedLevels.length; i++) {
                                    if (catScore >= sortedLevels[i].threshold) {
                                        categoryLevel = sortedLevels[i];
                                        nextCategoryLevel = sortedLevels[i + 1] || null;
                                    } else {
                                        break;
                                    }
                                }
                                
                                competency.categories[category] = {
                                    level: categoryLevel.name,
                                    percentage: catScore,
                                    nextLevel: nextCategoryLevel ? nextCategoryLevel.name : null,
                                    pointsToNextLevel: nextCategoryLevel ? nextCategoryLevel.threshold - catScore : 0
                                };
                            });
                        }
                        
                        // Skill-basierte Kompetenzlevel (sofern Test Skills definiert)
                        if (test.skills && Array.isArray(test.skills)) {
                            test.skills.forEach(skill => {
                                // Sammle alle Fragen, die zu diesem Skill gehören
                                const skillQuestions = Object.keys(evaluation.questionResults || {})
                                    .filter(questionId => {
                                        const question = app.dataManager.getQuestionById(questionId);
                                        return question && question.skills && question.skills.includes(skill.id);
                                    })
                                    .map(questionId => evaluation.questionResults[questionId]);
                                
                                // Berechne Skill-Score, falls Fragen vorhanden
                                if (skillQuestions.length > 0) {
                                    const totalSkillScore = skillQuestions.reduce((sum, q) => sum + q.score, 0);
                                    const totalMaxScore = skillQuestions.reduce((sum, q) => sum + q.maxScore, 0);
                                    
                                    const skillScore = totalMaxScore > 0 ? 
                                        (totalSkillScore / totalMaxScore) * 100 : 0;
                                    
                                    // Finde Level für diesen Skill
                                    let skillLevel = sortedLevels[0];
                                    let nextSkillLevel = null;
                                    
                                    for (let i = 0; i < sortedLevels.length; i++) {
                                        if (skillScore >= sortedLevels[i].threshold) {
                                            skillLevel = sortedLevels[i];
                                            nextSkillLevel = sortedLevels[i + 1] || null;
                                        } else {
                                            break;
                                        }
                                    }
                                    
                                    competency.skills[skill.id] = {
                                        name: skill.name,
                                        level: skillLevel.name,
                                        percentage: skillScore,
                                        nextLevel: nextSkillLevel ? nextSkillLevel.name : null,
                                        pointsToNextLevel: nextSkillLevel ? nextSkillLevel.threshold - skillScore : 0,
                                        questions: skillQuestions.length
                                    };
                                }
                            });
                        }
                        
                        // Fortschritt im Vergleich zu früheren Tests
                        app.dataManager.getUserTestResults(userId)
                            .then(userResults => {
                                // Filtere nach abgeschlossenen Tests desselben Typs (ohne den aktuellen)
                                const previousResults = userResults.filter(result => 
                                    result.testId === testId && 
                                    result.id !== evaluation.id && 
                                    result.percentageScore !== undefined);
                                
                                // Sortiere nach Datum (neueste zuerst)
                                previousResults.sort((a, b) => 
                                    new Date(b.timestamp) - new Date(a.timestamp));
                                
                                // Vergleiche mit dem vorherigen Test, falls vorhanden
                                if (previousResults.length > 0) {
                                    const previousScore = previousResults[0].percentageScore;
                                    competency.progress.previous = previousScore;
                                    competency.progress.current = evaluation.percentageScore;
                                    competency.progress.improvement = evaluation.percentageScore - previousScore;
                                }
                                
                                resolve(competency);
                            })
                            .catch(error => {
                                console.error('Fehler beim Laden der Benutzerhistorie für Kompetenzanalyse:', error);
                                resolve(competency);
                            });
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Testdaten für Kompetenzanalyse:', error);
                        resolve({
                            overall: {
                                level: 'Unbekannt',
                                percentage: evaluation.percentageScore
                            }
                        });
                    });
            } catch (error) {
                console.error('Fehler bei der Kompetenzlevelbewertung:', error);
                resolve({
                    error: error.message,
                    overall: {
                        level: 'Fehler',
                        percentage: evaluation.percentageScore
                    }
                });
            }
        });
    };
    
    /**
     * Generiert Erkenntnisse und analytische Beobachtungen für die Auswertung
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @return {Promise<Array>} - Promise mit Erkenntnissen
     */
    app.testEvaluation.generateInsights = function(evaluation) {
        console.log('Generiere Erkenntnisse für:', evaluation.testId);
        
        return new Promise((resolve) => {
            try {
                const insights = [];
                
                // Gesamtleistungsbeurteilung
                if (evaluation.percentageScore >= 90) {
                    insights.push({
                        type: 'performance',
                        title: 'Hervorragende Leistung',
                        text: 'Die Gesamtleistung liegt im Spitzenbereich, was auf ein umfassendes Verständnis der getesteten Inhalte hinweist.',
                        priority: 'high'
                    });
                } else if (evaluation.percentageScore < 40) {
                    insights.push({
                        type: 'performance',
                        title: 'Grundlegende Wissenslücken',
                        text: 'Die Gesamtleistung deutet auf substantielle Wissenslücken hin, die grundlegende Wiederholung erfordern könnten.',
                        priority: 'high'
                    });
                }
                
                // Erkenntnisse basierend auf Fragetypen
                if (evaluation.statistics) {
                    const totalAnswered = evaluation.statistics.correctAnswers + 
                                         evaluation.statistics.partiallyCorrectAnswers + 
                                         evaluation.statistics.incorrectAnswers;
                    
                    // Hohe Fehlerquote bei beantworteten Fragen
                    if (totalAnswered > 0 && 
                        (evaluation.statistics.incorrectAnswers / totalAnswered) > 0.6) {
                        insights.push({
                            type: 'error_rate',
                            title: 'Hohe Fehlerquote',
                            text: 'Bei den beantworteten Fragen gibt es eine auffällig hohe Fehlerquote, was auf Missverständnisse oder Fehleinschätzungen hindeuten könnte.',
                            priority: 'medium'
                        });
                    }
                    
                    // Viele unbeantwortete Fragen
                    if (evaluation.statistics.unansweredQuestions > 0 && 
                        (evaluation.statistics.unansweredQuestions / 
                         (totalAnswered + evaluation.statistics.unansweredQuestions)) > 0.2) {
                        insights.push({
                            type: 'unanswered',
                            title: 'Viele unbeantwortete Fragen',
                            text: 'Eine erhebliche Anzahl von Fragen blieb unbeantwortet, was auf Zeitprobleme, Unsicherheit oder fehlendes Wissen hindeuten könnte.',
                            priority: 'medium'
                        });
                    }
                }
                
                // Kategoriespezifische Erkenntnisse
                if (evaluation.statistics && evaluation.statistics.categoriesPerformance) {
                    const catPerformance = evaluation.statistics.categoriesPerformance;
                    
                    // Identifiziere Kategorien mit großen Leistungsunterschieden
                    const categories = Object.keys(catPerformance);
                    if (categories.length >= 2) {
                        const scores = categories.map(cat => catPerformance[cat].percentage);
                        const maxScore = Math.max(...scores);
                        const minScore = Math.min(...scores);
                        
                        if (maxScore - minScore >= 30) {
                            const bestCat = categories.find(cat => 
                                catPerformance[cat].percentage === maxScore);
                            const worstCat = categories.find(cat => 
                                catPerformance[cat].percentage === minScore);
                            
                            insights.push({
                                type: 'category_gap',
                                title: 'Große Leistungsunterschiede zwischen Kategorien',
                                text: `Es gibt einen erheblichen Leistungsunterschied zwischen den Kategorien "${bestCat}" (${maxScore}%) und "${worstCat}" (${minScore}%).`,
                                priority: 'medium'
                            });
                        }
                        
                        // Identifiziere besonders schwache Kategorien
                        categories.forEach(cat => {
                            if (catPerformance[cat].percentage < 40 && catPerformance[cat].total >= 3) {
                                insights.push({
                                    type: 'weak_category',
                                    title: `Schwierigkeit mit ${cat}`,
                                    text: `Die Kategorie "${cat}" zeigt mit ${catPerformance[cat].percentage}% eine besonders niedrige Leistung, was gezieltes Lernen in diesem Bereich nahelegt.`,
                                    priority: 'high'
                                });
                            }
                        });
                    }
                }
                
                // Erkenntnisse basierend auf individuellen Fragen
                const questionResults = evaluation.questionResults || {};
                
                // Analysiere Muster in falschen Antworten
                const incorrectQuestions = Object.values(questionResults)
                    .filter(q => !q.isCorrect && q.answered);
                
                if (incorrectQuestions.length >= 3) {
                    // Prüfe, ob es häufige Fehler bei bestimmten Fragetypen gibt
                    const typeErrors = {};
                    incorrectQuestions.forEach(q => {
                        typeErrors[q.questionType] = (typeErrors[q.questionType] || 0) + 1;
                    });
                    
                    Object.keys(typeErrors).forEach(type => {
                        if (typeErrors[type] >= 3) {
                            let typeName = '';
                            switch (type) {
                                case 'multiple-choice': typeName = 'Multiple-Choice-Fragen'; break;
                                case 'single-choice': typeName = 'Single-Choice-Fragen'; break;
                                case 'true-false': typeName = 'Wahr/Falsch-Fragen'; break;
                                case 'free-text': typeName = 'Freitext-Fragen'; break;
                                case 'matching': typeName = 'Zuordnungsfragen'; break;
                                case 'sequence': typeName = 'Reihenfolge-Fragen'; break;
                                default: typeName = `${type}-Fragen`;
                            }
                            
                            insights.push({
                                type: 'question_type_pattern',
                                title: `Schwierigkeit mit ${typeName}`,
                                text: `Es gibt ein Muster von Fehlern bei ${typeName}, was auf Schwierigkeiten mit diesem Frageformat hindeuten könnte.`,
                                priority: 'medium'
                            });
                        }
                    });
                }
                
                // Ausreichend Erkenntnisse gesammelt
                if (insights.length >= 5) {
                    resolve(insights);
                    return;
                }
                
                // Zusätzliche zeitbasierte Erkenntnisse
                app.dataManager.getTestResults(evaluation.testId)
                    .then(testResults => {
                        // Filtere nach abgeschlossenen Tests (ohne den aktuellen)
                        const otherResults = testResults.filter(result => 
                            result.userId !== evaluation.userId && 
                            result.duration !== undefined);
                        
                        if (otherResults.length >= this.analysisConfig.statistics.minSampleSize) {
                            // Vergleiche die Testdauer
                            const durations = otherResults.map(result => result.duration);
                            const avgDuration = this.calculateMean(durations);
                            
                            // Deutlich schneller als der Durchschnitt
                            if (evaluation.duration < avgDuration * 0.7) {
                                insights.push({
                                    type: 'time_fast',
                                    title: 'Schnelle Testdurchführung',
                                    text: 'Der Test wurde deutlich schneller als der Durchschnitt abgeschlossen, was auf Effizienz oder möglicherweise überstürztes Antworten hindeuten könnte.',
                                    priority: 'low'
                                });
                            }
                            // Deutlich langsamer als der Durchschnitt
                            else if (evaluation.duration > avgDuration * 1.5) {
                                insights.push({
                                    type: 'time_slow',
                                    title: 'Langsame Testdurchführung',
                                    text: 'Der Test wurde deutlich langsamer als der Durchschnitt abgeschlossen, was auf gründliche Überlegung oder möglicherweise Unsicherheit hindeuten könnte.',
                                    priority: 'low'
                                });
                            }
                        }
                        
                        // Sortiere Erkenntnisse nach Priorität
                        insights.sort((a, b) => {
                            const priorityValues = { high: 3, medium: 2, low: 1 };
                            return priorityValues[b.priority] - priorityValues[a.priority];
                        });
                        
                        resolve(insights);
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Testdaten für zeitbasierte Erkenntnisse:', error);
                        resolve(insights);
                    });
            } catch (error) {
                console.error('Fehler bei der Generierung von Erkenntnissen:', error);
                resolve([{
                    type: 'error',
                    title: 'Fehler bei der Analyse',
                    text: 'Es konnten keine detaillierten Erkenntnisse generiert werden aufgrund eines Systemfehlers.',
                    priority: 'low'
                }]);
            }
        });
    };
    
    /**
     * Generiert Empfehlungen basierend auf der Auswertung und Analyse
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @param {Object} analysis - Die erweiterte Analyse
     * @return {Promise<Array>} - Promise mit Empfehlungen
     */
    app.testEvaluation.generateRecommendations = function(evaluation, analysis) {
        console.log('Generiere Empfehlungen für:', evaluation.testId);
        
        return new Promise((resolve) => {
            try {
                const recommendations = [];
                
                // Empfehlungen basierend auf Schwächen
                if (analysis.statistics && analysis.statistics.weaknesses && 
                    analysis.statistics.weaknesses.length > 0) {
                    
                    analysis.statistics.weaknesses.forEach(weakness => {
                        recommendations.push({
                            type: 'content',
                            title: `Vertiefung: ${weakness.category}`,
                            text: `Wiederholen und vertiefen Sie Ihre Kenntnisse in der Kategorie "${weakness.category}", um Ihre Leistung zu verbessern.`,
                            priority: 'high',
                            category: weakness.category
                        });
                    });
                }
                
                // Allgemeine Empfehlungen basierend auf Gesamtleistung
                if (evaluation.percentageScore < evaluation.passingThreshold) {
                    recommendations.push({
                        type: 'general',
                        title: 'Grundlagen wiederholen',
                        text: 'Es wird empfohlen, die Grundlagen zu wiederholen, bevor der Test erneut versucht wird.',
                        priority: 'high'
                    });
                } else if (evaluation.percentageScore < 70) {
                    recommendations.push({
                        type: 'general',
                        title: 'Gezielte Wiederholung',
                        text: 'Gezielte Wiederholung in den schwächeren Bereichen könnte Ihre Leistung deutlich verbessern.',
                        priority: 'medium'
                    });
                }
                
                // Empfehlungen basierend auf Erkenntnissen
                if (analysis.insights) {
                    const unansweredInsight = analysis.insights.find(i => i.type === 'unanswered');
                    if (unansweredInsight) {
                        recommendations.push({
                            type: 'technique',
                            title: 'Zeitmanagement verbessern',
                            text: 'Verbessern Sie Ihr Zeitmanagement, um sicherzustellen, dass Sie alle Fragen beantworten können.',
                            priority: 'medium'
                        });
                    }
                    
                    const typePatternInsight = analysis.insights.find(i => i.type === 'question_type_pattern');
                    if (typePatternInsight) {
                        recommendations.push({
                            type: 'technique',
                            title: 'Fragentypstrategie',
                            text: typePatternInsight.text.replace('Es gibt ein Muster von Fehlern bei', 'Üben Sie gezielt den Umgang mit'),
                            priority: 'medium'
                        });
                    }
                }
                
                // Weiterführende Lernempfehlungen
                if (analysis.competency && analysis.competency.overall) {
                    const currentLevel = analysis.competency.overall.level;
                    const nextLevel = analysis.competency.overall.nextLevel;
                    
                    if (nextLevel) {
                        recommendations.push({
                            type: 'progress',
                            title: `Weiterentwicklung zum Level "${nextLevel}"`,
                            text: `Für den Fortschritt von "${currentLevel}" zu "${nextLevel}" fehlen noch ${analysis.competency.overall.pointsToNextLevel.toFixed(1)} Prozentpunkte. Konzentrieren Sie sich auf die empfohlenen Inhalte.`,
                            priority: 'medium'
                        });
                    }
                }
                
                // Empfehlungen basierend auf vergleichender Analyse
                if (analysis.comparisons && analysis.comparisons.userHistory) {
                    const trend = analysis.comparisons.userHistory.trend;
                    
                    if (trend === 'declining' && analysis.comparisons.userHistory.improvement < -10) {
                        recommendations.push({
                            type: 'trend',
                            title: 'Leistungsabnahme umkehren',
                            text: 'Ihre Leistung hat sich im Vergleich zu früheren Tests verschlechtert. Eine systematische Wiederholung der Inhalte wird empfohlen.',
                            priority: 'high'
                        });
                    } else if (trend === 'improving' && analysis.comparisons.userHistory.improvement > 15) {
                        recommendations.push({
                            type: 'trend',
                            title: 'Positiven Trend fortsetzen',
                            text: 'Ihre Leistung zeigt eine deutliche Verbesserung. Setzen Sie Ihre erfolgreiche Lernstrategie fort.',
                            priority: 'low'
                        });
                    }
                }
                
                // Limitiere die Anzahl der Empfehlungen
                const maxRecommendations = this.analysisConfig.reporting.maxRecommendations;
                const limitedRecommendations = recommendations
                    .sort((a, b) => {
                        const priorityValues = { high: 3, medium: 2, low: 1 };
                        return priorityValues[b.priority] - priorityValues[a.priority];
                    })
                    .slice(0, maxRecommendations);
                
                resolve(limitedRecommendations);
            } catch (error) {
                console.error('Fehler bei der Generierung von Empfehlungen:', error);
                resolve([{
                    type: 'general',
                    title: 'Standardempfehlung',
                    text: 'Wiederholen Sie die Bereiche, in denen Sie am wenigsten Punkte erzielt haben.',
                    priority: 'medium'
                }]);
            }
        });
    };
    
    /**
     * Berechnet den Mittelwert eines Arrays von Zahlen
     * @param {Array<number>} values - Array von Zahlenwerten
     * @return {number} - Mittelwert
     */
    app.testEvaluation.calculateMean = function(values) {
        if (!values || values.length === 0) return 0;
        
        const sum = values.reduce((total, val) => total + val, 0);
        return sum / values.length;
    };
    
    /**
     * Berechnet die Standardabweichung eines Arrays von Zahlen
     * @param {Array<number>} values - Array von Zahlenwerten
     * @param {number} mean - Mittelwert der Werte (optional)
     * @return {number} - Standardabweichung
     */
    app.testEvaluation.calculateStandardDeviation = function(values, mean = null) {
        if (!values || values.length < 2) return 0;
        
        const avg = mean !== null ? mean : this.calculateMean(values);
        
        const squaredDiffs = values.map(val => {
            const diff = val - avg;
            return diff * diff;
        });
        
        const variance = squaredDiffs.reduce((total, val) => total + val, 0) / values.length;
        return Math.sqrt(variance);
    };
    
    /**
     * Berechnet das Perzentil eines Wertes in einer Verteilung
     * @param {Array<number>} values - Array von Zahlenwerten
     * @param {number} value - Der Wert, für den das Perzentil berechnet werden soll
     * @return {number} - Perzentil (0-100)
     */
    app.testEvaluation.calculatePercentile = function(values, value) {
        if (!values || values.length === 0) return 0;
        
        const sortedValues = [...values].sort((a, b) => a - b);
        const position = sortedValues.filter(v => v < value).length;
        
        return (position / sortedValues.length) * 100;
    };
    
    /**
     * Berechnet Zeitstatistiken für eine Menge von Zeitwerten
     * @param {Array<number>} durations - Array von Zeitwerten
     * @return {Object} - Berechnete Zeitstatistiken
     */
    app.testEvaluation.calculateTimeStatistics = function(durations) {
        if (!durations || durations.length === 0) {
            return { min: 0, max: 0, mean: 0, median: 0 };
        }
        
        const sortedDurations = [...durations].sort((a, b) => a - b);
        const min = sortedDurations[0];
        const max = sortedDurations[sortedDurations.length - 1];
        const mean = this.calculateMean(sortedDurations);
        
        // Median berechnen
        let median;
        const mid = Math.floor(sortedDurations.length / 2);
        
        if (sortedDurations.length % 2 === 0) {
            median = (sortedDurations[mid - 1] + sortedDurations[mid]) / 2;
        } else {
            median = sortedDurations[mid];
        }
        
        return { min, max, mean, median };
    };
    
    /**
     * Ermittelt den Z-Score für ein gegebenes Konfidenzniveau
     * @param {number} confidence - Konfidenzniveau (z.B. 0.95 für 95%)
     * @return {number} - Z-Score
     */
    app.testEvaluation.getZScoreForConfidence = function(confidence) {
        // Vereinfachte Zuordnung häufig verwendeter Konfidenzniveaus
        const zScores = {
            0.99: 2.576,
            0.98: 2.326,
            0.95: 1.96,
            0.90: 1.645,
            0.85: 1.44,
            0.80: 1.282
        };
        
        return zScores[confidence] || 1.96; // Standard: 95% Konfidenz
    };
    
    // Erweitere die initialize-Methode, um auch die Analysekomponenten zu initialisieren
    const originalInitialize = app.testEvaluation.initialize;
    app.testEvaluation.initialize = function(options) {
        // Rufe die ursprüngliche Methode auf
        originalInitialize.call(this, options);
        
        // Initialisiere die Analysekomponenten
        this.initializeAnalysis(options);
    };
    
    // Erweitere die öffentliche Schnittstelle um die neuen Funktionen
    Object.assign(app.testEvaluation.interface, {
        performAdvancedAnalysis: app.testEvaluation.performAdvancedAnalysis.bind(app.testEvaluation),
        computeStatistics: app.testEvaluation.computeStatistics.bind(app.testEvaluation),
        performComparativeAnalysis: app.testEvaluation.performComparativeAnalysis.bind(app.testEvaluation),
        assessCompetencyLevels: app.testEvaluation.assessCompetencyLevels.bind(app.testEvaluation),
        generateInsights: app.testEvaluation.generateInsights.bind(app.testEvaluation),
        generateRecommendations: app.testEvaluation.generateRecommendations.bind(app.testEvaluation)
    });
    
    console.log('Auswertungsalgorithmen (Teil 2.2) initialisiert');
})();
/**
 * JS-Block 6.2.1-part1: Bewertungsinterface (Teil 1)
 * 
 * Dieser Block implementiert das Interface für die manuelle Bewertung von Freitext-Antworten.
 * Er stellt die notwendigen Funktionen zum Anzeigen, Bewerten und Kommentieren
 * von Antworten bereit, die nicht automatisch bewertet werden können.
 */
(function() {
    // Namespace für das Bewertungsinterface erstellen
    if (!app.manualEvaluation) {
        app.manualEvaluation = {};
    }
    
    // Status und Konfiguration
    app.manualEvaluation.state = {
        currentTestId: null,
        currentUserId: null,
        currentQuestionId: null,
        pendingEvaluations: [],
        currentIndex: 0,
        isLoading: false,
        evaluatorId: null,
        evaluatorName: null,
        totalPending: 0,
        evaluationHistory: []
    };
    
    // Konfiguration für das Bewertungsinterface
    app.manualEvaluation.config = {
        // Maximale Anzahl von Antworten, die pro Seite geladen werden
        pageSize: 10,
        
        // Ob die Originallösung neben der Antwort angezeigt werden soll
        showSolution: true,
        
        // Ob Vorschläge für Feedback-Kommentare angezeigt werden sollen
        showFeedbackSuggestions: true,
        
        // Standardkommentare für häufige Bewertungen
        feedbackTemplates: {
            excellent: 'Hervorragende Antwort, die alle Aspekte der Frage abdeckt.',
            good: 'Gute Antwort, die die Hauptpunkte der Frage erfasst.',
            partial: 'Teilweise korrekte Antwort. Einige wichtige Aspekte wurden nicht erwähnt.',
            incorrect: 'Die Antwort enthält grundlegende Missverständnisse oder fehlerhafte Konzepte.',
            missing: 'Die Antwort behandelt nicht die gestellte Frage.'
        },
        
        // Vordefinierte Score-Stufen
        scorePresets: [0, 25, 50, 75, 100],
        
        // Automatisches Speichern von Bewertungen
        autoSave: true,
        
        // Auto-Speichern-Verzögerung in Millisekunden (2 Sekunden)
        autoSaveDelay: 2000
    };
    
    /**
     * Initialisiert das Bewertungsinterface
     * @param {Object} options - Konfigurationsoptionen
     * @param {string} options.containerId - ID des Container-Elements
     * @param {string} options.evaluatorId - ID des Bewerters
     * @param {Object} options.config - Erweiterte Konfiguration
     */
    app.manualEvaluation.initialize = function(options = {}) {
        console.log('Initialisiere Bewertungsinterface mit Optionen:', options);
        
        // Container-Element finden oder erstellen
        const containerId = options.containerId || 'manual-evaluation-container';
        let container = document.getElementById(containerId);
        
        if (!container) {
            console.warn(`Container ${containerId} nicht gefunden, erstelle neu.`);
            container = document.createElement('div');
            container.id = containerId;
            document.body.appendChild(container);
        }
        
        // Optionen verarbeiten
        if (options.evaluatorId) {
            this.state.evaluatorId = options.evaluatorId;
            
            // Bewerternamen ermitteln
            const evaluator = app.dataManager.getUserById(options.evaluatorId);
            if (evaluator) {
                this.state.evaluatorName = evaluator.fullName;
            }
        } else {
            // Versuche, den aktuellen Benutzer als Bewerter zu verwenden
            const currentUser = app.authentication.getCurrentUser();
            if (currentUser && app.permissions.hasPermission(currentUser.role, 'evaluate_tests')) {
                this.state.evaluatorId = currentUser.id;
                this.state.evaluatorName = currentUser.fullName;
            } else {
                console.error('Keine Bewerter-ID angegeben und kein berechtigter Benutzer angemeldet');
                return;
            }
        }
        
        // Konfiguration erweitern
        if (options.config) {
            Object.assign(this.config, options.config);
        }
        
        // Interface rendern
        this.renderInterface(container);
        
        // Event-Listener registrieren
        this.setupEventListeners();
        
        // Ausstehende Bewertungen laden
        this.loadPendingEvaluations();
        
        console.log('Bewertungsinterface erfolgreich initialisiert');
    };
    
    /**
     * Rendert das Bewertungsinterface
     * @param {HTMLElement} container - Das Container-Element
     */
    app.manualEvaluation.renderInterface = function(container) {
        console.log('Rendere Bewertungsinterface');
        
        // Container leeren
        container.innerHTML = '';
        
        // Hauptstruktur erstellen
        const interfaceHtml = `
            <div class="manual-evaluation-interface">
                <div class="evaluation-header">
                    <h2>Manuelle Bewertung</h2>
                    <div class="evaluation-status">
                        <span class="status-text">Lade Bewertungen...</span>
                        <span class="status-count"></span>
                    </div>
                </div>

                <div class="evaluation-filters">
                    <div class="filter-group">
                        <label for="test-filter">Test:</label>
                        <select id="test-filter" class="test-selector">
                            <option value="">Alle Tests</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="user-filter">Benutzer:</label>
                        <select id="user-filter" class="user-selector">
                            <option value="">Alle Benutzer</option>
                        </select>
                    </div>
                    <button id="apply-filters" class="action-button">Filter anwenden</button>
                    <button id="clear-filters" class="secondary-button">Zurücksetzen</button>
                </div>

                <div class="evaluation-main">
                    <div class="evaluation-list-container">
                        <h3>Ausstehende Bewertungen</h3>
                        <div id="pending-evaluations-list" class="evaluation-list">
                            <div class="loading-indicator">Lade Bewertungen...</div>
                        </div>
                        <div class="evaluation-pagination">
                            <button id="prev-page" class="pagination-button" disabled>Zurück</button>
                            <span class="page-indicator">Seite <span id="current-page">1</span> von <span id="total-pages">1</span></span>
                            <button id="next-page" class="pagination-button" disabled>Weiter</button>
                        </div>
                    </div>

                    <div class="evaluation-workspace">
                        <div id="evaluation-content" class="evaluation-content">
                            <div class="empty-state">
                                <p>Wählen Sie eine ausstehende Bewertung aus der Liste aus, um mit der Bewertung zu beginnen.</p>
                                <p>Oder klicken Sie auf "Nächste Bewertung", um die erste ausstehende Bewertung zu laden.</p>
                                <button id="load-next-evaluation" class="action-button">Nächste Bewertung</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        container.innerHTML = interfaceHtml;
        
        // Styling hinzufügen (könnte auch in einer separaten CSS-Datei sein)
        this.applyStyles();
        
        console.log('Bewertungsinterface erfolgreich gerendert');
    };
    
    /**
     * Fügt CSS-Stile für das Bewertungsinterface hinzu
     */
    app.manualEvaluation.applyStyles = function() {
        // Prüfen, ob die Stile bereits existieren
        if (document.getElementById('manual-evaluation-styles')) {
            return;
        }
        
        // Style-Element erstellen
        const styleElement = document.createElement('style');
        styleElement.id = 'manual-evaluation-styles';
        
        // CSS-Regeln definieren
        const css = `
            .manual-evaluation-interface {
                display: flex;
                flex-direction: column;
                height: 100%;
                font-family: Arial, sans-serif;
                color: #333;
            }

            .evaluation-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                background-color: #f8f8f8;
                border-bottom: 1px solid #ddd;
            }

            .evaluation-header h2 {
                margin: 0;
                color: #333;
            }

            .evaluation-status {
                font-size: 14px;
                color: #666;
            }

            .evaluation-filters {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                padding: 15px;
                background-color: #f0f0f0;
                border-bottom: 1px solid #ddd;
            }

            .filter-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .filter-group label {
                font-weight: bold;
            }

            .filter-group select {
                padding: 6px 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                min-width: 200px;
            }

            .action-button {
                background-color: #00FFD0;
                color: #fff;
                border: none;
                padding: 8px 15px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                transition: background-color 0.3s;
            }

            .action-button:hover {
                background-color: #00e6bb;
            }

            .action-button:disabled {
                background-color: #ccc;
                cursor: not-allowed;
            }

            .secondary-button {
                background-color: #f8f8f8;
                color: #333;
                border: 1px solid #ddd;
                padding: 8px 15px;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            .secondary-button:hover {
                background-color: #eaeaea;
            }

            .evaluation-main {
                display: flex;
                flex: 1;
                overflow: hidden;
            }

            .evaluation-list-container {
                width: 30%;
                min-width: 300px;
                border-right: 1px solid #ddd;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .evaluation-list-container h3 {
                padding: 15px;
                margin: 0;
                background-color: #f8f8f8;
                border-bottom: 1px solid #ddd;
            }

            .evaluation-list {
                flex: 1;
                overflow-y: auto;
                padding: 10px;
            }

            .evaluation-item {
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-bottom: 10px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            .evaluation-item:hover {
                background-color: #f0f9f7;
            }

            .evaluation-item.selected {
                background-color: #e0f7f4;
                border-color: #00FFD0;
            }

            .evaluation-item-header {
                display: flex;
                justify-content: space-between;
                font-weight: bold;
                margin-bottom: 5px;
            }

            .evaluation-meta {
                font-size: 12px;
                color: #666;
                margin-bottom: 5px;
            }

            .evaluation-preview {
                font-size: 13px;
                color: #555;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .evaluation-pagination {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                background-color: #f8f8f8;
                border-top: 1px solid #ddd;
            }

            .pagination-button {
                background-color: #fff;
                border: 1px solid #ddd;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
            }

            .pagination-button:disabled {
                color: #ccc;
                cursor: not-allowed;
            }

            .evaluation-workspace {
                flex: 1;
                overflow-y: auto;
                padding: 20px;
            }

            .evaluation-content {
                max-width: 800px;
                margin: 0 auto;
            }

            .empty-state {
                text-align: center;
                padding: 40px 20px;
                color: #666;
            }

            .question-section {
                margin-bottom: 30px;
                padding: 20px;
                background-color: #f9f9f9;
                border-radius: 4px;
                border-left: 4px solid #00FFD0;
            }

            .question-header {
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 10px;
            }

            .question-text {
                margin-bottom: 15px;
                line-height: 1.5;
            }

            .question-meta {
                font-size: 12px;
                color: #666;
                margin-bottom: 15px;
            }

            .answer-section {
                margin-bottom: 30px;
                padding: 20px;
                background-color: #fff;
                border: 1px solid #ddd;
                border-radius: 4px;
            }

            .answer-header {
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 10px;
            }

            .answer-text {
                margin-bottom: 15px;
                line-height: 1.5;
                white-space: pre-wrap;
            }

            .answer-meta {
                font-size: 12px;
                color: #666;
                margin-bottom: 15px;
            }

            .model-answer {
                margin-bottom: 30px;
                padding: 15px;
                background-color: #f0f9f7;
                border: 1px solid #a8e6cf;
                border-radius: 4px;
            }

            .model-answer-header {
                font-size: 16px;
                font-weight: bold;
                color: #00a67d;
                margin-bottom: 10px;
            }

            .model-answer-text {
                line-height: 1.5;
            }

            .evaluation-form {
                margin-bottom: 30px;
                padding: 20px;
                background-color: #f8f8f8;
                border-radius: 4px;
            }

            .form-group {
                margin-bottom: 15px;
            }

            .form-group label {
                display: block;
                font-weight: bold;
                margin-bottom: 5px;
            }

            .score-input {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .score-input input {
                width: 80px;
                padding: 8px;
                border: 1px solid #ccc;
                border-radius: 4px;
            }

            .score-input .score-max {
                color: #666;
            }

            .score-presets {
                display: flex;
                gap: 5px;
                margin-top: 5px;
            }

            .score-preset-button {
                background-color: #f0f0f0;
                border: 1px solid #ddd;
                padding: 4px 8px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            }

            .score-preset-button:hover {
                background-color: #e0e0e0;
            }

            .feedback-input textarea {
                width: 100%;
                min-height: 100px;
                padding: 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                resize: vertical;
            }

            .feedback-templates {
                margin-top: 5px;
            }

            .template-button {
                background-color: #f0f0f0;
                border: 1px solid #ddd;
                padding: 4px 8px;
                margin-right: 5px;
                margin-bottom: 5px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
                display: inline-block;
            }

            .template-button:hover {
                background-color: #e0e0e0;
            }

            .evaluation-actions {
                display: flex;
                justify-content: space-between;
                margin-top: 20px;
            }

            .loading-indicator {
                text-align: center;
                padding: 20px;
                color: #666;
            }

            .save-status {
                font-size: 12px;
                color: #666;
                margin-top: 5px;
                text-align: right;
            }

            .save-status.saving {
                color: #f5a623;
            }

            .save-status.saved {
                color: #7ed321;
            }

            .save-status.error {
                color: #d0021b;
            }
        `;
        
        // CSS zum Style-Element hinzufügen
        styleElement.textContent = css;
        
        // Style-Element zum Dokument hinzufügen
        document.head.appendChild(styleElement);
    };
    
    /**
     * Richtet Event-Listener für das Bewertungsinterface ein
     */
    app.manualEvaluation.setupEventListeners = function() {
        console.log('Richte Event-Listener für Bewertungsinterface ein');
        
        // Filter-Buttons
        const applyFiltersButton = document.getElementById('apply-filters');
        const clearFiltersButton = document.getElementById('clear-filters');
        
        if (applyFiltersButton) {
            applyFiltersButton.addEventListener('click', () => {
                const testFilter = document.getElementById('test-filter').value;
                const userFilter = document.getElementById('user-filter').value;
                
                this.applyFilters(testFilter, userFilter);
            });
        }
        
        if (clearFiltersButton) {
            clearFiltersButton.addEventListener('click', () => {
                this.clearFilters();
            });
        }
        
        // Paginierung
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');
        
        if (prevPageButton) {
            prevPageButton.addEventListener('click', () => {
                this.navigatePage(-1);
            });
        }
        
        if (nextPageButton) {
            nextPageButton.addEventListener('click', () => {
                this.navigatePage(1);
            });
        }
        
        // "Nächste Bewertung" Button
        const loadNextEvaluationButton = document.getElementById('load-next-evaluation');
        
        if (loadNextEvaluationButton) {
            loadNextEvaluationButton.addEventListener('click', () => {
                this.loadNextPendingEvaluation();
            });
        }
        
        console.log('Event-Listener erfolgreich eingerichtet');
    };
    
    /**
     * Lädt ausstehende Bewertungen
     * @param {Object} filters - Optionale Filter für die Bewertungen
     */
    app.manualEvaluation.loadPendingEvaluations = function(filters = {}) {
        console.log('Lade ausstehende Bewertungen mit Filtern:', filters);
        
        this.state.isLoading = true;
        this.updateStatusMessage('Lade ausstehende Bewertungen...');
        
        // Liste der ausstehenden Bewertungen zurücksetzen
        const evaluationsList = document.getElementById('pending-evaluations-list');
        if (evaluationsList) {
            evaluationsList.innerHTML = '<div class="loading-indicator">Lade Bewertungen...</div>';
        }
        
        // Bewertungen aus dem Datenspeicher abrufen
        app.dataManager.getPendingEvaluations(filters)
            .then(pendingEvaluations => {
                this.state.pendingEvaluations = pendingEvaluations;
                this.state.totalPending = pendingEvaluations.length;
                this.state.currentIndex = 0;
                
                this.updateStatusMessage(`${pendingEvaluations.length} ausstehende Bewertungen gefunden`);
                this.renderEvaluationsList();
                this.updateFilters(pendingEvaluations);
                
                this.state.isLoading = false;
                
                // Wenn Bewertungen vorhanden sind, die erste laden
                if (pendingEvaluations.length > 0 && !this.state.currentQuestionId) {
                    this.loadNextPendingEvaluation();
                }
            })
            .catch(error => {
                console.error('Fehler beim Laden ausstehender Bewertungen:', error);
                this.updateStatusMessage('Fehler beim Laden der Bewertungen', true);
                this.state.isLoading = false;
                
                if (evaluationsList) {
                    evaluationsList.innerHTML = `
                        <div class="error-message">
                            <p>Fehler beim Laden der ausstehenden Bewertungen.</p>
                            <p>${error.message || 'Unbekannter Fehler'}</p>
                            <button id="retry-loading" class="action-button">Erneut versuchen</button>
                        </div>
                    `;
                    
                    const retryButton = document.getElementById('retry-loading');
                    if (retryButton) {
                        retryButton.addEventListener('click', () => {
                            this.loadPendingEvaluations(filters);
                        });
                    }
                }
            });
    };
    
    /**
     * Rendert die Liste der ausstehenden Bewertungen
     */
    app.manualEvaluation.renderEvaluationsList = function() {
        console.log('Rendere Liste der ausstehenden Bewertungen');
        
        const evaluationsList = document.getElementById('pending-evaluations-list');
        if (!evaluationsList) return;
        
        // Container leeren
        evaluationsList.innerHTML = '';
        
        const pendingEvaluations = this.state.pendingEvaluations;
        
        if (!pendingEvaluations || pendingEvaluations.length === 0) {
            evaluationsList.innerHTML = `
                <div class="empty-list">
                    <p>Keine ausstehenden Bewertungen gefunden.</p>
                </div>
            `;
            
            // Pagination aktualisieren
            this.updatePagination(0, 0);
            return;
        }
        
        // Paginierung berechnen
        const pageSize = this.config.pageSize;
        const totalPages = Math.ceil(pendingEvaluations.length / pageSize);
        const currentPage = Math.floor(this.state.currentIndex / pageSize) + 1;
        
        // Bereich für die aktuelle Seite berechnen
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = Math.min(startIndex + pageSize, pendingEvaluations.length);
        const currentPageItems = pendingEvaluations.slice(startIndex, endIndex);
        
        // Listeneinträge erstellen
        currentPageItems.forEach((evaluation, index) => {
            const absoluteIndex = startIndex + index;
            const isSelected = evaluation.questionId === this.state.currentQuestionId;
            
            // Vorschautext der Antwort (gekürzt)
            let answerPreview = 'Keine Antwort vorhanden';
            if (evaluation.answer && evaluation.answer.text) {
                answerPreview = evaluation.answer.text.substring(0, 100) + 
                    (evaluation.answer.text.length > 100 ? '...' : '');
            }
            
            // Datum formatieren
            const date = new Date(evaluation.timestamp);
            const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
            
            const itemHtml = `
                <div class="evaluation-item ${isSelected ? 'selected' : ''}" data-index="${absoluteIndex}">
                    <div class="evaluation-item-header">
                        <span class="test-name">${evaluation.testTitle || 'Unbekannter Test'}</span>
                        <span class="question-type">Freitext</span>
                    </div>
                    <div class="evaluation-meta">
                        <span class="user-name">Benutzer: ${evaluation.userName || 'Unbekannt'}</span> | 
                        <span class="timestamp">Datum: ${formattedDate}</span>
                    </div>
                    <div class="evaluation-preview">${answerPreview}</div>
                </div>
            `;
            
            evaluationsList.insertAdjacentHTML('beforeend', itemHtml);
        });
        
        // Event-Listener für Listeneinträge hinzufügen
        const itemElements = evaluationsList.querySelectorAll('.evaluation-item');
        itemElements.forEach(item => {
            item.addEventListener('click', () => {
                const index = parseInt(item.dataset.index);
                this.loadEvaluationByIndex(index);
            });
        });
        
        // Pagination aktualisieren
        this.updatePagination(currentPage, totalPages);
    };
    
    /**
     * Aktualisiert die Paginierung
     * @param {number} currentPage - Aktuelle Seite
     * @param {number} totalPages - Gesamtzahl der Seiten
     */
    app.manualEvaluation.updatePagination = function(currentPage, totalPages) {
        const currentPageElement = document.getElementById('current-page');
        const totalPagesElement = document.getElementById('total-pages');
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');
        
        if (currentPageElement) {
            currentPageElement.textContent = currentPage;
        }
        
        if (totalPagesElement) {
            totalPagesElement.textContent = totalPages;
        }
        
        if (prevPageButton) {
            prevPageButton.disabled = currentPage <= 1;
        }
        
        if (nextPageButton) {
            nextPageButton.disabled = currentPage >= totalPages;
        }
    };
    
    /**
     * Navigiert zur nächsten oder vorherigen Seite
     * @param {number} direction - Richtung der Navigation (1 = vorwärts, -1 = rückwärts)
     */
    app.manualEvaluation.navigatePage = function(direction) {
        const pageSize = this.config.pageSize;
        const totalPages = Math.ceil(this.state.pendingEvaluations.length / pageSize);
        const currentPage = Math.floor(this.state.currentIndex / pageSize) + 1;
        
        const newPage = currentPage + direction;
        
        if (newPage < 1 || newPage > totalPages) {
            return;
        }
        
        // Neue Startposition berechnen
        const newIndex = (newPage - 1) * pageSize;
        this.state.currentIndex = newIndex;
        
        // Liste neu rendern
        this.renderEvaluationsList();
    };
    
    /**
     * Aktualisiert die Filterdropdowns mit verfügbaren Optionen
     * @param {Array} evaluations - Liste der Bewertungen
     */
    app.manualEvaluation.updateFilters = function(evaluations) {
        console.log('Aktualisiere Filter-Optionen');
        
        const testFilter = document.getElementById('test-filter');
        const userFilter = document.getElementById('user-filter');
        
        if (!testFilter || !userFilter || !evaluations) return;
        
        // Aktuelle Auswahl speichern
        const selectedTest = testFilter.value;
        const selectedUser = userFilter.value;
        
        // Test-Filter zurücksetzen
        testFilter.innerHTML = '<option value="">Alle Tests</option>';
        
        // Benutzer-Filter zurücksetzen
        userFilter.innerHTML = '<option value="">Alle Benutzer</option>';
        
        // Eindeutige Tests und Benutzer sammeln
        const tests = new Map();
        const users = new Map();
        
        evaluations.forEach(evaluation => {
            if (evaluation.testId && evaluation.testTitle) {
                tests.set(evaluation.testId, evaluation.testTitle);
            }
            
            if (evaluation.userId && evaluation.userName) {
                users.set(evaluation.userId, evaluation.userName);
            }
        });
        
        // Test-Optionen hinzufügen
        tests.forEach((title, id) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = title;
            option.selected = id === selectedTest;
            testFilter.appendChild(option);
        });
        
        // Benutzer-Optionen hinzufügen
        users.forEach((name, id) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = name;
            option.selected = id === selectedUser;
            userFilter.appendChild(option);
        });
    };
    
    /**
     * Wendet Filter auf die Liste der Bewertungen an
     * @param {string} testId - Test-ID-Filter
     * @param {string} userId - Benutzer-ID-Filter
     */
    app.manualEvaluation.applyFilters = function(testId, userId) {
        console.log('Wende Filter an:', { testId, userId });
        
        const filters = {};
        
        if (testId) {
            filters.testId = testId;
        }
        
        if (userId) {
            filters.userId = userId;
        }
        
        // Lade Bewertungen mit Filtern
        this.loadPendingEvaluations(filters);
    };
    
    /**
     * Setzt alle Filter zurück
     */
    app.manualEvaluation.clearFilters = function() {
        console.log('Setze Filter zurück');
        
        const testFilter = document.getElementById('test-filter');
        const userFilter = document.getElementById('user-filter');
        
        if (testFilter) {
            testFilter.value = '';
        }
        
        if (userFilter) {
            userFilter.value = '';
        }
        
        // Lade alle Bewertungen ohne Filter
        this.loadPendingEvaluations();
    };
    
    /**
     * Lädt die nächste ausstehende Bewertung
     */
    app.manualEvaluation.loadNextPendingEvaluation = function() {
        console.log('Lade nächste ausstehende Bewertung');
        
        const pendingEvaluations = this.state.pendingEvaluations;
        
        if (!pendingEvaluations || pendingEvaluations.length === 0) {
            this.updateStatusMessage('Keine ausstehenden Bewertungen verfügbar');
            return;
        }
        
        // Aktuelle Position in den Bewertungen
        let index = this.state.currentIndex;
        
        // Laden der Bewertung
        this.loadEvaluationByIndex(index);
    };
    
    /**
     * Lädt eine Bewertung basierend auf dem Index
     * @param {number} index - Index der zu ladenden Bewertung
     */
    app.manualEvaluation.loadEvaluationByIndex = function(index) {
        console.log(`Lade Bewertung mit Index ${index}`);
        
        const pendingEvaluations = this.state.pendingEvaluations;
        
        if (!pendingEvaluations || index >= pendingEvaluations.length) {
            console.error('Ungültiger Index oder keine Bewertungen verfügbar');
            return;
        }
        
        this.state.isLoading = true;
        this.state.currentIndex = index;
        
        const evaluation = pendingEvaluations[index];
        
        // Aktuelle Bewertungsdaten speichern
        this.state.currentTestId = evaluation.testId;
        this.state.currentUserId = evaluation.userId;
        this.state.currentQuestionId = evaluation.questionId;
        
        // Lade detaillierte Daten
        Promise.all([
            app.dataManager.getTestById(evaluation.testId),
            app.dataManager.getQuestionById(evaluation.questionId),
            app.dataManager.getUserById(evaluation.userId)
        ])
        .then(([test, question, user]) => {
            if (!question) {
                throw new Error('Frage nicht gefunden');
            }
            
            // Rendere die Bewertungsansicht
            this.renderEvaluationView(evaluation, test, question, user);
            
            // Aktualisiere die Liste und markiere den ausgewählten Eintrag
            this.renderEvaluationsList();
            this.state.isLoading = false;
        })
        .catch(error => {
            console.error('Fehler beim Laden der Bewertungsdaten:', error);
            this.showEvaluationError(error.message || 'Fehler beim Laden der Bewertungsdaten');
            this.state.isLoading = false;
        });
    };
    
    /**
     * Rendert die Bewertungsansicht für eine Freitext-Antwort
     * @param {Object} evaluation - Bewertungsdaten
     * @param {Object} test - Testdaten
     * @param {Object} question - Fragendaten
     * @param {Object} user - Benutzerdaten
     */
    app.manualEvaluation.renderEvaluationView = function(evaluation, test, question, user) {
        console.log('Rendere Bewertungsansicht für Frage:', question.id);
        
        const contentContainer = document.getElementById('evaluation-content');
        if (!contentContainer) return;
        
        // Datum formatieren
        const date = new Date(evaluation.timestamp);
        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        
        // Maximale Punktzahl
        const maxScore = question.points || 1;
        
        // Antworttext
        const answerText = evaluation.answer && evaluation.answer.text ? 
            evaluation.answer.text : 'Keine Antwort vorhanden';
        
        // Container-Inhalt erstellen
        let contentHtml = `
            <div class="evaluation-view">
                <div class="question-section">
                    <div class="question-header">Freitext-Frage</div>
                    <div class="question-meta">
                        Test: ${test ? test.title : 'Unbekannter Test'} | 
                        Kategorie: ${question.category || 'Allgemein'} | 
                        Max. Punkte: ${maxScore}
                    </div>
                    <div class="question-text">${question.text}</div>
                </div>
                
                <div class="answer-section">
                    <div class="answer-header">Antwort des Benutzers</div>
                    <div class="answer-meta">
                        Benutzer: ${user ? user.fullName : 'Unbekannter Benutzer'} | 
                        Datum: ${formattedDate}
                    </div>
                    <div class="answer-text">${answerText}</div>
                </div>
        `;
        
        // Musterlösung anzeigen, falls konfiguriert
        if (this.config.showSolution && (question.correctAnswer || question.solution)) {
            const solution = question.solution || question.correctAnswer || 'Keine Musterlösung definiert';
            
            contentHtml += `
                <div class="model-answer">
                    <div class="model-answer-header">Musterlösung</div>
                    <div class="model-answer-text">${solution}</div>
                </div>
            `;
        }
        
        // Bewertungsformular
        contentHtml += `
            <div class="evaluation-form">
                <div class="form-group">
                    <label for="evaluation-score">Punktzahl:</label>
                    <div class="score-input">
                        <input type="number" id="evaluation-score" min="0" max="${maxScore}" step="0.5" value="0">
                        <span class="score-max">von ${maxScore} Punkten</span>
                    </div>
                    <div class="score-presets">
        `;
        
        // Score-Presets hinzufügen
        this.config.scorePresets.forEach(scorePercent => {
            const scoreValue = (scorePercent / 100) * maxScore;
            contentHtml += `
                <button class="score-preset-button" data-score="${scoreValue}">
                    ${scorePercent}% (${scoreValue})
                </button>
            `;
        });
        
        contentHtml += `
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="evaluation-feedback">Feedback/Kommentar:</label>
                    <textarea id="evaluation-feedback" placeholder="Geben Sie Feedback oder einen Kommentar zur Antwort ein..."></textarea>
        `;
        
        // Feedback-Vorlagen hinzufügen, falls konfiguriert
        if (this.config.showFeedbackSuggestions) {
            contentHtml += `<div class="feedback-templates">`;
            
            for (const [key, template] of Object.entries(this.config.feedbackTemplates)) {
                contentHtml += `
                    <div class="template-button" data-template="${template}">
                        ${key.charAt(0).toUpperCase() + key.slice(1)}
                    </div>
                `;
            }
            
            contentHtml += `</div>`;
        }
        
        contentHtml += `
                </div>
                
                <div class="save-status" id="save-status"></div>
                
                <div class="evaluation-actions">
                    <button id="skip-evaluation" class="secondary-button">Überspringen</button>
                    <div class="action-group">
                        <button id="save-evaluation" class="action-button">Speichern</button>
                        <button id="save-and-next" class="action-button">Speichern & Nächste</button>
                    </div>
                </div>
            </div>
        `;
        
        // HTML in den Container einfügen
        contentContainer.innerHTML = contentHtml;
        
        // Event-Listener hinzufügen
        this.setupEvaluationFormEventListeners(maxScore);
    };
    
    /**
     * Richtet Event-Listener für das Bewertungsformular ein
     * @param {number} maxScore - Maximale Punktzahl für die Frage
     */
    app.manualEvaluation.setupEvaluationFormEventListeners = function(maxScore) {
        console.log('Richte Event-Listener für Bewertungsformular ein');
        
        // Event-Listener für Score-Preset-Buttons
        const scorePresetButtons = document.querySelectorAll('.score-preset-button');
        const scoreInput = document.getElementById('evaluation-score');
        
        scorePresetButtons.forEach(button => {
            button.addEventListener('click', () => {
                const score = parseFloat(button.dataset.score);
                if (scoreInput) {
                    scoreInput.value = score;
                }
            });
        });
        
        // Event-Listener für Feedback-Template-Buttons
        const templateButtons = document.querySelectorAll('.template-button');
        const feedbackInput = document.getElementById('evaluation-feedback');
        
        templateButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (feedbackInput) {
                    feedbackInput.value = button.dataset.template;
                }
            });
        });
        
        // Event-Listener für Speichern-Button
        const saveButton = document.getElementById('save-evaluation');
        
        if (saveButton) {
            saveButton.addEventListener('click', () => {
                this.saveEvaluation(false);
            });
        }
        
        // Event-Listener für Speichern & Nächste-Button
        const saveAndNextButton = document.getElementById('save-and-next');
        
        if (saveAndNextButton) {
            saveAndNextButton.addEventListener('click', () => {
                this.saveEvaluation(true);
            });
        }
        
        // Event-Listener für Überspringen-Button
        const skipButton = document.getElementById('skip-evaluation');
        
        if (skipButton) {
            skipButton.addEventListener('click', () => {
                this.navigateToNextEvaluation();
            });
        }
        
        // Auto-Speichern, falls konfiguriert
        if (this.config.autoSave) {
            let autoSaveTimeout;
            
            const triggerAutoSave = () => {
                clearTimeout(autoSaveTimeout);
                
                // Statusanzeige aktualisieren
                const saveStatus = document.getElementById('save-status');
                if (saveStatus) {
                    saveStatus.textContent = 'Automatisches Speichern...';
                    saveStatus.className = 'save-status saving';
                }
                
                autoSaveTimeout = setTimeout(() => {
                    this.saveEvaluation(false, true);
                }, this.config.autoSaveDelay);
            };
            
            // Input-Änderungen überwachen
            if (scoreInput) {
                scoreInput.addEventListener('input', triggerAutoSave);
            }
            
            if (feedbackInput) {
                feedbackInput.addEventListener('input', triggerAutoSave);
            }
        }
    };
    
    /**
     * Speichert die Bewertung
     * @param {boolean} navigateToNext - Ob nach dem Speichern zur nächsten Bewertung navigiert werden soll
     * @param {boolean} isAutoSave - Ob es sich um ein automatisches Speichern handelt
     */
    app.manualEvaluation.saveEvaluation = function(navigateToNext = false, isAutoSave = false) {
        console.log('Speichere Bewertung, navigateToNext:', navigateToNext, 'isAutoSave:', isAutoSave);
        
        const scoreInput = document.getElementById('evaluation-score');
        const feedbackInput = document.getElementById('evaluation-feedback');
        const saveStatus = document.getElementById('save-status');
        
        if (!scoreInput) {
            console.error('Score-Input nicht gefunden');
            return;
        }
        
        // Bewertungsdaten sammeln
        const score = parseFloat(scoreInput.value) || 0;
        const feedback = feedbackInput ? feedbackInput.value : '';
        
        // ID-Daten aus dem State holen
        const { currentTestId, currentUserId, currentQuestionId, evaluatorId } = this.state;
        
        if (!currentTestId || !currentUserId || !currentQuestionId) {
            console.error('Fehlende ID-Daten für die Bewertung');
            if (saveStatus) {
                saveStatus.textContent = 'Fehler: Unvollständige Bewertungsdaten';
                saveStatus.className = 'save-status error';
            }
            return;
        }
        
        // Bewertungsobjekt erstellen
        const evaluation = {
            testId: currentTestId,
            userId: currentUserId,
            questionId: currentQuestionId,
            evaluatorId: evaluatorId,
            score: score,
            feedback: feedback,
            timestamp: new Date().toISOString()
        };
        
        // Statusanzeige aktualisieren
        if (saveStatus) {
            saveStatus.textContent = 'Speichern...';
            saveStatus.className = 'save-status saving';
        }
        
        // Speichern über den DataManager
        app.dataManager.saveManualEvaluation(evaluation)
            .then(savedEvaluation => {
                console.log('Bewertung erfolgreich gespeichert:', savedEvaluation);
                
                // Zur Bewertungshistorie hinzufügen
                this.state.evaluationHistory.push(savedEvaluation);
                
                // Statusanzeige aktualisieren
                if (saveStatus) {
                    saveStatus.textContent = 'Erfolgreich gespeichert';
                    saveStatus.className = 'save-status saved';
                }
                
                // Event auslösen
                const evaluationEvent = new CustomEvent('manualEvaluationSaved', {
                    detail: savedEvaluation
                });
                document.dispatchEvent(evaluationEvent);
                
                // Bei automatischem Speichern hier stoppen
                if (isAutoSave) {
                    return;
                }
                
                // Navigieren, falls erforderlich
                if (navigateToNext) {
                    setTimeout(() => {
                        this.navigateToNextEvaluation();
                    }, 500);
                }
            })
            .catch(error => {
                console.error('Fehler beim Speichern der Bewertung:', error);
                
                // Statusanzeige aktualisieren
                if (saveStatus) {
                    saveStatus.textContent = `Fehler beim Speichern: ${error.message || 'Unbekannter Fehler'}`;
                    saveStatus.className = 'save-status error';
                }
            });
    };
    
    /**
     * Navigiert zur nächsten Bewertung
     */
    app.manualEvaluation.navigateToNextEvaluation = function() {
        console.log('Navigiere zur nächsten Bewertung');
        
        const pendingEvaluations = this.state.pendingEvaluations;
        
        if (!pendingEvaluations || pendingEvaluations.length === 0) {
            this.updateStatusMessage('Keine weiteren ausstehenden Bewertungen verfügbar');
            return;
        }
        
        // Nächster Index
        const nextIndex = this.state.currentIndex + 1;
        
        // Wenn es keine weitere Bewertung gibt, bei 0 neu anfangen
        if (nextIndex >= pendingEvaluations.length) {
            this.updateStatusMessage('Ende der Liste erreicht, starte von vorne');
            this.loadEvaluationByIndex(0);
        } else {
            this.loadEvaluationByIndex(nextIndex);
        }
    };
    
    /**
     * Zeigt eine Fehlermeldung in der Bewertungsansicht an
     * @param {string} message - Die anzuzeigende Fehlermeldung
     */
    app.manualEvaluation.showEvaluationError = function(message) {
        console.log('Zeige Bewertungsfehler:', message);
        
        const contentContainer = document.getElementById('evaluation-content');
        if (!contentContainer) return;
        
        contentContainer.innerHTML = `
            <div class="error-state">
                <h3>Fehler beim Laden der Bewertung</h3>
                <p>${message}</p>
                <button id="try-next-evaluation" class="action-button">Nächste Bewertung versuchen</button>
            </div>
        `;
        
        const tryNextButton = document.getElementById('try-next-evaluation');
        if (tryNextButton) {
            tryNextButton.addEventListener('click', () => {
                this.navigateToNextEvaluation();
            });
        }
    };
    
    /**
     * Aktualisiert die Statusanzeige
     * @param {string} message - Die anzuzeigende Nachricht
     * @param {boolean} isError - Ob es sich um eine Fehlermeldung handelt
     */
    app.manualEvaluation.updateStatusMessage = function(message, isError = false) {
        console.log('Aktualisiere Statusanzeige:', message, isError);
        
        const statusText = document.querySelector('.status-text');
        const statusCount = document.querySelector('.status-count');
        
        if (statusText) {
            statusText.textContent = message;
            
            if (isError) {
                statusText.classList.add('error');
            } else {
                statusText.classList.remove('error');
            }
        }
        
        if (statusCount) {
            statusCount.textContent = `(${this.state.evaluationHistory.length}/${this.state.totalPending} bewertet)`;
        }
    };
    
    // Öffentliche Schnittstelle
    app.manualEvaluation.interface = {
        initialize: app.manualEvaluation.initialize.bind(app.manualEvaluation),
        loadPendingEvaluations: app.manualEvaluation.loadPendingEvaluations.bind(app.manualEvaluation),
        loadEvaluationByIndex: app.manualEvaluation.loadEvaluationByIndex.bind(app.manualEvaluation)
    };
    
    console.log('Bewertungsinterface (Teil 1) initialisiert');
})();
/**
 * JS-Block 6.2.1-part2: Bewertungsinterface (Teil 2)
 * Erweiterte Funktionen für die manuelle Bewertung von Freitext-Antworten
 * 
 * Dieses Modul erweitert das Bewertungsinterface um fortgeschrittene Funktionen:
 * - Erweiterte Feedback-Tools und Vorlagen
 * - Stapelverarbeitung von Bewertungen
 * - Bewertungshistorie und Nachverfolgung
 * - Kollaborative Bewertungsfunktionen
 * - Erweiterte UI-Komponenten
 */

// Namespace für Bewertungsinterface erweitern
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Interface) window.ImmoLern.Assessment.Interface = {};

// Modul für erweiterte Bewertungs-UI-Komponenten
window.ImmoLern.Assessment.Interface.Advanced = (function() {
    // Private Variablen
    let _currentReviewSession = null;
    let _feedbackTemplates = [];
    let _reviewHistory = [];
    let _batchProcessingQueue = [];
    let _collaborators = [];
    let _activeFilters = {};
    
    // DOM-Referenzen (werden bei Initialisierung gesetzt)
    let _elements = {
        feedbackTemplateContainer: null,
        batchActionsContainer: null,
        historyPanel: null,
        collaborationPanel: null,
        advancedFilters: null,
        rubricBuilder: null,
        annotationTools: null
    };
    
    // Ereignis-Handler
    const _events = {
        // Handler für Template-Auswahl
        onTemplateSelect: function(templateId) {
            const template = _feedbackTemplates.find(t => t.id === templateId);
            if (!template) return;
            
            // Template-Text in Feedback-Feld einfügen
            const feedbackField = document.getElementById('assessmentFeedback');
            if (feedbackField) {
                // Cursor-Position speichern
                const cursorPos = feedbackField.selectionStart;
                const currentText = feedbackField.value;
                
                // Text einfügen an Cursor-Position
                const newText = currentText.substring(0, cursorPos) + 
                                template.text + 
                                currentText.substring(cursorPos);
                                
                feedbackField.value = newText;
                
                // Cursor nach eingefügtem Text positionieren
                feedbackField.selectionStart = cursorPos + template.text.length;
                feedbackField.selectionEnd = cursorPos + template.text.length;
                feedbackField.focus();
            }
            
            // Event protokollieren
            window.ImmoLern.Logger.log('Template verwendet: ' + template.name);
        },
        
        // Handler für Stapelverarbeitung
        onBatchProcess: function(action) {
            if (!_batchProcessingQueue.length) {
                window.ImmoLern.UI.showToast('Keine Einträge zum Verarbeiten ausgewählt', 'warning');
                return;
            }
            
            // Bestätigungsdialog anzeigen
            const itemCount = _batchProcessingQueue.length;
            window.ImmoLern.UI.showConfirm(
                'Stapelverarbeitung',
                `Möchten Sie wirklich ${action} für ${itemCount} ausgewählte Antworten durchführen?`,
                () => {
                    // Stapelverarbeitung ausführen
                    _processBatch(action);
                }
            );
        },
        
        // Handler für die Anzeige der Bewertungshistorie
        onViewHistory: function(submissionId) {
            _loadReviewHistory(submissionId);
            
            // Historienpanel anzeigen
            if (_elements.historyPanel) {
                _elements.historyPanel.classList.remove('hidden');
                // Animation für sanftes Einblenden
                setTimeout(() => {
                    _elements.historyPanel.classList.add('active');
                }, 10);
            }
        },
        
        // Handler zum Schließen des Historienpanels
        onCloseHistoryPanel: function() {
            if (_elements.historyPanel) {
                _elements.historyPanel.classList.remove('active');
                // Nach Animation ausblenden
                setTimeout(() => {
                    _elements.historyPanel.classList.add('hidden');
                }, 300);
            }
        },
        
        // Handler für das Hinzufügen eines Bewertungskommentars
        onAddAnnotation: function(event) {
            const targetElement = document.querySelector('.student-answer-text');
            if (!targetElement) return;
            
            const selection = window.getSelection();
            if (selection.isCollapsed) {
                window.ImmoLern.UI.showToast('Bitte markieren Sie einen Text für die Anmerkung', 'info');
                return;
            }
            
            const range = selection.getRangeAt(0);
            const selectedText = range.toString();
            
            // Anmerkung Dialog anzeigen
            window.ImmoLern.UI.showPrompt(
                'Anmerkung hinzufügen',
                'Bitte geben Sie Ihren Kommentar ein:',
                '',
                (commentText) => {
                    if (!commentText) return;
                    
                    // Anmerkung speichern und anzeigen
                    _addAnnotationToText(range, selectedText, commentText);
                }
            );
        }
    };
    
    // Private Funktionen
    
    /**
     * Fügt eine Textanmerkung zum markierten Bereich hinzu
     * @param {Range} range - Der markierte Textbereich
     * @param {string} selectedText - Der markierte Text
     * @param {string} commentText - Der Anmerkungstext
     */
    function _addAnnotationToText(range, selectedText, commentText) {
        // Ursprünglichen Bereich entfernen
        range.deleteContents();
        
        // Anmerkungselement erstellen
        const annotationId = 'annotation-' + Date.now();
        const annotationSpan = document.createElement('span');
        annotationSpan.className = 'annotated-text';
        annotationSpan.setAttribute('data-annotation-id', annotationId);
        annotationSpan.textContent = selectedText;
        
        // Anmerkung in DOM einfügen
        range.insertNode(annotationSpan);
        
        // Anmerkungsdetails speichern
        const currentSubmissionId = _currentReviewSession?.currentSubmission?.id;
        if (currentSubmissionId) {
            const annotation = {
                id: annotationId,
                submissionId: currentSubmissionId,
                text: selectedText,
                comment: commentText,
                timestamp: new Date().toISOString(),
                reviewer: window.ImmoLern.Auth.getCurrentUser().username
            };
            
            // Anmerkung zur Session hinzufügen
            if (!_currentReviewSession.annotations) {
                _currentReviewSession.annotations = [];
            }
            _currentReviewSession.annotations.push(annotation);
            
            // Tooltip für die Anmerkung hinzufügen
            _createAnnotationTooltip(annotationSpan, annotation);
            
            // Anmerkung in Datenbank speichern
            window.ImmoLern.Assessment.Data.saveAnnotation(annotation)
                .then(() => {
                    window.ImmoLern.UI.showToast('Anmerkung gespeichert', 'success');
                })
                .catch(error => {
                    console.error('Fehler beim Speichern der Anmerkung:', error);
                    window.ImmoLern.UI.showToast('Fehler beim Speichern der Anmerkung', 'error');
                });
        }
    }
    
    /**
     * Erstellt ein Tooltip für eine Textanmerkung
     * @param {HTMLElement} element - Das Anmerkungselement
     * @param {Object} annotation - Die Anmerkungsdaten
     */
    function _createAnnotationTooltip(element, annotation) {
        // Popper.js für Tooltip verwenden, falls verfügbar
        if (window.Popper) {
            const tooltipId = 'tooltip-' + annotation.id;
            
            // Tooltip-Element erstellen
            const tooltipElement = document.createElement('div');
            tooltipElement.id = tooltipId;
            tooltipElement.className = 'annotation-tooltip';
            tooltipElement.innerHTML = `
                <div class="annotation-tooltip-header">
                    <span class="reviewer">${annotation.reviewer}</span>
                    <span class="timestamp">${new Date(annotation.timestamp).toLocaleString()}</span>
                </div>
                <div class="annotation-tooltip-body">${annotation.comment}</div>
            `;
            
            document.body.appendChild(tooltipElement);
            
            // Tooltip verstecken
            tooltipElement.style.display = 'none';
            
            // Event-Listener für Hover
            element.addEventListener('mouseenter', () => {
                tooltipElement.style.display = 'block';
                
                // Tooltip positionieren
                window.Popper.createPopper(element, tooltipElement, {
                    placement: 'top'
                });
            });
            
            element.addEventListener('mouseleave', () => {
                tooltipElement.style.display = 'none';
            });
        } else {
            // Fallback für Browser ohne Popper.js
            element.title = annotation.comment;
        }
    }
    
    /**
     * Lädt die Bewertungsverlauf für eine Einreichung
     * @param {string} submissionId - ID der Einreichung
     */
    function _loadReviewHistory(submissionId) {
        // Historie aus dem Datenspeicher laden
        window.ImmoLern.Assessment.Data.getReviewHistory(submissionId)
            .then(history => {
                _reviewHistory = history;
                _renderReviewHistory();
            })
            .catch(error => {
                console.error('Fehler beim Laden der Bewertungshistorie:', error);
                window.ImmoLern.UI.showToast('Fehler beim Laden der Bewertungshistorie', 'error');
                _reviewHistory = [];
                _renderReviewHistory();
            });
    }
    
    /**
     * Rendert die Bewertungshistorie im Historien-Panel
     */
    function _renderReviewHistory() {
        if (!_elements.historyPanel) return;
        
        const historyContentElement = _elements.historyPanel.querySelector('.history-content');
        if (!historyContentElement) return;
        
        if (_reviewHistory.length === 0) {
            historyContentElement.innerHTML = '<p class="empty-state">Keine Bewertungshistorie verfügbar</p>';
            return;
        }
        
        // Historie chronologisch sortieren (neueste zuerst)
        const sortedHistory = [..._reviewHistory].sort((a, b) => 
            new Date(b.timestamp) - new Date(a.timestamp)
        );
        
        // HTML für die Historie erzeugen
        let historyHtml = '<div class="history-timeline">';
        
        sortedHistory.forEach(entry => {
            const date = new Date(entry.timestamp);
            const formattedDate = date.toLocaleDateString();
            const formattedTime = date.toLocaleTimeString();
            
            historyHtml += `
                <div class="history-item">
                    <div class="history-item-header">
                        <span class="history-date">${formattedDate}</span>
                        <span class="history-time">${formattedTime}</span>
                        <span class="history-reviewer">${entry.reviewerName}</span>
                    </div>
                    <div class="history-item-content">
                        <div class="history-action">${entry.action}</div>
                        <div class="history-points">Punkte: ${entry.points} / ${entry.maxPoints}</div>
                        ${entry.comment ? `<div class="history-comment">${entry.comment}</div>` : ''}
                    </div>
                </div>
            `;
        });
        
        historyHtml += '</div>';
        historyContentElement.innerHTML = historyHtml;
    }
    
    /**
     * Verarbeitet eine Warteschlange von Bewertungselementen
     * @param {string} action - Die auszuführende Aktion
     */
    function _processBatch(action) {
        // Status-Indikator anzeigen
        window.ImmoLern.UI.showLoading('Stapelverarbeitung läuft...');
        
        // Stapelaktionen verarbeiten
        const processPromises = [];
        
        _batchProcessingQueue.forEach(item => {
            switch (action) {
                case 'approve':
                    // Maximale Punkte vergeben und genehmigen
                    processPromises.push(
                        window.ImmoLern.Assessment.Data.approveSubmission(
                            item.id, 
                            item.maxPoints,
                            'Automatisch genehmigt durch Stapelverarbeitung'
                        )
                    );
                    break;
                    
                case 'reject':
                    // Zurückweisen mit 0 Punkten
                    processPromises.push(
                        window.ImmoLern.Assessment.Data.rejectSubmission(
                            item.id,
                            'Automatisch zurückgewiesen durch Stapelverarbeitung'
                        )
                    );
                    break;
                    
                case 'markReview':
                    // Zur Überprüfung markieren
                    processPromises.push(
                        window.ImmoLern.Assessment.Data.markForReview(
                            item.id,
                            'Zur Überprüfung markiert durch Stapelverarbeitung'
                        )
                    );
                    break;
                    
                case 'assignToMe':
                    // Dieser Person zuweisen
                    const currentUser = window.ImmoLern.Auth.getCurrentUser();
                    processPromises.push(
                        window.ImmoLern.Assessment.Data.assignSubmission(
                            item.id,
                            currentUser.id
                        )
                    );
                    break;
                    
                default:
                    console.warn('Unbekannte Stapelverarbeitungsaktion:', action);
            }
        });
        
        // Alle Verarbeitungen abwarten
        Promise.all(processPromises)
            .then(() => {
                window.ImmoLern.UI.hideLoading();
                
                // Erfolg anzeigen
                window.ImmoLern.UI.showToast(
                    `${_batchProcessingQueue.length} Einreichungen erfolgreich verarbeitet`,
                    'success'
                );
                
                // Queue leeren
                _batchProcessingQueue = [];
                
                // UI aktualisieren
                _updateBatchUI();
                
                // Bewertungsliste aktualisieren
                window.ImmoLern.Assessment.Interface.refreshSubmissionList();
            })
            .catch(error => {
                window.ImmoLern.UI.hideLoading();
                console.error('Fehler bei der Stapelverarbeitung:', error);
                window.ImmoLern.UI.showToast('Fehler bei der Stapelverarbeitung', 'error');
            });
    }
    
    /**
     * Aktualisiert die Stapelverarbeitungs-UI
     */
    function _updateBatchUI() {
        const batchCountElement = document.getElementById('batchSelectionCount');
        if (batchCountElement) {
            batchCountElement.textContent = _batchProcessingQueue.length;
        }
        
        // Batch-Aktionen aktivieren/deaktivieren
        const batchButtons = document.querySelectorAll('.batch-action-btn');
        batchButtons.forEach(button => {
            if (_batchProcessingQueue.length > 0) {
                button.removeAttribute('disabled');
            } else {
                button.setAttribute('disabled', 'disabled');
            }
        });
    }
    
    /**
     * Lädt die Feedback-Vorlagen
     * @returns {Promise} - Promise, der nach dem Laden aufgelöst wird
     */
    function _loadFeedbackTemplates() {
        return window.ImmoLern.Assessment.Data.getFeedbackTemplates()
            .then(templates => {
                _feedbackTemplates = templates;
                _renderFeedbackTemplates();
                return templates;
            })
            .catch(error => {
                console.error('Fehler beim Laden der Feedback-Vorlagen:', error);
                window.ImmoLern.UI.showToast('Fehler beim Laden der Feedback-Vorlagen', 'error');
                _feedbackTemplates = [];
                _renderFeedbackTemplates();
                return [];
            });
    }
    
    /**
     * Rendert die Feedback-Vorlagen im Vorlagen-Container
     */
    function _renderFeedbackTemplates() {
        if (!_elements.feedbackTemplateContainer) return;
        
        if (_feedbackTemplates.length === 0) {
            _elements.feedbackTemplateContainer.innerHTML = '<p class="empty-state">Keine Feedback-Vorlagen verfügbar</p>';
            return;
        }
        
        // Nach Kategorien gruppieren
        const groupedTemplates = {};
        _feedbackTemplates.forEach(template => {
            if (!groupedTemplates[template.category]) {
                groupedTemplates[template.category] = [];
            }
            groupedTemplates[template.category].push(template);
        });
        
        // HTML für die gruppierten Vorlagen erstellen
        let templatesHtml = '';
        
        Object.keys(groupedTemplates).forEach(category => {
            templatesHtml += `
                <div class="template-category">
                    <h4 class="template-category-title">${category}</h4>
                    <div class="template-list">
            `;
            
            groupedTemplates[category].forEach(template => {
                templatesHtml += `
                    <div class="template-item" data-template-id="${template.id}">
                        <div class="template-name">${template.name}</div>
                        <div class="template-preview">${template.text.substring(0, 50)}${template.text.length > 50 ? '...' : ''}</div>
                    </div>
                `;
            });
            
            templatesHtml += `
                    </div>
                </div>
            `;
        });
        
        _elements.feedbackTemplateContainer.innerHTML = templatesHtml;
        
        // Event-Listener hinzufügen
        const templateItems = _elements.feedbackTemplateContainer.querySelectorAll('.template-item');
        templateItems.forEach(item => {
            item.addEventListener('click', () => {
                const templateId = item.getAttribute('data-template-id');
                _events.onTemplateSelect(templateId);
            });
        });
    }
    
    /**
     * Erstellt das erweiterte Bewertungsformular
     */
    function _createAdvancedAssessmentPanel() {
        // Überprüfen, ob das Basic-Interface bereits geladen wurde
        if (!document.getElementById('assessmentPanel')) {
            console.warn('Das Basis-Bewertungsinterface wurde noch nicht initialisiert');
            return;
        }
        
        // Container für die erweiterten Tools erstellen
        const advancedToolsContainer = document.createElement('div');
        advancedToolsContainer.id = 'advancedAssessmentTools';
        advancedToolsContainer.className = 'advanced-assessment-tools';
        
        // Erweiterte Tools-Komponenten hinzufügen
        advancedToolsContainer.innerHTML = `
            <div class="tools-section">
                <div class="tools-header">
                    <h3>Erweiterte Bewertungstools</h3>
                    <button type="button" id="toggleAdvancedTools" class="toggle-btn">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                </div>
                
                <div class="tools-content">
                    <!-- Feedback-Vorlagen -->
                    <div class="tool-panel feedback-templates-panel">
                        <h4>Feedback-Vorlagen</h4>
                        <div id="feedbackTemplateContainer" class="template-container"></div>
                        <div class="template-actions">
                            <button type="button" id="addTemplateBtn" class="btn btn-sm">
                                <i class="fas fa-plus"></i> Neue Vorlage
                            </button>
                            <button type="button" id="manageTemplatesBtn" class="btn btn-sm">
                                <i class="fas fa-cog"></i> Verwalten
                            </button>
                        </div>
                    </div>
                    
                    <!-- Batch-Aktionen -->
                    <div class="tool-panel batch-actions-panel">
                        <h4>Stapelverarbeitung</h4>
                        <div class="batch-selection">
                            Ausgewählt: <span id="batchSelectionCount">0</span> Antworten
                        </div>
                        <div id="batchActionsContainer" class="batch-actions">
                            <button type="button" class="btn btn-sm batch-action-btn" data-action="approve" disabled>
                                <i class="fas fa-check"></i> Alle genehmigen
                            </button>
                            <button type="button" class="btn btn-sm batch-action-btn" data-action="reject" disabled>
                                <i class="fas fa-times"></i> Alle ablehnen
                            </button>
                            <button type="button" class="btn btn-sm batch-action-btn" data-action="markReview" disabled>
                                <i class="fas fa-flag"></i> Zur Überprüfung
                            </button>
                            <button type="button" class="btn btn-sm batch-action-btn" data-action="assignToMe" disabled>
                                <i class="fas fa-user-check"></i> Mir zuweisen
                            </button>
                        </div>
                    </div>
                    
                    <!-- Textannotation -->
                    <div class="tool-panel annotation-tools-panel">
                        <h4>Textanmerkungen</h4>
                        <div id="annotationTools" class="annotation-tools">
                            <button type="button" id="addAnnotationBtn" class="btn btn-sm">
                                <i class="fas fa-comment-alt"></i> Anmerkung hinzufügen
                            </button>
                            <button type="button" id="showAnnotationsBtn" class="btn btn-sm">
                                <i class="fas fa-eye"></i> Anmerkungen anzeigen
                            </button>
                            <button type="button" id="hideAnnotationsBtn" class="btn btn-sm">
                                <i class="fas fa-eye-slash"></i> Anmerkungen ausblenden
                            </button>
                        </div>
                    </div>
                    
                    <!-- Bewertungsschema-Builder -->
                    <div class="tool-panel rubric-builder-panel">
                        <h4>Bewertungsschema</h4>
                        <div id="rubricBuilder" class="rubric-builder">
                            <button type="button" id="createRubricBtn" class="btn btn-sm">
                                <i class="fas fa-table"></i> Schema erstellen
                            </button>
                            <button type="button" id="loadRubricBtn" class="btn btn-sm">
                                <i class="fas fa-folder-open"></i> Schema laden
                            </button>
                            <div class="rubric-status">Kein Schema geladen</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Historienpanel (versteckt) -->
            <div id="historyPanel" class="history-panel hidden">
                <div class="panel-header">
                    <h3>Bewertungsverlauf</h3>
                    <button type="button" id="closeHistoryPanelBtn" class="close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="history-content"></div>
            </div>
            
            <!-- Kollaborationspanel (versteckt) -->
            <div id="collaborationPanel" class="collaboration-panel hidden">
                <div class="panel-header">
                    <h3>Zusammenarbeit</h3>
                    <button type="button" id="closeCollaborationPanelBtn" class="close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="collaboration-content"></div>
            </div>
        `;
        
        // Panel an das Bewertungsformular anhängen
        const assessmentPanel = document.getElementById('assessmentPanel');
        assessmentPanel.appendChild(advancedToolsContainer);
        
        // DOM-Referenzen speichern
        _elements.feedbackTemplateContainer = document.getElementById('feedbackTemplateContainer');
        _elements.batchActionsContainer = document.getElementById('batchActionsContainer');
        _elements.historyPanel = document.getElementById('historyPanel');
        _elements.collaborationPanel = document.getElementById('collaborationPanel');
        _elements.advancedFilters = document.getElementById('advancedFilters');
        _elements.rubricBuilder = document.getElementById('rubricBuilder');
        _elements.annotationTools = document.getElementById('annotationTools');
        
        // Event-Listener hinzufügen
        _initEventListeners();
        
        // Feedback-Vorlagen laden
        _loadFeedbackTemplates();
    }
    
    /**
     * Initialisiert die Event-Listener für die erweiterten Tools
     */
    function _initEventListeners() {
        // Toggle für erweiterte Tools
        const toggleBtn = document.getElementById('toggleAdvancedTools');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                const toolsContent = document.querySelector('.tools-content');
                toolsContent.classList.toggle('collapsed');
                
                // Icon aktualisieren
                const icon = toggleBtn.querySelector('i');
                if (toolsContent.classList.contains('collapsed')) {
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');
                } else {
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                }
            });
        }
        
        // Batch-Aktions-Buttons
        const batchButtons = document.querySelectorAll('.batch-action-btn');
        batchButtons.forEach(button => {
            button.addEventListener('click', () => {
                const action = button.getAttribute('data-action');
                _events.onBatchProcess(action);
            });
        });
        
        // Anmerkungs-Buttons
        const addAnnotationBtn = document.getElementById('addAnnotationBtn');
        if (addAnnotationBtn) {
            addAnnotationBtn.addEventListener('click', _events.onAddAnnotation);
        }
        
        const showAnnotationsBtn = document.getElementById('showAnnotationsBtn');
        if (showAnnotationsBtn) {
            showAnnotationsBtn.addEventListener('click', () => {
                document.querySelectorAll('.annotated-text').forEach(el => {
                    el.classList.add('active');
                });
            });
        }
        
        const hideAnnotationsBtn = document.getElementById('hideAnnotationsBtn');
        if (hideAnnotationsBtn) {
            hideAnnotationsBtn.addEventListener('click', () => {
                document.querySelectorAll('.annotated-text').forEach(el => {
                    el.classList.remove('active');
                });
            });
        }
        
        // Vorlagen-Verwaltung
        const addTemplateBtn = document.getElementById('addTemplateBtn');
        if (addTemplateBtn) {
            addTemplateBtn.addEventListener('click', () => {
                _showTemplateForm();
            });
        }
        
        // Historien-Panel schließen
        const closeHistoryPanelBtn = document.getElementById('closeHistoryPanelBtn');
        if (closeHistoryPanelBtn) {
            closeHistoryPanelBtn.addEventListener('click', _events.onCloseHistoryPanel);
        }
        
        // Bewertungsschema-Buttons
        const createRubricBtn = document.getElementById('createRubricBtn');
        if (createRubricBtn) {
            createRubricBtn.addEventListener('click', () => {
                _showRubricBuilder();
            });
        }
        
        const loadRubricBtn = document.getElementById('loadRubricBtn');
        if (loadRubricBtn) {
            loadRubricBtn.addEventListener('click', () => {
                _showRubricSelector();
            });
        }
    }
    
    /**
     * Zeigt das Formular zum Erstellen einer neuen Feedback-Vorlage
     */
    function _showTemplateForm(templateToEdit = null) {
        const isEditMode = templateToEdit !== null;
        
        // Dialog-Inhalt erstellen
        const dialogContent = document.createElement('div');
        dialogContent.className = 'template-form';
        dialogContent.innerHTML = `
            <div class="form-group">
                <label for="templateName">Vorlagenname</label>
                <input type="text" id="templateName" class="form-control" 
                    value="${isEditMode ? templateToEdit.name : ''}" required>
            </div>
            <div class="form-group">
                <label for="templateCategory">Kategorie</label>
                <select id="templateCategory" class="form-control">
                    <option value="Allgemein" ${isEditMode && templateToEdit.category === 'Allgemein' ? 'selected' : ''}>Allgemein</option>
                    <option value="Lob" ${isEditMode && templateToEdit.category === 'Lob' ? 'selected' : ''}>Lob</option>
                    <option value="Kritik" ${isEditMode && templateToEdit.category === 'Kritik' ? 'selected' : ''}>Kritik</option>
                    <option value="Verbesserungsvorschläge" ${isEditMode && templateToEdit.category === 'Verbesserungsvorschläge' ? 'selected' : ''}>Verbesserungsvorschläge</option>
                    <option value="Standardhinweise" ${isEditMode && templateToEdit.category === 'Standardhinweise' ? 'selected' : ''}>Standardhinweise</option>
                </select>
            </div>
            <div class="form-group">
                <label for="templateText">Vorlagentext</label>
                <textarea id="templateText" class="form-control" rows="5" required>${isEditMode ? templateToEdit.text : ''}</textarea>
            </div>
        `;
        
        // Dialog anzeigen
        window.ImmoLern.UI.showCustomDialog(
            isEditMode ? 'Vorlage bearbeiten' : 'Neue Feedback-Vorlage erstellen',
            dialogContent,
            [
                {
                    text: 'Abbrechen',
                    action: 'cancel',
                    class: 'btn-secondary'
                },
                {
                    text: isEditMode ? 'Aktualisieren' : 'Speichern',
                    action: 'confirm',
                    class: 'btn-primary'
                }
            ],
            (action) => {
                if (action !== 'confirm') return;
                
                // Daten aus dem Formular extrahieren
                const nameInput = document.getElementById('templateName');
                const categorySelect = document.getElementById('templateCategory');
                const textArea = document.getElementById('templateText');
                
                // Validierung
                if (!nameInput.value || !textArea.value) {
                    window.ImmoLern.UI.showToast('Bitte füllen Sie alle Pflichtfelder aus', 'warning');
                    return;
                }
                
                // Template-Objekt erstellen
                const template = {
                    id: isEditMode ? templateToEdit.id : 'template-' + Date.now(),
                    name: nameInput.value,
                    category: categorySelect.value,
                    text: textArea.value,
                    createdBy: window.ImmoLern.Auth.getCurrentUser().id,
                    lastModified: new Date().toISOString()
                };
                
                // Template speichern
                window.ImmoLern.Assessment.Data.saveFeedbackTemplate(template)
                    .then(() => {
                        window.ImmoLern.UI.showToast(
                            isEditMode ? 'Vorlage aktualisiert' : 'Neue Vorlage erstellt',
                            'success'
                        );
                        
                        // Vorlagen neu laden
                        _loadFeedbackTemplates();
                    })
                    .catch(error => {
                        console.error('Fehler beim Speichern der Vorlage:', error);
                        window.ImmoLern.UI.showToast('Fehler beim Speichern der Vorlage', 'error');
                    });
            }
        );
    }
    
    /**
     * Zeigt den Bewertungsschema-Builder
     */
    function _showRubricBuilder(existingRubric = null) {
        // Dialog-Inhalt erstellen
        const dialogContent = document.createElement('div');
        dialogContent.className = 'rubric-builder-container';
        dialogContent.innerHTML = `
            <div class="rubric-header">
                <div class="form-group">
                    <label for="rubricName">Schemaname</label>
                    <input type="text" id="rubricName" class="form-control" 
                        value="${existingRubric ? existingRubric.name : ''}" required>
                </div>
                <div class="form-group">
                    <label for="rubricDescription">Beschreibung</label>
                    <textarea id="rubricDescription" class="form-control" rows="2">${existingRubric ? existingRubric.description : ''}</textarea>
                </div>
            </div>
            
            <div class="rubric-criteria">
                <h4>Bewertungskriterien</h4>
                <div id="criteriaList" class="criteria-list">
                    ${existingRubric ? _generateCriteriaHTML(existingRubric.criteria) : '<p class="empty-state">Keine Kriterien definiert</p>'}
                </div>
                <button type="button" id="addCriterionBtn" class="btn btn-sm">
                    <i class="fas fa-plus"></i> Kriterium hinzufügen
                </button>
            </div>
        `;
        
        // Dialog anzeigen
        window.ImmoLern.UI.showCustomDialog(
            existingRubric ? 'Bewertungsschema bearbeiten' : 'Neues Bewertungsschema erstellen',
            dialogContent,
            [
                {
                    text: 'Abbrechen',
                    action: 'cancel',
                    class: 'btn-secondary'
                },
                {
                    text: existingRubric ? 'Aktualisieren' : 'Speichern',
                    action: 'confirm',
                    class: 'btn-primary'
                }
            ],
            (action) => {
                if (action !== 'confirm') return;
                
                // Implementierung des Speichern-Handlers
                // ...
            },
            // Erweiterte Optionen
            {
                size: 'large',
                onOpen: () => {
                    // Kriterien-Button initialisieren
                    const addCriterionBtn = document.getElementById('addCriterionBtn');
                    if (addCriterionBtn) {
                        addCriterionBtn.addEventListener('click', _addRubricCriterion);
                    }
                }
            }
        );
    }
    
    /**
     * Generiert HTML für die Kriterien
     * @param {Array} criteria - Liste der Kriterien
     * @returns {string} - HTML-String
     */
    function _generateCriteriaHTML(criteria = []) {
        if (!criteria || criteria.length === 0) {
            return '<p class="empty-state">Keine Kriterien definiert</p>';
        }
        
        let html = '';
        
        criteria.forEach((criterion, index) => {
            html += `
                <div class="criterion-item" data-criterion-index="${index}">
                    <div class="criterion-header">
                        <div class="criterion-name">${criterion.name}</div>
                        <div class="criterion-actions">
                            <button type="button" class="btn-icon edit-criterion" title="Bearbeiten">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button type="button" class="btn-icon remove-criterion" title="Entfernen">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                    </div>
                    <div class="criterion-details">
                        <div class="criterion-description">${criterion.description || 'Keine Beschreibung'}</div>
                        <div class="criterion-weight">Gewichtung: ${criterion.weight}%</div>
                    </div>
                    <div class="criterion-levels">
                        ${_generateLevelsHTML(criterion.levels)}
                    </div>
                </div>
            `;
        });
        
        return html;
    }
    
    /**
     * Generiert HTML für die Bewertungsstufen
     * @param {Array} levels - Liste der Bewertungsstufen
     * @returns {string} - HTML-String
     */
    function _generateLevelsHTML(levels = []) {
        if (!levels || levels.length === 0) {
            return '<p class="empty-state">Keine Bewertungsstufen definiert</p>';
        }
        
        let html = '<div class="levels-container">';
        
        levels.forEach(level => {
            html += `
                <div class="level-item">
                    <div class="level-name">${level.name}</div>
                    <div class="level-points">${level.points} Punkte</div>
                    <div class="level-description">${level.description || 'Keine Beschreibung'}</div>
                </div>
            `;
        });
        
        html += '</div>';
        return html;
    }
    
    /**
     * Fügt ein neues Kriterium zum Bewertungsschema hinzu
     */
    function _addRubricCriterion() {
        // Formular für neues Kriterium anzeigen
        const dialogContent = document.createElement('div');
        dialogContent.className = 'criterion-form';
        dialogContent.innerHTML = `
            <div class="form-group">
                <label for="criterionName">Kriteriumsname</label>
                <input type="text" id="criterionName" class="form-control" required>
            </div>
            <div class="form-group">
                <label for="criterionDescription">Beschreibung</label>
                <textarea id="criterionDescription" class="form-control" rows="2"></textarea>
            </div>
            <div class="form-group">
                <label for="criterionWeight">Gewichtung (%)</label>
                <input type="number" id="criterionWeight" class="form-control" min="0" max="100" value="10" required>
            </div>
            
            <div class="levels-section">
                <h4>Bewertungsstufen</h4>
                <div id="levelsList" class="levels-list">
                    <p class="empty-state">Keine Bewertungsstufen definiert</p>
                </div>
                <button type="button" id="addLevelBtn" class="btn btn-sm">
                    <i class="fas fa-plus"></i> Stufe hinzufügen
                </button>
            </div>
        `;
        
        // Dialog anzeigen
        window.ImmoLern.UI.showCustomDialog(
            'Neues Kriterium hinzufügen',
            dialogContent,
            [
                {
                    text: 'Abbrechen',
                    action: 'cancel',
                    class: 'btn-secondary'
                },
                {
                    text: 'Hinzufügen',
                    action: 'confirm',
                    class: 'btn-primary'
                }
            ],
            (action) => {
                if (action !== 'confirm') return;
                
                // Daten aus dem Formular extrahieren und verarbeiten
                // ...
            },
            // Erweiterte Optionen
            {
                onOpen: () => {
                    // Stufen-Button initialisieren
                    const addLevelBtn = document.getElementById('addLevelBtn');
                    if (addLevelBtn) {
                        addLevelBtn.addEventListener('click', _addRubricLevel);
                    }
                }
            }
        );
    }
    
    /**
     * Fügt eine neue Bewertungsstufe hinzu
     */
    function _addRubricLevel() {
        // Formular für neue Bewertungsstufe anzeigen
        const dialogContent = document.createElement('div');
        dialogContent.className = 'level-form';
        dialogContent.innerHTML = `
            <div class="form-group">
                <label for="levelName">Stufenname</label>
                <input type="text" id="levelName" class="form-control" required>
            </div>
            <div class="form-group">
                <label for="levelPoints">Punkte</label>
                <input type="number" id="levelPoints" class="form-control" min="0" value="1" required>
            </div>
            <div class="form-group">
                <label for="levelDescription">Beschreibung</label>
                <textarea id="levelDescription" class="form-control" rows="3"></textarea>
            </div>
        `;
        
        // Dialog anzeigen
        window.ImmoLern.UI.showCustomDialog(
            'Neue Bewertungsstufe hinzufügen',
            dialogContent,
            [
                {
                    text: 'Abbrechen',
                    action: 'cancel',
                    class: 'btn-secondary'
                },
                {
                    text: 'Hinzufügen',
                    action: 'confirm',
                    class: 'btn-primary'
                }
            ],
            (action) => {
                if (action !== 'confirm') return;
                
                // Daten aus dem Formular extrahieren und verarbeiten
                // ...
            }
        );
    }
    
    /**
     * Zeigt den Dialog zur Auswahl eines Bewertungsschemas
     */
    function _showRubricSelector() {
        // Bewertungsschemata laden
        window.ImmoLern.Assessment.Data.getRubrics()
            .then(rubrics => {
                if (rubrics.length === 0) {
                    window.ImmoLern.UI.showToast('Keine Bewertungsschemata verfügbar', 'info');
                    return;
                }
                
                // Dialog-Inhalt erstellen
                const dialogContent = document.createElement('div');
                dialogContent.className = 'rubric-selector';
                
                // Rubric-Liste erstellen
                let rubricListHtml = '<div class="rubric-list">';
                
                rubrics.forEach(rubric => {
                    rubricListHtml += `
                        <div class="rubric-item" data-rubric-id="${rubric.id}">
                            <div class="rubric-item-header">
                                <span class="rubric-name">${rubric.name}</span>
                                <span class="rubric-created">${new Date(rubric.createdAt).toLocaleDateString()}</span>
                            </div>
                            <div class="rubric-description">${rubric.description || 'Keine Beschreibung'}</div>
                            <div class="rubric-meta">
                                <span class="rubric-criteria-count">${rubric.criteria.length} Kriterien</span>
                                <span class="rubric-creator">Erstellt von: ${rubric.createdBy}</span>
                            </div>
                        </div>
                    `;
                });
                
                rubricListHtml += '</div>';
                dialogContent.innerHTML = rubricListHtml;
                
                // Dialog anzeigen
                window.ImmoLern.UI.showCustomDialog(
                    'Bewertungsschema auswählen',
                    dialogContent,
                    [
                        {
                            text: 'Abbrechen',
                            action: 'cancel',
                            class: 'btn-secondary'
                        },
                        {
                            text: 'Auswählen',
                            action: 'confirm',
                            class: 'btn-primary',
                            disabled: true
                        }
                    ],
                    (action, data) => {
                        if (action !== 'confirm' || !data.selectedRubricId) return;
                        
                        // Ausgewähltes Schema laden
                        const selectedRubric = rubrics.find(r => r.id === data.selectedRubricId);
                        if (selectedRubric) {
                            _loadRubric(selectedRubric);
                        }
                    },
                    // Erweiterte Optionen
                    {
                        data: { selectedRubricId: null },
                        onOpen: () => {
                            // Klick-Handler für Rubric-Items hinzufügen
                            const rubricItems = dialogContent.querySelectorAll('.rubric-item');
                            rubricItems.forEach(item => {
                                item.addEventListener('click', (e) => {
                                    // Bestehende Auswahl zurücksetzen
                                    rubricItems.forEach(i => i.classList.remove('selected'));
                                    
                                    // Dieses Item auswählen
                                    item.classList.add('selected');
                                    
                                    // ID speichern
                                    const rubricId = item.getAttribute('data-rubric-id');
                                    
                                    // Dialog-Daten aktualisieren
                                    const dialog = e.target.closest('.custom-dialog');
                                    if (dialog) {
                                        dialog._dialogData.selectedRubricId = rubricId;
                                        
                                        // Button aktivieren
                                        const confirmBtn = dialog.querySelector('.btn-primary');
                                        if (confirmBtn) {
                                            confirmBtn.removeAttribute('disabled');
                                        }
                                    }
                                });
                            });
                        }
                    }
                );
            })
            .catch(error => {
                console.error('Fehler beim Laden der Bewertungsschemata:', error);
                window.ImmoLern.UI.showToast('Fehler beim Laden der Bewertungsschemata', 'error');
            });
    }
    
    /**
     * Lädt ein Bewertungsschema und wendet es auf die aktuelle Bewertung an
     * @param {Object} rubric - Das zu ladende Bewertungsschema
     */
    function _loadRubric(rubric) {
        if (!rubric) return;
        
        // Status aktualisieren
        const rubricStatus = document.querySelector('.rubric-status');
        if (rubricStatus) {
            rubricStatus.textContent = `Schema geladen: ${rubric.name}`;
            rubricStatus.classList.add('active');
        }
        
        // Schema auf die aktuelle Bewertung anwenden
        window.ImmoLern.Assessment.Interface.applyRubric(rubric);
        
        // Erfolgsmeldung anzeigen
        window.ImmoLern.UI.showToast(`Bewertungsschema "${rubric.name}" geladen`, 'success');
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das erweiterte Bewertungsinterface
         */
        init: function() {
            // Warten bis das DOM geladen ist
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', _createAdvancedAssessmentPanel);
            } else {
                _createAdvancedAssessmentPanel();
            }
            return this;
        },
        
        /**
         * Setzt die aktuelle Bewertungssitzung
         * @param {Object} session - Die aktuelle Bewertungssitzung
         */
        setCurrentSession: function(session) {
            _currentReviewSession = session;
            return this;
        },
        
        /**
         * Aktualisiert die Stapelverarbeitungs-Warteschlange
         * @param {Array} items - Liste der zu verarbeitenden Elemente
         */
        updateBatchQueue: function(items) {
            _batchProcessingQueue = items || [];
            _updateBatchUI();
            return this;
        },
        
        /**
         * Zeigt den Bewertungsverlauf für eine bestimmte Einreichung an
         * @param {string} submissionId - ID der Einreichung
         */
        showHistory: function(submissionId) {
            _events.onViewHistory(submissionId);
            return this;
        },
        
        /**
         * Fügt eine benutzerdefinierte Feedback-Vorlage hinzu
         * @param {Object} template - Die Feedback-Vorlage
         */
        addFeedbackTemplate: function(template) {
            if (!template || !template.name || !template.text) {
                console.error('Ungültige Feedback-Vorlage');
                return this;
            }
            
            const newTemplate = {
                id: template.id || 'template-' + Date.now(),
                name: template.name,
                category: template.category || 'Benutzerdefiniert',
                text: template.text,
                createdBy: window.ImmoLern.Auth.getCurrentUser().id,
                lastModified: new Date().toISOString()
            };
            
            window.ImmoLern.Assessment.Data.saveFeedbackTemplate(newTemplate)
                .then(() => {
                    window.ImmoLern.UI.showToast('Feedback-Vorlage hinzugefügt', 'success');
                    _loadFeedbackTemplates();
                })
                .catch(error => {
                    console.error('Fehler beim Speichern der Feedback-Vorlage:', error);
                });
                
            return this;
        },
        
        /**
         * Ruft die Feedback-Vorlagen ab
         * @returns {Array} - Liste der Feedback-Vorlagen
         */
        getFeedbackTemplates: function() {
            return _feedbackTemplates;
        }
    };
})();

// Modul für das Managen von Bewertungsgruppen
window.ImmoLern.Assessment.Interface.Groups = (function() {
    // Private Variablen
    let _assessmentGroups = [];
    let _currentGroupId = null;
    
    // DOM-Elemente
    let _elements = {
        groupSelector: null,
        groupInfo: null,
        membersList: null
    };
    
    // Ereignis-Handler
    const _events = {
        // Handler für Gruppenauswahl
        onGroupSelect: function(groupId) {
            _loadGroupData(groupId);
        },
        
        // Handler für das Hinzufügen eines Mitglieds
        onAddMember: function() {
            _showMemberSelector();
        },
        
        // Handler für das Entfernen eines Mitglieds
        onRemoveMember: function(userId) {
            _removeGroupMember(userId);
        }
    };
    
    // Private Funktionen
    
    /**
     * Lädt die Daten für eine ausgewählte Bewertungsgruppe
     * @param {string} groupId - ID der Gruppe
     */
    function _loadGroupData(groupId) {
        if (!groupId) return;
        
        _currentGroupId = groupId;
        
        // Gruppendaten aus dem Speicher laden
        window.ImmoLern.Assessment.Data.getAssessmentGroup(groupId)
            .then(group => {
                if (!group) {
                    console.error('Gruppe nicht gefunden:', groupId);
                    return;
                }
                
                // Gruppeninformationen anzeigen
                _renderGroupInfo(group);
                
                // Mitgliederliste anzeigen
                _loadGroupMembers(group.members);
            })
            .catch(error => {
                console.error('Fehler beim Laden der Gruppendaten:', error);
                window.ImmoLern.UI.showToast('Fehler beim Laden der Gruppendaten', 'error');
            });
    }
    
    /**
     * Rendert die Gruppeninformationen
     * @param {Object} group - Die Gruppendaten
     */
    function _renderGroupInfo(group) {
        if (!_elements.groupInfo) return;
        
        _elements.groupInfo.innerHTML = `
            <div class="group-header">
                <h3 class="group-name">${group.name}</h3>
                <span class="group-type">${group.type}</span>
            </div>
            <div class="group-description">${group.description || 'Keine Beschreibung'}</div>
            <div class="group-meta">
                <span class="group-created">Erstellt am: ${new Date(group.createdAt).toLocaleDateString()}</span>
                <span class="group-member-count">Mitglieder: ${group.members.length}</span>
            </div>
        `;
    }
    
    /**
     * Lädt die Mitglieder einer Gruppe
     * @param {Array} memberIds - Liste der Mitglieder-IDs
     */
    function _loadGroupMembers(memberIds) {
        if (!memberIds || !memberIds.length) {
            if (_elements.membersList) {
                _elements.membersList.innerHTML = '<p class="empty-state">Keine Mitglieder in dieser Gruppe</p>';
            }
            return;
        }
        
        // Mitgliederdaten laden
        const userPromises = memberIds.map(id => window.ImmoLern.Users.getUserById(id));
        
        Promise.all(userPromises)
            .then(members => {
                _renderGroupMembers(members.filter(m => m !== null));
            })
            .catch(error => {
                console.error('Fehler beim Laden der Gruppenmitglieder:', error);
                if (_elements.membersList) {
                    _elements.membersList.innerHTML = '<p class="error-state">Fehler beim Laden der Mitglieder</p>';
                }
            });
    }
    
    /**
     * Rendert die Mitgliederliste
     * @param {Array} members - Liste der Mitglieder
     */
    function _renderGroupMembers(members) {
        if (!_elements.membersList) return;
        
        if (!members || members.length === 0) {
            _elements.membersList.innerHTML = '<p class="empty-state">Keine Mitglieder in dieser Gruppe</p>';
            return;
        }
        
        let membersHtml = '<ul class="members-list">';
        
        members.forEach(member => {
            membersHtml += `
                <li class="member-item" data-user-id="${member.id}">
                    <div class="member-avatar">
                        <img src="${member.avatar || 'assets/default-avatar.png'}" alt="${member.name}">
                    </div>
                    <div class="member-info">
                        <div class="member-name">${member.name}</div>
                        <div class="member-role">${member.role}</div>
                    </div>
                    <div class="member-actions">
                        <button type="button" class="btn-icon remove-member" title="Entfernen">
                            <i class="fas fa-user-minus"></i>
                        </button>
                    </div>
                </li>
            `;
        });
        
        membersHtml += '</ul>';
        _elements.membersList.innerHTML = membersHtml;
        
        // Event-Listener für Mitgliederaktionen hinzufügen
        const removeButtons = _elements.membersList.querySelectorAll('.remove-member');
        removeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const memberItem = e.target.closest('.member-item');
                if (memberItem) {
                    const userId = memberItem.getAttribute('data-user-id');
                    _events.onRemoveMember(userId);
                }
            });
        });
    }
    
    /**
     * Zeigt den Dialog zur Mitgliederauswahl
     */
    function _showMemberSelector() {
        // Liste der verfügbaren Benutzer laden
        window.ImmoLern.Users.getAllUsers()
            .then(users => {
                // Aktuelle Gruppenmitglieder filtern
                window.ImmoLern.Assessment.Data.getAssessmentGroup(_currentGroupId)
                    .then(group => {
                        const currentMembers = group.members || [];
                        
                        // Benutzer filtern, die nicht bereits Mitglieder sind
                        const availableUsers = users.filter(user => !currentMembers.includes(user.id));
                        
                        if (availableUsers.length === 0) {
                            window.ImmoLern.UI.showToast('Keine weiteren Benutzer verfügbar', 'info');
                            return;
                        }
                        
                        // Dialog-Inhalt erstellen
                        const dialogContent = document.createElement('div');
                        dialogContent.className = 'user-selector';
                        
                        // Suchfeld
                        dialogContent.innerHTML = `
                            <div class="search-container">
                                <input type="text" id="userSearchInput" class="form-control" placeholder="Nach Benutzern suchen...">
                            </div>
                            <div class="user-list">
                                ${_generateUserListHTML(availableUsers)}
                            </div>
                        `;
                        
                        // Dialog anzeigen
                        window.ImmoLern.UI.showCustomDialog(
                            'Gruppenmitglieder hinzufügen',
                            dialogContent,
                            [
                                {
                                    text: 'Abbrechen',
                                    action: 'cancel',
                                    class: 'btn-secondary'
                                },
                                {
                                    text: 'Hinzufügen',
                                    action: 'confirm',
                                    class: 'btn-primary',
                                    disabled: true
                                }
                            ],
                            (action, data) => {
                                if (action !== 'confirm' || !data.selectedUsers || data.selectedUsers.length === 0) return;
                                
                                // Ausgewählte Benutzer zur Gruppe hinzufügen
                                _addGroupMembers(data.selectedUsers);
                            },
                            // Erweiterte Optionen
                            {
                                data: { selectedUsers: [] },
                                onOpen: () => {
                                    // Event-Listener für Benutzerauswahl hinzufügen
                                    _initUserSelectionListeners(dialogContent);
                                    
                                    // Suchfunktion initialisieren
                                    const searchInput = document.getElementById('userSearchInput');
                                    if (searchInput) {
                                        searchInput.addEventListener('input', (e) => {
                                            _filterUserList(e.target.value, availableUsers);
                                        });
                                        
                                        // Fokus auf Suchfeld setzen
                                        searchInput.focus();
                                    }
                                }
                            }
                        );
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Gruppendaten:', error);
                        window.ImmoLern.UI.showToast('Fehler beim Laden der Gruppendaten', 'error');
                    });
            })
            .catch(error => {
                console.error('Fehler beim Laden der Benutzer:', error);
                window.ImmoLern.UI.showToast('Fehler beim Laden der Benutzer', 'error');
            });
    }

    // Restliche Implementierung...
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Gruppenverwaltungsmodul
         */
        init: function() {
            // DOM-Elemente initialisieren
            _elements.groupSelector = document.getElementById('assessmentGroupSelector');
            _elements.groupInfo = document.getElementById('assessmentGroupInfo');
            _elements.membersList = document.getElementById('assessmentGroupMembers');
            
            // Gruppen laden und Selector füllen
            this.loadGroups();
            
            return this;
        },
        
        /**
         * Lädt alle verfügbaren Bewertungsgruppen
         */
        loadGroups: function() {
            window.ImmoLern.Assessment.Data.getAllAssessmentGroups()
                .then(groups => {
                    _assessmentGroups = groups;
                    
                    if (_elements.groupSelector) {
                        // Selector-Optionen erstellen
                        let optionsHtml = '<option value="">Bewertungsgruppe auswählen</option>';
                        
                        groups.forEach(group => {
                            optionsHtml += `<option value="${group.id}">${group.name}</option>`;
                        });
                        
                        _elements.groupSelector.innerHTML = optionsHtml;
                        
                        // Event-Listener hinzufügen
                        _elements.groupSelector.addEventListener('change', () => {
                            const selectedGroupId = _elements.groupSelector.value;
                            if (selectedGroupId) {
                                _events.onGroupSelect(selectedGroupId);
                            } else {
                                // Gruppenanzeige zurücksetzen
                                if (_elements.groupInfo) {
                                    _elements.groupInfo.innerHTML = '';
                                }
                                if (_elements.membersList) {
                                    _elements.membersList.innerHTML = '';
                                }
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Fehler beim Laden der Bewertungsgruppen:', error);
                });
        }
    };
})();

// Modul initialisieren, wenn das Basisbewertungsmodul geladen ist
document.addEventListener('assessmentInterfaceLoaded', () => {
    window.ImmoLern.Assessment.Interface.Advanced.init();
    window.ImmoLern.Assessment.Interface.Groups.init();
});
/**
 * JS-Block 6.2.2-part1: Speichern und Verarbeiten (Teil 1)
 * 
 * Dieses Modul implementiert die Funktionen zum Speichern und Verarbeiten
 * manueller Bewertungen von Freitext-Antworten. Es umfasst:
 * - Datenvalidierung und -strukturierung
 * - Speichermechanismen und Datenintegration
 * - Bewertungsstatusmanagement
 * - Versionsmanagement der Bewertungen
 * - Synchronisationsmechanismen
 */

// Namespace für Bewertungsdatenverarbeitung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Processing) window.ImmoLern.Assessment.Processing = {};

// Modul für die Bewertungsdatenverarbeitung
window.ImmoLern.Assessment.Processing.Manual = (function() {
    // Private Variablen
    let _pendingChanges = {};
    let _saveTimeout = null;
    let _isSaving = false;
    let _savingQueue = [];
    let _lastSavedState = null;
    let _currentRevision = 0;
    
    // Validierungsregeln für Bewertungsdaten
    const _validationRules = {
        // Generelle Regeln
        general: {
            maxPointsAllowed: true,
            minPointsAllowed: 0,
            feedbackRequired: true,
            minFeedbackLength: 10,
            requireRubricCriteria: false
        },
        
        // Spezifische Regeln je nach Bewertungstyp
        byType: {
            standard: {},
            strict: {
                feedbackRequired: true,
                minFeedbackLength: 50,
                requireRubricCriteria: true
            },
            lenient: {
                feedbackRequired: false,
                minFeedbackLength: 0
            }
        }
    };
    
    // Aktuelle Bewertungseinstellungen (Standard-Modus)
    let _assessmentSettings = { ..._validationRules.general };
    
    // Ereignis-Listener
    const _events = new EventTarget();
    
    // Private Funktionen
    
    /**
     * Validiert die Bewertungsdaten
     * @param {Object} assessmentData - Die zu validierenden Bewertungsdaten
     * @returns {Object} - Validierungsergebnis mit Status und etwaigen Fehlern
     */
    function _validateAssessmentData(assessmentData) {
        const errors = [];
        let isValid = true;
        
        // Prüfen, ob die erforderlichen Felder vorhanden sind
        if (!assessmentData) {
            return { isValid: false, errors: ['Keine Bewertungsdaten vorhanden'] };
        }
        
        // Prüfen, ob eine Punktzahl angegeben wurde
        if (assessmentData.points === undefined) {
            errors.push('Bitte geben Sie eine Punktzahl an');
            isValid = false;
        } else {
            // Punktzahl muss eine Zahl sein
            if (typeof assessmentData.points !== 'number') {
                errors.push('Die Punktzahl muss eine Zahl sein');
                isValid = false;
            }
            
            // Punktzahl muss im gültigen Bereich liegen
            if (assessmentData.points < _assessmentSettings.minPointsAllowed) {
                errors.push(`Die Punktzahl muss mindestens ${_assessmentSettings.minPointsAllowed} sein`);
                isValid = false;
            }
            
            if (assessmentData.maxPoints !== undefined && assessmentData.points > assessmentData.maxPoints) {
                errors.push(`Die Punktzahl darf maximal ${assessmentData.maxPoints} sein`);
                isValid = false;
            }
        }
        
        // Prüfen, ob Feedback erforderlich ist
        if (_assessmentSettings.feedbackRequired && (!assessmentData.feedback || assessmentData.feedback.trim() === '')) {
            errors.push('Bitte geben Sie ein Feedback an');
            isValid = false;
        } else if (assessmentData.feedback && assessmentData.feedback.length < _assessmentSettings.minFeedbackLength) {
            errors.push(`Das Feedback muss mindestens ${_assessmentSettings.minFeedbackLength} Zeichen lang sein`);
            isValid = false;
        }
        
        // Prüfen, ob Rubrik-Kriterien erforderlich sind
        if (_assessmentSettings.requireRubricCriteria && (!assessmentData.rubricScores || Object.keys(assessmentData.rubricScores).length === 0)) {
            errors.push('Bitte bewerten Sie alle Kriterien des Bewertungsschemas');
            isValid = false;
        }
        
        return { isValid, errors };
    }
    
    /**
     * Strukturiert die Bewertungsdaten für die Speicherung
     * @param {Object} formData - Die Formulardaten aus dem Bewertungsinterface
     * @returns {Object} - Strukturierte Bewertungsdaten
     */
    function _structureAssessmentData(formData) {
        // ID des Bewertenden
        const assessorId = window.ImmoLern.Auth.getCurrentUser().id;
        
        // Aktuelle Zeit
        const timestamp = new Date().toISOString();
        
        // Bewertungsdaten strukturieren
        const structuredData = {
            submissionId: formData.submissionId,
            questionId: formData.questionId,
            userId: formData.userId,
            testId: formData.testId,
            points: parseFloat(formData.points) || 0,
            maxPoints: parseFloat(formData.maxPoints) || 0,
            feedback: formData.feedback || '',
            status: formData.status || 'reviewed',
            assessorId: assessorId,
            timestamp: timestamp,
            rubricId: formData.rubricId || null,
            rubricScores: formData.rubricScores || {},
            annotations: formData.annotations || [],
            revision: _currentRevision + 1
        };
        
        // Optional: Flag für automatische vs. manuelle Bewertung
        structuredData.isManualAssessment = true;
        
        return structuredData;
    }
    
    /**
     * Speichert Bewertungsdaten im lokalen Speicher als Backup
     * @param {Object} assessmentData - Die zu speichernden Bewertungsdaten
     */
    function _saveToLocalBackup(assessmentData) {
        try {
            // Eindeutigen Schlüssel für die Bewertungsdaten erstellen
            const storageKey = `assessmentBackup_${assessmentData.submissionId}`;
            
            // Mit Zeitstempel versehen
            const backupData = {
                data: assessmentData,
                timestamp: new Date().toISOString(),
                backupType: 'auto'
            };
            
            // Im LocalStorage speichern
            localStorage.setItem(storageKey, JSON.stringify(backupData));
            
            // Alten Backup-Eintrag von der Warteschlange entfernen
            const existingIndex = _savingQueue.findIndex(item => item.id === assessmentData.submissionId);
            if (existingIndex !== -1) {
                _savingQueue.splice(existingIndex, 1);
            }
            
            console.log('Bewertungs-Backup lokal gespeichert:', storageKey);
        } catch (error) {
            console.error('Fehler beim lokalen Backup der Bewertungsdaten:', error);
        }
    }
    
    /**
     * Lädt ein lokales Backup der Bewertungsdaten
     * @param {string} submissionId - ID der Einreichung
     * @returns {Object|null} - Die Backup-Daten oder null, wenn kein Backup vorhanden
     */
    function _loadFromLocalBackup(submissionId) {
        try {
            const storageKey = `assessmentBackup_${submissionId}`;
            const backupDataJson = localStorage.getItem(storageKey);
            
            if (!backupDataJson) {
                return null;
            }
            
            const backupData = JSON.parse(backupDataJson);
            return backupData.data;
        } catch (error) {
            console.error('Fehler beim Laden des lokalen Backups:', error);
            return null;
        }
    }
    
    /**
     * Löscht ein lokales Backup der Bewertungsdaten
     * @param {string} submissionId - ID der Einreichung
     */
    function _clearLocalBackup(submissionId) {
        try {
            const storageKey = `assessmentBackup_${submissionId}`;
            localStorage.removeItem(storageKey);
        } catch (error) {
            console.error('Fehler beim Löschen des lokalen Backups:', error);
        }
    }
    
    /**
     * Speichert Änderungen an der Bewertung mit Verzögerung (Auto-Save)
     * @param {Object} assessmentData - Die zu speichernden Bewertungsdaten
     */
    function _debouncedSave(assessmentData) {
        // Aktuelle Änderungen speichern
        _pendingChanges[assessmentData.submissionId] = assessmentData;
        
        // Bestehenden Timeout löschen
        if (_saveTimeout) {
            clearTimeout(_saveTimeout);
        }
        
        // Auto-Save mit Verzögerung starten
        _saveTimeout = setTimeout(() => {
            // Alle ausstehenden Änderungen speichern
            _saveAllPendingChanges();
        }, 3000); // 3 Sekunden Verzögerung
        
        // Lokales Backup sofort erstellen
        _saveToLocalBackup(assessmentData);
    }
    
    /**
     * Speichert alle ausstehenden Änderungen
     * @returns {Promise} - Promise, der nach dem Speichern aufgelöst wird
     */
    function _saveAllPendingChanges() {
        // Wenn gerade gespeichert wird, zur Warteschlange hinzufügen
        if (_isSaving) {
            // Alle ausstehenden Änderungen zur Warteschlange hinzufügen
            Object.values(_pendingChanges).forEach(data => {
                // Prüfen, ob bereits in der Warteschlange
                const existingIndex = _savingQueue.findIndex(item => item.id === data.submissionId);
                if (existingIndex !== -1) {
                    // Aktualisieren
                    _savingQueue[existingIndex] = { id: data.submissionId, data: data };
                } else {
                    // Neu hinzufügen
                    _savingQueue.push({ id: data.submissionId, data: data });
                }
            });
            
            return Promise.resolve();
        }
        
        // Keine ausstehenden Änderungen
        if (Object.keys(_pendingChanges).length === 0) {
            return Promise.resolve();
        }
        
        // Speicherzustand setzen
        _isSaving = true;
        
        // Änderungen kopieren und zurücksetzen
        const changesToSave = { ..._pendingChanges };
        _pendingChanges = {};
        
        // Statusinformation anzeigen
        window.ImmoLern.UI.showSavingIndicator();
        
        // Alle Änderungen speichern
        const savePromises = Object.values(changesToSave).map(data => {
            return window.ImmoLern.Assessment.Data.saveAssessment(data)
                .then(result => {
                    console.log('Bewertung gespeichert:', data.submissionId);
                    
                    // Lokales Backup löschen, da nun gespeichert
                    _clearLocalBackup(data.submissionId);
                    
                    // Neuen Revisionsstatus setzen
                    if (data.submissionId === _lastSavedState?.submissionId) {
                        _currentRevision = data.revision;
                    }
                    
                    // Ereignis für erfolgreiche Speicherung auslösen
                    _events.dispatchEvent(new CustomEvent('assessmentSaved', {
                        detail: { submissionId: data.submissionId, result: result }
                    }));
                    
                    return { success: true, id: data.submissionId };
                })
                .catch(error => {
                    console.error('Fehler beim Speichern der Bewertung:', error);
                    
                    // Fehlgeschlagene Speicherung zurück in die Warteschlange
                    _pendingChanges[data.submissionId] = data;
                    
                    // Ereignis für Speicherfehler auslösen
                    _events.dispatchEvent(new CustomEvent('assessmentSaveError', {
                        detail: { submissionId: data.submissionId, error: error }
                    }));
                    
                    return { success: false, id: data.submissionId, error };
                });
        });
        
        // Warten, bis alle Speicherungen abgeschlossen sind
        return Promise.all(savePromises)
            .then(results => {
                // Speicherindikator ausblenden
                window.ImmoLern.UI.hideSavingIndicator();
                
                // Speicherzustand zurücksetzen
                _isSaving = false;
                
                // Statusmeldung anzeigen
                const successCount = results.filter(r => r.success).length;
                const errorCount = results.length - successCount;
                
                if (errorCount === 0) {
                    window.ImmoLern.UI.showToast(`${successCount} Bewertung(en) gespeichert`, 'success');
                } else if (successCount === 0) {
                    window.ImmoLern.UI.showToast(`Fehler beim Speichern von ${errorCount} Bewertung(en)`, 'error');
                } else {
                    window.ImmoLern.UI.showToast(`${successCount} gespeichert, ${errorCount} fehlgeschlagen`, 'warning');
                }
                
                // Wenn noch Elemente in der Warteschlange sind, diese verarbeiten
                if (_savingQueue.length > 0) {
                    // Verzögert verarbeiten, um UI-Updates zu ermöglichen
                    setTimeout(() => {
                        const queueCopy = [..._savingQueue];
                        _savingQueue = [];
                        
                        // Änderungen aus der Warteschlange übernehmen
                        queueCopy.forEach(item => {
                            _pendingChanges[item.id] = item.data;
                        });
                        
                        // Erneut speichern
                        _saveAllPendingChanges();
                    }, 100);
                }
                
                return results;
            });
    }
    
    /**
     * Berechnet eine Gesamtpunktzahl aus den Rubrik-Bewertungen
     * @param {Object} rubricScores - Die Bewertungen pro Kriterium
     * @param {Object} rubric - Das verwendete Bewertungsschema
     * @param {number} maxPoints - Die maximale Punktzahl
     * @returns {number} - Die berechnete Gesamtpunktzahl
     */
    function _calculatePointsFromRubric(rubricScores, rubric, maxPoints) {
        if (!rubricScores || !rubric || !rubric.criteria || !maxPoints) {
            return 0;
        }
        
        // Gesamtpunkte und Gewichtung berechnen
        let totalWeightedScore = 0;
        let totalWeight = 0;
        
        rubric.criteria.forEach(criterion => {
            if (rubricScores[criterion.id]) {
                const score = rubricScores[criterion.id];
                const weight = criterion.weight || 1;
                
                // Jedes Kriterium hat eine maximale Punktzahl und eine Gewichtung
                // Die gewichtete Punktzahl ist der Anteil an der Maximalpunktzahl * Gewichtung
                totalWeightedScore += (score.points / score.maxPoints) * weight;
                totalWeight += weight;
            }
        });
        
        // Wenn keine Gewichtungen vorhanden, Standardwert zurückgeben
        if (totalWeight === 0) {
            return 0;
        }
        
        // Gesamtpunktzahl berechnen als Anteil an der Maximalpunktzahl
        const normalizedScore = totalWeightedScore / totalWeight;
        return Math.round(normalizedScore * maxPoints * 100) / 100; // Auf 2 Nachkommastellen runden
    }
    
    /**
     * Speichert eine Bewertung mit Versionsmanagement
     * @param {Object} assessmentData - Die zu speichernden Bewertungsdaten
     * @param {boolean} immediate - Ob sofort gespeichert werden soll (statt Auto-Save)
     * @returns {Promise|void} - Promise, wenn sofort gespeichert wird
     */
    function _saveWithVersioning(assessmentData, immediate = false) {
        // Zu speichernde Revision aktualisieren
        if (_lastSavedState && _lastSavedState.submissionId === assessmentData.submissionId) {
            assessmentData.revision = _currentRevision + 1;
        } else {
            assessmentData.revision = 1;
            _currentRevision = 0;
        }
        
        // Aktuellen Zustand für spätere Vergleiche merken
        _lastSavedState = { ...assessmentData };
        
        // Sofort speichern oder Auto-Save verwenden
        if (immediate) {
            _pendingChanges[assessmentData.submissionId] = assessmentData;
            return _saveAllPendingChanges();
        } else {
            _debouncedSave(assessmentData);
        }
    }
    
    /**
     * Aktualisiert den Status einer Bewertung
     * @param {string} submissionId - ID der Einreichung
     * @param {string} newStatus - Der neue Status
     * @param {string} [comment] - Optionaler Kommentar zur Statusänderung
     * @returns {Promise} - Promise, der nach der Aktualisierung aufgelöst wird
     */
    function _updateAssessmentStatus(submissionId, newStatus, comment) {
        // Aktuelle Bewertungsdaten laden
        return window.ImmoLern.Assessment.Data.getAssessment(submissionId)
            .then(currentData => {
                if (!currentData) {
                    return Promise.reject(new Error('Bewertung nicht gefunden'));
                }
                
                // Status aktualisieren
                currentData.status = newStatus;
                
                // Kommentar hinzufügen, falls vorhanden
                if (comment) {
                    if (!currentData.statusHistory) {
                        currentData.statusHistory = [];
                    }
                    
                    currentData.statusHistory.push({
                        status: newStatus,
                        timestamp: new Date().toISOString(),
                        userId: window.ImmoLern.Auth.getCurrentUser().id,
                        comment: comment
                    });
                }
                
                // Aktualisierte Daten speichern
                return _saveWithVersioning(currentData, true);
            });
    }
    
    /**
     * Überprüft, ob Änderungen an der Bewertung vorhanden sind
     * @param {Object} currentData - Die aktuellen Bewertungsdaten
     * @param {Object} previousData - Die vorherigen Bewertungsdaten
     * @returns {boolean} - True, wenn Änderungen vorhanden sind
     */
    function _hasChanges(currentData, previousData) {
        if (!previousData) return true;
        
        // Relevante Felder prüfen
        return (
            currentData.points !== previousData.points ||
            currentData.feedback !== previousData.feedback ||
            currentData.status !== previousData.status ||
            JSON.stringify(currentData.rubricScores) !== JSON.stringify(previousData.rubricScores) ||
            (currentData.annotations && previousData.annotations && 
             currentData.annotations.length !== previousData.annotations.length)
        );
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Bewertungsdatenverarbeitungsmodul
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Bewertungseinstellungen überschreiben, falls vorhanden
            if (options.assessmentType) {
                const typeSettings = _validationRules.byType[options.assessmentType];
                if (typeSettings) {
                    _assessmentSettings = {
                        ..._validationRules.general,
                        ...typeSettings
                    };
                }
            }
            
            // Benutzerdefinierte Einstellungen überschreiben
            if (options.customSettings) {
                _assessmentSettings = {
                    ..._assessmentSettings,
                    ...options.customSettings
                };
            }
            
            console.log('Bewertungsdatenverarbeitung initialisiert mit Einstellungen:', _assessmentSettings);
            
            // Event-Listener für Formularänderungen initialisieren
            document.addEventListener('assessmentFormChange', (event) => {
                const formData = event.detail;
                if (formData && formData.submissionId) {
                    // Formular-/DOM-Daten strukturieren
                    const assessmentData = _structureAssessmentData(formData);
                    
                    // Auto-Save der strukturierten Daten
                    _debouncedSave(assessmentData);
                }
            });
            
            return this;
        },
        
        /**
         * Event-Listener für das Bewertungsmodul registrieren
         * @param {string} eventName - Name des Ereignisses
         * @param {Function} callback - Callback-Funktion
         */
        addEventListener: function(eventName, callback) {
            _events.addEventListener(eventName, callback);
            return this;
        },
        
        /**
         * Event-Listener für das Bewertungsmodul entfernen
         * @param {string} eventName - Name des Ereignisses
         * @param {Function} callback - Callback-Funktion
         */
        removeEventListener: function(eventName, callback) {
            _events.removeEventListener(eventName, callback);
            return this;
        },
        
        /**
         * Validiert die Bewertungsdaten
         * @param {Object} assessmentData - Die zu validierenden Bewertungsdaten
         * @returns {Object} - Validierungsergebnis
         */
        validateAssessment: function(assessmentData) {
            return _validateAssessmentData(assessmentData);
        },
        
        /**
         * Speichert eine Bewertung
         * @param {Object} formData - Die Formulardaten aus dem Bewertungsinterface
         * @param {boolean} immediate - Ob sofort gespeichert werden soll
         * @returns {Promise|void} - Promise, wenn sofort gespeichert wird
         */
        saveAssessment: function(formData, immediate = false) {
            // Formular-/DOM-Daten strukturieren
            const assessmentData = _structureAssessmentData(formData);
            
            // Validieren
            const validation = _validateAssessmentData(assessmentData);
            if (!validation.isValid) {
                // Validierungsfehler anzeigen
                window.ImmoLern.UI.showToast(validation.errors[0], 'error');
                
                // Validierungsereignis auslösen
                _events.dispatchEvent(new CustomEvent('assessmentValidationError', {
                    detail: { errors: validation.errors, data: assessmentData }
                }));
                
                // Bei sofortiger Speicherung einen abgelehnten Promise zurückgeben
                if (immediate) {
                    return Promise.reject(new Error(validation.errors[0]));
                }
                
                return;
            }
            
            // Mit Versionsmanagement speichern
            return _saveWithVersioning(assessmentData, immediate);
        },
        
        /**
         * Speichert alle ausstehenden Änderungen sofort
         * @returns {Promise} - Promise, der nach dem Speichern aufgelöst wird
         */
        saveAllChanges: function() {
            return _saveAllPendingChanges();
        },
        
        /**
         * Setzt eine Bewertung auf "Genehmigt" und speichert sie
         * @param {string} submissionId - ID der Einreichung
         * @param {string} [comment] - Optionaler Kommentar zur Genehmigung
         * @returns {Promise} - Promise, der nach der Aktualisierung aufgelöst wird
         */
        approveAssessment: function(submissionId, comment) {
            return _updateAssessmentStatus(submissionId, 'approved', comment);
        },
        
        /**
         * Setzt eine Bewertung auf "Abgelehnt" und speichert sie
         * @param {string} submissionId - ID der Einreichung
         * @param {string} [comment] - Optionaler Kommentar zur Ablehnung
         * @returns {Promise} - Promise, der nach der Aktualisierung aufgelöst wird
         */
        rejectAssessment: function(submissionId, comment) {
            return _updateAssessmentStatus(submissionId, 'rejected', comment);
        },
        
        /**
         * Setzt eine Bewertung auf "Zur Überprüfung" und speichert sie
         * @param {string} submissionId - ID der Einreichung
         * @param {string} [comment] - Optionaler Kommentar zur Überprüfung
         * @returns {Promise} - Promise, der nach der Aktualisierung aufgelöst wird
         */
        markForReview: function(submissionId, comment) {
            return _updateAssessmentStatus(submissionId, 'needsReview', comment);
        },
        
        /**
         * Lädt ein lokales Backup einer Bewertung
         * @param {string} submissionId - ID der Einreichung
         * @returns {Object|null} - Die Backup-Daten oder null, wenn kein Backup vorhanden
         */
        loadFromLocalBackup: function(submissionId) {
            return _loadFromLocalBackup(submissionId);
        },
        
        /**
         * Prüft, ob es ungespeicherte Änderungen gibt
         * @returns {boolean} - True, wenn ungespeicherte Änderungen vorhanden sind
         */
        hasUnsavedChanges: function() {
            return Object.keys(_pendingChanges).length > 0;
        },
        
        /**
         * Berechnet Punkte aus einem Bewertungsschema
         * @param {Object} rubricScores - Die Bewertungen pro Kriterium
         * @param {Object} rubric - Das verwendete Bewertungsschema
         * @param {number} maxPoints - Die maximale Punktzahl
         * @returns {number} - Die berechnete Gesamtpunktzahl
         */
        calculatePointsFromRubric: function(rubricScores, rubric, maxPoints) {
            return _calculatePointsFromRubric(rubricScores, rubric, maxPoints);
        }
    };
})();

// Modul für die Stapelverarbeitung von Bewertungen
window.ImmoLern.Assessment.Processing.Batch = (function() {
    // Private Variablen
    let _currentBatch = [];
    let _processingStatus = {
        total: 0,
        processed: 0,
        successful: 0,
        failed: 0
    };
    let _isBatchProcessing = false;
    
    // Status-Callback
    let _statusCallback = null;
    
    // Private Funktionen
    
    /**
     * Aktualisiert den Verarbeitungsstatus
     * @param {Object} update - Die Status-Updates
     */
    function _updateStatus(update) {
        // Status aktualisieren
        if (update.processed !== undefined) _processingStatus.processed = update.processed;
        if (update.successful !== undefined) _processingStatus.successful = update.successful;
        if (update.failed !== undefined) _processingStatus.failed = update.failed;
        
        // Callback aufrufen, falls vorhanden
        if (_statusCallback) {
            _statusCallback({ ..._processingStatus });
        }
    }
    
    /**
     * Verarbeitet einen Batch von Bewertungen
     * @param {Array} batch - Die zu verarbeitenden Bewertungen
     * @param {Object} options - Optionen für die Verarbeitung
     * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
     */
    function _processBatch(batch, options) {
        if (_isBatchProcessing) {
            return Promise.reject(new Error('Stapelverarbeitung läuft bereits'));
        }
        
        // Verarbeitungszustand setzen
        _isBatchProcessing = true;
        _currentBatch = batch;
        
        // Status zurücksetzen
        _processingStatus = {
            total: batch.length,
            processed: 0,
            successful: 0,
            failed: 0
        };
        
        // Status-Callback setzen, falls vorhanden
        _statusCallback = options.statusCallback || null;
        
        // UI-Feedback anzeigen
        if (options.showUI !== false) {
            window.ImmoLern.UI.showLoading('Stapelverarbeitung läuft...');
        }
        
        // Elemente nacheinander verarbeiten, um Überlastung zu vermeiden
        return _processNextItem(0, options)
            .then(() => {
                // Verarbeitung abschließen
                _isBatchProcessing = false;
                
                // UI-Feedback ausblenden
                if (options.showUI !== false) {
                    window.ImmoLern.UI.hideLoading();
                    
                    // Zusammenfassung anzeigen
                    window.ImmoLern.UI.showToast(
                        `Verarbeitung abgeschlossen: ${_processingStatus.successful} erfolgreich, ${_processingStatus.failed} fehlgeschlagen`,
                        _processingStatus.failed > 0 ? 'warning' : 'success'
                    );
                }
                
                return { ..._processingStatus };
            })
            .catch(error => {
                console.error('Fehler bei der Stapelverarbeitung:', error);
                
                // Verarbeitung abschließen
                _isBatchProcessing = false;
                
                // UI-Feedback ausblenden
                if (options.showUI !== false) {
                    window.ImmoLern.UI.hideLoading();
                    window.ImmoLern.UI.showToast('Fehler bei der Stapelverarbeitung', 'error');
                }
                
                throw error;
            });
    }
    
    /**
     * Verarbeitet das nächste Element im Batch
     * @param {number} index - Der Index des zu verarbeitenden Elements
     * @param {Object} options - Optionen für die Verarbeitung
     * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
     */
    function _processNextItem(index, options) {
        // Alle Elemente verarbeitet
        if (index >= _currentBatch.length) {
            return Promise.resolve();
        }
        
        const item = _currentBatch[index];
        let processPromise;
        
        // Element je nach Aktionstyp verarbeiten
        switch (options.actionType) {
            case 'approve':
                processPromise = window.ImmoLern.Assessment.Processing.Manual.approveAssessment(
                    item.id, 
                    options.comment || 'Automatisch genehmigt durch Stapelverarbeitung'
                );
                break;
                
            case 'reject':
                processPromise = window.ImmoLern.Assessment.Processing.Manual.rejectAssessment(
                    item.id,
                    options.comment || 'Automatisch abgelehnt durch Stapelverarbeitung'
                );
                break;
                
            case 'markReview':
                processPromise = window.ImmoLern.Assessment.Processing.Manual.markForReview(
                    item.id,
                    options.comment || 'Zur Überprüfung markiert durch Stapelverarbeitung'
                );
                break;
                
            default:
                // Unbekannte Aktion
                processPromise = Promise.reject(new Error('Unbekannte Stapelverarbeitungsaktion'));
        }
        
        // Element verarbeiten und zum nächsten übergehen
        return processPromise
            .then(() => {
                // Erfolgreiche Verarbeitung
                _updateStatus({
                    processed: index + 1,
                    successful: _processingStatus.successful + 1
                });
                
                // Fortschritt aktualisieren
                if (options.progressCallback) {
                    options.progressCallback(index + 1, _currentBatch.length);
                }
                
                // Pause zwischen Verarbeitungen, um UI-Updates zu ermöglichen
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(_processNextItem(index + 1, options));
                    }, options.delay || 100);
                });
            })
            .catch(error => {
                console.error(`Fehler bei der Verarbeitung von Element ${index}:`, error);
                
                // Fehlgeschlagene Verarbeitung
                _updateStatus({
                    processed: index + 1,
                    failed: _processingStatus.failed + 1
                });
                
                // Fortschritt aktualisieren
                if (options.progressCallback) {
                    options.progressCallback(index + 1, _currentBatch.length, error);
                }
                
                // Zum nächsten Element übergehen, auch bei Fehler
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(_processNextItem(index + 1, options));
                    }, options.delay || 100);
                });
            });
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Genehmigt mehrere Bewertungen in einem Batch
         * @param {Array} items - Die zu genehmigenden Elemente
         * @param {Object} options - Optionen für die Verarbeitung
         * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
         */
        approveBatch: function(items, options = {}) {
            return _processBatch(items, {
                ...options,
                actionType: 'approve'
            });
        },
        
        /**
         * Lehnt mehrere Bewertungen in einem Batch ab
         * @param {Array} items - Die abzulehnenden Elemente
         * @param {Object} options - Optionen für die Verarbeitung
         * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
         */
        rejectBatch: function(items, options = {}) {
            return _processBatch(items, {
                ...options,
                actionType: 'reject'
            });
        },
        
        /**
         * Markiert mehrere Bewertungen zur Überprüfung
         * @param {Array} items - Die zu markierenden Elemente
         * @param {Object} options - Optionen für die Verarbeitung
         * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
         */
        markBatchForReview: function(items, options = {}) {
            return _processBatch(items, {
                ...options,
                actionType: 'markReview'
            });
        },
        
        /**
         * Prüft, ob gerade eine Stapelverarbeitung läuft
         * @returns {boolean} - True, wenn eine Stapelverarbeitung läuft
         */
        isProcessing: function() {
            return _isBatchProcessing;
        },
        
        /**
         * Gibt den aktuellen Verarbeitungsstatus zurück
         * @returns {Object} - Der Verarbeitungsstatus
         */
        getProcessingStatus: function() {
            return { ..._processingStatus };
        }
    };
})();

// Modul initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    window.ImmoLern.Assessment.Processing.Manual.init();
    
    // Event-Listener für das manuelle Speichern
    const saveButton = document.getElementById('saveAssessmentBtn');
    if (saveButton) {
        saveButton.addEventListener('click', () => {
            // Bewertungsdaten aus dem Formular extrahieren
            const form = document.getElementById('assessmentForm');
            if (!form) return;
            
            // Formulardaten sammeln
            const formData = {
                submissionId: form.getAttribute('data-submission-id'),
                questionId: form.getAttribute('data-question-id'),
                userId: form.getAttribute('data-user-id'),
                testId: form.getAttribute('data-test-id'),
                points: parseFloat(document.getElementById('assessmentPoints').value),
                maxPoints: parseFloat(form.getAttribute('data-max-points')),
                feedback: document.getElementById('assessmentFeedback').value,
                status: document.getElementById('assessmentStatus').value
            };
            
            // Bewertungsschema-Daten hinzufügen, falls vorhanden
            const rubricForm = document.getElementById('rubricForm');
            if (rubricForm) {
                formData.rubricId = rubricForm.getAttribute('data-rubric-id');
                formData.rubricScores = {};
                
                // Alle Kriterienbewertungen sammeln
                const criteriaInputs = rubricForm.querySelectorAll('[data-criterion-id]');
                criteriaInputs.forEach(input => {
                    const criterionId = input.getAttribute('data-criterion-id');
                    const levelId = input.value;
                    const level = Array.from(input.options).find(opt => opt.value === levelId);
                    
                    if (criterionId && levelId && level) {
                        formData.rubricScores[criterionId] = {
                            levelId: levelId,
                            points: parseFloat(level.getAttribute('data-points')),
                            maxPoints: parseFloat(input.getAttribute('data-max-points'))
                        };
                    }
                });
            }
            
            // Annotationen hinzufügen, falls vorhanden
            const annotations = window.ImmoLern.Assessment.Interface.Advanced.getAnnotations();
            if (annotations && annotations.length > 0) {
                formData.annotations = annotations;
            }
            
            // Sofort speichern
            window.ImmoLern.Assessment.Processing.Manual.saveAssessment(formData, true)
                .then(() => {
                    console.log('Bewertung manuell gespeichert');
                })
                .catch(error => {
                    console.error('Fehler beim manuellen Speichern:', error);
                });
        });
    }
});

// Warnung anzeigen, wenn der Benutzer die Seite mit ungespeicherten Änderungen verlassen möchte
window.addEventListener('beforeunload', (event) => {
    if (window.ImmoLern.Assessment.Processing.Manual.hasUnsavedChanges()) {
        // Standard-Abfrage für ungespeicherte Änderungen
        const message = 'Es gibt ungespeicherte Änderungen. Möchten Sie die Seite wirklich verlassen?';
        event.returnValue = message;
        return message;
    }
});

// Benutzerdefiniertes Ereignis auslösen, wenn das Modul geladen ist
document.dispatchEvent(new CustomEvent('assessmentProcessingLoaded'));
/**
 * JS-Block 6.2.2-part2: Speichern und Verarbeiten (Teil 2)
 * 
 * Erweiterte Funktionen zur Bewertungsdatenverarbeitung:
 * - Datenintegration mit anderen Systemkomponenten
 * - Synchronisierung mehrerer Bewerter
 * - Daten-Export und Berichterstellung
 * - Analytics und Statistikfunktionen
 * - Backup und Archivierungsmechanismen
 */

// Namespace für die erweiterte Bewertungsdatenverarbeitung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Processing) window.ImmoLern.Assessment.Processing = {};
if (!window.ImmoLern.Assessment.Analytics) window.ImmoLern.Assessment.Analytics = {};

// Modul für die Datenintegration und erweiterte Verarbeitung
window.ImmoLern.Assessment.Processing.Integration = (function() {
    // Private Variablen
    let _integratedModules = [];
    let _dataChangeListeners = [];
    let _exportFormats = ['json', 'csv', 'pdf'];
    let _archiveSettings = {
        autoArchive: true,
        archiveAfterDays: 90,
        includeRawData: true
    };
    
    // Event-Bus für die Kommunikation zwischen Modulen
    const _eventBus = new EventTarget();
    
    // Private Funktionen
    
    /**
     * Benachrichtigt alle registrierten Listener über Datenänderungen
     * @param {string} changeType - Art der Änderung
     * @param {Object} data - Die geänderten Daten
     */
    function _notifyDataChangeListeners(changeType, data) {
        _dataChangeListeners.forEach(listener => {
            try {
                if (listener.type === 'all' || listener.type === changeType) {
                    listener.callback(changeType, data);
                }
            } catch (error) {
                console.error('Fehler bei der Benachrichtigung eines Listeners:', error);
            }
        });
        
        // Ereignis im Event-Bus auslösen
        _eventBus.dispatchEvent(new CustomEvent('dataChange', {
            detail: {
                type: changeType,
                data: data
            }
        }));
    }
    
    /**
     * Erstellt einen Assessment-Datensatz für den Export
     * @param {string} assessmentId - ID der Bewertung
     * @returns {Promise<Object>} - Exportierbarer Datensatz
     */
    function _createExportRecord(assessmentId) {
        // Bewertungsdaten laden
        return window.ImmoLern.Assessment.Data.getAssessment(assessmentId)
            .then(assessmentData => {
                if (!assessmentData) {
                    throw new Error('Bewertung nicht gefunden');
                }
                
                // Zusatzdaten laden (Frage, Test, Benutzer, etc.)
                return Promise.all([
                    window.ImmoLern.Tests.getQuestionById(assessmentData.questionId),
                    window.ImmoLern.Tests.getTestById(assessmentData.testId),
                    window.ImmoLern.Users.getUserById(assessmentData.userId),
                    window.ImmoLern.Users.getUserById(assessmentData.assessorId)
                ]).then(([question, test, user, assessor]) => {
                    // Exportdatensatz erstellen
                    return {
                        assessment: {
                            id: assessmentData.submissionId,
                            points: assessmentData.points,
                            maxPoints: assessmentData.maxPoints,
                            percentageScore: Math.round((assessmentData.points / assessmentData.maxPoints) * 100),
                            status: assessmentData.status,
                            feedback: assessmentData.feedback,
                            createdAt: assessmentData.timestamp,
                            revision: assessmentData.revision
                        },
                        question: question ? {
                            id: question.id,
                            text: question.text,
                            type: question.type,
                            category: question.category
                        } : null,
                        test: test ? {
                            id: test.id,
                            title: test.title,
                            description: test.description
                        } : null,
                        user: user ? {
                            id: user.id,
                            name: user.name,
                            team: user.team
                        } : null,
                        assessor: assessor ? {
                            id: assessor.id,
                            name: assessor.name
                        } : null
                    };
                });
            });
    }
    
    /**
     * Verarbeitet einen Bewertungsdatensatz zur Integration mit anderen Modulen
     * @param {Object} assessment - Der Bewertungsdatensatz
     * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
     */
    function _processAssessmentForIntegration(assessment) {
        if (!assessment) return Promise.resolve();
        
        // Integration mit allen registrierten Modulen
        const integrationPromises = _integratedModules.map(module => {
            try {
                // Module mit einer process-Methode können Daten verarbeiten
                if (typeof module.process === 'function') {
                    return module.process(assessment);
                }
            } catch (error) {
                console.error(`Fehler bei der Integration mit Modul ${module.name}:`, error);
            }
            return Promise.resolve();
        });
        
        return Promise.all(integrationPromises);
    }
    
    /**
     * Erstellt eine CSV-Datei aus Bewertungsdaten
     * @param {Array} assessments - Liste von Bewertungsdatensätzen
     * @returns {string} - CSV-Inhalt
     */
    function _createCSV(assessments) {
        if (!assessments || assessments.length === 0) {
            return '';
        }
        
        // Spaltenüberschriften erstellen
        const headers = [
            'ID', 'Benutzer', 'Test', 'Frage', 'Punkte', 'Max. Punkte', 
            'Prozent', 'Status', 'Bewerter', 'Datum', 'Feedback'
        ];
        
        // CSV-Zeilen erstellen
        const rows = assessments.map(record => {
            const assessment = record.assessment;
            const user = record.user || {};
            const test = record.test || {};
            const question = record.question || {};
            const assessor = record.assessor || {};
            
            // Zeileneinträge (in der gleichen Reihenfolge wie die Überschriften)
            return [
                assessment.id,
                user.name || 'Unbekannt',
                test.title || 'Unbekannt',
                question.text ? question.text.substring(0, 50) + (question.text.length > 50 ? '...' : '') : 'Unbekannt',
                assessment.points,
                assessment.maxPoints,
                assessment.percentageScore,
                assessment.status,
                assessor.name || 'Unbekannt',
                new Date(assessment.createdAt).toLocaleString(),
                assessment.feedback ? assessment.feedback.substring(0, 100) + (assessment.feedback.length > 100 ? '...' : '') : ''
            ];
        });
        
        // CSV erstellen
        let csv = headers.join(',') + '\n';
        
        rows.forEach(row => {
            // Werte für CSV formatieren (Anführungszeichen für Texte mit Kommas oder Zeilenumbrüchen)
            const formattedRow = row.map(value => {
                if (typeof value === 'string' && (value.includes(',') || value.includes('\n') || value.includes('"'))) {
                    // Anführungszeichen verdoppeln und Wert in Anführungszeichen setzen
                    return '"' + value.replace(/"/g, '""') + '"';
                }
                return value;
            });
            
            csv += formattedRow.join(',') + '\n';
        });
        
        return csv;
    }
    
    /**
     * Erstellt ein JSON-Dokument aus Bewertungsdaten
     * @param {Array} assessments - Liste von Bewertungsdatensätzen
     * @returns {string} - JSON-Inhalt
     */
    function _createJSON(assessments) {
        return JSON.stringify(assessments, null, 2);
    }
    
    /**
     * Erstellt ein PDF-Dokument aus Bewertungsdaten (Platzhalter)
     * @param {Array} assessments - Liste von Bewertungsdatensätzen
     * @returns {Promise<Blob>} - Promise mit dem PDF-Blob
     */
    function _createPDF(assessments) {
        // Hinweis: In dieser Browser-Umgebung verwenden wir einen Platzhalter
        // In der realen Implementierung würde hier eine PDF-Bibliothek genutzt werden
        
        // HTML für das PDF erstellen
        let html = `
            <html>
            <head>
                <title>Bewertungsbericht</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    h1 { color: #00FFD0; }
                    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    .header { display: flex; justify-content: space-between; align-items: center; }
                    .logo { height: 50px; }
                    .summary { margin: 20px 0; padding: 15px; background-color: #f9f9f9; border-radius: 5px; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>ImmoScout24 E-Learning - Bewertungsbericht</h1>
                    <img class="logo" src="data:image/png;base64,..." alt="Logo">
                </div>
                
                <div class="summary">
                    <h2>Zusammenfassung</h2>
                    <p>Anzahl der Bewertungen: ${assessments.length}</p>
                    <p>Erstellungsdatum: ${new Date().toLocaleDateString()}</p>
                    <p>Erstellt von: ${window.ImmoLern.Auth.getCurrentUser().name}</p>
                </div>
                
                <h2>Bewertungsdetails</h2>
                <table>
                    <tr>
                        <th>ID</th>
                        <th>Benutzer</th>
                        <th>Test</th>
                        <th>Punkte</th>
                        <th>Prozent</th>
                        <th>Status</th>
                        <th>Bewerter</th>
                        <th>Datum</th>
                    </tr>
        `;
        
        // Tabellenzeilen für jede Bewertung
        assessments.forEach(record => {
            const assessment = record.assessment;
            const user = record.user || {};
            const test = record.test || {};
            const assessor = record.assessor || {};
            
            html += `
                <tr>
                    <td>${assessment.id}</td>
                    <td>${user.name || 'Unbekannt'}</td>
                    <td>${test.title || 'Unbekannt'}</td>
                    <td>${assessment.points} / ${assessment.maxPoints}</td>
                    <td>${assessment.percentageScore}%</td>
                    <td>${assessment.status}</td>
                    <td>${assessor.name || 'Unbekannt'}</td>
                    <td>${new Date(assessment.createdAt).toLocaleString()}</td>
                </tr>
            `;
        });
        
        html += `
                </table>
            </body>
            </html>
        `;
        
        // PDF erstellungsmethode als String zurückgeben
        return Promise.resolve(html);
    }
    
    /**
     * Archiviert einen Bewertungsdatensatz
     * @param {string} assessmentId - ID der Bewertung
     * @returns {Promise} - Promise, der nach der Archivierung aufgelöst wird
     */
    function _archiveAssessment(assessmentId) {
        // Bewertungsdaten für die Archivierung laden
        return _createExportRecord(assessmentId)
            .then(exportRecord => {
                // Archivierungszeitstempel hinzufügen
                const archiveData = {
                    ...exportRecord,
                    archiveMetadata: {
                        archivedAt: new Date().toISOString(),
                        archivedBy: window.ImmoLern.Auth.getCurrentUser().id,
                        archiveReason: 'Automatische Archivierung',
                        archiveVersion: '1.0'
                    }
                };
                
                // Rohdaten hinzufügen, falls konfiguriert
                if (_archiveSettings.includeRawData) {
                    return window.ImmoLern.Assessment.Data.getAssessmentRawData(assessmentId)
                        .then(rawData => {
                            archiveData.rawData = rawData;
                            return window.ImmoLern.Assessment.Data.archiveAssessment(archiveData);
                        });
                } else {
                    return window.ImmoLern.Assessment.Data.archiveAssessment(archiveData);
                }
            });
    }
    
    /**
     * Prüft, ob eine Bewertung archiviert werden sollte
     * @param {Object} assessment - Die Bewertungsdaten
     * @returns {boolean} - True, wenn die Bewertung archiviert werden sollte
     */
    function _shouldArchive(assessment) {
        if (!assessment || !assessment.timestamp || !_archiveSettings.autoArchive) {
            return false;
        }
        
        // Prüfen, ob die Bewertung das Archivierungsalter erreicht hat
        const assessmentDate = new Date(assessment.timestamp);
        const archiveThreshold = _archiveSettings.archiveAfterDays * 24 * 60 * 60 * 1000; // in Millisekunden
        const now = new Date();
        
        return (now - assessmentDate) > archiveThreshold;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Archivierungseinstellungen überschreiben, falls vorhanden
            if (options.archiveSettings) {
                _archiveSettings = {
                    ..._archiveSettings,
                    ...options.archiveSettings
                };
            }
            
            // Event-Listener für Änderungen an Bewertungen hinzufügen
            document.addEventListener('assessmentProcessingLoaded', () => {
                window.ImmoLern.Assessment.Processing.Manual.addEventListener('assessmentSaved', (event) => {
                    _notifyDataChangeListeners('update', event.detail);
                    _processAssessmentForIntegration(event.detail.result);
                });
            });
            
            // Event-Listener für die automatische Archivierung
            if (_archiveSettings.autoArchive) {
                // Regelmäßige Prüfung auf zu archivierende Bewertungen
                setInterval(() => {
                    this.checkForArchivableAssessments();
                }, 24 * 60 * 60 * 1000); // Einmal pro Tag
            }
            
            return this;
        },
        
        /**
         * Registriert ein Modul für die Integration
         * @param {Object} module - Das zu integrierende Modul
         */
        registerModule: function(module) {
            if (!module || !module.name) {
                console.error('Ungültiges Modul für die Integration');
                return this;
            }
            
            // Prüfen, ob das Modul bereits registriert ist
            const existingModule = _integratedModules.find(m => m.name === module.name);
            if (existingModule) {
                console.warn(`Modul ${module.name} ist bereits registriert`);
                return this;
            }
            
            // Modul registrieren
            _integratedModules.push(module);
            console.log(`Modul ${module.name} für die Integration registriert`);
            
            return this;
        },
        
        /**
         * Fügt einen Listener für Datenänderungen hinzu
         * @param {string} changeType - Art der Änderung ('all', 'create', 'update', 'delete')
         * @param {Function} callback - Callback-Funktion
         */
        addDataChangeListener: function(changeType, callback) {
            if (typeof callback !== 'function') {
                console.error('Callback muss eine Funktion sein');
                return this;
            }
            
            _dataChangeListeners.push({
                type: changeType || 'all',
                callback: callback
            });
            
            return this;
        },
        
        /**
         * Entfernt einen Listener für Datenänderungen
         * @param {Function} callback - Die zu entfernende Callback-Funktion
         */
        removeDataChangeListener: function(callback) {
            _dataChangeListeners = _dataChangeListeners.filter(listener => listener.callback !== callback);
            return this;
        },
        
        /**
         * Prüft, ob es Bewertungen gibt, die archiviert werden sollten
         */
        checkForArchivableAssessments: function() {
            // Bewertungen abrufen, die für die Archivierung in Frage kommen
            window.ImmoLern.Assessment.Data.getCompletedAssessments()
                .then(assessments => {
                    // Bewertungen filtern, die archiviert werden sollten
                    const toArchive = assessments.filter(_shouldArchive);
                    
                    if (toArchive.length === 0) {
                        console.log('Keine Bewertungen zur Archivierung gefunden');
                        return;
                    }
                    
                    console.log(`${toArchive.length} Bewertungen zur Archivierung gefunden`);
                    
                    // Bewertungen archivieren
                    toArchive.forEach(assessment => {
                        _archiveAssessment(assessment.submissionId)
                            .then(() => {
                                console.log(`Bewertung ${assessment.submissionId} erfolgreich archiviert`);
                            })
                            .catch(error => {
                                console.error(`Fehler bei der Archivierung von Bewertung ${assessment.submissionId}:`, error);
                            });
                    });
                })
                .catch(error => {
                    console.error('Fehler bei der Suche nach archivierbaren Bewertungen:', error);
                });
        },
        
        /**
         * Exportiert Bewertungsdaten in verschiedenen Formaten
         * @param {Array} assessmentIds - Liste von Bewertungs-IDs
         * @param {string} format - Exportformat ('json', 'csv', 'pdf')
         * @returns {Promise<Object>} - Promise mit den exportierten Daten
         */
        exportAssessments: function(assessmentIds, format = 'json') {
            if (!assessmentIds || assessmentIds.length === 0) {
                return Promise.reject(new Error('Keine Bewertungen für den Export angegeben'));
            }
            
            // Format validieren
            if (!_exportFormats.includes(format)) {
                return Promise.reject(new Error(`Ungültiges Format: ${format}`));
            }
            
            // Export-Records für alle Bewertungen erstellen
            const exportPromises = assessmentIds.map(_createExportRecord);
            
            return Promise.all(exportPromises)
                .then(exportRecords => {
                    // Daten je nach Format konvertieren
                    switch (format) {
                        case 'csv':
                            return {
                                data: _createCSV(exportRecords),
                                filename: `bewertungen_export_${new Date().toISOString().slice(0, 10)}.csv`,
                                mimeType: 'text/csv'
                            };
                            
                        case 'pdf':
                            return _createPDF(exportRecords).then(pdfData => {
                                return {
                                    data: pdfData,
                                    filename: `bewertungen_export_${new Date().toISOString().slice(0, 10)}.html`, // Platzhalter, wäre in der realen Implementierung .pdf
                                    mimeType: 'text/html' // Platzhalter, wäre in der realen Implementierung application/pdf
                                };
                            });
                            
                        case 'json':
                        default:
                            return {
                                data: _createJSON(exportRecords),
                                filename: `bewertungen_export_${new Date().toISOString().slice(0, 10)}.json`,
                                mimeType: 'application/json'
                            };
                    }
                });
        },
        
        /**
         * Gibt den Event-Bus für die Kommunikation zwischen Modulen zurück
         * @returns {EventTarget} - Der Event-Bus
         */
        getEventBus: function() {
            return _eventBus;
        },
        
        /**
         * Manuell eine Bewertung archivieren
         * @param {string} assessmentId - ID der Bewertung
         * @returns {Promise} - Promise, der nach der Archivierung aufgelöst wird
         */
        archiveAssessment: function(assessmentId) {
            return _archiveAssessment(assessmentId);
        }
    };
})();

// Modul für Bewertungsanalysen und Statistiken
window.ImmoLern.Assessment.Analytics = (function() {
    // Private Variablen
    let _cachedAnalytics = {};
    let _cacheTimeout = 30 * 60 * 1000; // 30 Minuten
    let _lastCacheUpdate = {};
    
    // Private Funktionen
    
    /**
     * Berechnet statistische Werte für eine Zahlenreihe
     * @param {Array<number>} values - Die zu analysierenden Werte
     * @returns {Object} - Statistische Kennzahlen
     */
    function _calculateStats(values) {
        if (!values || values.length === 0) {
            return {
                count: 0,
                min: null,
                max: null,
                sum: 0,
                average: 0,
                median: 0,
                variance: 0,
                standardDeviation: 0
            };
        }
        
        // Sortierte Kopie der Werte für Median und Perzentile
        const sortedValues = [...values].sort((a, b) => a - b);
        
        // Grundlegende Statistiken
        const count = values.length;
        const min = sortedValues[0];
        const max = sortedValues[count - 1];
        const sum = values.reduce((a, b) => a + b, 0);
        const average = sum / count;
        
        // Median berechnen
        let median;
        if (count % 2 === 0) {
            // Gerade Anzahl: Durchschnitt der beiden mittleren Werte
            const mid1 = sortedValues[count / 2 - 1];
            const mid2 = sortedValues[count / 2];
            median = (mid1 + mid2) / 2;
        } else {
            // Ungerade Anzahl: Mittlerer Wert
            median = sortedValues[Math.floor(count / 2)];
        }
        
        // Varianz und Standardabweichung berechnen
        const variance = values.reduce((acc, val) => acc + Math.pow(val - average, 2), 0) / count;
        const standardDeviation = Math.sqrt(variance);
        
        // Perzentile berechnen
        const percentile25 = sortedValues[Math.floor(count * 0.25)];
        const percentile75 = sortedValues[Math.floor(count * 0.75)];
        
        return {
            count,
            min,
            max,
            sum,
            average,
            median,
            variance,
            standardDeviation,
            percentile25,
            percentile75
        };
    }
    
    /**
     * Gruppiert Bewertungen nach einem Kriterium
     * @param {Array} assessments - Die zu gruppierenden Bewertungen
     * @param {string} groupBy - Das Gruppierungskriterium
     * @returns {Object} - Gruppierte Bewertungen
     */
    function _groupAssessments(assessments, groupBy) {
        const groups = {};
        
        assessments.forEach(assessment => {
            let groupKey;
            
            // Gruppierungswert ermitteln
            switch (groupBy) {
                case 'status':
                    groupKey = assessment.status || 'unbekannt';
                    break;
                    
                case 'date':
                    const date = new Date(assessment.timestamp);
                    groupKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                    break;
                    
                case 'week':
                    const date2 = new Date(assessment.timestamp);
                    const startOfYear = new Date(date2.getFullYear(), 0, 1);
                    const days = Math.floor((date2 - startOfYear) / (24 * 60 * 60 * 1000));
                    const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);
                    groupKey = `${date2.getFullYear()}-W${String(weekNumber).padStart(2, '0')}`;
                    break;
                    
                case 'month':
                    const date3 = new Date(assessment.timestamp);
                    groupKey = `${date3.getFullYear()}-${String(date3.getMonth() + 1).padStart(2, '0')}`;
                    break;
                    
                case 'assessor':
                    groupKey = assessment.assessorId || 'unbekannt';
                    break;
                    
                case 'user':
                    groupKey = assessment.userId || 'unbekannt';
                    break;
                    
                case 'test':
                    groupKey = assessment.testId || 'unbekannt';
                    break;
                    
                default:
                    groupKey = 'all';
            }
            
            // Gruppe erstellen, falls noch nicht vorhanden
            if (!groups[groupKey]) {
                groups[groupKey] = [];
            }
            
            // Bewertung zur Gruppe hinzufügen
            groups[groupKey].push(assessment);
        });
        
        return groups;
    }
    
    /**
     * Berechnet Statistiken für gruppierte Bewertungen
     * @param {Object} groupedAssessments - Gruppierte Bewertungen
     * @returns {Object} - Statistiken pro Gruppe
     */
    function _calculateGroupStats(groupedAssessments) {
        const stats = {};
        
        Object.keys(groupedAssessments).forEach(groupKey => {
            const assessments = groupedAssessments[groupKey];
            
            // Punktzahlen und Prozentsätze extrahieren
            const points = assessments.map(a => a.points);
            const percentages = assessments.map(a => {
                if (a.maxPoints && a.maxPoints > 0) {
                    return (a.points / a.maxPoints) * 100;
                }
                return 0;
            });
            
            // Statusverteilung berechnen
            const statusCounts = {};
            assessments.forEach(a => {
                const status = a.status || 'unbekannt';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });
            
            // Statistiken für diese Gruppe
            stats[groupKey] = {
                count: assessments.length,
                pointStats: _calculateStats(points),
                percentageStats: _calculateStats(percentages),
                statusDistribution: statusCounts,
                averageProcessingTime: _calculateAverageProcessingTime(assessments)
            };
        });
        
        return stats;
    }
    
    /**
     * Berechnet die durchschnittliche Bearbeitungszeit für Bewertungen
     * @param {Array} assessments - Die zu analysierenden Bewertungen
     * @returns {number} - Durchschnittliche Bearbeitungszeit in Millisekunden
     */
    function _calculateAverageProcessingTime(assessments) {
        // Nur Bewertungen mit Start- und Endzeit berücksichtigen
        const assessmentsWithTimes = assessments.filter(a => a.startTime && a.timestamp);
        
        if (assessmentsWithTimes.length === 0) {
            return 0;
        }
        
        // Bearbeitungszeiten berechnen
        const processingTimes = assessmentsWithTimes.map(a => {
            const start = new Date(a.startTime);
            const end = new Date(a.timestamp);
            return end - start;
        });
        
        // Durchschnitt berechnen
        return processingTimes.reduce((sum, time) => sum + time, 0) / processingTimes.length;
    }
    
    /**
     * Identifiziert Ausreißer in den Bewertungen
     * @param {Array} assessments - Die zu analysierenden Bewertungen
     * @returns {Array} - Identifizierte Ausreißer
     */
    function _identifyOutliers(assessments) {
        if (!assessments || assessments.length < 5) {
            return []; // Zu wenige Daten für eine sinnvolle Ausreißererkennung
        }
        
        // Prozentsätze berechnen
        const percentages = assessments.map(a => {
            if (a.maxPoints && a.maxPoints > 0) {
                return (a.points / a.maxPoints) * 100;
            }
            return 0;
        });
        
        // Statistiken berechnen
        const stats = _calculateStats(percentages);
        
        // Interquartilsabstand (IQR) berechnen
        const iqr = stats.percentile75 - stats.percentile25;
        
        // Grenzen für Ausreißer (1,5 * IQR unter Q1 oder über Q3)
        const lowerBound = stats.percentile25 - 1.5 * iqr;
        const upperBound = stats.percentile75 + 1.5 * iqr;
        
        // Ausreißer identifizieren
        const outliers = [];
        
        assessments.forEach((assessment, index) => {
            const percentage = percentages[index];
            
            if (percentage < lowerBound || percentage > upperBound) {
                outliers.push({
                    assessment: assessment,
                    percentage: percentage,
                    isLow: percentage < lowerBound,
                    isHigh: percentage > upperBound,
                    deviation: percentage < lowerBound ? 
                        Math.abs(percentage - lowerBound) : 
                        Math.abs(percentage - upperBound)
                });
            }
        });
        
        // Nach Abweichungsstärke sortieren
        return outliers.sort((a, b) => b.deviation - a.deviation);
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Berechnet Statistiken für einen Satz von Bewertungen
         * @param {Array} assessments - Die zu analysierenden Bewertungen
         * @param {Object} options - Analyseoptionen
         * @returns {Object} - Die berechneten Statistiken
         */
        calculateStatistics: function(assessments, options = {}) {
            if (!assessments || assessments.length === 0) {
                return {
                    count: 0,
                    pointStats: _calculateStats([]),
                    percentageStats: _calculateStats([]),
                    statusDistribution: {},
                    processingTime: 0
                };
            }
            
            // Punktzahlen und Prozentsätze extrahieren
            const points = assessments.map(a => a.points);
            const percentages = assessments.map(a => {
                if (a.maxPoints && a.maxPoints > 0) {
                    return (a.points / a.maxPoints) * 100;
                }
                return 0;
            });
            
            // Statusverteilung berechnen
            const statusCounts = {};
            assessments.forEach(a => {
                const status = a.status || 'unbekannt';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });
            
            // Zeitliche Analyse
            let timeTrend = null;
            if (options.includeTimeTrend && assessments.length >= 5) {
                timeTrend = this.analyzeTimeTrend(assessments);
            }
            
            // Ausreißer identifizieren
            let outliers = null;
            if (options.includeOutliers) {
                outliers = _identifyOutliers(assessments);
            }
            
            // Statistiken zurückgeben
            return {
                count: assessments.length,
                pointStats: _calculateStats(points),
                percentageStats: _calculateStats(percentages),
                statusDistribution: statusCounts,
                processingTime: _calculateAverageProcessingTime(assessments),
                timeTrend: timeTrend,
                outliers: outliers
            };
        },
        
        /**
         * Analysiert Bewertungen nach Gruppen
         * @param {Array} assessments - Die zu analysierenden Bewertungen
         * @param {string} groupBy - Das Gruppierungskriterium
         * @returns {Object} - Gruppierte Statistiken
         */
        analyzeByGroups: function(assessments, groupBy = 'status') {
            if (!assessments || assessments.length === 0) {
                return {
                    overall: this.calculateStatistics([]),
                    groups: {}
                };
            }
            
            // Cache-Key erstellen
            const cacheKey = `group_${groupBy}_${assessments.length}`;
            
            // Aus Cache laden, falls vorhanden und nicht zu alt
            const now = Date.now();
            if (_cachedAnalytics[cacheKey] && _lastCacheUpdate[cacheKey] && 
                (now - _lastCacheUpdate[cacheKey]) < _cacheTimeout) {
                return _cachedAnalytics[cacheKey];
            }
            
            // Bewertungen gruppieren
            const groupedAssessments = _groupAssessments(assessments, groupBy);
            
            // Statistiken pro Gruppe berechnen
            const groupStats = _calculateGroupStats(groupedAssessments);
            
            // Gesamtstatistiken berechnen
            const overallStats = this.calculateStatistics(assessments);
            
            // Ergebnis erstellen
            const result = {
                overall: overallStats,
                groups: groupStats
            };
            
            // Im Cache speichern
            _cachedAnalytics[cacheKey] = result;
            _lastCacheUpdate[cacheKey] = now;
            
            return result;
        },
        
        /**
         * Analysiert den zeitlichen Trend von Bewertungen
         * @param {Array} assessments - Die zu analysierenden Bewertungen
         * @returns {Object} - Trendanalyse
         */
        analyzeTimeTrend: function(assessments) {
            if (!assessments || assessments.length < 5) {
                return {
                    trend: 'insufficient_data',
                    slope: 0,
                    significance: 0
                };
            }
            
            // Nach Datum sortieren
            const sortedAssessments = [...assessments].sort((a, b) => {
                return new Date(a.timestamp) - new Date(b.timestamp);
            });
            
            // Bewertungen in chronologische Gruppen unterteilen (z.B. Wochen)
            const weekGroups = _groupAssessments(sortedAssessments, 'week');
            
            // Durchschnittliche Prozentwerte pro Woche berechnen
            const weeklyAverages = [];
            
            Object.keys(weekGroups).sort().forEach(week => {
                const weekAssessments = weekGroups[week];
                const percentages = weekAssessments.map(a => 
                    (a.points / (a.maxPoints || 1)) * 100
                );
                
                const average = percentages.reduce((sum, p) => sum + p, 0) / percentages.length;
                
                weeklyAverages.push({
                    week: week,
                    average: average,
                    count: weekAssessments.length
                });
            });
            
            // Lineare Regression für den Trend berechnen
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumXX = 0;
            let n = weeklyAverages.length;
            
            weeklyAverages.forEach((week, index) => {
                sumX += index;
                sumY += week.average;
                sumXY += index * week.average;
                sumXX += index * index;
            });
            
            // Steigung und y-Achsenabschnitt berechnen
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Signifikanz des Trends bestimmen (vereinfacht)
            const absSlope = Math.abs(slope);
            let significance = 0;
            
            if (absSlope >= 5) {
                significance = 3; // Stark
            } else if (absSlope >= 2) {
                significance = 2; // Mittel
            } else if (absSlope >= 0.5) {
                significance = 1; // Schwach
            }
            
            // Trendrichtung bestimmen
            let trend;
            if (absSlope < 0.5) {
                trend = 'stable';
            } else if (slope > 0) {
                trend = 'improving';
            } else {
                trend = 'declining';
            }
            
            return {
                trend: trend,
                slope: slope,
                intercept: intercept,
                significance: significance,
                weeklyData: weeklyAverages
            };
        },
        
        /**
         * Vergleicht verschiedene Gruppen von Bewertungen
         * @param {Object} groupsData - Daten der zu vergleichenden Gruppen
         * @returns {Object} - Vergleichsergebnisse
         */
        compareGroups: function(groupsData) {
            const results = {
                differences: {},
                rankings: {},
                significantFindings: []
            };
            
            if (!groupsData || Object.keys(groupsData).length < 2) {
                return results;
            }
            
            // Vergleichsmetriken definieren
            const metrics = [
                { name: 'averageScore', path: 'percentageStats.average', label: 'Durchschnittliche Bewertung' },
                { name: 'medianScore', path: 'percentageStats.median', label: 'Median der Bewertungen' },
                { name: 'processingTime', path: 'processingTime', label: 'Bearbeitungszeit' },
                { name: 'approvalRate', calculate: (stats) => {
                    const approved = stats.statusDistribution.approved || 0;
                    return (approved / stats.count) * 100;
                }, label: 'Genehmigungsrate' }
            ];
            
            // Daten für jede Metrik extrahieren
            metrics.forEach(metric => {
                const metricData = {};
                
                // Daten für alle Gruppen extrahieren
                Object.keys(groupsData).forEach(groupKey => {
                    const groupStats = groupsData[groupKey];
                    
                    // Wert je nach Definition extrahieren
                    let value;
                    if (metric.calculate) {
                        value = metric.calculate(groupStats);
                    } else if (metric.path) {
                        // Path traversieren (z.B. 'percentageStats.average')
                        value = metric.path.split('.').reduce((obj, key) => 
                            (obj && obj[key] !== undefined) ? obj[key] : null, groupStats);
                    }
                    
                    metricData[groupKey] = value;
                });
                
                // Unterschiede zwischen Gruppen berechnen
                results.differences[metric.name] = {};
                const groups = Object.keys(metricData);
                
                for (let i = 0; i < groups.length; i++) {
                    for (let j = i + 1; j < groups.length; j++) {
                        const group1 = groups[i];
                        const group2 = groups[j];
                        const value1 = metricData[group1];
                        const value2 = metricData[group2];
                        
                        if (value1 !== null && value2 !== null) {
                            const difference = value1 - value2;
                            const percentDifference = ((difference / Math.abs(value2)) * 100);
                            
                            const comparisonKey = `${group1}_vs_${group2}`;
                            results.differences[metric.name][comparisonKey] = {
                                absoluteDifference: difference,
                                percentDifference: percentDifference,
                                group1Value: value1,
                                group2Value: value2
                            };
                            
                            // Signifikante Unterschiede identifizieren (mehr als 20%)
                            if (Math.abs(percentDifference) >= 20) {
                                results.significantFindings.push({
                                    metric: metric.label,
                                    comparison: `${group1} vs ${group2}`,
                                    difference: percentDifference.toFixed(1) + '%',
                                    message: `${group1} ist ${percentDifference > 0 ? 'besser' : 'schlechter'} als ${group2} bei ${metric.label} (${Math.abs(percentDifference).toFixed(1)}% Unterschied)`
                                });
                            }
                        }
                    }
                }
                
                // Rangliste für diese Metrik erstellen
                results.rankings[metric.name] = Object.keys(metricData)
                    .filter(key => metricData[key] !== null)
                    .sort((a, b) => {
                        // Bei Bearbeitungszeit ist weniger besser
                        if (metric.name === 'processingTime') {
                            return metricData[a] - metricData[b];
                        }
                        // Bei anderen Metriken ist mehr besser
                        return metricData[b] - metricData[a];
                    })
                    .map((key, index) => ({
                        rank: index + 1,
                        group: key,
                        value: metricData[key]
                    }));
            });
            
            return results;
        },
        
        /**
         * Erstellt eine Zusammenfassung der wichtigsten Erkenntnisse aus den Statistiken
         * @param {Object} stats - Die berechneten Statistiken
         * @returns {Array} - Liste der wichtigsten Erkenntnisse
         */
        generateInsights: function(stats) {
            if (!stats || !stats.overall) {
                return [];
            }
            
            const insights = [];
            
            // Generelle Statistiken
            insights.push({
                type: 'general',
                message: `Insgesamt wurden ${stats.overall.count} Bewertungen analysiert.`
            });
            
            if (stats.overall.percentageStats && stats.overall.percentageStats.average) {
                insights.push({
                    type: 'general',
                    message: `Die durchschnittliche Bewertung beträgt ${stats.overall.percentageStats.average.toFixed(1)}%.`
                });
            }
            
            // Statusverteilung
            if (stats.overall.statusDistribution) {
                const approved = stats.overall.statusDistribution.approved || 0;
                const rejected = stats.overall.statusDistribution.rejected || 0;
                const needsReview = stats.overall.statusDistribution.needsReview || 0;
                
                if (stats.overall.count > 0) {
                    const approvalRate = (approved / stats.overall.count) * 100;
                    insights.push({
                        type: 'status',
                        message: `Die Genehmigungsrate beträgt ${approvalRate.toFixed(1)}% (${approved} von ${stats.overall.count}).`
                    });
                    
                    if (needsReview > 0) {
                        insights.push({
                            type: 'status',
                            importance: 'high',
                            message: `${needsReview} Bewertungen benötigen noch eine Überprüfung.`
                        });
                    }
                }
            }
            
            // Zeittrend
            if (stats.overall.timeTrend) {
                const trend = stats.overall.timeTrend;
                
                if (trend.trend === 'improving' && trend.significance >= 2) {
                    insights.push({
                        type: 'trend',
                        importance: 'high',
                        message: 'Die Bewertungen zeigen einen signifikant positiven Trend über die Zeit.'
                    });
                } else if (trend.trend === 'declining' && trend.significance >= 2) {
                    insights.push({
                        type: 'trend',
                        importance: 'high',
                        message: 'Die Bewertungen zeigen einen signifikant negativen Trend über die Zeit. Dies sollte näher untersucht werden.'
                    });
                }
            }
            
            // Ausreißer
            if (stats.overall.outliers && stats.overall.outliers.length > 0) {
                const outlierCount = stats.overall.outliers.length;
                
                if (outlierCount > 0) {
                    insights.push({
                        type: 'outliers',
                        importance: outlierCount > stats.overall.count * 0.1 ? 'high' : 'medium',
                        message: `Es wurden ${outlierCount} Ausreißer identifiziert, die deutlich vom Durchschnitt abweichen.`
                    });
                }
            }
            
            // Gruppenvergleiche
            if (stats.groups) {
                // Beste und schlechteste Gruppe identifizieren
                let bestGroup = null;
                let worstGroup = null;
                let bestAverage = -1;
                let worstAverage = 101; // Über 100% für Initialisierung
                
                Object.keys(stats.groups).forEach(groupKey => {
                    const groupStats = stats.groups[groupKey];
                    
                    if (groupStats.percentageStats && groupStats.percentageStats.average) {
                        const average = groupStats.percentageStats.average;
                        
                        if (average > bestAverage) {
                            bestAverage = average;
                            bestGroup = groupKey;
                        }
                        
                        if (average < worstAverage) {
                            worstAverage = average;
                            worstGroup = groupKey;
                        }
                    }
                });
                
                if (bestGroup && worstGroup && bestGroup !== worstGroup) {
                    insights.push({
                        type: 'comparison',
                        message: `Die Gruppe "${bestGroup}" zeigt mit ${bestAverage.toFixed(1)}% die besten Ergebnisse, während "${worstGroup}" mit ${worstAverage.toFixed(1)}% am schlechtesten abschneidet.`
                    });
                    
                    // Signifikanten Unterschied berechnen
                    const difference = bestAverage - worstAverage;
                    const percentDifference = (difference / worstAverage) * 100;
                    
                    if (percentDifference > 50) {
                        insights.push({
                            type: 'comparison',
                            importance: 'high',
                            message: `Der Unterschied zwischen der besten und schlechtesten Gruppe beträgt ${percentDifference.toFixed(1)}%, was auf großen Handlungsbedarf hinweist.`
                        });
                    }
                }
            }
            
            return insights;
        },
        
        /**
         * Erstellt einen zusammenfassenden Bericht über die Bewertungsstatistiken
         * @param {string} title - Titel des Berichts
         * @param {Object} stats - Die berechneten Statistiken
         * @returns {Object} - Der Berichtsdatensatz
         */
        generateReport: function(title, stats) {
            const report = {
                title: title || 'Bewertungsstatistik-Bericht',
                createdAt: new Date().toISOString(),
                createdBy: window.ImmoLern.Auth.getCurrentUser().id,
                summary: {},
                details: {},
                insights: [],
                recommendations: []
            };
            
            // Zusammenfassung erstellen
            if (stats.overall) {
                report.summary = {
                    totalAssessments: stats.overall.count,
                    averageScore: stats.overall.percentageStats ? 
                        stats.overall.percentageStats.average : null,
                    medianScore: stats.overall.percentageStats ? 
                        stats.overall.percentageStats.median : null,
                    statusDistribution: stats.overall.statusDistribution,
                    trend: stats.overall.timeTrend ? 
                        stats.overall.timeTrend.trend : null
                };
            }
            
            // Details hinzufügen
            report.details = stats;
            
            // Erkenntnisse generieren
            report.insights = this.generateInsights(stats);
            
            // Empfehlungen generieren
            if (report.insights && report.insights.length > 0) {
                // Empfehlungen basierend auf Erkenntnissen
                report.insights.forEach(insight => {
                    if (insight.importance === 'high') {
                        // Empfehlungen für wichtige Erkenntnisse
                        if (insight.type === 'trend' && insight.message.includes('negativen Trend')) {
                            report.recommendations.push({
                                priority: 'high',
                                message: 'Die negativen Trends sollten eingehender untersucht werden. Überprüfen Sie mögliche Änderungen in den Schulungsmaterialien oder Testkriterien.'
                            });
                        } else if (insight.type === 'outliers') {
                            report.recommendations.push({
                                priority: 'medium',
                                message: 'Die identifizierten Ausreißer sollten überprüft werden, um systematische Probleme bei der Bewertung oder dem Verständnis auszuschließen.'
                            });
                        } else if (insight.type === 'comparison') {
                            report.recommendations.push({
                                priority: 'high',
                                message: 'Die großen Unterschiede zwischen den Gruppen deuten auf Ungleichmäßigkeiten hin. Schulungsmaßnahmen sollten angepasst werden, um eine einheitlichere Leistung zu erreichen.'
                            });
                        }
                    }
                });
                
                // Standard-Empfehlungen ergänzen
                if (stats.overall && stats.overall.count > 0) {
                    // Bei geringer Genehmigungsrate
                    const approved = stats.overall.statusDistribution?.approved || 0;
                    const approvalRate = (approved / stats.overall.count) * 100;
                    
                    if (approvalRate < 50) {
                        report.recommendations.push({
                            priority: 'medium',
                            message: 'Die niedrige Genehmigungsrate deutet auf Schwierigkeiten bei den Tests oder Bewertungskriterien hin. Eine Überprüfung der Test-Komplexität und Bewertungsstandards wird empfohlen.'
                        });
                    }
                }
            }
            
            return report;
        }
    };
})();

// Modul für die Synchronisierung und Zusammenarbeit mehrerer Bewerter
window.ImmoLern.Assessment.Collaboration = (function() {
    // Private Variablen
    let _activeCollaborations = {};
    let _collaborationSettings = {
        enableRealtime: false,
        notifyOnConflict: true,
        automergeStrategy: 'newest', // 'newest', 'manual', 'majority'
        requireConsensus: false,
        consensusThreshold: 0.75 // 75% Übereinstimmung erforderlich
    };
    
    // Eigenen Status und Warteschlange
    let _userId = null;
    let _syncQueue = [];
    let _isSyncing = false;
    
    // Private Funktionen
    
    /**
     * Prüft auf Bewertungskonflikte
     * @param {string} submissionId - ID der Einreichung
     * @param {Object} localData - Lokale Bewertungsdaten
     * @param {Object} remoteData - Remote-Bewertungsdaten
     * @returns {Object} - Konfliktinformationen
     */
    function _checkForConflicts(submissionId, localData, remoteData) {
        if (!localData || !remoteData) {
            return { hasConflict: false };
        }
        
        const conflicts = {
            hasConflict: false,
            fields: []
        };
        
        // Zu prüfende Felder
        const fieldsToCheck = [
            { name: 'points', label: 'Punktzahl' },
            { name: 'status', label: 'Status' },
            { name: 'feedback', label: 'Feedback', threshold: 0.7 } // Für Text-Feldvergleich
        ];
        
        fieldsToCheck.forEach(field => {
            // Prüfen, ob die Werte unterschiedlich sind
            let isConflicting = false;
            
            if (field.name === 'feedback') {
                // Für Textfelder: Similarity-Prüfung
                if (localData.feedback && remoteData.feedback) {
                    const similarity = _calculateTextSimilarity(localData.feedback, remoteData.feedback);
                    isConflicting = similarity < (field.threshold || 0.5);
                } else {
                    isConflicting = !!localData.feedback !== !!remoteData.feedback;
                }
            } else {
                // Für andere Felder: Direkte Gleichheitsprüfung
                isConflicting = localData[field.name] !== remoteData[field.name];
            }
            
            if (isConflicting) {
                conflicts.hasConflict = true;
                conflicts.fields.push({
                    field: field.name,
                    label: field.label,
                    localValue: localData[field.name],
                    remoteValue: remoteData[field.name]
                });
            }
        });
        
        // Konflikte bei Rubrik-Bewertungen prüfen
        if (localData.rubricScores && remoteData.rubricScores) {
            const localCriteriaIds = Object.keys(localData.rubricScores);
            const remoteCriteriaIds = Object.keys(remoteData.rubricScores);
            
            // Alle Kriterien durchgehen
            const allCriteriaIds = [...new Set([...localCriteriaIds, ...remoteCriteriaIds])];
            
            allCriteriaIds.forEach(criterionId => {
                const localScore = localData.rubricScores[criterionId];
                const remoteScore = remoteData.rubricScores[criterionId];
                
                if (!localScore || !remoteScore) {
                    // Ein Kriterium existiert nur in einer der Bewertungen
                    conflicts.hasConflict = true;
                    conflicts.fields.push({
                        field: `rubric_${criterionId}`,
                        label: `Rubrik-Kriterium ${criterionId}`,
                        localValue: localScore ? localScore.points : 'Nicht bewertet',
                        remoteValue: remoteScore ? remoteScore.points : 'Nicht bewertet'
                    });
                } else if (localScore.points !== remoteScore.points) {
                    // Punktzahlen für das Kriterium sind unterschiedlich
                    conflicts.hasConflict = true;
                    conflicts.fields.push({
                        field: `rubric_${criterionId}`,
                        label: `Rubrik-Kriterium ${criterionId}`,
                        localValue: localScore.points,
                        remoteValue: remoteScore.points
                    });
                }
            });
        }
        
        return conflicts;
    }
    
    /**
     * Berechnet die Ähnlichkeit zwischen zwei Texten
     * @param {string} text1 - Erster Text
     * @param {string} text2 - Zweiter Text
     * @returns {number} - Ähnlichkeitswert zwischen 0 und 1
     */
    function _calculateTextSimilarity(text1, text2) {
        if (!text1 || !text2) {
            return 0;
        }
        
        // Sehr einfache Implementierung für die Ähnlichkeitsberechnung
        // Basierend auf dem Verhältnis der Textlängen
        const length1 = text1.length;
        const length2 = text2.length;
        
        const lengthRatio = Math.min(length1, length2) / Math.max(length1, length2);
        
        // In einer vollständigen Implementierung würde hier ein Algorithmus wie
        // Levenshtein-Distanz oder Jaccard-Index verwendet werden
        return lengthRatio;
    }
    
    /**
     * Führt eine automatische Konfliktlösung durch
     * @param {Object} conflicts - Die Konfliktinformationen
     * @param {Object} localData - Lokale Bewertungsdaten
     * @param {Object} remoteData - Remote-Bewertungsdaten
     * @returns {Object} - Die zusammengeführten Daten
     */
    function _autoResolveConflicts(conflicts, localData, remoteData) {
        // Neue Kopie der Daten für das Zusammenführen erstellen
        const mergedData = { ...localData };
        
        // Strategie für die automatische Zusammenführung anwenden
        switch (_collaborationSettings.automergeStrategy) {
            case 'newest':
                // Neuesten Datensatz verwenden (basierend auf Zeitstempel)
                if (new Date(remoteData.timestamp) > new Date(localData.timestamp)) {
                    return { ...remoteData };
                } else {
                    return { ...localData };
                }
                
            case 'manual':
                // Keine automatische Zusammenführung
                return null;
                
            case 'majority':
                // Mehrheitsprinzip erfordert mehr als zwei Bewertungen
                // Hier einfach implementiert als: Wenn Remote neuer ist, übernehmen
                if (new Date(remoteData.timestamp) > new Date(localData.timestamp)) {
                    return { ...remoteData };
                } else {
                    return { ...localData };
                }
                
            default:
                // Standardmäßig feldweise zusammenführen
                conflicts.fields.forEach(conflict => {
                    if (conflict.field.startsWith('rubric_')) {
                        // Für Rubrik-Kriterien
                        const criterionId = conflict.field.replace('rubric_', '');
                        if (remoteData.rubricScores && remoteData.rubricScores[criterionId]) {
                            mergedData.rubricScores = mergedData.rubricScores || {};
                            mergedData.rubricScores[criterionId] = { ...remoteData.rubricScores[criterionId] };
                        }
                    } else {
                        // Für Standardfelder
                        mergedData[conflict.field] = remoteData[conflict.field];
                    }
                });
                
                return mergedData;
        }
    }
    
    /**
     * Benachrichtigt den Benutzer über einen Bewertungskonflikt
     * @param {Object} conflicts - Die Konfliktinformationen
     * @param {Object} localData - Lokale Bewertungsdaten
     * @param {Object} remoteData - Remote-Bewertungsdaten
     * @returns {Promise} - Promise, der nach der Konfliktlösung aufgelöst wird
     */
    function _notifyConflict(conflicts, localData, remoteData) {
        return new Promise((resolve, reject) => {
            if (!_collaborationSettings.notifyOnConflict) {
                // Wenn keine Benachrichtigung erwünscht ist, automatisch zusammenführen
                const mergedData = _autoResolveConflicts(conflicts, localData, remoteData);
                return resolve(mergedData);
            }
            
            // Konfliktinformationen für die Anzeige aufbereiten
            let conflictHtml = '<div class="conflict-details">';
            
            conflicts.fields.forEach(conflict => {
                conflictHtml += `
                    <div class="conflict-item">
                        <div class="conflict-field">${conflict.label}</div>
                        <div class="conflict-values">
                            <div class="conflict-local">
                                <strong>Ihre Bewertung:</strong> 
                                <span>${conflict.localValue !== undefined ? conflict.localValue : 'Nicht angegeben'}</span>
                            </div>
                            <div class="conflict-remote">
                                <strong>Andere Bewertung:</strong> 
                                <span>${conflict.remoteValue !== undefined ? conflict.remoteValue : 'Nicht angegeben'}</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            conflictHtml += '</div>';
            
            // Dialog für den Benutzer anzeigen
            window.ImmoLern.UI.showCustomDialog(
                'Bewertungskonflikt erkannt',
                `
                    <div class="conflict-notification">
                        <p>Es wurden Unterschiede zwischen Ihrer Bewertung und einer anderen Bewertung für dieselbe Einreichung festgestellt.</p>
                        ${conflictHtml}
                        <p>Wie möchten Sie mit diesem Konflikt umgehen?</p>
                    </div>
                `,
                [
                    {
                        text: 'Meine Bewertung beibehalten',
                        action: 'keep-local',
                        class: 'btn-secondary'
                    },
                    {
                        text: 'Andere Bewertung übernehmen',
                        action: 'keep-remote',
                        class: 'btn-secondary'
                    },
                    {
                        text: 'Zusammenführen',
                        action: 'merge',
                        class: 'btn-primary'
                    }
                ],
                (action) => {
                    switch (action) {
                        case 'keep-local':
                            resolve({ ...localData });
                            break;
                            
                        case 'keep-remote':
                            resolve({ ...remoteData });
                            break;
                            
                        case 'merge':
                            _showMergeDialog(conflicts, localData, remoteData)
                                .then(mergedData => resolve(mergedData))
                                .catch(error => reject(error));
                            break;
                            
                        default:
                            // Bei Abbruch lokale Daten beibehalten
                            resolve({ ...localData });
                    }
                }
            );
        });
    }
    
    /**
     * Zeigt einen Dialog zur manuellen Zusammenführung von Bewertungskonflikten
     * @param {Object} conflicts - Die Konfliktinformationen
     * @param {Object} localData - Lokale Bewertungsdaten
     * @param {Object} remoteData - Remote-Bewertungsdaten
     * @returns {Promise<Object>} - Promise mit den zusammengeführten Daten
     */
    function _showMergeDialog(conflicts, localData, remoteData) {
        return new Promise((resolve, reject) => {
            // Formular für die manuelle Zusammenführung erstellen
            let mergeFormHtml = '<div class="merge-form">';
            
            conflicts.fields.forEach(conflict => {
                const fieldId = `merge_${conflict.field}`;
                
                mergeFormHtml += `
                    <div class="merge-field">
                        <label for="${fieldId}">${conflict.label}:</label>
                        <div class="merge-options">
                            <div class="option">
                                <input type="radio" name="${fieldId}" id="${fieldId}_local" value="local" checked>
                                <label for="${fieldId}_local">
                                    <span class="value">${conflict.localValue !== undefined ? conflict.localValue : 'Nicht angegeben'}</span>
                                    <span class="source">(Ihre Bewertung)</span>
                                </label>
                            </div>
                            <div class="option">
                                <input type="radio" name="${fieldId}" id="${fieldId}_remote" value="remote">
                                <label for="${fieldId}_remote">
                                    <span class="value">${conflict.remoteValue !== undefined ? conflict.remoteValue : 'Nicht angegeben'}</span>
                                    <span class="source">(Andere Bewertung)</span>
                                </label>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            mergeFormHtml += '</div>';
            
            // Dialog für die manuelle Zusammenführung anzeigen
            window.ImmoLern.UI.showCustomDialog(
                'Bewertungen zusammenführen',
                `
                    <div class="merge-dialog">
                        <p>Bitte wählen Sie für jedes Feld, welche Version übernommen werden soll:</p>
                        ${mergeFormHtml}
                    </div>
                `,
                [
                    {
                        text: 'Abbrechen',
                        action: 'cancel',
                        class: 'btn-secondary'
                    },
                    {
                        text: 'Zusammenführen',
                        action: 'merge',
                        class: 'btn-primary'
                    }
                ],
                (action, data) => {
                    if (action !== 'merge') {
                        // Bei Abbruch lokale Daten beibehalten
                        return resolve({ ...localData });
                    }
                    
                    // Daten zusammenführen basierend auf den Benutzerauswahlen
                    const mergedData = { ...localData };
                    
                    conflicts.fields.forEach(conflict => {
                        const fieldId = `merge_${conflict.field}`;
                        const selection = document.querySelector(`input[name="${fieldId}"]:checked`)?.value;
                        
                        if (selection === 'remote') {
                            if (conflict.field.startsWith('rubric_')) {
                                // Für Rubrik-Kriterien
                                const criterionId = conflict.field.replace('rubric_', '');
                                if (remoteData.rubricScores && remoteData.rubricScores[criterionId]) {
                                    mergedData.rubricScores = mergedData.rubricScores || {};
                                    mergedData.rubricScores[criterionId] = { ...remoteData.rubricScores[criterionId] };
                                }
                            } else {
                                // Für Standardfelder
                                mergedData[conflict.field] = remoteData[conflict.field];
                            }
                        }
                    });
                    
                    // Version aktualisieren und Zusammenführungsinformationen hinzufügen
                    mergedData.revision = Math.max(localData.revision || 0, remoteData.revision || 0) + 1;
                    mergedData.mergeMetadata = {
                        mergedAt: new Date().toISOString(),
                        mergedBy: _userId,
                        sourceRevisions: [
                            { id: localData.revision, userId: localData.assessorId },
                            { id: remoteData.revision, userId: remoteData.assessorId }
                        ]
                    };
                    
                    resolve(mergedData);
                }
            );
        });
    }
    
    /**
     * Verarbeitet die Synchronisationswarteschlange
     * @returns {Promise} - Promise, der nach der Verarbeitung aufgelöst wird
     */
    function _processSyncQueue() {
        if (_isSyncing || _syncQueue.length === 0) {
            return Promise.resolve();
        }
        
        // Synchronisationszustand setzen
        _isSyncing = true;
        
        // Nächstes Element aus der Warteschlange nehmen
        const nextSync = _syncQueue.shift();
        
        // Lokale und Remote-Daten laden
        return Promise.all([
            window.ImmoLern.Assessment.Data.getAssessment(nextSync.submissionId),
            window.ImmoLern.Assessment.Data.getRemoteAssessment(nextSync.submissionId)
        ])
            .then(([localData, remoteData]) => {
                if (!localData || !remoteData) {
                    return null; // Nichts zu synchronisieren
                }
                
                // Auf Konflikte prüfen
                const conflicts = _checkForConflicts(nextSync.submissionId, localData, remoteData);
                
                if (!conflicts.hasConflict) {
                    // Keine Konflikte, neuere Version verwenden
                    if (new Date(remoteData.timestamp) > new Date(localData.timestamp)) {
                        return window.ImmoLern.Assessment.Data.saveAssessment(remoteData);
                    }
                    return null;
                }
                
                // Konflikt gefunden, Lösung starten
                return _notifyConflict(conflicts, localData, remoteData)
                    .then(mergedData => {
                        if (mergedData) {
                            return window.ImmoLern.Assessment.Data.saveAssessment(mergedData);
                        }
                        return null;
                    });
            })
            .catch(error => {
                console.error(`Fehler bei der Synchronisierung von ${nextSync.submissionId}:`, error);
                return null;
            })
            .finally(() => {
                // Synchronisierungsstatus zurücksetzen
                _isSyncing = false;
                
                // Weitere Elemente in der Warteschlange verarbeiten
                if (_syncQueue.length > 0) {
                    return _processSyncQueue();
                }
            });
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul für die Zusammenarbeit
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Benutzer-ID abrufen
            _userId = window.ImmoLern.Auth.getCurrentUser().id;
            
            // Einstellungen überschreiben, falls vorhanden
            if (options.collaborationSettings) {
                _collaborationSettings = {
                    ..._collaborationSettings,
                    ...options.collaborationSettings
                };
            }
            
            // Echtzeit-Synchronisierung aktivieren, falls konfiguriert
            if (_collaborationSettings.enableRealtime) {
                // In einer realen Implementierung würde hier eine WebSocket-Verbindung
                // oder ein ähnlicher Echtzeit-Kommunikationskanal eingerichtet werden
                console.log('Echtzeit-Zusammenarbeit ist aktiviert');
            }
            
            return this;
        },
        
        /**
         * Startet eine Zusammenarbeit für eine Bewertung
         * @param {string} submissionId - ID der Einreichung
         * @returns {Promise} - Promise, der nach dem Start aufgelöst wird
         */
        startCollaboration: function(submissionId) {
            if (!submissionId) {
                return Promise.reject(new Error('Ungültige Einreichungs-ID'));
            }
            
            // Prüfen, ob bereits eine Zusammenarbeit läuft
            if (_activeCollaborations[submissionId]) {
                console.log(`Zusammenarbeit für ${submissionId} läuft bereits`);
                return Promise.resolve(_activeCollaborations[submissionId]);
            }
            
            // Neue Zusammenarbeit erstellen
            const collaboration = {
                id: `collab_${submissionId}_${Date.now()}`,
                submissionId: submissionId,
                startedAt: new Date().toISOString(),
                startedBy: _userId,
                participants: [_userId],
                status: 'active'
            };
            
            // Zusammenarbeit speichern
            return window.ImmoLern.Assessment.Data.saveCollaboration(collaboration)
                .then(() => {
                    // Lokal speichern
                    _activeCollaborations[submissionId] = collaboration;
                    
                    console.log(`Zusammenarbeit für ${submissionId} gestartet`);
                    return collaboration;
                });
        },
        
        /**
         * Synchronisiert eine Bewertung mit dem Server
         * @param {string} submissionId - ID der Einreichung
         * @returns {Promise} - Promise, der nach der Synchronisierung aufgelöst wird
         */
        synchronize: function(submissionId) {
            if (!submissionId) {
                return Promise.reject(new Error('Ungültige Einreichungs-ID'));
            }
            
            // Prüfen, ob bereits in der Warteschlange
            const existingIndex = _syncQueue.findIndex(item => item.submissionId === submissionId);
            if (existingIndex !== -1) {
                // Nach vorne in der Warteschlange verschieben
                const item = _syncQueue.splice(existingIndex, 1)[0];
                _syncQueue.unshift(item);
            } else {
                // Neu zur Warteschlange hinzufügen
                _syncQueue.unshift({
                    submissionId: submissionId,
                    queuedAt: new Date().toISOString()
                });
            }
            
            // Synchronisierung starten, falls nicht bereits aktiv
            if (!_isSyncing) {
                return _processSyncQueue();
            }
            
            return Promise.resolve();
        },
        
        /**
         * Sendet eine Zusammenarbeitsanfrage an andere Benutzer
         * @param {string} submissionId - ID der Einreichung
         * @param {Array} userIds - Liste der Benutzer-IDs
         * @param {string} message - Nachricht für die Anfrage
         * @returns {Promise} - Promise, der nach dem Senden aufgelöst wird
         */
        inviteCollaborators: function(submissionId, userIds, message) {
            if (!submissionId || !userIds || userIds.length === 0) {
                return Promise.reject(new Error('Ungültige Parameter für die Zusammenarbeitsanfrage'));
            }
            
            // Zusammenarbeit starten oder abrufen
            return this.startCollaboration(submissionId)
                .then(collaboration => {
                    // Einladungen für alle Benutzer erstellen
                    const invitations = userIds.map(userId => ({
                        collaborationId: collaboration.id,
                        submissionId: submissionId,
                        invitedUser: userId,
                        invitedBy: _userId,
                        message: message || 'Bitte überprüfen Sie diese Bewertung gemeinsam.',
                        status: 'pending',
                        createdAt: new Date().toISOString()
                    }));
                    
                    // Einladungen speichern
                    return window.ImmoLern.Assessment.Data.saveCollaborationInvitations(invitations);
                });
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Integration initialisieren
    window.ImmoLern.Assessment.Processing.Integration.init();
    
    // Collaboration-Modul initialisieren
    window.ImmoLern.Assessment.Collaboration.init();
    
    // Exportfunktion im UI registrieren
    const exportButton = document.getElementById('exportAssessmentsBtn');
    if (exportButton) {
        exportButton.addEventListener('click', () => {
            // Bewertungen für den Export abrufen
            const assessmentIds = window.ImmoLern.Assessment.Interface.getSelectedAssessmentIds();
            
            if (!assessmentIds || assessmentIds.length === 0) {
                window.ImmoLern.UI.showToast('Bitte wählen Sie mindestens eine Bewertung für den Export aus', 'warning');
                return;
            }
            
            // Format-Auswahl anzeigen
            window.ImmoLern.UI.showCustomDialog(
                'Bewertungen exportieren',
                `
                    <div class="export-dialog">
                        <p>Sie möchten ${assessmentIds.length} Bewertung(en) exportieren.</p>
                        <div class="form-group">
                            <label for="exportFormat">Format auswählen:</label>
                            <select id="exportFormat" class="form-control">
                                <option value="json">JSON</option>
                                <option value="csv">CSV</option>
                                <option value="pdf">PDF</option>
                            </select>
                        </div>
                    </div>
                `,
                [
                    {
                        text: 'Abbrechen',
                        action: 'cancel',
                        class: 'btn-secondary'
                    },
                    {
                        text: 'Exportieren',
                        action: 'export',
                        class: 'btn-primary'
                    }
                ],
                (action) => {
                    if (action !== 'export') return;
                    
                    const formatSelect = document.getElementById('exportFormat');
                    const format = formatSelect ? formatSelect.value : 'json';
                    
                    // Export durchführen
                    window.ImmoLern.UI.showLoading('Bewertungen werden exportiert...');
                    
                    window.ImmoLern.Assessment.Processing.Integration.exportAssessments(assessmentIds, format)
                        .then(exportResult => {
                            window.ImmoLern.UI.hideLoading();
                            
                            // Export herunterladen
                            if (exportResult) {
                                _downloadExport(exportResult.data, exportResult.filename, exportResult.mimeType);
                                window.ImmoLern.UI.showToast('Export erfolgreich erstellt', 'success');
                            }
                        })
                        .catch(error => {
                            window.ImmoLern.UI.hideLoading();
                            console.error('Fehler beim Export:', error);
                            window.ImmoLern.UI.showToast('Fehler beim Export der Bewertungen', 'error');
                        });
                }
            );
        });
    }
    
    // Funktion zum Herunterladen des Exports
    function _downloadExport(data, filename, mimeType) {
        // Blob erstellen
        const blob = new Blob([data], { type: mimeType });
        
        // Download-Link erstellen
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        
        // Link klicken und entfernen
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // URL freigeben
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 100);
    }
});

// Benutzerdefiniertes Ereignis auslösen, wenn das Modul geladen ist
document.dispatchEvent(new CustomEvent('assessmentIntegrationLoaded'));
/**
 * JS-Block 6.3.1-part1: Berechnungslogik (Teil 1)
 * 
 * Dieses Modul enthält die Grundfunktionen zur Berechnung von Punkten in Bewertungen:
 * - Berechnungsalgorithmen für verschiedene Fragetypen
 * - Gewichtungsfunktionen für Fragen und Kategorien
 * - Teilpunktberechnung und Bewertungsregeln
 * - Normalisierung und Skalierungsfunktionen
 */

// Namespace für Punkteberechnung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Scoring) window.ImmoLern.Assessment.Scoring = {};

// Punkteberechnungsmodul
window.ImmoLern.Assessment.Scoring.Calculator = (function() {
    // Standardeinstellungen für die Punkteberechnung
    const _defaultSettings = {
        enableNegativeScoring: false,  // Abzug von Punkten für falsche Antworten?
        negativeScoreFactor: 0.25,     // Welcher Anteil wird bei falschen Antworten abgezogen
        enablePartialCredit: true,     // Teilpunkte für teilweise richtige Antworten?
        roundingMethod: 'half_up',     // Rundungsmethode: 'half_up', 'ceiling', 'floor'
        roundToPrecision: 2,           // Nachkommastellen bei der Rundung
        multipleChoiceMethod: 'proportional', // 'all_or_nothing', 'proportional'
        minScorePerQuestion: 0,        // Minimalpunktzahl pro Frage
        allowExtraCredit: false,       // Zusatzpunkte erlauben?
        maxExtraCreditPercent: 10      // Maximale Zusatzpunkte in Prozent
    };
    
    // Aktuelle Einstellungen (werden bei Initialisierung angepasst)
    let _settings = { ..._defaultSettings };
    
    // Private Funktionen
    
    /**
     * Rundet einen Wert entsprechend der konfigurierten Rundungsmethode
     * @param {number} value - Der zu rundende Wert
     * @returns {number} - Der gerundete Wert
     */
    function _roundScore(value) {
        const precision = Math.pow(10, _settings.roundToPrecision);
        
        switch (_settings.roundingMethod) {
            case 'ceiling':
                return Math.ceil(value * precision) / precision;
                
            case 'floor':
                return Math.floor(value * precision) / precision;
                
            case 'half_up':
            default:
                return Math.round(value * precision) / precision;
        }
    }
    
    /**
     * Berechnet Punkte für eine Multiple-Choice-Frage
     * @param {Object} question - Die Frage
     * @param {Array} userAnswers - Die Antworten des Benutzers (Array von IDs)
     * @returns {number} - Die berechneten Punkte
     */
    function _calculateMultipleChoiceScore(question, userAnswers) {
        if (!question || !userAnswers) {
            return 0;
        }
        
        // Maximale Punkte für die Frage
        const maxPoints = question.points || 1;
        
        // Richtige Antworten aus der Frage extrahieren
        const correctAnswerIds = question.answers
            .filter(answer => answer.isCorrect)
            .map(answer => answer.id);
            
        // Richtige und falsche Antworten des Benutzers zählen
        const correctUserAnswers = userAnswers.filter(id => correctAnswerIds.includes(id));
        const incorrectUserAnswers = userAnswers.filter(id => !correctAnswerIds.includes(id));
        
        let score = 0;
        
        // Je nach Berechnungsmethode Punkte berechnen
        if (_settings.multipleChoiceMethod === 'all_or_nothing') {
            // Alle oder nichts: Nur volle Punktzahl wenn alles richtig, sonst 0
            if (correctUserAnswers.length === correctAnswerIds.length && incorrectUserAnswers.length === 0) {
                score = maxPoints;
            }
        } else {
            // Proportionale Methode: Teilpunkte basierend auf richtigen/falschen Antworten
            
            // 1. Punkte für richtige Antworten
            const correctAnswerRatio = correctUserAnswers.length / correctAnswerIds.length;
            score = maxPoints * correctAnswerRatio;
            
            // 2. Abzug für falsche Antworten, falls aktiviert
            if (_settings.enableNegativeScoring && incorrectUserAnswers.length > 0) {
                const totalPossibleIncorrect = question.answers.length - correctAnswerIds.length;
                // Vermeiden von Division durch Null
                const incorrectRatio = totalPossibleIncorrect > 0 
                    ? incorrectUserAnswers.length / totalPossibleIncorrect 
                    : 0;
                
                const penaltyPoints = maxPoints * incorrectRatio * _settings.negativeScoreFactor;
                score -= penaltyPoints;
            }
        }
        
        // Sicherstellen, dass die Punktzahl nicht unter das Minimum fällt
        score = Math.max(score, _settings.minScorePerQuestion);
        
        // Rundung anwenden
        return _roundScore(score);
    }
    
    /**
     * Berechnet Punkte für eine Single-Choice-Frage
     * @param {Object} question - Die Frage
     * @param {string} userAnswer - Die Antwort des Benutzers (ID)
     * @returns {number} - Die berechneten Punkte
     */
    function _calculateSingleChoiceScore(question, userAnswer) {
        if (!question || !userAnswer) {
            return 0;
        }
        
        // Maximale Punkte für die Frage
        const maxPoints = question.points || 1;
        
        // Richtige Antwort aus der Frage extrahieren
        const correctAnswerId = question.answers.find(answer => answer.isCorrect)?.id;
        
        // Prüfen, ob die Antwort richtig ist
        if (userAnswer === correctAnswerId) {
            return maxPoints;
        } else {
            // Bei negativer Bewertung Punkte abziehen
            if (_settings.enableNegativeScoring) {
                return _roundScore(maxPoints * -1 * _settings.negativeScoreFactor);
            }
            
            // Sonst Minimalpunktzahl zurückgeben
            return _settings.minScorePerQuestion;
        }
    }
    
    /**
     * Berechnet Punkte für eine Wahr/Falsch-Frage
     * @param {Object} question - Die Frage
     * @param {boolean} userAnswer - Die Antwort des Benutzers
     * @returns {number} - Die berechneten Punkte
     */
    function _calculateTrueFalseScore(question, userAnswer) {
        if (!question || userAnswer === undefined || userAnswer === null) {
            return 0;
        }
        
        // Maximale Punkte für die Frage
        const maxPoints = question.points || 1;
        
        // Richtige Antwort aus der Frage extrahieren
        const correctAnswer = question.correctAnswer === true;
        
        // Prüfen, ob die Antwort richtig ist
        if (userAnswer === correctAnswer) {
            return maxPoints;
        } else {
            // Bei negativer Bewertung Punkte abziehen
            if (_settings.enableNegativeScoring) {
                return _roundScore(maxPoints * -1 * _settings.negativeScoreFactor);
            }
            
            // Sonst Minimalpunktzahl zurückgeben
            return _settings.minScorePerQuestion;
        }
    }
    
    /**
     * Berechnet einen gewichteten Durchschnitt
     * @param {Array} items - Array von Objekten mit value und weight Eigenschaften
     * @returns {number} - Der gewichtete Durchschnitt
     */
    function _calculateWeightedAverage(items) {
        if (!items || items.length === 0) {
            return 0;
        }
        
        let totalWeight = 0;
        let weightedSum = 0;
        
        items.forEach(item => {
            const weight = item.weight || 1;
            totalWeight += weight;
            weightedSum += (item.value || 0) * weight;
        });
        
        // Vermeiden von Division durch Null
        if (totalWeight === 0) {
            return 0;
        }
        
        return weightedSum / totalWeight;
    }
    
    /**
     * Skaliert einen Wert innerhalb eines bestimmten Bereichs
     * @param {number} value - Der zu skalierende Wert
     * @param {number} oldMin - Minimum des alten Bereichs
     * @param {number} oldMax - Maximum des alten Bereichs
     * @param {number} newMin - Minimum des neuen Bereichs
     * @param {number} newMax - Maximum des neuen Bereichs
     * @returns {number} - Der skalierte Wert
     */
    function _scaleValue(value, oldMin, oldMax, newMin, newMax) {
        // Prüfen auf gleiche Werte im alten Bereich
        if (oldMin === oldMax) {
            return newMin;
        }
        
        // Wert auf den alten Bereich beschränken
        const clampedValue = Math.max(oldMin, Math.min(oldMax, value));
        
        // Skalierung berechnen
        const scale = (newMax - newMin) / (oldMax - oldMin);
        
        // Wert skalieren
        const scaledValue = newMin + (clampedValue - oldMin) * scale;
        
        return scaledValue;
    }
    
    /**
     * Berechnet Punktzahl und Bestehensgrenze für einen Test
     * @param {Object} test - Der Test
     * @param {Array} questionScores - Die Punktzahlen pro Frage
     * @returns {Object} - Ergebnisobjekt mit Punkten, Prozent und Bestanden/Nicht-Bestanden
     */
    function _calculateTestResult(test, questionScores) {
        if (!test || !questionScores || questionScores.length === 0) {
            return {
                score: 0,
                maxScore: 0,
                percentage: 0,
                passed: false
            };
        }
        
        // Gesamtpunktzahl berechnen
        const totalScore = questionScores.reduce((sum, item) => sum + (item.score || 0), 0);
        
        // Maximale Punktzahl berechnen
        const maxPossibleScore = questionScores.reduce((sum, item) => sum + (item.maxScore || 0), 0);
        
        // Prozentsatz berechnen
        let percentage = 0;
        if (maxPossibleScore > 0) {
            percentage = (totalScore / maxPossibleScore) * 100;
        }
        
        // Prozentsatz runden
        percentage = _roundScore(percentage);
        
        // Bestanden/Nicht-Bestanden prüfen
        const passingThreshold = test.passingThreshold || 50;
        const passed = percentage >= passingThreshold;
        
        return {
            score: totalScore,
            maxScore: maxPossibleScore,
            percentage: percentage,
            passed: passed,
            passingThreshold: passingThreshold
        };
    }
    
    /**
     * Berechnet Teilpunkte für eine Freitext-Antwort basierend auf Schlüsselwörtern
     * @param {Object} question - Die Frage
     * @param {string} userAnswer - Die Antwort des Benutzers
     * @returns {Object} - Ergebnisobjekt mit automatisch berechneten Teilpunkten
     */
    function _calculateFreeTextPartialScore(question, userAnswer) {
        if (!question || !userAnswer || !question.keywords || question.keywords.length === 0) {
            return {
                autoScore: 0,
                maxAutoScore: 0,
                matchedKeywords: [],
                needsManualReview: true
            };
        }
        
        // Maximale Punkte für die Frage
        const maxPoints = question.points || 1;
        
        // Schlüsselwörter extrahieren und nach Wichtigkeit sortieren
        const keywords = [...question.keywords].sort((a, b) => (b.weight || 1) - (a.weight || 1));
        
        // Maximale Punkte für die automatische Bewertung (kann geringer sein als die Gesamtpunktzahl)
        const maxAutoScore = question.autoScorePercentage ? 
            maxPoints * (question.autoScorePercentage / 100) : 
            maxPoints;
        
        // Antwort des Benutzers in Kleinbuchstaben für den Vergleich
        const normalizedAnswer = userAnswer.toLowerCase();
        
        // Gefundene Schlüsselwörter und deren Gewichtung
        const matchedKeywords = [];
        let totalKeywordWeight = 0;
        let matchedKeywordWeight = 0;
        
        // Überprüfen, welche Schlüsselwörter in der Antwort vorkommen
        keywords.forEach(keyword => {
            const weight = keyword.weight || 1;
            totalKeywordWeight += weight;
            
            // Schlüsselwort in Kleinbuchstaben umwandeln
            const normalizedKeyword = keyword.text.toLowerCase();
            
            // Prüfen, ob das Schlüsselwort in der Antwort enthalten ist
            if (normalizedAnswer.includes(normalizedKeyword)) {
                matchedKeywords.push({
                    keyword: keyword.text,
                    weight: weight
                });
                matchedKeywordWeight += weight;
            }
        });
        
        // Teilpunkte basierend auf dem Verhältnis gefundener Schlüsselwörter berechnen
        let autoScore = 0;
        if (totalKeywordWeight > 0) {
            autoScore = maxAutoScore * (matchedKeywordWeight / totalKeywordWeight);
        }
        
        // Punktzahl runden
        autoScore = _roundScore(autoScore);
        
        // Festlegen, ob eine manuelle Prüfung erforderlich ist
        // Wenn die automatische Bewertung unter 100% der möglichen Punktzahl liegt,
        // ist in der Regel eine manuelle Prüfung erforderlich
        const needsManualReview = autoScore < maxPoints || question.requireManualReview === true;
        
        return {
            autoScore: autoScore,
            maxAutoScore: maxAutoScore,
            maxPoints: maxPoints,
            matchedKeywords: matchedKeywords,
            matchedKeywordWeight: matchedKeywordWeight,
            totalKeywordWeight: totalKeywordWeight,
            needsManualReview: needsManualReview
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert den Punkterechner mit benutzerdefinierten Einstellungen
         * @param {Object} customSettings - Benutzerdefinierte Einstellungen
         */
        init: function(customSettings = {}) {
            // Einstellungen mit benutzerdefinierten Werten überschreiben
            _settings = {
                ..._defaultSettings,
                ...customSettings
            };
            
            console.log('Punkterechner initialisiert mit Einstellungen:', _settings);
            
            return this;
        },
        
        /**
         * Gibt die aktuellen Einstellungen des Punkterechners zurück
         * @returns {Object} - Die aktuellen Einstellungen
         */
        getSettings: function() {
            return { ..._settings };
        },
        
        /**
         * Aktualisiert die Einstellungen des Punkterechners
         * @param {Object} newSettings - Neue Einstellungen
         * @returns {Object} - Die aktualisierten Einstellungen
         */
        updateSettings: function(newSettings = {}) {
            _settings = {
                ..._settings,
                ...newSettings
            };
            
            return { ..._settings };
        },
        
        /**
         * Berechnet die Punktzahl für eine Frage basierend auf der Antwort des Benutzers
         * @param {Object} question - Die Frage
         * @param {any} userAnswer - Die Antwort des Benutzers
         * @returns {number} - Die berechnete Punktzahl
         */
        calculateQuestionScore: function(question, userAnswer) {
            if (!question) {
                return 0;
            }
            
            // Je nach Fragetyp entsprechende Berechnungsfunktion aufrufen
            switch (question.type) {
                case 'multiple_choice':
                    return _calculateMultipleChoiceScore(question, userAnswer);
                    
                case 'single_choice':
                    return _calculateSingleChoiceScore(question, userAnswer);
                    
                case 'true_false':
                    return _calculateTrueFalseScore(question, userAnswer);
                    
                case 'free_text':
                    // Für Freitext-Fragen zunächst Teilpunkte berechnen
                    const partialResult = _calculateFreeTextPartialScore(question, userAnswer);
                    // Rückgabe der automatisch berechneten Punktzahl
                    return partialResult.autoScore;
                    
                default:
                    console.warn('Unbekannter Fragetyp:', question.type);
                    return 0;
            }
        },
        
        /**
         * Berechnet detaillierte Ergebnisse für eine Freitext-Frage
         * @param {Object} question - Die Frage
         * @param {string} userAnswer - Die Antwort des Benutzers
         * @returns {Object} - Detaillierte Ergebnisse mit Teilpunkten und gefundenen Schlüsselwörtern
         */
        calculateFreeTextDetails: function(question, userAnswer) {
            return _calculateFreeTextPartialScore(question, userAnswer);
        },
        
        /**
         * Berechnet das Gesamtergebnis für einen Test
         * @param {Object} test - Der Test
         * @param {Array} questionScores - Die Punktzahlen pro Frage
         * @returns {Object} - Ergebnisobjekt mit Gesamtpunkten, Prozent und Bestanden/Nicht-Bestanden
         */
        calculateTestResult: function(test, questionScores) {
            return _calculateTestResult(test, questionScores);
        },
        
        /**
         * Berechnet einen gewichteten Durchschnitt
         * @param {Array} items - Array von Objekten mit value und weight Eigenschaften
         * @returns {number} - Der gewichtete Durchschnitt
         */
        calculateWeightedAverage: function(items) {
            return _calculateWeightedAverage(items);
        },
        
        /**
         * Skaliert einen Wert in einen neuen Wertebereich
         * @param {number} value - Der zu skalierende Wert
         * @param {number} oldMin - Minimum des alten Bereichs
         * @param {number} oldMax - Maximum des alten Bereichs
         * @param {number} newMin - Minimum des neuen Bereichs
         * @param {number} newMax - Maximum des neuen Bereichs
         * @returns {number} - Der skalierte Wert
         */
        scaleValue: function(value, oldMin, oldMax, newMin, newMax) {
            return _scaleValue(value, oldMin, oldMax, newMin, newMax);
        },
        
        /**
         * Rundet eine Punktzahl entsprechend der Einstellungen
         * @param {number} value - Der zu rundende Wert
         * @returns {number} - Der gerundete Wert
         */
        roundScore: function(value) {
            return _roundScore(value);
        }
    };
})();

// Modul für kategorisierte Punkteberechnung
window.ImmoLern.Assessment.Scoring.CategoryCalculator = (function() {
    // Private Variablen
    let _testConfig = null;
    let _questionsByCategory = {};
    
    // Private Funktionen
    
    /**
     * Gruppiert Fragen nach Kategorien
     * @param {Array} questions - Liste der Fragen
     * @returns {Object} - Nach Kategorien gruppierte Fragen
     */
    function _groupQuestionsByCategory(questions) {
        const categories = {};
        
        questions.forEach(question => {
            const category = question.category || 'uncategorized';
            
            if (!categories[category]) {
                categories[category] = [];
            }
            
            categories[category].push(question);
        });
        
        return categories;
    }
    
    /**
     * Berechnet die Gewichtung jeder Kategorie
     * @param {Object} categories - Nach Kategorien gruppierte Fragen
     * @param {Object} categoryWeights - Benutzerdefinierte Kategoriegewichtungen
     * @returns {Object} - Berechnete Gewichtungen pro Kategorie
     */
    function _calculateCategoryWeights(categories, categoryWeights = {}) {
        const weights = {};
        let totalQuestionsWeight = 0;
        
        // Standardgewichtungen basierend auf der Anzahl der Fragen berechnen
        Object.keys(categories).forEach(category => {
            const questions = categories[category];
            const totalCategoryPoints = questions.reduce((sum, q) => sum + (q.points || 1), 0);
            
            weights[category] = {
                questionCount: questions.length,
                totalPoints: totalCategoryPoints,
                weight: categoryWeights[category] || 1
            };
            
            totalQuestionsWeight += weights[category].weight;
        });
        
        // Gewichtungen normalisieren (falls nötig)
        if (totalQuestionsWeight > 0) {
            Object.keys(weights).forEach(category => {
                weights[category].normalizedWeight = weights[category].weight / totalQuestionsWeight;
            });
        }
        
        return weights;
    }
    
    /**
     * Berechnet Punkte pro Kategorie
     * @param {Object} categories - Nach Kategorien gruppierte Fragen
     * @param {Object} userAnswers - Antworten des Benutzers
     * @returns {Object} - Berechnete Punkte pro Kategorie
     */
    function _calculateCategoryScores(categories, userAnswers) {
        const categoryScores = {};
        
        Object.keys(categories).forEach(category => {
            const questions = categories[category];
            let categoryScore = 0;
            let categoryMaxScore = 0;
            
            questions.forEach(question => {
                const userAnswer = userAnswers[question.id];
                const score = window.ImmoLern.Assessment.Scoring.Calculator.calculateQuestionScore(question, userAnswer);
                const maxScore = question.points || 1;
                
                categoryScore += score;
                categoryMaxScore += maxScore;
            });
            
            categoryScores[category] = {
                score: categoryScore,
                maxScore: categoryMaxScore,
                percentage: categoryMaxScore > 0 ? (categoryScore / categoryMaxScore) * 100 : 0,
                questionCount: questions.length
            };
        });
        
        return categoryScores;
    }
    
    /**
     * Berechnet Stärken und Schwächen basierend auf Kategorieauswertungen
     * @param {Object} categoryScores - Punktzahlen pro Kategorie
     * @returns {Object} - Stärken und Schwächen mit Prozentsätzen
     */
    function _calculateStrengthsAndWeaknesses(categoryScores) {
        if (!categoryScores || Object.keys(categoryScores).length === 0) {
            return {
                strengths: [],
                weaknesses: []
            };
        }
        
        // Kategorien nach Prozentsatz sortieren
        const sortedCategories = Object.keys(categoryScores)
            .map(category => ({
                category,
                percentage: categoryScores[category].percentage
            }))
            .sort((a, b) => b.percentage - a.percentage);
        
        // Durchschnittliche Prozentzahl berechnen
        const avgPercentage = sortedCategories.reduce((sum, item) => sum + item.percentage, 0) / sortedCategories.length;
        
        // Stärken: Kategorien über dem Durchschnitt
        const strengths = sortedCategories
            .filter(item => item.percentage > avgPercentage)
            .map(item => ({
                category: item.category,
                percentage: item.percentage,
                performance: _getCategoryPerformanceLabel(item.percentage)
            }));
        
        // Schwächen: Kategorien unter dem Durchschnitt
        const weaknesses = sortedCategories
            .filter(item => item.percentage < avgPercentage)
            .map(item => ({
                category: item.category,
                percentage: item.percentage,
                performance: _getCategoryPerformanceLabel(item.percentage)
            }));
        
        return {
            strengths,
            weaknesses
        };
    }
    
    /**
     * Generiert ein Label für die Leistung in einer Kategorie
     * @param {number} percentage - Die Prozentzahl
     * @returns {string} - Das Leistungslabel
     */
    function _getCategoryPerformanceLabel(percentage) {
        if (percentage >= 90) return 'hervorragend';
        if (percentage >= 80) return 'sehr gut';
        if (percentage >= 70) return 'gut';
        if (percentage >= 60) return 'befriedigend';
        if (percentage >= 50) return 'ausreichend';
        if (percentage >= 40) return 'mangelhaft';
        return 'ungenügend';
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert den Kategorien-Rechner mit einer Testkonfiguration
         * @param {Object} testConfig - Die Testkonfiguration
         * @param {Array} questions - Die Fragen des Tests
         */
        init: function(testConfig, questions) {
            _testConfig = testConfig || {};
            
            // Fragen nach Kategorien gruppieren
            if (questions && questions.length > 0) {
                _questionsByCategory = _groupQuestionsByCategory(questions);
            } else {
                _questionsByCategory = {};
            }
            
            return this;
        },
        
        /**
         * Gruppiert Fragen nach Kategorien
         * @param {Array} questions - Liste der Fragen
         * @returns {Object} - Nach Kategorien gruppierte Fragen
         */
        groupQuestionsByCategory: function(questions) {
            return _groupQuestionsByCategory(questions);
        },
        
        /**
         * Berechnet die Punktzahlen pro Kategorie
         * @param {Array} questions - Liste der Fragen
         * @param {Object} userAnswers - Antworten des Benutzers
         * @returns {Object} - Berechnete Punktzahlen pro Kategorie
         */
        calculateCategoryScores: function(questions, userAnswers) {
            const categories = _groupQuestionsByCategory(questions);
            return _calculateCategoryScores(categories, userAnswers);
        },
        
        /**
         * Berechnet das Gesamtergebnis mit Kategorieauswertung
         * @param {Array} questions - Liste der Fragen
         * @param {Object} userAnswers - Antworten des Benutzers
         * @returns {Object} - Detailliertes Ergebnissobjekt
         */
        calculateDetailedResult: function(questions, userAnswers) {
            // Fragen nach Kategorien gruppieren
            const categories = _groupQuestionsByCategory(questions);
            
            // Kategoriegewichtungen aus der Testkonfiguration oder Standard
            const categoryWeights = _testConfig.categoryWeights || {};
            
            // Gewichtungen pro Kategorie berechnen
            const weights = _calculateCategoryWeights(categories, categoryWeights);
            
            // Punkte pro Kategorie berechnen
            const categoryScores = _calculateCategoryScores(categories, userAnswers);
            
            // Gewichtete Gesamtpunktzahl berechnen
            let weightedTotalScore = 0;
            let weightedMaxScore = 0;
            
            Object.keys(categoryScores).forEach(category => {
                const score = categoryScores[category];
                const weight = weights[category].normalizedWeight || 0;
                
                weightedTotalScore += score.score * weight;
                weightedMaxScore += score.maxScore * weight;
            });
            
            // Prozentsatz berechnen
            const percentage = weightedMaxScore > 0 ? 
                (weightedTotalScore / weightedMaxScore) * 100 : 0;
            
            // Bestanden/Nicht-Bestanden prüfen
            const passingThreshold = _testConfig.passingThreshold || 50;
            const passed = percentage >= passingThreshold;
            
            // Stärken und Schwächen berechnen
            const strengthsAndWeaknesses = _calculateStrengthsAndWeaknesses(categoryScores);
            
            // Ergebnis erstellen
            return {
                totalScore: weightedTotalScore,
                maxScore: weightedMaxScore,
                percentage: window.ImmoLern.Assessment.Scoring.Calculator.roundScore(percentage),
                passed: passed,
                passingThreshold: passingThreshold,
                categoryScores: categoryScores,
                categoryWeights: weights,
                strengths: strengthsAndWeaknesses.strengths,
                weaknesses: strengthsAndWeaknesses.weaknesses
            };
        },
        
        /**
         * Berechnet Stärken und Schwächen basierend auf Kategorieauswertungen
         * @param {Object} categoryScores - Punktzahlen pro Kategorie
         * @returns {Object} - Stärken und Schwächen mit Prozentsätzen
         */
        calculateStrengthsAndWeaknesses: function(categoryScores) {
            return _calculateStrengthsAndWeaknesses(categoryScores);
        }
    };
})();

// Modul für Bewertungsregeln und Grading
window.ImmoLern.Assessment.Scoring.GradingRules = (function() {
    // Private Variablen
    let _gradingSchemes = {
        // Deutsches Notensystem (1-6)
        'de_school': [
            { minPercentage: 92, grade: '1+', label: 'Sehr gut' },
            { minPercentage: 87, grade: '1', label: 'Sehr gut' },
            { minPercentage: 83, grade: '1-', label: 'Sehr gut' },
            { minPercentage: 78, grade: '2+', label: 'Gut' },
            { minPercentage: 73, grade: '2', label: 'Gut' },
            { minPercentage: 69, grade: '2-', label: 'Gut' },
            { minPercentage: 64, grade: '3+', label: 'Befriedigend' },
            { minPercentage: 59, grade: '3', label: 'Befriedigend' },
            { minPercentage: 55, grade: '3-', label: 'Befriedigend' },
            { minPercentage: 50, grade: '4+', label: 'Ausreichend' },
            { minPercentage: 45, grade: '4', label: 'Ausreichend' },
            { minPercentage: 40, grade: '4-', label: 'Ausreichend' },
            { minPercentage: 33, grade: '5+', label: 'Mangelhaft' },
            { minPercentage: 27, grade: '5', label: 'Mangelhaft' },
            { minPercentage: 20, grade: '5-', label: 'Mangelhaft' },
            { minPercentage: 0, grade: '6', label: 'Ungenügend' }
        ],
        
        // US-Notensystem (A-F)
        'us_school': [
            { minPercentage: 97, grade: 'A+', label: 'Excellent' },
            { minPercentage: 93, grade: 'A', label: 'Excellent' },
            { minPercentage: 90, grade: 'A-', label: 'Excellent' },
            { minPercentage: 87, grade: 'B+', label: 'Good' },
            { minPercentage: 83, grade: 'B', label: 'Good' },
            { minPercentage: 80, grade: 'B-', label: 'Good' },
            { minPercentage: 77, grade: 'C+', label: 'Satisfactory' },
            { minPercentage: 73, grade: 'C', label: 'Satisfactory' },
            { minPercentage: 70, grade: 'C-', label: 'Satisfactory' },
            { minPercentage: 67, grade: 'D+', label: 'Passing' },
            { minPercentage: 63, grade: 'D', label: 'Passing' },
            { minPercentage: 60, grade: 'D-', label: 'Passing' },
            { minPercentage: 0, grade: 'F', label: 'Failing' }
        ],
        
        // Einfaches Bewertungssystem
        'simple': [
            { minPercentage: 90, grade: 'A', label: 'Hervorragend' },
            { minPercentage: 80, grade: 'B', label: 'Sehr gut' },
            { minPercentage: 70, grade: 'C', label: 'Gut' },
            { minPercentage: 60, grade: 'D', label: 'Befriedigend' },
            { minPercentage: 50, grade: 'E', label: 'Ausreichend' },
            { minPercentage: 0, grade: 'F', label: 'Nicht bestanden' }
        ],
        
        // Bestanden/Nicht-Bestanden
        'pass_fail': [
            { minPercentage: 50, grade: 'Bestanden', label: 'Bestanden' },
            { minPercentage: 0, grade: 'Nicht bestanden', label: 'Nicht bestanden' }
        ]
    };
    
    // Private Funktionen
    
    /**
     * Bestimmt die Bewertung basierend auf einem Prozentsatz
     * @param {number} percentage - Der zu bewertende Prozentsatz
     * @param {string} schemeId - ID des Bewertungsschemas
     * @returns {Object} - Die entsprechende Bewertung
     */
    function _getGradeForPercentage(percentage, schemeId = 'simple') {
        const scheme = _gradingSchemes[schemeId] || _gradingSchemes.simple;
        
        // Schema durchlaufen und passende Bewertung finden
        for (const grade of scheme) {
            if (percentage >= grade.minPercentage) {
                return {
                    ...grade,
                    percentage: percentage
                };
            }
        }
        
        // Fallback: niedrigste Bewertung zurückgeben
        return {
            ...scheme[scheme.length - 1],
            percentage: percentage
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Fügt ein benutzerdefiniertes Bewertungsschema hinzu
         * @param {string} schemeId - ID des Schemas
         * @param {Array} scheme - Das Bewertungsschema
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addGradingScheme: function(schemeId, scheme) {
            if (!schemeId || !scheme || !Array.isArray(scheme) || scheme.length === 0) {
                console.error('Ungültiges Bewertungsschema');
                return false;
            }
            
            // Prüfen, ob alle erforderlichen Eigenschaften vorhanden sind
            const isValid = scheme.every(grade => 
                grade.minPercentage !== undefined && 
                grade.grade !== undefined && 
                grade.label !== undefined
            );
            
            if (!isValid) {
                console.error('Ungültiges Bewertungsschema-Format');
                return false;
            }
            
            // Schema nach minPercentage sortieren (absteigend)
            const sortedScheme = [...scheme].sort((a, b) => b.minPercentage - a.minPercentage);
            
            // Schema hinzufügen
            _gradingSchemes[schemeId] = sortedScheme;
            
            return true;
        },
        
        /**
         * Gibt eine Liste aller verfügbaren Bewertungsschemata zurück
         * @returns {Object} - Verfügbare Schemata
         */
        getAvailableSchemes: function() {
            const result = {};
            
            Object.keys(_gradingSchemes).forEach(schemeId => {
                result[schemeId] = {
                    id: schemeId,
                    name: this.getSchemeName(schemeId),
                    gradeCount: _gradingSchemes[schemeId].length
                };
            });
            
            return result;
        },
        
        /**
         * Gibt einen benutzerfreundlichen Namen für ein Schema zurück
         * @param {string} schemeId - ID des Schemas
         * @returns {string} - Benutzerfreundlicher Name
         */
        getSchemeName: function(schemeId) {
            const schemeNames = {
                'de_school': 'Deutsches Notensystem (1-6)',
                'us_school': 'US-Notensystem (A-F)',
                'simple': 'Einfaches Bewertungssystem',
                'pass_fail': 'Bestanden/Nicht-Bestanden'
            };
            
            return schemeNames[schemeId] || schemeId;
        },
        
        /**
         * Ermittelt die Bewertung für einen bestimmten Prozentsatz
         * @param {number} percentage - Der zu bewertende Prozentsatz
         * @param {string} schemeId - ID des Bewertungsschemas
         * @returns {Object} - Die entsprechende Bewertung
         */
        getGrade: function(percentage, schemeId = 'simple') {
            return _getGradeForPercentage(percentage, schemeId);
        },
        
        /**
         * Gibt ein vollständiges Bewertungsschema zurück
         * @param {string} schemeId - ID des Schemas
         * @returns {Array|null} - Das Bewertungsschema oder null, wenn nicht gefunden
         */
        getScheme: function(schemeId) {
            return _gradingSchemes[schemeId] ? [..._gradingSchemes[schemeId]] : null;
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Punkterechner mit Standardeinstellungen initialisieren
    window.ImmoLern.Assessment.Scoring.Calculator.init();
});

// Benutzerdefiniertes Ereignis auslösen, wenn das Modul geladen ist
document.dispatchEvent(new CustomEvent('assessmentScoringLoaded'));
/**
 * JS-Block 6.3.1-part2: Berechnungslogik (Teil 2)
 * 
 * Erweiterte Funktionen zur Punkteberechnung:
 * - Vergleichsanalysen zwischen Testdurchläufen
 * - Wachstumsmetriken für Lernfortschritt
 * - Adaptive Bewertung basierend auf Schwierigkeitsgraden
 * - Zeitbasierte Bewertungsfaktoren
 * - Gruppenübergreifende Analysen
 * - Leistungsmetriken und Trends
 */

// Namespace für erweiterte Punkteberechnung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Scoring) window.ImmoLern.Assessment.Scoring = {};

// Modul für erweiterte Bewertungsmetriken
window.ImmoLern.Assessment.Scoring.AdvancedMetrics = (function() {
    // Private Variablen
    let _difficultyLevels = {
        'easy': 0.8,     // Einfache Fragen sind mit 0.8 gewichtet
        'medium': 1.0,   // Mittlere Fragen haben Standardgewichtung
        'hard': 1.5,     // Schwere Fragen zählen 1.5-fach
        'expert': 2.0    // Expertenfragen zählen 2-fach
    };
    
    let _timeFactors = {
        maxTimeBonus: 0.1,         // Maximal 10% Bonus für schnelle Bearbeitung
        maxTimePenalty: 0.2,       // Maximal 20% Abzug für sehr langsame Bearbeitung
        optimalTimePercentage: 0.6, // 60% der maximalen Zeit ist optimal
        enabled: false              // Standardmäßig deaktiviert
    };
    
    // Private Funktionen
    
    /**
     * Berechnet den Schwierigkeitsfaktor für eine Frage
     * @param {Object} question - Die Frage
     * @returns {number} - Der Schwierigkeitsfaktor
     */
    function _calculateDifficultyFactor(question) {
        if (!question) return 1.0;
        
        const difficulty = question.difficulty || 'medium';
        return _difficultyLevels[difficulty] || 1.0;
    }
    
    /**
     * Berechnet den Zeitfaktor für eine Antwort
     * @param {number} timeSpent - Verwendete Zeit in Millisekunden
     * @param {number} maxTime - Maximale Zeit in Millisekunden
     * @returns {number} - Der Zeitfaktor (1.0 bedeutet keine Anpassung)
     */
    function _calculateTimeFactor(timeSpent, maxTime) {
        // Wenn zeitbasierte Faktoren deaktiviert sind, keine Anpassung
        if (!_timeFactors.enabled || !timeSpent || !maxTime || maxTime <= 0) {
            return 1.0;
        }
        
        // Zeitverbrauch als Prozentsatz der maximalen Zeit
        const timePercentage = timeSpent / maxTime;
        
        // Optimale Zeit definieren
        const optimalTime = maxTime * _timeFactors.optimalTimePercentage;
        
        // Wenn schneller als optimal, Bonus geben
        if (timeSpent < optimalTime) {
            // Berechnung wie viel schneller als optimal (0-1 Skala)
            const bonusFactor = (optimalTime - timeSpent) / optimalTime;
            // Bonus berechnen, maximal _timeFactors.maxTimeBonus
            return 1.0 + (bonusFactor * _timeFactors.maxTimeBonus);
        } 
        // Wenn langsamer als maximal, Abzug geben
        else if (timeSpent > maxTime) {
            // Bei Überschreitung maximale Strafe anwenden
            return 1.0 - _timeFactors.maxTimePenalty;
        }
        // Wenn zwischen optimal und maximal, anteiligen Abzug berechnen
        else {
            // Berechnung wie viel langsamer als optimal (0-1 Skala)
            const penaltyFactor = (timeSpent - optimalTime) / (maxTime - optimalTime);
            // Abzug berechnen, maximal _timeFactors.maxTimePenalty
            return 1.0 - (penaltyFactor * _timeFactors.maxTimePenalty);
        }
    }
    
    /**
     * Berechnet die Verbesserung zwischen zwei Testergebnissen
     * @param {Object} previousResult - Vorheriges Testergebnis
     * @param {Object} currentResult - Aktuelles Testergebnis
     * @returns {Object} - Verbesserungsdaten
     */
    function _calculateImprovement(previousResult, currentResult) {
        if (!previousResult || !currentResult) {
            return {
                hasImproved: false,
                improvementPoints: 0,
                improvementPercentage: 0
            };
        }
        
        // Punktzahlen extrahieren
        const prevPercentage = previousResult.percentage || 0;
        const currPercentage = currentResult.percentage || 0;
        
        // Verbesserung berechnen
        const pointsDifference = currPercentage - prevPercentage;
        
        // Prozentuale Verbesserung berechnen (relativ zum vorherigen Ergebnis)
        let percentageImprovement = 0;
        if (prevPercentage > 0) {
            percentageImprovement = (pointsDifference / prevPercentage) * 100;
        }
        
        return {
            hasImproved: pointsDifference > 0,
            improvementPoints: pointsDifference,
            improvementPercentage: percentageImprovement,
            previousResult: {
                percentage: prevPercentage,
                score: previousResult.score,
                maxScore: previousResult.maxScore
            },
            currentResult: {
                percentage: currPercentage,
                score: currentResult.score,
                maxScore: currentResult.maxScore
            }
        };
    }
    
    /**
     * Identifiziert Muster in den Antworten eines Benutzers
     * @param {Array} questions - Die Testfragen
     * @param {Object} userAnswers - Die Antworten des Benutzers
     * @returns {Object} - Identifizierte Antwortmuster
     */
    function _identifyAnswerPatterns(questions, userAnswers) {
        if (!questions || !userAnswers) {
            return {
                patterns: [],
                insights: []
            };
        }
        
        const patterns = {
            // Zähler für verschiedene Mustertypen
            skippedQuestions: 0,
            correctAnswers: 0,
            incorrectAnswers: 0,
            
            // Muster nach Frage- und Antworttypen
            byQuestionType: {},
            byDifficulty: {},
            byCategory: {},
            
            // Zeitbezogene Muster
            timeDistribution: {
                fast: 0,
                average: 0,
                slow: 0
            },
            
            // Fehlerhafte Antwortmuster
            errorPatterns: [],
            
            // Stärken und Schwächen
            strengths: [],
            weaknesses: []
        };
        
        // Alle Fragen durchgehen und Muster identifizieren
        questions.forEach(question => {
            const questionId = question.id;
            const userAnswer = userAnswers[questionId];
            
            // Übersprungende Fragen
            if (userAnswer === undefined || userAnswer === null) {
                patterns.skippedQuestions++;
                return;
            }
            
            // Antwort bewerten
            const score = window.ImmoLern.Assessment.Scoring.Calculator.calculateQuestionScore(question, userAnswer);
            const maxScore = question.points || 1;
            const isCorrect = score >= maxScore * 0.5; // Als "korrekt" gilt, wenn mind. 50% der Punkte erreicht wurden
            
            // Zähler aktualisieren
            if (isCorrect) {
                patterns.correctAnswers++;
            } else {
                patterns.incorrectAnswers++;
            }
            
            // Nach Fragetyp gruppieren
            const questionType = question.type || 'unknown';
            if (!patterns.byQuestionType[questionType]) {
                patterns.byQuestionType[questionType] = { correct: 0, incorrect: 0, total: 0 };
            }
            patterns.byQuestionType[questionType].total++;
            if (isCorrect) {
                patterns.byQuestionType[questionType].correct++;
            } else {
                patterns.byQuestionType[questionType].incorrect++;
            }
            
            // Nach Schwierigkeitsgrad gruppieren
            const difficulty = question.difficulty || 'medium';
            if (!patterns.byDifficulty[difficulty]) {
                patterns.byDifficulty[difficulty] = { correct: 0, incorrect: 0, total: 0 };
            }
            patterns.byDifficulty[difficulty].total++;
            if (isCorrect) {
                patterns.byDifficulty[difficulty].correct++;
            } else {
                patterns.byDifficulty[difficulty].incorrect++;
            }
            
            // Nach Kategorie gruppieren
            const category = question.category || 'uncategorized';
            if (!patterns.byCategory[category]) {
                patterns.byCategory[category] = { correct: 0, incorrect: 0, total: 0 };
            }
            patterns.byCategory[category].total++;
            if (isCorrect) {
                patterns.byCategory[category].correct++;
            } else {
                patterns.byCategory[category].incorrect++;
            }
            
            // Zeitbezogene Muster (falls verfügbar)
            if (userAnswer.timeSpent && question.expectedTime) {
                const timeRatio = userAnswer.timeSpent / question.expectedTime;
                if (timeRatio < 0.7) {
                    patterns.timeDistribution.fast++;
                } else if (timeRatio > 1.3) {
                    patterns.timeDistribution.slow++;
                } else {
                    patterns.timeDistribution.average++;
                }
            }
            
            // Fehlermuster bei falschen Antworten sammeln
            if (!isCorrect && question.type === 'multiple_choice' || question.type === 'single_choice') {
                // Für Multiple-Choice und Single-Choice
                const selectedAnswers = Array.isArray(userAnswer) ? userAnswer : [userAnswer];
                
                // Falsch ausgewählte Antwortoptionen
                const wrongSelections = selectedAnswers.filter(answerId => {
                    const answerOption = question.answers.find(a => a.id === answerId);
                    return answerOption && !answerOption.isCorrect;
                });
                
                // Korrekte Optionen, die nicht ausgewählt wurden
                const missedCorrectOptions = question.answers
                    .filter(a => a.isCorrect && !selectedAnswers.includes(a.id))
                    .map(a => a.id);
                
                if (wrongSelections.length > 0 || missedCorrectOptions.length > 0) {
                    patterns.errorPatterns.push({
                        questionId: questionId,
                        type: question.type,
                        category: category,
                        wrongSelections: wrongSelections,
                        missedCorrectOptions: missedCorrectOptions
                    });
                }
            }
        });
        
        // Stärken und Schwächen basierend auf Kategorien identifizieren
        const categoryPerformance = [];
        Object.keys(patterns.byCategory).forEach(category => {
            const data = patterns.byCategory[category];
            if (data.total > 0) {
                const correctPercentage = (data.correct / data.total) * 100;
                categoryPerformance.push({
                    category: category,
                    percentage: correctPercentage
                });
            }
        });
        
        // Sortieren nach Leistung (absteigend)
        categoryPerformance.sort((a, b) => b.percentage - a.percentage);
        
        // Top 3 Stärken
        patterns.strengths = categoryPerformance.slice(0, 3).map(item => ({
            category: item.category,
            percentage: item.percentage
        }));
        
        // Bottom 3 Schwächen
        patterns.weaknesses = categoryPerformance.slice(-3).map(item => ({
            category: item.category,
            percentage: item.percentage
        })).reverse();
        
        // Erkenntnisse aus den Mustern generieren
        const insights = _generateInsightsFromPatterns(patterns, questions.length);
        
        return {
            patterns: patterns,
            insights: insights
        };
    }
    
    /**
     * Generiert Erkenntnisse aus identifizierten Antwortmustern
     * @param {Object} patterns - Die identifizierten Muster
     * @param {number} totalQuestions - Gesamtzahl der Fragen
     * @returns {Array} - Liste von Erkenntnissen
     */
    function _generateInsightsFromPatterns(patterns, totalQuestions) {
        const insights = [];
        
        // Übersprungene Fragen
        if (patterns.skippedQuestions > 0) {
            const skippedPercentage = (patterns.skippedQuestions / totalQuestions) * 100;
            if (skippedPercentage > 20) {
                insights.push({
                    type: 'warning',
                    message: `Sie haben ${patterns.skippedQuestions} Fragen (${skippedPercentage.toFixed(0)}%) übersprungen. Versuchen Sie, alle Fragen zu beantworten, auch wenn Sie sich nicht sicher sind.`
                });
            }
        }
        
        // Fragetypen analysieren
        Object.keys(patterns.byQuestionType).forEach(type => {
            const data = patterns.byQuestionType[type];
            if (data.total >= 3) { // Nur Typen mit ausreichender Anzahl an Fragen
                const correctPercentage = (data.correct / data.total) * 100;
                
                // Schwächen bei Fragetypen
                if (correctPercentage < 40) {
                    insights.push({
                        type: 'weakness',
                        message: `Bei ${_getQuestionTypeLabel(type)}-Fragen liegt Ihre Erfolgsquote bei nur ${correctPercentage.toFixed(0)}%. Hier besteht Verbesserungsbedarf.`
                    });
                }
                // Stärken bei Fragetypen
                else if (correctPercentage > 80) {
                    insights.push({
                        type: 'strength',
                        message: `Bei ${_getQuestionTypeLabel(type)}-Fragen liegt Ihre Erfolgsquote bei ${correctPercentage.toFixed(0)}%. Das ist eine Ihrer Stärken.`
                    });
                }
            }
        });
        
        // Schwierigkeitsgrade analysieren
        if (patterns.byDifficulty.hard && patterns.byDifficulty.hard.total > 0) {
            const hardCorrectPercentage = (patterns.byDifficulty.hard.correct / patterns.byDifficulty.hard.total) * 100;
            if (hardCorrectPercentage > 70) {
                insights.push({
                    type: 'achievement',
                    message: `Sie haben ${hardCorrectPercentage.toFixed(0)}% der schwierigen Fragen richtig beantwortet. Das ist beeindruckend!`
                });
            }
        }
        
        // Zeitverteilung analysieren
        const totalTimeResponses = patterns.timeDistribution.fast + patterns.timeDistribution.average + patterns.timeDistribution.slow;
        if (totalTimeResponses > 0) {
            const fastPercentage = (patterns.timeDistribution.fast / totalTimeResponses) * 100;
            const slowPercentage = (patterns.timeDistribution.slow / totalTimeResponses) * 100;
            
            if (fastPercentage > 50) {
                insights.push({
                    type: 'speed',
                    message: `Sie haben mehr als die Hälfte der Fragen schneller als erwartet beantwortet. Achten Sie darauf, dass die Geschwindigkeit nicht auf Kosten der Genauigkeit geht.`
                });
            } else if (slowPercentage > 50) {
                insights.push({
                    type: 'speed',
                    message: `Sie haben mehr als die Hälfte der Fragen langsamer als erwartet beantwortet. Arbeiten Sie an Ihrer Geschwindigkeit, um effizienter zu werden.`
                });
            }
        }
        
        // Häufige Fehlermuster analysieren
        if (patterns.errorPatterns.length > 0) {
            // Zählen, wie oft bestimmte Kategorien in Fehlermustern auftauchen
            const categoryErrorCounts = {};
            patterns.errorPatterns.forEach(error => {
                if (!categoryErrorCounts[error.category]) {
                    categoryErrorCounts[error.category] = 0;
                }
                categoryErrorCounts[error.category]++;
            });
            
            // Kategorien mit den meisten Fehlern identifizieren
            const sortedErrorCategories = Object.keys(categoryErrorCounts)
                .sort((a, b) => categoryErrorCounts[b] - categoryErrorCounts[a]);
            
            if (sortedErrorCategories.length > 0) {
                const worstCategory = sortedErrorCategories[0];
                insights.push({
                    type: 'improvement',
                    message: `Die meisten Fehler traten in der Kategorie "${worstCategory}" auf. Konzentrieren Sie sich auf diesen Bereich, um Ihre Gesamtleistung zu verbessern.`
                });
            }
        }
        
        return insights;
    }
    
    /**
     * Gibt ein benutzerfreundliches Label für einen Fragetyp zurück
     * @param {string} type - Der Fragetyp
     * @returns {string} - Das benutzerfreundliche Label
     */
    function _getQuestionTypeLabel(type) {
        const labels = {
            'multiple_choice': 'Multiple-Choice',
            'single_choice': 'Single-Choice',
            'true_false': 'Wahr/Falsch',
            'free_text': 'Freitext'
        };
        
        return labels[type] || type;
    }
    
    /**
     * Berechnet die adaptive Punktzahl basierend auf Schwierigkeit und Zeit
     * @param {number} baseScore - Die Basispunktzahl
     * @param {Object} question - Die Frage
     * @param {Object} userAnswer - Die Antwort des Benutzers
     * @returns {number} - Die angepasste Punktzahl
     */
    function _calculateAdaptiveScore(baseScore, question, userAnswer) {
        if (!question || baseScore === undefined) {
            return baseScore || 0;
        }
        
        // Basispunktzahl
        let adaptiveScore = baseScore;
        
        // Schwierigkeitsfaktor anwenden
        const difficultyFactor = _calculateDifficultyFactor(question);
        adaptiveScore *= difficultyFactor;
        
        // Zeitfaktor anwenden, falls Zeitdaten vorhanden sind
        if (userAnswer && userAnswer.timeSpent && question.expectedTime) {
            const timeFactor = _calculateTimeFactor(userAnswer.timeSpent, question.expectedTime);
            adaptiveScore *= timeFactor;
        }
        
        // Rundung anwenden
        return window.ImmoLern.Assessment.Scoring.Calculator.roundScore(adaptiveScore);
    }
    
    /**
     * Berechnet die Lernkurve basierend auf mehreren Testdurchläufen
     * @param {Array} testResults - Liste von Testergebnissen
     * @returns {Object} - Lernkurvenanalyse
     */
    function _calculateLearningCurve(testResults) {
        if (!testResults || testResults.length < 2) {
            return {
                hasEnoughData: false,
                dataPoints: [],
                trend: 'insufficient_data',
                improvement: 0,
                slope: 0,
                prediction: null
            };
        }
        
        // Ergebnisse nach Datum sortieren
        const sortedResults = [...testResults].sort((a, b) => {
            return new Date(a.timestamp) - new Date(b.timestamp);
        });
        
        // Datenpunkte extrahieren
        const dataPoints = sortedResults.map((result, index) => {
            return {
                x: index,
                y: result.percentage || 0,
                timestamp: result.timestamp,
                testId: result.testId
            };
        });
        
        // Lineare Regression berechnen
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;
        const n = dataPoints.length;
        
        dataPoints.forEach(point => {
            sumX += point.x;
            sumY += point.y;
            sumXY += point.x * point.y;
            sumXX += point.x * point.x;
        });
        
        // Steigung und y-Achsenabschnitt berechnen
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Vorhersage für den nächsten Versuch
        const nextX = n;
        const predictedScore = Math.min(100, Math.max(0, intercept + slope * nextX));
        
        // Gesamtverbesserung berechnen
        const firstScore = dataPoints[0].y;
        const lastScore = dataPoints[dataPoints.length - 1].y;
        const improvement = lastScore - firstScore;
        
        // Trend bestimmen
        let trend;
        if (slope >= 5) {
            trend = 'rapid_improvement';
        } else if (slope >= 2) {
            trend = 'steady_improvement';
        } else if (slope >= 0) {
            trend = 'slight_improvement';
        } else if (slope >= -2) {
            trend = 'slight_decline';
        } else {
            trend = 'significant_decline';
        }
        
        return {
            hasEnoughData: true,
            dataPoints: dataPoints,
            trend: trend,
            improvement: improvement,
            slope: slope,
            intercept: intercept,
            prediction: {
                nextAttempt: nextX,
                predictedScore: predictedScore
            }
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul mit benutzerdefinierten Einstellungen
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Schwierigkeitsgrade aktualisieren, falls angegeben
            if (options.difficultyLevels) {
                _difficultyLevels = {
                    ..._difficultyLevels,
                    ...options.difficultyLevels
                };
            }
            
            // Zeitfaktoren aktualisieren, falls angegeben
            if (options.timeFactors) {
                _timeFactors = {
                    ..._timeFactors,
                    ...options.timeFactors
                };
            }
            
            return this;
        },
        
        /**
         * Berechnet eine adaptive Punktzahl mit Berücksichtigung von Schwierigkeit und Zeit
         * @param {number} baseScore - Die Basispunktzahl
         * @param {Object} question - Die Frage
         * @param {Object} userAnswer - Die Antwort des Benutzers
         * @returns {number} - Die angepasste Punktzahl
         */
        calculateAdaptiveScore: function(baseScore, question, userAnswer) {
            return _calculateAdaptiveScore(baseScore, question, userAnswer);
        },
        
        /**
         * Berechnet adaptive Punktzahlen für alle Fragen eines Tests
         * @param {Array} questions - Die Testfragen
         * @param {Object} userAnswers - Die Antworten des Benutzers
         * @returns {Array} - Liste von Fragen mit adaptiven Punktzahlen
         */
        calculateAdaptiveTest: function(questions, userAnswers) {
            if (!questions || !userAnswers) {
                return [];
            }
            
            return questions.map(question => {
                const userAnswer = userAnswers[question.id];
                const baseScore = window.ImmoLern.Assessment.Scoring.Calculator.calculateQuestionScore(question, userAnswer);
                const adaptiveScore = _calculateAdaptiveScore(baseScore, question, userAnswer);
                
                return {
                    questionId: question.id,
                    baseScore: baseScore,
                    adaptiveScore: adaptiveScore,
                    maxScore: question.points || 1,
                    difficulty: question.difficulty || 'medium',
                    difficultyFactor: _calculateDifficultyFactor(question)
                };
            });
        },
        
        /**
         * Berechnet die Verbesserung zwischen zwei Testergebnissen
         * @param {Object} previousResult - Vorheriges Testergebnis
         * @param {Object} currentResult - Aktuelles Testergebnis
         * @returns {Object} - Verbesserungsdaten
         */
        calculateImprovement: function(previousResult, currentResult) {
            return _calculateImprovement(previousResult, currentResult);
        },
        
        /**
         * Analysiert Muster in den Antworten eines Benutzers
         * @param {Array} questions - Die Testfragen
         * @param {Object} userAnswers - Die Antworten des Benutzers
         * @returns {Object} - Identifizierte Antwortmuster und Erkenntnisse
         */
        analyzeAnswerPatterns: function(questions, userAnswers) {
            return _identifyAnswerPatterns(questions, userAnswers);
        },
        
        /**
         * Berechnet die Lernkurve basierend auf mehreren Testdurchläufen
         * @param {Array} testResults - Liste von Testergebnissen
         * @returns {Object} - Lernkurvenanalyse
         */
        calculateLearningCurve: function(testResults) {
            return _calculateLearningCurve(testResults);
        },
        
        /**
         * Aktiviert oder deaktiviert zeitbasierte Bewertungsfaktoren
         * @param {boolean} enabled - Ob zeitbasierte Faktoren aktiviert werden sollen
         * @returns {Object} - Die aktualisierten Zeitfaktoren
         */
        setTimeFactorsEnabled: function(enabled) {
            _timeFactors.enabled = !!enabled;
            return { ..._timeFactors };
        }
    };
})();

// Modul für Vergleichsanalysen
window.ImmoLern.Assessment.Scoring.Comparisons = (function() {
    // Private Variablen
    let _benchmarks = {
        byTest: {},          // Durchschnittswerte nach Test-ID
        byCategory: {},      // Durchschnittswerte nach Kategorie
        byGroupAndTest: {}   // Durchschnittswerte nach Gruppe und Test
    };
    
    let _comparisonModels = {
        'percentile': {
            // Perzentilgrenzen für die Interpretation
            'excellent': 90,  // 90. Perzentil oder höher
            'good': 75,       // 75. Perzentil oder höher
            'average': 50,    // 50. Perzentil oder höher
            'below_average': 25, // 25. Perzentil oder höher
            'poor': 0         // Unter dem 25. Perzentil
        },
        'z_score': {
            // Z-Score Grenzen für die Interpretation
            'excellent': 1.5,  // 1.5 Standardabweichungen über dem Durchschnitt
            'good': 0.5,       // 0.5 Standardabweichungen über dem Durchschnitt
            'average': -0.5,   // Zwischen -0.5 und 0.5 Standardabweichungen
            'below_average': -1.5, // Zwischen -1.5 und -0.5 Standardabweichungen
            'poor': -999       // Unter -1.5 Standardabweichungen
        }
    };
    
    // Private Funktionen
    
    /**
     * Berechnet die Perzentil-Position eines Werts in einer Liste
     * @param {number} value - Der zu prüfende Wert
     * @param {Array} values - Die Liste der Vergleichswerte
     * @returns {number} - Der Perzentil-Rang (0-100)
     */
    function _calculatePercentile(value, values) {
        if (!values || values.length === 0) {
            return 50; // Standardwert bei fehlenden Daten
        }
        
        // Werte sortieren (aufsteigend)
        const sortedValues = [...values].sort((a, b) => a - b);
        
        // Anzahl der Werte kleiner als der gegebene Wert
        const smaller = sortedValues.filter(v => v < value).length;
        
        // Anzahl der Werte gleich dem gegebenen Wert
        const equal = sortedValues.filter(v => v === value).length;
        
        // Perzentil berechnen (Formel: (kleinere + 0.5*gleiche) / Gesamtanzahl * 100)
        return ((smaller + 0.5 * equal) / sortedValues.length) * 100;
    }
    
    /**
     * Berechnet den Z-Score eines Werts
     * @param {number} value - Der zu prüfende Wert
     * @param {number} mean - Der Durchschnittswert
     * @param {number} stdDev - Die Standardabweichung
     * @returns {number} - Der Z-Score
     */
    function _calculateZScore(value, mean, stdDev) {
        if (stdDev === 0) {
            return 0; // Vermeiden von Division durch Null
        }
        
        return (value - mean) / stdDev;
    }
    
    /**
     * Berechnet statistische Kennzahlen für eine Werteliste
     * @param {Array} values - Die zu analysierenden Werte
     * @returns {Object} - Statistische Kennzahlen
     */
    function _calculateStatistics(values) {
        if (!values || values.length === 0) {
            return {
                count: 0,
                min: 0,
                max: 0,
                mean: 0,
                median: 0,
                stdDev: 0,
                percentiles: {}
            };
        }
        
        // Sortierte Kopie der Werte
        const sortedValues = [...values].sort((a, b) => a - b);
        
        // Grundlegende Statistiken
        const count = values.length;
        const min = sortedValues[0];
        const max = sortedValues[count - 1];
        const sum = values.reduce((a, b) => a + b, 0);
        const mean = sum / count;
        
        // Median berechnen
        let median;
        if (count % 2 === 0) {
            // Gerade Anzahl: Durchschnitt der beiden mittleren Werte
            const mid1 = sortedValues[count / 2 - 1];
            const mid2 = sortedValues[count / 2];
            median = (mid1 + mid2) / 2;
        } else {
            // Ungerade Anzahl: Mittlerer Wert
            median = sortedValues[Math.floor(count / 2)];
        }
        
        // Standardabweichung berechnen
        const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
        const stdDev = Math.sqrt(variance);
        
        // Perzentile berechnen
        const percentiles = {
            p10: sortedValues[Math.floor(count * 0.1)],
            p25: sortedValues[Math.floor(count * 0.25)],
            p50: median,
            p75: sortedValues[Math.floor(count * 0.75)],
            p90: sortedValues[Math.floor(count * 0.9)]
        };
        
        return {
            count,
            min,
            max,
            mean,
            median,
            stdDev,
            percentiles
        };
    }
    
    /**
     * Aktualisiert die Benchmark-Daten mit einem neuen Testergebnis
     * @param {Object} testResult - Das Testergebnis
     */
    function _updateBenchmarks(testResult) {
        if (!testResult || !testResult.testId) {
            return;
        }
        
        // Nach Test-ID
        if (!_benchmarks.byTest[testResult.testId]) {
            _benchmarks.byTest[testResult.testId] = {
                values: [],
                stats: null,
                lastUpdated: null
            };
        }
        
        _benchmarks.byTest[testResult.testId].values.push(testResult.percentage);
        _benchmarks.byTest[testResult.testId].lastUpdated = new Date().toISOString();
        
        // Statistik neu berechnen
        _benchmarks.byTest[testResult.testId].stats = _calculateStatistics(_benchmarks.byTest[testResult.testId].values);
        
        // Nach Kategorie
        if (testResult.categoryScores) {
            Object.keys(testResult.categoryScores).forEach(category => {
                if (!_benchmarks.byCategory[category]) {
                    _benchmarks.byCategory[category] = {
                        values: [],
                        stats: null,
                        lastUpdated: null
                    };
                }
                
                _benchmarks.byCategory[category].values.push(testResult.categoryScores[category].percentage);
                _benchmarks.byCategory[category].lastUpdated = new Date().toISOString();
                
                // Statistik neu berechnen
                _benchmarks.byCategory[category].stats = _calculateStatistics(_benchmarks.byCategory[category].values);
            });
        }
        
        // Nach Gruppe und Test
        if (testResult.groupId) {
            const groupTestKey = `${testResult.groupId}_${testResult.testId}`;
            
            if (!_benchmarks.byGroupAndTest[groupTestKey]) {
                _benchmarks.byGroupAndTest[groupTestKey] = {
                    values: [],
                    stats: null,
                    lastUpdated: null
                };
            }
            
            _benchmarks.byGroupAndTest[groupTestKey].values.push(testResult.percentage);
            _benchmarks.byGroupAndTest[groupTestKey].lastUpdated = new Date().toISOString();
            
            // Statistik neu berechnen
            _benchmarks.byGroupAndTest[groupTestKey].stats = _calculateStatistics(_benchmarks.byGroupAndTest[groupTestKey].values);
        }
    }
    
    /**
     * Evaluiert die Leistung eines Benutzers im Vergleich zu Benchmarks
     * @param {number} value - Der Wert
     * @param {Object} benchmarkStats - Die Benchmark-Statistiken
     * @param {string} model - Das Vergleichsmodell ('percentile' oder 'z_score')
     * @returns {Object} - Die Leistungsbewertung
     */
    function _evaluatePerformance(value, benchmarkStats, model = 'percentile') {
        if (!benchmarkStats || !benchmarkStats.count) {
            return {
                level: 'no_data',
                label: 'Keine Vergleichsdaten',
                comparison: null,
                value: value
            };
        }
        
        let level, comparison;
        
        if (model === 'z_score') {
            // Z-Score berechnen
            const zScore = _calculateZScore(value, benchmarkStats.mean, benchmarkStats.stdDev);
            comparison = zScore;
            
            // Leistungsstufe bestimmen
            const thresholds = _comparisonModels.z_score;
            if (zScore >= thresholds.excellent) level = 'excellent';
            else if (zScore >= thresholds.good) level = 'good';
            else if (zScore >= thresholds.average) level = 'average';
            else if (zScore >= thresholds.below_average) level = 'below_average';
            else level = 'poor';
        } else {
            // Perzentil berechnen
            const percentile = _calculatePercentile(value, benchmarkStats.values);
            comparison = percentile;
            
            // Leistungsstufe bestimmen
            const thresholds = _comparisonModels.percentile;
            if (percentile >= thresholds.excellent) level = 'excellent';
            else if (percentile >= thresholds.good) level = 'good';
            else if (percentile >= thresholds.average) level = 'average';
            else if (percentile >= thresholds.below_average) level = 'below_average';
            else level = 'poor';
        }
        
        // Benutzerfreundliches Label für die Leistungsstufe
        const labels = {
            'excellent': 'Hervorragend',
            'good': 'Gut',
            'average': 'Durchschnittlich',
            'below_average': 'Unterdurchschnittlich',
            'poor': 'Verbesserungsbedürftig',
            'no_data': 'Keine Vergleichsdaten'
        };
        
        return {
            level: level,
            label: labels[level] || level,
            comparison: comparison,
            value: value,
            benchmarkStats: {
                mean: benchmarkStats.mean,
                median: benchmarkStats.median,
                stdDev: benchmarkStats.stdDev,
                count: benchmarkStats.count
            }
        };
    }
    
    /**
     * Vergleicht Kategorien miteinander, um Stärken und Schwächen zu identifizieren
     * @param {Object} categoryScores - Die Punktzahlen pro Kategorie
     * @returns {Object} - Vergleichsergebnisse
     */
    function _compareCategoryPerformance(categoryScores) {
        if (!categoryScores || Object.keys(categoryScores).length === 0) {
            return {
                strengths: [],
                weaknesses: [],
                overall: 'no_data'
            };
        }
        
        // Kategorien nach Leistung sortieren
        const sortedCategories = Object.keys(categoryScores).map(category => {
            return {
                category: category,
                percentage: categoryScores[category].percentage,
                score: categoryScores[category].score,
                maxScore: categoryScores[category].maxScore
            };
        }).sort((a, b) => b.percentage - a.percentage);
        
        // Durchschnittliche Leistung berechnen
        const avgPercentage = sortedCategories.reduce((sum, item) => sum + item.percentage, 0) / sortedCategories.length;
        
        // Stärken: 10% besser als Durchschnitt
        const strengths = sortedCategories.filter(item => item.percentage >= avgPercentage * 1.1);
        
        // Schwächen: 10% schlechter als Durchschnitt
        const weaknesses = sortedCategories.filter(item => item.percentage <= avgPercentage * 0.9);
        
        // Gesamtbewertung basierend auf Standardabweichung
        const percentages = sortedCategories.map(item => item.percentage);
        const stats = _calculateStatistics(percentages);
        
        // Gleichmäßigkeit der Leistung bewerten
        let overall;
        const variationCoefficient = stats.stdDev / stats.mean;
        
        if (variationCoefficient < 0.1) {
            overall = 'very_consistent';
        } else if (variationCoefficient < 0.2) {
            overall = 'consistent';
        } else if (variationCoefficient < 0.3) {
            overall = 'somewhat_consistent';
        } else if (variationCoefficient < 0.5) {
            overall = 'inconsistent';
        } else {
            overall = 'very_inconsistent';
        }
        
        return {
            strengths: strengths,
            weaknesses: weaknesses,
            average: avgPercentage,
            overall: overall,
            variationCoefficient: variationCoefficient,
            sortedCategories: sortedCategories
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Lädt Benchmark-Daten
         * @param {Object} benchmarkData - Die zu ladenden Benchmark-Daten
         */
        loadBenchmarks: function(benchmarkData) {
            if (benchmarkData && typeof benchmarkData === 'object') {
                if (benchmarkData.byTest) _benchmarks.byTest = benchmarkData.byTest;
                if (benchmarkData.byCategory) _benchmarks.byCategory = benchmarkData.byCategory;
                if (benchmarkData.byGroupAndTest) _benchmarks.byGroupAndTest = benchmarkData.byGroupAndTest;
            }
            
            return this;
        },
        
        /**
         * Fügt ein Testergebnis zu den Benchmark-Daten hinzu
         * @param {Object} testResult - Das hinzuzufügende Testergebnis
         */
        addToBenchmarks: function(testResult) {
            _updateBenchmarks(testResult);
            return this;
        },
        
        /**
         * Gibt die aktuellen Benchmark-Daten zurück
         * @returns {Object} - Die Benchmark-Daten
         */
        getBenchmarks: function() {
            return { ..._benchmarks };
        },
        
        /**
         * Gibt Benchmark-Statistiken für einen bestimmten Test zurück
         * @param {string} testId - ID des Tests
         * @returns {Object|null} - Die Benchmark-Statistiken oder null, wenn nicht vorhanden
         */
        getTestBenchmark: function(testId) {
            return _benchmarks.byTest[testId] ? { ..._benchmarks.byTest[testId] } : null;
        },
        
        /**
         * Vergleicht ein Testergebnis mit den Benchmarks
         * @param {Object} testResult - Das zu vergleichende Testergebnis
         * @param {string} model - Das Vergleichsmodell ('percentile' oder 'z_score')
         * @returns {Object} - Die Vergleichsergebnisse
         */
        compareWithBenchmarks: function(testResult, model = 'percentile') {
            if (!testResult) {
                return {
                    overall: {
                        level: 'no_data',
                        label: 'Keine Daten',
                        comparison: null
                    },
                    categories: {}
                };
            }
            
            const results = {
                overall: {
                    level: 'no_data',
                    label: 'Keine Vergleichsdaten',
                    comparison: null,
                    value: testResult.percentage
                },
                categories: {}
            };
            
            // Gesamtleistung vergleichen
            if (testResult.testId && _benchmarks.byTest[testResult.testId]) {
                results.overall = _evaluatePerformance(
                    testResult.percentage,
                    _benchmarks.byTest[testResult.testId].stats,
                    model
                );
            }
            
            // Kategorien vergleichen
            if (testResult.categoryScores) {
                Object.keys(testResult.categoryScores).forEach(category => {
                    const categoryPercentage = testResult.categoryScores[category].percentage;
                    
                    if (_benchmarks.byCategory[category]) {
                        results.categories[category] = _evaluatePerformance(
                            categoryPercentage,
                            _benchmarks.byCategory[category].stats,
                            model
                        );
                    } else {
                        results.categories[category] = {
                            level: 'no_data',
                            label: 'Keine Vergleichsdaten',
                            comparison: null,
                            value: categoryPercentage
                        };
                    }
                });
            }
            
            // Gruppen-Vergleich hinzufügen, falls verfügbar
            if (testResult.groupId && testResult.testId) {
                const groupTestKey = `${testResult.groupId}_${testResult.testId}`;
                
                if (_benchmarks.byGroupAndTest[groupTestKey]) {
                    results.groupComparison = _evaluatePerformance(
                        testResult.percentage,
                        _benchmarks.byGroupAndTest[groupTestKey].stats,
                        model
                    );
                }
            }
            
            return results;
        },
        
        /**
         * Vergleicht die Leistung in verschiedenen Kategorien
         * @param {Object} categoryScores - Die Punktzahlen pro Kategorie
         * @returns {Object} - Vergleichsergebnisse
         */
        compareCategoryPerformance: function(categoryScores) {
            return _compareCategoryPerformance(categoryScores);
        },
        
        /**
         * Erstellt einen detaillierten Vergleichsbericht
         * @param {Object} testResult - Das Testergebnis
         * @param {Array} userHistory - Frühere Ergebnisse des Benutzers
         * @returns {Object} - Der Vergleichsbericht
         */
        createDetailedComparisonReport: function(testResult, userHistory = []) {
            if (!testResult) {
                return {
                    status: 'error',
                    message: 'Keine Testdaten vorhanden'
                };
            }
            
            const report = {
                testId: testResult.testId,
                userId: testResult.userId,
                timestamp: testResult.timestamp,
                score: testResult.score,
                maxScore: testResult.maxScore,
                percentage: testResult.percentage,
                passed: testResult.passed,
                comparisons: {},
                historicalTrend: null,
                categoryComparison: null,
                insights: []
            };
            
            // Benchmark-Vergleich
            report.comparisons = this.compareWithBenchmarks(testResult);
            
            // Lernkurve analysieren, falls Verlaufsdaten vorhanden
            if (userHistory && userHistory.length > 0) {
                // Aktuelle Ergebnisse für die Trendanalyse hinzufügen
                const fullHistory = [...userHistory, testResult];
                report.historicalTrend = window.ImmoLern.Assessment.Scoring.AdvancedMetrics.calculateLearningCurve(fullHistory);
                
                // Verbesserung zum letzten Test berechnen
                if (userHistory.length > 0) {
                    const previousResult = userHistory[userHistory.length - 1];
                    report.improvement = window.ImmoLern.Assessment.Scoring.AdvancedMetrics.calculateImprovement(previousResult, testResult);
                }
            }
            
            // Kategorien-Vergleich
            if (testResult.categoryScores) {
                report.categoryComparison = _compareCategoryPerformance(testResult.categoryScores);
            }
            
            // Erkenntnisse generieren
            report.insights = _generateReportInsights(report);
            
            return report;
        }
    };
})();

/**
 * Generiert Erkenntnisse aus einem Vergleichsbericht
 * @param {Object} report - Der Vergleichsbericht
 * @returns {Array} - Liste von Erkenntnissen
 */
function _generateReportInsights(report) {
    const insights = [];
    
    // Gesamtleistung
    if (report.comparisons && report.comparisons.overall) {
        const overallPerformance = report.comparisons.overall;
        
        if (overallPerformance.level === 'excellent' || overallPerformance.level === 'good') {
            insights.push({
                type: 'success',
                message: `Ihre Gesamtleistung ist ${overallPerformance.label.toLowerCase()} (${report.percentage.toFixed(1)}%).`
            });
        } else if (overallPerformance.level === 'poor') {
            insights.push({
                type: 'warning',
                message: `Ihre Gesamtleistung ist verbesserungsbedürftig (${report.percentage.toFixed(1)}%).`
            });
        }
    }
    
    // Lernfortschritt
    if (report.historicalTrend && report.historicalTrend.hasEnoughData) {
        if (report.historicalTrend.trend === 'rapid_improvement') {
            insights.push({
                type: 'improvement',
                message: `Sie zeigen eine schnelle Verbesserung über die letzten Testdurchläufe.`
            });
        } else if (report.historicalTrend.trend === 'significant_decline') {
            insights.push({
                type: 'warning',
                message: `Ihre Leistung hat sich im Verlauf der letzten Tests verschlechtert. Überprüfen Sie Ihre Lernstrategie.`
            });
        }
    }
    
    // Kategorien-Stärken und Schwächen
    if (report.categoryComparison) {
        // Stärken hervorheben
        if (report.categoryComparison.strengths.length > 0) {
            const topStrength = report.categoryComparison.strengths[0];
            insights.push({
                type: 'strength',
                message: `Ihre größte Stärke liegt in der Kategorie "${topStrength.category}" (${topStrength.percentage.toFixed(1)}%).`
            });
        }
        
        // Schwächen identifizieren
        if (report.categoryComparison.weaknesses.length > 0) {
            const worstWeakness = report.categoryComparison.weaknesses[report.categoryComparison.weaknesses.length - 1];
            insights.push({
                type: 'weakness',
                message: `Verbesserungspotenzial besteht vor allem in der Kategorie "${worstWeakness.category}" (${worstWeakness.percentage.toFixed(1)}%).`
            });
        }
        
        // Gleichmäßigkeit der Leistung
        if (report.categoryComparison.overall === 'very_inconsistent') {
            insights.push({
                type: 'consistency',
                message: `Ihre Leistung ist über die verschiedenen Kategorien sehr unterschiedlich. Arbeiten Sie an einer gleichmäßigeren Kompetenzverteilung.`
            });
        }
    }
    
    // Verbesserung zum letzten Test
    if (report.improvement) {
        if (report.improvement.hasImproved && report.improvement.improvementPoints >= 10) {
            insights.push({
                type: 'improvement',
                message: `Sie haben sich im Vergleich zum letzten Test um ${report.improvement.improvementPoints.toFixed(1)} Prozentpunkte verbessert.`
            });
        } else if (!report.improvement.hasImproved && Math.abs(report.improvement.improvementPoints) >= 10) {
            insights.push({
                type: 'regression',
                message: `Ihre Leistung liegt um ${Math.abs(report.improvement.improvementPoints).toFixed(1)} Prozentpunkte unter Ihrem letzten Ergebnis.`
            });
        }
    }
    
    return insights;
}

// Modul für Kompetenzmodelle und Leistungskarte
window.ImmoLern.Assessment.Scoring.CompetencyMapping = (function() {
    // Private Variablen
    let _competencyModels = {};
    let _userCompetencies = {};
    
    // Beispiel für ein Kompetenzmodell
    const _defaultModel = {
        id: 'default',
        name: 'Standard-Kompetenzmodell',
        description: 'Standardmodell für die Kompetenzerfassung',
        competencyAreas: [
            {
                id: 'knowledge',
                name: 'Wissen',
                description: 'Faktenwissen und Konzeptverständnis',
                weight: 1.0
            },
            {
                id: 'application',
                name: 'Anwendung',
                description: 'Praktische Anwendung des Wissens',
                weight: 1.2
            },
            {
                id: 'analysis',
                name: 'Analyse',
                description: 'Analytische Fähigkeiten und Problemlösung',
                weight: 1.5
            }
        ],
        levels: [
            {
                id: 'beginner',
                name: 'Anfänger',
                minScore: 0,
                maxScore: 40
            },
            {
                id: 'intermediate',
                name: 'Fortgeschritten',
                minScore: 40,
                maxScore: 70
            },
            {
                id: 'advanced',
                name: 'Experte',
                minScore: 70,
                maxScore: 90
            },
            {
                id: 'master',
                name: 'Meister',
                minScore: 90,
                maxScore: 100
            }
        ]
    };
    
    // Private Funktionen
    
    /**
     * Ordnet Kategorien den Kompetenzbereichen zu
     * @param {Object} testResult - Das Testergebnis
     * @param {Object} model - Das Kompetenzmodell
     * @returns {Object} - Die zugeordneten Kompetenzen
     */
    function _mapCategoriesToCompetencies(testResult, model) {
        if (!testResult || !testResult.categoryScores || !model) {
            return {};
        }
        
        // Zuordnungstabelle von Kategorien zu Kompetenzbereichen
        // In einer realen Implementierung würde diese Zuordnung konfigurierbar sein
        const categoryMapping = {
            // Beispielzuordnungen
            'grundlagen': 'knowledge',
            'konzepte': 'knowledge',
            'fakten': 'knowledge',
            'praxis': 'application',
            'übungen': 'application',
            'probleme': 'analysis',
            'fallstudien': 'analysis'
        };
        
        // Kompetenzwerte initialisieren
        const competencies = {};
        model.competencyAreas.forEach(area => {
            competencies[area.id] = {
                id: area.id,
                name: area.name,
                description: area.description,
                score: 0,
                categories: [],
                level: null
            };
        });
        
        // Kategorien zu Kompetenzbereichen zuordnen
        Object.keys(testResult.categoryScores).forEach(category => {
            // Bestimme Kompetenzbereich (fallback auf 'knowledge')
            const normalizedCategory = category.toLowerCase();
            let competencyId = 'knowledge';
            
            // Prüfe auf exakte Übereinstimmung
            if (categoryMapping[normalizedCategory]) {
                competencyId = categoryMapping[normalizedCategory];
            } else {
                // Prüfe auf partielle Übereinstimmung
                for (const [cat, comp] of Object.entries(categoryMapping)) {
                    if (normalizedCategory.includes(cat)) {
                        competencyId = comp;
                        break;
                    }
                }
            }
            
            // Stelle sicher, dass der Kompetenzbereich im Modell existiert
            if (competencies[competencyId]) {
                // Kategorie zum Kompetenzbereich hinzufügen
                competencies[competencyId].categories.push({
                    category: category,
                    percentage: testResult.categoryScores[category].percentage
                });
            }
        });
        
        // Durchschnittliche Punktzahl pro Kompetenzbereich berechnen
        Object.keys(competencies).forEach(competencyId => {
            const competency = competencies[competencyId];
            
            if (competency.categories.length > 0) {
                // Durchschnitt der Kategorien berechnen
                const sum = competency.categories.reduce((total, cat) => total + cat.percentage, 0);
                competency.score = sum / competency.categories.length;
                
                // Kompetenzniveau bestimmen
                competency.level = _determineCompetencyLevel(competency.score, model.levels);
            }
        });
        
        return competencies;
    }
    
    /**
     * Bestimmt das Kompetenzniveau basierend auf der Punktzahl
     * @param {number} score - Die Punktzahl
     * @param {Array} levels - Die verfügbaren Niveaustufen
     * @returns {Object} - Die bestimmte Niveaustufe
     */
    function _determineCompetencyLevel(score, levels) {
        if (!levels || levels.length === 0) {
            return null;
        }
        
        // Passende Niveaustufe finden
        for (const level of levels) {
            if (score >= level.minScore && score <= level.maxScore) {
                return {
                    id: level.id,
                    name: level.name,
                    score: score
                };
            }
        }
        
        // Fallback zur höchsten Stufe, wenn kein passendes Level gefunden wurde
        const highestLevel = levels[levels.length - 1];
        return {
            id: highestLevel.id,
            name: highestLevel.name,
            score: score
        };
    }
    
    /**
     * Aktualisiert die Kompetenzwerte eines Benutzers
     * @param {string} userId - ID des Benutzers
     * @param {Object} competencies - Die zu aktualisierenden Kompetenzen
     */
    function _updateUserCompetencies(userId, competencies) {
        if (!userId || !competencies) {
            return;
        }
        
        // Initialisieren, falls noch nicht vorhanden
        if (!_userCompetencies[userId]) {
            _userCompetencies[userId] = {};
        }
        
        // Jede Kompetenz aktualisieren
        Object.keys(competencies).forEach(competencyId => {
            const newCompetency = competencies[competencyId];
            
            // Bestehende Kompetenz abrufen oder neue erstellen
            if (!_userCompetencies[userId][competencyId]) {
                _userCompetencies[userId][competencyId] = {
                    id: competencyId,
                    name: newCompetency.name,
                    scores: [],
                    currentScore: 0,
                    currentLevel: null,
                    trend: 'stable',
                    lastUpdated: null
                };
            }
            
            const userCompetency = _userCompetencies[userId][competencyId];
            
            // Neue Punktzahl mit Zeitstempel hinzufügen
            userCompetency.scores.push({
                score: newCompetency.score,
                timestamp: new Date().toISOString()
            });
            
            // Auf die letzten 10 Einträge beschränken
            if (userCompetency.scores.length > 10) {
                userCompetency.scores = userCompetency.scores.slice(-10);
            }
            
            // Aktuelle Punktzahl aktualisieren (gewichteter Durchschnitt der letzten 3)
            if (userCompetency.scores.length >= 3) {
                const recentScores = userCompetency.scores.slice(-3);
                let weightedSum = 0;
                let weightSum = 0;
                
                recentScores.forEach((entry, index) => {
                    const weight = index + 1; // Neuere Einträge haben höheres Gewicht
                    weightedSum += entry.score * weight;
                    weightSum += weight;
                });
                
                userCompetency.currentScore = weightedSum / weightSum;
            } else {
                userCompetency.currentScore = newCompetency.score;
            }
            
            // Aktuelles Level aktualisieren
            userCompetency.currentLevel = newCompetency.level;
            
            // Trend berechnen
            if (userCompetency.scores.length >= 3) {
                const oldestScore = userCompetency.scores[0].score;
                const newestScore = userCompetency.scores[userCompetency.scores.length - 1].score;
                const difference = newestScore - oldestScore;
                
                if (difference >= 5) {
                    userCompetency.trend = 'improving';
                } else if (difference <= -5) {
                    userCompetency.trend = 'declining';
                } else {
                    userCompetency.trend = 'stable';
                }
            }
            
            // Letzte Aktualisierung setzen
            userCompetency.lastUpdated = new Date().toISOString();
        });
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Kompetenzmodell-Modul
         */
        init: function() {
            // Standard-Kompetenzmodell hinzufügen
            _competencyModels[_defaultModel.id] = _defaultModel;
            
            return this;
        },
        
        /**
         * Fügt ein neues Kompetenzmodell hinzu
         * @param {Object} model - Das hinzuzufügende Kompetenzmodell
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addCompetencyModel: function(model) {
            if (!model || !model.id) {
                return false;
            }
            
            _competencyModels[model.id] = model;
            return true;
        },
        
        /**
         * Gibt alle verfügbaren Kompetenzmodelle zurück
         * @returns {Object} - Die verfügbaren Kompetenzmodelle
         */
        getCompetencyModels: function() {
            return { ..._competencyModels };
        },
        
        /**
         * Analysiert ein Testergebnis und erstellt eine Kompetenzkarte
         * @param {Object} testResult - Das zu analysierende Testergebnis
         * @param {string} modelId - ID des zu verwendenden Kompetenzmodells
         * @returns {Object} - Die erstellte Kompetenzkarte
         */
        analyzeCompetencies: function(testResult, modelId = 'default') {
            if (!testResult) {
                return {
                    status: 'error',
                    message: 'Keine Testdaten vorhanden'
                };
            }
            
            // Kompetenzmodell abrufen
            const model = _competencyModels[modelId] || _defaultModel;
            
            // Kategorien zu Kompetenzen zuordnen
            const competencies = _mapCategoriesToCompetencies(testResult, model);
            
            // Benutzerkompetenzen aktualisieren, falls Benutzer-ID vorhanden
            if (testResult.userId) {
                _updateUserCompetencies(testResult.userId, competencies);
            }
            
            // Kompetenzkarte erstellen
            return {
                testId: testResult.testId,
                userId: testResult.userId,
                timestamp: testResult.timestamp,
                modelId: model.id,
                modelName: model.name,
                competencies: competencies,
                overallLevel: _determineCompetencyLevel(testResult.percentage, model.levels)
            };
        },
        
        /**
         * Gibt die Kompetenzwerte eines Benutzers zurück
         * @param {string} userId - ID des Benutzers
         * @returns {Object|null} - Die Kompetenzwerte oder null, wenn nicht vorhanden
         */
        getUserCompetencies: function(userId) {
            return _userCompetencies[userId] ? { ..._userCompetencies[userId] } : null;
        },
        
        /**
         * Erstellt einen Kompetenzentwicklungsbericht für einen Benutzer
         * @param {string} userId - ID des Benutzers
         * @returns {Object} - Der Entwicklungsbericht
         */
        createCompetencyDevelopmentReport: function(userId) {
            const userCompetencies = this.getUserCompetencies(userId);
            
            if (!userCompetencies) {
                return {
                    status: 'error',
                    message: 'Keine Kompetenzdaten für diesen Benutzer vorhanden'
                };
            }
            
            // Kompetenzbericht erstellen
            const report = {
                userId: userId,
                timestamp: new Date().toISOString(),
                competencies: userCompetencies,
                strengths: [],
                improvementAreas: [],
                recommendations: []
            };
            
            // Stärken und Verbesserungsbereiche identifizieren
            const competencyArray = Object.values(userCompetencies);
            competencyArray.sort((a, b) => b.currentScore - a.currentScore);
            
            // Top 3 Stärken
            report.strengths = competencyArray.slice(0, 3);
            
            // Bottom 3 Verbesserungsbereiche
            report.improvementAreas = competencyArray.slice(-3).reverse();
            
            // Empfehlungen generieren
            report.improvementAreas.forEach(area => {
                report.recommendations.push({
                    competencyId: area.id,
                    competencyName: area.name,
                    currentLevel: area.currentLevel,
                    message: `Für die Verbesserung im Bereich "${area.name}" empfehlen wir gezieltes Training in den zugehörigen Kategorien.`
                });
            });
            
            return report;
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Erweiterte Metriken mit Standardeinstellungen initialisieren
    window.ImmoLern.Assessment.Scoring.AdvancedMetrics.init();
    
    // Kompetenzmodell initialisieren
    window.ImmoLern.Assessment.Scoring.CompetencyMapping.init();
});

// Benutzerdefiniertes Ereignis auslösen, wenn das Modul geladen ist
document.dispatchEvent(new CustomEvent('advancedScoringLoaded'));
/**
 * JS-Block 6.3.2-part1: Berechnungslogik (Teil 2.1)
 * 
 * Spezialisierte und erweiterte Punkteberechnungsfunktionen:
 * - Gewichtete Punkteberechnung für Test-Serien
 * - Normalisierung zwischen unterschiedlichen Testversionen
 * - Berechnung von Durchschnittswerten und Trends
 * - Testübergreifende Bewertung und Leistungsindex
 * - Anpassbare Bewertungsregeln
 */

// Namespace für erweiterte Punkteberechnung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Scoring) window.ImmoLern.Assessment.Scoring = {};

// Modul für testübergreifende Bewertungen
window.ImmoLern.Assessment.Scoring.CrossTestScoring = (function() {
    // Private Variablen
    let _testWeightingRules = {
        default: {
            // Standardgewichtung: Neuere Tests zählen mehr
            type: 'time_based',
            maxTests: 5,        // Maximal 5 Tests berücksichtigen
            newestWeight: 2.0,  // Neuester Test zählt 2-fach
            oldestWeight: 0.5,  // Ältester Test zählt 0.5-fach
            threshold: null     // Alle Tests über dem Schwellenwert berücksichtigen
        },
        
        // Gewichtung für wichtige Zertifizierungstests
        certification: {
            type: 'best_score',
            maxTests: 3,       // Die besten 3 Tests berücksichtigen
            minScore: 50,      // Nur Tests mit mindestens 50% berücksichtigen
            threshold: null    // Kein weiterer Schwellenwert
        },
        
        // Gleichmäßige Gewichtung für Übungstests
        practice: {
            type: 'equal',
            maxTests: 10,      // Die letzten 10 Tests berücksichtigen
            threshold: null,   // Kein Schwellenwert
            lastDays: 90       // Nur Tests der letzten 90 Tage berücksichtigen
        }
    };
    
    // Normalisierungsfaktoren für verschiedene Testversionen
    let _testVersionNormalization = {};
    
    // Private Funktionen
    
    /**
     * Filtert und gewichtet Testergebnisse nach den angegebenen Regeln
     * @param {Array} testResults - Die zu verarbeitenden Testergebnisse
     * @param {Object} rules - Die anzuwendenden Regeln
     * @returns {Array} - Die gefilterten und gewichteten Ergebnisse
     */
    function _filterAndWeightTests(testResults, rules) {
        if (!testResults || testResults.length === 0) {
            return [];
        }
        
        rules = rules || _testWeightingRules.default;
        
        // Kopie der Ergebnisse erstellen, um das Original nicht zu verändern
        let filteredResults = [...testResults];
        
        // Nach Datum sortieren (neueste zuerst)
        filteredResults.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Zunächst nach Zeitfilter filtern, falls vorhanden
        if (rules.lastDays) {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - rules.lastDays);
            
            filteredResults = filteredResults.filter(result => 
                new Date(result.timestamp) >= cutoffDate
            );
        }
        
        // Dann nach Score-Schwellenwert filtern, falls vorhanden
        if (rules.minScore) {
            filteredResults = filteredResults.filter(result => 
                (result.percentage || 0) >= rules.minScore
            );
        }
        
        // Bei leerer Ergebnismenge nach Filterung abbrechen
        if (filteredResults.length === 0) {
            return [];
        }
        
        // Je nach Typ die passende Gewichtung anwenden
        switch (rules.type) {
            case 'best_score':
                // Nach Punktzahl sortieren (höchste zuerst)
                filteredResults.sort((a, b) => 
                    (b.percentage || 0) - (a.percentage || 0)
                );
                
                // Auf die maximale Anzahl begrenzen
                if (rules.maxTests && filteredResults.length > rules.maxTests) {
                    filteredResults = filteredResults.slice(0, rules.maxTests);
                }
                
                // Gleichmäßige Gewichtung für alle berücksichtigten Tests
                filteredResults.forEach(result => {
                    result.weight = 1.0;
                });
                break;
                
            case 'time_based':
                // Auf die maximale Anzahl begrenzen
                if (rules.maxTests && filteredResults.length > rules.maxTests) {
                    filteredResults = filteredResults.slice(0, rules.maxTests);
                }
                
                // Gewichtung basierend auf der Position im Array
                const count = filteredResults.length;
                if (count > 1) {
                    // Lineares Gewichtungsmodell zwischen newestWeight und oldestWeight
                    const newestWeight = rules.newestWeight || 1.0;
                    const oldestWeight = rules.oldestWeight || 1.0;
                    const weightStep = (newestWeight - oldestWeight) / (count - 1);
                    
                    filteredResults.forEach((result, index) => {
                        result.weight = newestWeight - (index * weightStep);
                    });
                } else {
                    // Nur ein Ergebnis: newestWeight verwenden
                    filteredResults[0].weight = rules.newestWeight || 1.0;
                }
                break;
                
            case 'equal':
            default:
                // Auf die maximale Anzahl begrenzen
                if (rules.maxTests && filteredResults.length > rules.maxTests) {
                    filteredResults = filteredResults.slice(0, rules.maxTests);
                }
                
                // Gleichmäßige Gewichtung für alle Tests
                filteredResults.forEach(result => {
                    result.weight = 1.0;
                });
                break;
        }
        
        return filteredResults;
    }
    
    /**
     * Berechnet eine gewichtete Durchschnittspunktzahl für mehrere Tests
     * @param {Array} weightedResults - Die gewichteten Testergebnisse
     * @returns {number} - Die durchschnittliche Punktzahl
     */
    function _calculateWeightedAverage(weightedResults) {
        if (!weightedResults || weightedResults.length === 0) {
            return 0;
        }
        
        let totalWeight = 0;
        let weightedSum = 0;
        
        weightedResults.forEach(result => {
            const weight = result.weight || 1.0;
            const score = result.percentage || 0;
            
            totalWeight += weight;
            weightedSum += score * weight;
        });
        
        // Gewichteten Durchschnitt berechnen
        if (totalWeight > 0) {
            return weightedSum / totalWeight;
        }
        
        return 0;
    }
    
    /**
     * Normalisiert eine Punktzahl basierend auf der Testversion
     * @param {number} score - Die zu normalisierende Punktzahl
     * @param {string} testId - ID des Tests
     * @param {string} testVersion - Version des Tests
     * @returns {number} - Die normalisierte Punktzahl
     */
    function _normalizeScore(score, testId, testVersion) {
        if (typeof score !== 'number') {
            return 0;
        }
        
        // Wenn keine Normalisierungsdaten vorhanden sind, Original zurückgeben
        if (!_testVersionNormalization[testId] || !_testVersionNormalization[testId][testVersion]) {
            return score;
        }
        
        const normalizationData = _testVersionNormalization[testId][testVersion];
        
        // Verschiedene Normalisierungsmethoden
        switch (normalizationData.method) {
            case 'linear_adjustment':
                // Lineare Anpassung mit Faktor und Offset
                return score * normalizationData.factor + normalizationData.offset;
                
            case 'percentile':
                // Perzentil-basierte Anpassung
                if (!normalizationData.percentiles) {
                    return score;
                }
                
                // Finde das nächste Perzentil
                for (let i = 0; i < normalizationData.percentiles.length; i++) {
                    const entry = normalizationData.percentiles[i];
                    if (score <= entry.score) {
                        return entry.normalizedScore;
                    }
                }
                
                // Wenn über allen Perzentilen, verwende das höchste
                const lastPercentile = normalizationData.percentiles[normalizationData.percentiles.length - 1];
                return lastPercentile.normalizedScore;
                
            case 'z_score':
                // Z-Score-basierte Anpassung
                if (!normalizationData.mean || !normalizationData.stdDev) {
                    return score;
                }
                
                // Z-Score berechnen und dann in den Zielbereich umwandeln
                const zScore = (score - normalizationData.mean) / normalizationData.stdDev;
                return normalizationData.targetMean + zScore * normalizationData.targetStdDev;
                
            default:
                // Keine Anpassung
                return score;
        }
    }
    
    /**
     * Berechnet die Konsistenz der Testergebnisse
     * @param {Array} testResults - Die zu analysierenden Testergebnisse
     * @returns {Object} - Konsistenzmetriken
     */
    function _calculateConsistency(testResults) {
        if (!testResults || testResults.length < 2) {
            return {
                hasEnoughData: false,
                consistency: 0,
                variability: 0,
                trend: 'insufficient_data'
            };
        }
        
        // Prozentsätze extrahieren
        const percentages = testResults.map(result => result.percentage || 0);
        
        // Statistiken berechnen
        const sum = percentages.reduce((a, b) => a + b, 0);
        const mean = sum / percentages.length;
        
        // Varianz und Standardabweichung
        const squaredDiffs = percentages.map(p => Math.pow(p - mean, 2));
        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / percentages.length;
        const stdDev = Math.sqrt(variance);
        
        // Variationskoeffizient (normierte Standardabweichung)
        const coefficientOfVariation = mean > 0 ? stdDev / mean : 0;
        
        // Konsistenz als inverser Variationskoeffizient
        // 0 bedeutet sehr inkonsistent, 1 bedeutet perfekt konsistent
        const consistency = Math.max(0, Math.min(1, 1 - coefficientOfVariation));
        
        // Trend berechnen
        let trend = 'stable';
        if (testResults.length >= 3) {
            // Lineare Regression für Trend
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumXX = 0;
            const n = testResults.length;
            
            // Sortierte Kopie erstellen (älteste zuerst)
            const sortedResults = [...testResults].sort((a, b) => 
                new Date(a.timestamp) - new Date(b.timestamp)
            );
            
            sortedResults.forEach((result, index) => {
                const x = index;
                const y = result.percentage || 0;
                
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            
            // Steigung berechnen
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            
            // Trend basierend auf Steigung
            if (slope >= 3) {
                trend = 'improving';
            } else if (slope <= -3) {
                trend = 'declining';
            } else {
                trend = 'stable';
            }
        }
        
        return {
            hasEnoughData: true,
            consistency: consistency,
            variability: coefficientOfVariation,
            mean: mean,
            stdDev: stdDev,
            trend: trend,
            trendValue: trend === 'stable' ? 0 : (trend === 'improving' ? 1 : -1)
        };
    }
    
    /**
     * Berechnet einen Leistungsindex basierend auf mehreren Faktoren
     * @param {Array} testResults - Die zu analysierenden Testergebnisse
     * @returns {Object} - Der berechnete Leistungsindex
     */
    function _calculatePerformanceIndex(testResults) {
        if (!testResults || testResults.length === 0) {
            return {
                hasEnoughData: false,
                index: 0,
                level: 'insufficient_data',
                components: {}
            };
        }
        
        // Gewichtete Durchschnittspunktzahl (zählt 60%)
        const weightedTestResults = _filterAndWeightTests(testResults, _testWeightingRules.default);
        const averageScore = _calculateWeightedAverage(weightedTestResults);
        
        // Konsistenz berechnen (zählt 20%)
        const consistency = _calculateConsistency(testResults);
        
        // Trend berechnen (zählt 20%)
        const trendFactor = consistency.hasEnoughData ? consistency.trendValue : 0;
        
        // Komponenten für den Index
        const components = {
            averageScore: {
                value: averageScore,
                weight: 0.6,
                contribution: averageScore * 0.6
            },
            consistency: {
                value: consistency.consistency * 100, // Auf 0-100 Skala normalisieren
                weight: 0.2,
                contribution: consistency.consistency * 100 * 0.2
            },
            trend: {
                value: (trendFactor + 1) * 50, // Auf 0-100 Skala normalisieren
                weight: 0.2,
                contribution: (trendFactor + 1) * 50 * 0.2
            }
        };
        
        // Gesamtindex berechnen (0-100 Skala)
        const index = components.averageScore.contribution +
                      components.consistency.contribution +
                      components.trend.contribution;
        
        // Leistungsniveau bestimmen
        let level;
        if (index >= 85) level = 'excellent';
        else if (index >= 70) level = 'good';
        else if (index >= 55) level = 'satisfactory';
        else if (index >= 40) level = 'fair';
        else level = 'needs_improvement';
        
        return {
            hasEnoughData: true,
            index: index,
            level: level,
            components: components,
            averageScore: averageScore,
            consistency: consistency.consistency,
            trend: trendFactor
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul mit benutzerdefinierten Einstellungen
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Anpassbare Gewichtungsregeln übernehmen, falls vorhanden
            if (options.testWeightingRules) {
                _testWeightingRules = {
                    ..._testWeightingRules,
                    ...options.testWeightingRules
                };
            }
            
            // Normalisierungsdaten übernehmen, falls vorhanden
            if (options.testVersionNormalization) {
                _testVersionNormalization = {
                    ..._testVersionNormalization,
                    ...options.testVersionNormalization
                };
            }
            
            return this;
        },
        
        /**
         * Berechnet eine gewichtete Durchschnittspunktzahl für mehrere Tests
         * @param {Array} testResults - Die Testergebnisse
         * @param {string} ruleSet - Name des Regelsatzes ('default', 'certification', 'practice')
         * @returns {Object} - Berechnungsergebnis
         */
        calculateWeightedAverage: function(testResults, ruleSet = 'default') {
            if (!testResults || testResults.length === 0) {
                return {
                    average: 0,
                    count: 0,
                    includesTests: []
                };
            }
            
            // Regelsatz auswählen
            const rules = _testWeightingRules[ruleSet] || _testWeightingRules.default;
            
            // Tests filtern und gewichten
            const weightedResults = _filterAndWeightTests(testResults, rules);
            
            // Gewichteten Durchschnitt berechnen
            const average = _calculateWeightedAverage(weightedResults);
            
            return {
                average: average,
                count: weightedResults.length,
                includesTests: weightedResults.map(result => ({
                    id: result.testId,
                    timestamp: result.timestamp,
                    score: result.percentage,
                    weight: result.weight
                }))
            };
        },
        
        /**
         * Normalisiert eine Punktzahl basierend auf der Testversion
         * @param {number} score - Die zu normalisierende Punktzahl
         * @param {string} testId - ID des Tests
         * @param {string} testVersion - Version des Tests
         * @returns {number} - Die normalisierte Punktzahl
         */
        normalizeScore: function(score, testId, testVersion) {
            return _normalizeScore(score, testId, testVersion);
        },
        
        /**
         * Fügt Normalisierungsdaten für eine Testversion hinzu
         * @param {string} testId - ID des Tests
         * @param {string} testVersion - Version des Tests
         * @param {Object} normalizationData - Normalisierungsdaten
         */
        addNormalizationData: function(testId, testVersion, normalizationData) {
            if (!testId || !testVersion || !normalizationData) {
                return false;
            }
            
            // Initialisieren, falls noch nicht vorhanden
            if (!_testVersionNormalization[testId]) {
                _testVersionNormalization[testId] = {};
            }
            
            // Daten hinzufügen
            _testVersionNormalization[testId][testVersion] = normalizationData;
            
            return true;
        },
        
        /**
         * Berechnet die Konsistenz der Testergebnisse
         * @param {Array} testResults - Die zu analysierenden Testergebnisse
         * @returns {Object} - Konsistenzmetriken
         */
        calculateConsistency: function(testResults) {
            return _calculateConsistency(testResults);
        },
        
        /**
         * Berechnet einen Leistungsindex basierend auf mehreren Faktoren
         * @param {Array} testResults - Die zu analysierenden Testergebnisse
         * @returns {Object} - Der berechnete Leistungsindex
         */
        calculatePerformanceIndex: function(testResults) {
            return _calculatePerformanceIndex(testResults);
        }
    };
})();

// Modul für anpassbare Bewertungsregeln
window.ImmoLern.Assessment.Scoring.RuleEngine = (function() {
    // Private Variablen
    let _scoringRules = [];
    let _ruleTemplates = {
        // Standardregeln
        passFailThreshold: {
            name: 'Bestehens-Schwellenwert',
            description: 'Legt den Prozentsatz fest, der zum Bestehen erforderlich ist',
            type: 'threshold',
            params: {
                threshold: 50 // Standardmäßig 50%
            },
            evaluate: function(result, params) {
                const threshold = params.threshold || 50;
                return {
                    passed: result.percentage >= threshold,
                    threshold: threshold
                };
            }
        },
        
        categoryMinimum: {
            name: 'Kategorie-Mindestwert',
            description: 'Stellt sicher, dass jede Kategorie einen Mindestwert erreicht',
            type: 'category',
            params: {
                minPercentage: 40, // Mindestens 40% in jeder Kategorie
                categories: []     // Alle Kategorien oder spezifische Liste
            },
            evaluate: function(result, params) {
                const minPercentage = params.minPercentage || 40;
                const categoriesToCheck = params.categories || [];
                const allCategories = Object.keys(result.categoryScores || {});
                
                // Zu prüfende Kategorien (entweder alle oder nur spezifizierte)
                const categories = categoriesToCheck.length > 0 ? 
                    categoriesToCheck : allCategories;
                
                // Prüfen, ob alle Kategorien den Mindestwert erreichen
                const failedCategories = [];
                
                categories.forEach(category => {
                    if (result.categoryScores && result.categoryScores[category]) {
                        const percentage = result.categoryScores[category].percentage;
                        if (percentage < minPercentage) {
                            failedCategories.push({
                                category: category,
                                percentage: percentage,
                                required: minPercentage
                            });
                        }
                    }
                });
                
                return {
                    passed: failedCategories.length === 0,
                    failedCategories: failedCategories,
                    threshold: minPercentage
                };
            }
        },
        
        minimumCorrectQuestions: {
            name: 'Mindestanzahl richtiger Fragen',
            description: 'Verlangt eine Mindestanzahl korrekt beantworteter Fragen',
            type: 'questions',
            params: {
                minCorrect: 10,     // Mindestens 10 Fragen richtig
                minPercentage: 50   // Oder mindestens 50% der Fragen
            },
            evaluate: function(result, params) {
                const minCorrect = params.minCorrect || 10;
                const minPercentage = params.minPercentage || 50;
                
                // Anzahl korrekt beantworteter Fragen
                const correctQuestions = result.correctQuestions || 0;
                const totalQuestions = result.totalQuestions || 1;
                
                // Prozentsatz korrekter Fragen
                const percentageCorrect = (correctQuestions / totalQuestions) * 100;
                
                // Dynamischer Schwellenwert (entweder absolute Anzahl oder Prozentsatz)
                const dynamicThreshold = Math.min(minCorrect, Math.ceil(totalQuestions * minPercentage / 100));
                
                return {
                    passed: correctQuestions >= dynamicThreshold,
                    correctQuestions: correctQuestions,
                    totalQuestions: totalQuestions,
                    percentageCorrect: percentageCorrect,
                    threshold: dynamicThreshold
                };
            }
        },
        
        requiredQuestions: {
            name: 'Pflichtfragen',
            description: 'Bestimmte Fragen müssen korrekt beantwortet werden',
            type: 'questions',
            params: {
                requiredQuestionIds: [], // IDs der Pflichtfragen
                minCorrectRequired: 1    // Mindestens 1 richtig
            },
            evaluate: function(result, params) {
                const requiredQuestionIds = params.requiredQuestionIds || [];
                const minCorrectRequired = params.minCorrectRequired || 1;
                
                // Wenn keine Pflichtfragen definiert sind, gilt die Regel als bestanden
                if (requiredQuestionIds.length === 0) {
                    return {
                        passed: true,
                        correctRequired: 0,
                        totalRequired: 0
                    };
                }
                
                // Prüfen, wie viele der Pflichtfragen korrekt beantwortet wurden
                const questionResults = result.questionResults || [];
                let correctRequired = 0;
                
                requiredQuestionIds.forEach(questionId => {
                    const questionResult = questionResults.find(qr => qr.questionId === questionId);
                    if (questionResult && questionResult.correct) {
                        correctRequired++;
                    }
                });
                
                return {
                    passed: correctRequired >= minCorrectRequired,
                    correctRequired: correctRequired,
                    totalRequired: requiredQuestionIds.length,
                    threshold: minCorrectRequired
                };
            }
        },
        
        timeLimit: {
            name: 'Zeitlimit',
            description: 'Der Test muss innerhalb eines Zeitlimits abgeschlossen werden',
            type: 'time',
            params: {
                maxTimeMinutes: 60 // Maximal 60 Minuten
            },
            evaluate: function(result, params) {
                const maxTimeMinutes = params.maxTimeMinutes || 60;
                const maxTimeMs = maxTimeMinutes * 60 * 1000;
                
                // Tatsächlich benötigte Zeit
                const timeSpent = result.timeSpent || 0;
                
                return {
                    passed: timeSpent <= maxTimeMs,
                    timeSpent: timeSpent,
                    timeSpentMinutes: Math.round(timeSpent / 60000 * 10) / 10,
                    maxTimeMinutes: maxTimeMinutes
                };
            }
        }
    };
    
    // Private Funktionen
    
    /**
     * Wendet eine Bewertungsregel auf ein Testergebnis an
     * @param {Object} rule - Die anzuwendende Regel
     * @param {Object} testResult - Das zu bewertende Testergebnis
     * @returns {Object} - Das Auswertungsergebnis
     */
    function _applyRule(rule, testResult) {
        if (!rule || !rule.templateId || !testResult) {
            return {
                passed: true,
                ruleId: rule ? rule.id : null,
                templateId: rule ? rule.templateId : null,
                error: 'Ungültige Regel oder Testergebnis'
            };
        }
        
        // Regelvorlage abrufen
        const template = _ruleTemplates[rule.templateId];
        if (!template || !template.evaluate) {
            return {
                passed: true,
                ruleId: rule.id,
                templateId: rule.templateId,
                error: 'Unbekannte Regelvorlage'
            };
        }
        
        // Parameter zusammenführen (Standardparameter + regelspezifische Parameter)
        const params = {
            ...template.params,
            ...(rule.params || {})
        };
        
        try {
            // Regel auswerten
            const evaluation = template.evaluate(testResult, params);
            
            // Metadaten hinzufügen
            return {
                ...evaluation,
                ruleId: rule.id,
                ruleName: rule.name || template.name,
                templateId: rule.templateId
            };
        } catch (error) {
            console.error('Fehler bei der Auswertung der Regel:', error);
            
            return {
                passed: true, // Bei Fehlern als bestanden werten
                ruleId: rule.id,
                templateId: rule.templateId,
                error: 'Fehler bei der Regelauswertung: ' + error.message
            };
        }
    }
    
    /**
     * Wertet alle Regeln für ein Testergebnis aus
     * @param {Object} testResult - Das zu bewertende Testergebnis
     * @param {Array} rules - Die anzuwendenden Regeln
     * @returns {Object} - Die Auswertungsergebnisse
     */
    function _evaluateAllRules(testResult, rules) {
        if (!testResult) {
            return {
                passed: false,
                error: 'Keine Testergebnisse vorhanden'
            };
        }
        
        // Zu verwendende Regeln
        const rulesToApply = rules || _scoringRules;
        
        // Alle Regeln anwenden
        const evaluations = rulesToApply.map(rule => _applyRule(rule, testResult));
        
        // Gesamtergebnis ermitteln (bestanden, wenn alle Regeln bestanden wurden)
        const allPassed = evaluations.every(eval => eval.passed);
        
        return {
            passed: allPassed,
            evaluations: evaluations,
            failedRules: evaluations.filter(eval => !eval.passed)
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert die Regel-Engine mit vordefinierten Regeln
         * @param {Array} rules - Die zu verwendenden Regeln
         */
        init: function(rules = []) {
            _scoringRules = rules;
            return this;
        },
        
        /**
         * Gibt alle verfügbaren Regelvorlagen zurück
         * @returns {Object} - Die verfügbaren Regelvorlagen
         */
        getRuleTemplates: function() {
            const templates = {};
            
            Object.keys(_ruleTemplates).forEach(id => {
                const template = _ruleTemplates[id];
                templates[id] = {
                    id: id,
                    name: template.name,
                    description: template.description,
                    type: template.type,
                    defaultParams: { ...template.params }
                };
            });
            
            return templates;
        },
        
        /**
         * Fügt eine neue Regelvorlage hinzu
         * @param {string} id - ID der Regelvorlage
         * @param {Object} template - Die Regelvorlage
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addRuleTemplate: function(id, template) {
            if (!id || !template || !template.evaluate) {
                return false;
            }
            
            _ruleTemplates[id] = template;
            return true;
        },
        
        /**
         * Fügt eine Bewertungsregel hinzu
         * @param {Object} rule - Die hinzuzufügende Regel
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addRule: function(rule) {
            if (!rule || !rule.id || !rule.templateId) {
                return false;
            }
            
            // Prüfen, ob die Regelvorlage existiert
            if (!_ruleTemplates[rule.templateId]) {
                return false;
            }
            
            // Prüfen, ob bereits eine Regel mit dieser ID existiert
            const existingIndex = _scoringRules.findIndex(r => r.id === rule.id);
            if (existingIndex >= 0) {
                // Bestehende Regel aktualisieren
                _scoringRules[existingIndex] = rule;
            } else {
                // Neue Regel hinzufügen
                _scoringRules.push(rule);
            }
            
            return true;
        },
        
        /**
         * Entfernt eine Bewertungsregel
         * @param {string} ruleId - ID der zu entfernenden Regel
         * @returns {boolean} - True, wenn erfolgreich entfernt
         */
        removeRule: function(ruleId) {
            const initialLength = _scoringRules.length;
            _scoringRules = _scoringRules.filter(rule => rule.id !== ruleId);
            
            return _scoringRules.length < initialLength;
        },
        
        /**
         * Wertet ein Testergebnis anhand der Bewertungsregeln aus
         * @param {Object} testResult - Das zu bewertende Testergebnis
         * @param {Array} specificRules - Optionale spezifische Regeln
         * @returns {Object} - Die Auswertungsergebnisse
         */
        evaluateRules: function(testResult, specificRules) {
            return _evaluateAllRules(testResult, specificRules);
        },
        
        /**
         * Erstellt eine textuelle Erklärung der Regelbewertungen
         * @param {Object} evaluationResult - Das Ergebnis der Regelbewertung
         * @returns {Array} - Liste von Erklärungen
         */
        generateExplanations: function(evaluationResult) {
            if (!evaluationResult || !evaluationResult.evaluations) {
                return [];
            }
            
            const explanations = [];
            
            // Alle Regelauswertungen durchgehen
            evaluationResult.evaluations.forEach(evaluation => {
                let explanation = {
                    ruleId: evaluation.ruleId,
                    ruleName: evaluation.ruleName,
                    passed: evaluation.passed,
                    message: ''
                };
                
                // Je nach Regelvorlage unterschiedliche Erklärungen generieren
                switch (evaluation.templateId) {
                    case 'passFailThreshold':
                        explanation.message = evaluation.passed ?
                            `Bestanden: ${Math.round(evaluation.threshold)}% Schwellenwert erreicht.` :
                            `Nicht bestanden: Mindestens ${Math.round(evaluation.threshold)}% sind erforderlich.`;
                        break;
                        
                    case 'categoryMinimum':
                        if (evaluation.passed) {
                            explanation.message = `Alle Kategorien erreichen den Mindestwert von ${Math.round(evaluation.threshold)}%.`;
                        } else {
                            const categories = evaluation.failedCategories.map(fc => 
                                `${fc.category} (${Math.round(fc.percentage)}% / gefordert: ${Math.round(fc.required)}%)`
                            ).join(', ');
                            explanation.message = `Mindestanforderungen in folgenden Kategorien nicht erfüllt: ${categories}`;
                        }
                        break;
                        
                    case 'minimumCorrectQuestions':
                        explanation.message = evaluation.passed ?
                            `Genügend richtige Antworten: ${evaluation.correctQuestions} von ${evaluation.totalQuestions} (erforderlich: ${evaluation.threshold}).` :
                            `Zu wenige richtige Antworten: ${evaluation.correctQuestions} von ${evaluation.totalQuestions} (erforderlich: ${evaluation.threshold}).`;
                        break;
                        
                    case 'requiredQuestions':
                        explanation.message = evaluation.passed ?
                            `${evaluation.correctRequired} von ${evaluation.totalRequired} Pflichtfragen korrekt beantwortet (erforderlich: ${evaluation.threshold}).` :
                            `Nur ${evaluation.correctRequired} von ${evaluation.totalRequired} Pflichtfragen korrekt beantwortet (erforderlich: ${evaluation.threshold}).`;
                        break;
                        
                    case 'timeLimit':
                        explanation.message = evaluation.passed ?
                            `Zeitlimit eingehalten: ${evaluation.timeSpentMinutes} Minuten von maximal ${evaluation.maxTimeMinutes} Minuten.` :
                            `Zeitlimit überschritten: ${evaluation.timeSpentMinutes} Minuten verwendet (maximal: ${evaluation.maxTimeMinutes} Minuten).`;
                        break;
                        
                    default:
                        explanation.message = evaluation.passed ?
                            `Regel bestanden.` :
                            `Regel nicht bestanden.`;
                }
                
                explanations.push(explanation);
            });
            
            return explanations;
        }
    };
})();

// Hilfsfunktionen für die Testbewertung
window.ImmoLern.Assessment.Scoring.TestResultFactory = (function() {
    // Private Funktionen
    
    /**
     * Berechnet detaillierte Statistiken für Testergebnisse
     * @param {Object} testResult - Das Testergebnis
     * @param {Array} questionResults - Die Ergebnisse der einzelnen Fragen
     * @returns {Object} - Erweiterte Statistiken
     */
    function _calculateDetailedStats(testResult, questionResults) {
        if (!testResult || !questionResults) {
            return {};
        }
        
        // Korrekt und falsch beantwortete Fragen zählen
        const correctQuestions = questionResults.filter(q => q.correct).length;
        const incorrectQuestions = questionResults.filter(q => !q.correct).length;
        const unansweredQuestions = questionResults.filter(q => q.unanswered).length;
        
        // Fragen nach Schwierigkeitsgrad gruppieren
        const byDifficulty = {};
        questionResults.forEach(question => {
            const difficulty = question.difficulty || 'medium';
            
            if (!byDifficulty[difficulty]) {
                byDifficulty[difficulty] = { correct: 0, incorrect: 0, total: 0 };
            }
            
            byDifficulty[difficulty].total++;
            if (question.correct) {
                byDifficulty[difficulty].correct++;
            } else {
                byDifficulty[difficulty].incorrect++;
            }
        });
        
        // Erfolgsraten pro Schwierigkeitsgrad berechnen
        Object.keys(byDifficulty).forEach(difficulty => {
            const data = byDifficulty[difficulty];
            data.successRate = data.total > 0 ? (data.correct / data.total) * 100 : 0;
        });
        
        // Fragen nach Fragetyp gruppieren
        const byQuestionType = {};
        questionResults.forEach(question => {
            const type = question.type || 'unknown';
            
            if (!byQuestionType[type]) {
                byQuestionType[type] = { correct: 0, incorrect: 0, total: 0 };
            }
            
            byQuestionType[type].total++;
            if (question.correct) {
                byQuestionType[type].correct++;
            } else {
                byQuestionType[type].incorrect++;
            }
        });
        
        // Erfolgsraten pro Fragetyp berechnen
        Object.keys(byQuestionType).forEach(type => {
            const data = byQuestionType[type];
            data.successRate = data.total > 0 ? (data.correct / data.total) * 100 : 0;
        });
        
        return {
            totalQuestions: questionResults.length,
            correctQuestions: correctQuestions,
            incorrectQuestions: incorrectQuestions,
            unansweredQuestions: unansweredQuestions,
            correctPercentage: (correctQuestions / questionResults.length) * 100,
            incorrectPercentage: (incorrectQuestions / questionResults.length) * 100,
            unansweredPercentage: (unansweredQuestions / questionResults.length) * 100,
            byDifficulty: byDifficulty,
            byQuestionType: byQuestionType
        };
    }
    
    /**
     * Generiert Empfehlungen basierend auf Testergebnissen
     * @param {Object} testResult - Das Testergebnis
     * @param {Object} detailedStats - Die detaillierten Statistiken
     * @returns {Array} - Liste von Empfehlungen
     */
    function _generateRecommendations(testResult, detailedStats) {
        if (!testResult || !detailedStats) {
            return [];
        }
        
        const recommendations = [];
        
        // Allgemeine Empfehlung basierend auf Gesamtergebnis
        if (testResult.passed) {
            if (testResult.percentage >= 90) {
                recommendations.push({
                    type: 'general',
                    importance: 'low',
                    message: 'Hervorragendes Ergebnis! Halten Sie Ihr Wissen mit regelmäßigen Wiederholungen aktuell.'
                });
            } else if (testResult.percentage >= 75) {
                recommendations.push({
                    type: 'general',
                    importance: 'medium',
                    message: 'Gutes Ergebnis! Fokussieren Sie sich auf die Bereiche, in denen Sie Punkte verloren haben, um Ihr Wissen zu vervollständigen.'
                });
            } else {
                recommendations.push({
                    type: 'general',
                    importance: 'high',
                    message: 'Sie haben bestanden, aber es gibt noch Verbesserungspotenzial. Wiederholen Sie die Themenbereiche, in denen Sie am meisten Punkte verloren haben.'
                });
            }
        } else {
            recommendations.push({
                type: 'general',
                importance: 'critical',
                message: 'Sie haben den Test nicht bestanden. Nehmen Sie sich Zeit, die Themen gründlich zu wiederholen, bevor Sie den Test erneut versuchen.'
            });
        }
        
        // Empfehlungen basierend auf unbeantorteten Fragen
        if (detailedStats.unansweredPercentage > 10) {
            recommendations.push({
                type: 'time_management',
                importance: 'high',
                message: `Sie haben ${Math.round(detailedStats.unansweredPercentage)}% der Fragen nicht beantwortet. Arbeiten Sie an Ihrem Zeitmanagement und versuchen Sie, alle Fragen zu beantworten.`
            });
        }
        
        // Empfehlungen basierend auf Schwierigkeitsgrad
        if (detailedStats.byDifficulty.hard && detailedStats.byDifficulty.hard.successRate < 50) {
            recommendations.push({
                type: 'difficulty',
                importance: 'medium',
                message: 'Sie haben bei schwierigen Fragen unter 50% erreicht. Fokussieren Sie sich auf komplexere Themen zur Verbesserung.'
            });
        }
        
        // Empfehlungen basierend auf Fragetypen
        Object.keys(detailedStats.byQuestionType).forEach(type => {
            const data = detailedStats.byQuestionType[type];
            if (data.total >= 3 && data.successRate < 50) {
                const typeLabel = _getQuestionTypeLabel(type);
                recommendations.push({
                    type: 'question_type',
                    importance: 'medium',
                    message: `Sie haben bei ${typeLabel}-Fragen unter 50% erreicht. Üben Sie diesen Fragetyp gezielt.`
                });
            }
        });
        
        // Empfehlungen basierend auf Kategorien
        if (testResult.categoryScores) {
            // Kategorien nach Leistung sortieren
            const sortedCategories = Object.keys(testResult.categoryScores)
                .map(category => ({
                    category,
                    percentage: testResult.categoryScores[category].percentage
                }))
                .sort((a, b) => a.percentage - b.percentage);
            
            // Kategorien mit den schwächsten Ergebnissen
            if (sortedCategories.length > 0) {
                const weakestCategory = sortedCategories[0];
                if (weakestCategory.percentage < 60) {
                    recommendations.push({
                        type: 'category',
                        importance: 'high',
                        message: `In der Kategorie "${weakestCategory.category}" haben Sie am schwächsten abgeschnitten (${Math.round(weakestCategory.percentage)}%). Konzentrieren Sie sich besonders auf diesen Bereich.`
                    });
                }
                
                // Wenn eine zweite schwache Kategorie existiert
                if (sortedCategories.length > 1 && sortedCategories[1].percentage < 70) {
                    recommendations.push({
                        type: 'category',
                        importance: 'medium',
                        message: `Auch in der Kategorie "${sortedCategories[1].category}" besteht Verbesserungspotenzial (${Math.round(sortedCategories[1].percentage)}%).`
                    });
                }
            }
        }
        
        return recommendations;
    }
    
    /**
     * Gibt ein benutzerfreundliches Label für einen Fragetyp zurück
     * @param {string} type - Der Fragetyp
     * @returns {string} - Das benutzerfreundliche Label
     */
    function _getQuestionTypeLabel(type) {
        const labels = {
            'multiple_choice': 'Multiple-Choice',
            'single_choice': 'Single-Choice',
            'true_false': 'Wahr/Falsch',
            'free_text': 'Freitext'
        };
        
        return labels[type] || type;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Erstellt ein erweitertes Testergebnis mit Statistiken und Empfehlungen
         * @param {Object} testResult - Das Basisergebnis
         * @param {Array} questionResults - Die Ergebnisse der einzelnen Fragen
         * @returns {Object} - Das erweiterte Testergebnis
         */
        createDetailedResult: function(testResult, questionResults) {
            if (!testResult) {
                return null;
            }
            
            // Detaillierte Statistiken berechnen
            const detailedStats = _calculateDetailedStats(testResult, questionResults);
            
            // Empfehlungen generieren
            const recommendations = _generateRecommendations(testResult, detailedStats);
            
            // Erweiterte Informationen hinzufügen
            const detailedResult = {
                ...testResult,
                detailedStats: detailedStats,
                recommendations: recommendations
            };
            
            return detailedResult;
        },
        
        /**
         * Analysiert mehrere Testergebnisse eines Benutzers für einen übergreifenden Bericht
         * @param {string} userId - ID des Benutzers
         * @param {Array} testResults - Liste von Testergebnissen
         * @returns {Object} - Zusammenfassender Bericht
         */
        createUserSummaryReport: function(userId, testResults) {
            if (!userId || !testResults || testResults.length === 0) {
                return {
                    userId: userId,
                    error: 'Keine Testergebnisse vorhanden'
                };
            }
            
            // Testübergreifende Kennzahlen
            const performanceIndex = window.ImmoLern.Assessment.Scoring.CrossTestScoring.calculatePerformanceIndex(testResults);
            
            // Leistungsübersicht nach Testgruppen
            const testGroupSummaries = {};
            
            // Gruppiere Tests nach ihrer Gruppe
            testResults.forEach(result => {
                const groupId = result.testGroupId || 'ungrouped';
                
                if (!testGroupSummaries[groupId]) {
                    testGroupSummaries[groupId] = {
                        groupId: groupId,
                        groupName: result.testGroupName || 'Nicht gruppiert',
                        testCount: 0,
                        passedCount: 0,
                        totalPercentage: 0,
                        results: []
                    };
                }
                
                const summary = testGroupSummaries[groupId];
                summary.testCount++;
                
                if (result.passed) {
                    summary.passedCount++;
                }
                
                summary.totalPercentage += result.percentage || 0;
                summary.results.push({
                    testId: result.testId,
                    testName: result.testName,
                    timestamp: result.timestamp,
                    percentage: result.percentage,
                    passed: result.passed
                });
            });
            
            // Durchschnitte für jede Gruppe berechnen
            Object.keys(testGroupSummaries).forEach(groupId => {
                const summary = testGroupSummaries[groupId];
                summary.averagePercentage = summary.testCount > 0 ? summary.totalPercentage / summary.testCount : 0;
                summary.successRate = summary.testCount > 0 ? (summary.passedCount / summary.testCount) * 100 : 0;
                
                // Neueste Tests zuerst sortieren
                summary.results.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            });
            
            // Lerntrend berechnen, falls genügend Ergebnisse vorhanden sind
            let learningTrend = null;
            if (testResults.length >= 3) {
                // Lernkurve für alle Tests berechnen
                learningTrend = window.ImmoLern.Assessment.Scoring.AdvancedMetrics.calculateLearningCurve(testResults);
            }
            
            // Zusammenfassenden Bericht erstellen
            return {
                userId: userId,
                timestamp: new Date().toISOString(),
                overallStats: {
                    totalTests: testResults.length,
                    passedTests: testResults.filter(r => r.passed).length,
                    averagePercentage: testResults.reduce((sum, r) => sum + (r.percentage || 0), 0) / testResults.length,
                    performanceIndex: performanceIndex
                },
                testGroupSummaries: testGroupSummaries,
                learningTrend: learningTrend,
                recentTests: testResults
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 5) // Die letzten 5 Tests
            };
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Module mit Standardeinstellungen initialisieren
    window.ImmoLern.Assessment.Scoring.CrossTestScoring.init();
    window.ImmoLern.Assessment.Scoring.RuleEngine.init();
    
    // Benutzerdefiniertes Ereignis auslösen, wenn die Module geladen sind
    document.dispatchEvent(new CustomEvent('crossTestScoringLoaded'));
});
/**
 * JS-Block 6.3.2-part2: Berechnungslogik (Teil 2.2)
 * 
 * Erweiterte Berechnungsfunktionen für die Integration mit anderen Modulen:
 * - Teambezogene Auswertungen
 * - Achievement- und Badgesystem
 * - Lernempfehlungen und adaptives Lernen
 * - Exportfunktionen für Ergebnisse
 * - Integration mit Berichtssystem
 */

// Namespace für Bewertungsauswertung
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Scoring) window.ImmoLern.Assessment.Scoring = {};

// Modul für teambezogene Auswertungen
window.ImmoLern.Assessment.Scoring.TeamAnalytics = (function() {
    // Private Variablen
    let _teamCache = {};
    let _lastUpdate = {};
    const _cacheTimeout = 30 * 60 * 1000; // 30 Minuten Cache-Gültigkeit
    
    // Private Funktionen
    
    /**
     * Gruppiert Benutzerergebnisse nach Teams
     * @param {Array} userResults - Liste von Benutzerergebnissen
     * @returns {Object} - Nach Teams gruppierte Ergebnisse
     */
    function _groupResultsByTeam(userResults) {
        if (!userResults || userResults.length === 0) {
            return {};
        }
        
        const teamResults = {};
        
        userResults.forEach(result => {
            // Wenn kein Team zugewiesen, in "unassigned" gruppieren
            const teamId = result.teamId || 'unassigned';
            
            // Team-Eintrag initialisieren, falls noch nicht vorhanden
            if (!teamResults[teamId]) {
                teamResults[teamId] = {
                    teamId: teamId,
                    teamName: result.teamName || 'Nicht zugewiesen',
                    userCount: 0,
                    testCount: 0,
                    passedCount: 0,
                    totalPercentage: 0,
                    users: {},
                    testCategories: {}
                };
            }
            
            const team = teamResults[teamId];
            
            // Benutzer zur Team-Statistik hinzufügen
            if (!team.users[result.userId]) {
                team.users[result.userId] = {
                    userId: result.userId,
                    userName: result.userName || 'Unbekannt',
                    testCount: 0,
                    passedCount: 0,
                    totalPercentage: 0
                };
                team.userCount++;
            }
            
            const user = team.users[result.userId];
            user.testCount++;
            
            if (result.passed) {
                user.passedCount++;
                team.passedCount++;
            }
            
            user.totalPercentage += result.percentage || 0;
            team.totalPercentage += result.percentage || 0;
            team.testCount++;
            
            // Kategorien-Statistiken aktualisieren
            if (result.categoryScores) {
                Object.keys(result.categoryScores).forEach(category => {
                    if (!team.testCategories[category]) {
                        team.testCategories[category] = {
                            category: category,
                            testCount: 0,
                            totalPercentage: 0
                        };
                    }
                    
                    const catScore = result.categoryScores[category];
                    team.testCategories[category].testCount++;
                    team.testCategories[category].totalPercentage += catScore.percentage || 0;
                });
            }
        });
        
        // Durchschnitte berechnen
        Object.keys(teamResults).forEach(teamId => {
            const team = teamResults[teamId];
            
            // Team-Durchschnitt
            team.averagePercentage = team.testCount > 0 ? team.totalPercentage / team.testCount : 0;
            team.passRate = team.testCount > 0 ? (team.passedCount / team.testCount) * 100 : 0;
            
            // Benutzer-Durchschnitte
            Object.keys(team.users).forEach(userId => {
                const user = team.users[userId];
                user.averagePercentage = user.testCount > 0 ? user.totalPercentage / user.testCount : 0;
                user.passRate = user.testCount > 0 ? (user.passedCount / user.testCount) * 100 : 0;
            });
            
            // Kategorie-Durchschnitte
            Object.keys(team.testCategories).forEach(category => {
                const cat = team.testCategories[category];
                cat.averagePercentage = cat.testCount > 0 ? cat.totalPercentage / cat.testCount : 0;
            });
            
            // Ergebnisse für die Verwendung in Charts aufbereiten
            _prepareChartData(team);
        });
        
        return teamResults;
    }
    
    /**
     * Bereitet Daten für Chart-Visualisierungen vor
     * @param {Object} team - Team-Objekt mit Auswertungsdaten
     */
    function _prepareChartData(team) {
        if (!team) return;
        
        // Arrays für Chart-Daten erstellen
        team.chartData = {
            // Daten für Teammitglieder-Vergleich
            userComparison: Object.values(team.users).map(user => ({
                name: user.userName,
                average: user.averagePercentage,
                testCount: user.testCount,
                passRate: user.passRate
            })).sort((a, b) => b.average - a.average),
            
            // Daten für Kategorien-Vergleich
            categoryComparison: Object.values(team.testCategories).map(cat => ({
                name: cat.category,
                average: cat.averagePercentage,
                testCount: cat.testCount
            })).sort((a, b) => b.average - a.average)
        };
    }
    
    /**
     * Analysiert Stärken und Schwächen eines Teams
     * @param {Object} team - Team-Objekt mit Auswertungsdaten
     * @returns {Object} - Stärken und Schwächen des Teams
     */
    function _analyzeTeamStrengthsWeaknesses(team) {
        if (!team || !team.testCategories || Object.keys(team.testCategories).length === 0) {
            return {
                strengths: [],
                weaknesses: [],
                topPerformers: [],
                needsImprovement: []
            };
        }
        
        // Kategorien nach Leistung sortieren
        const sortedCategories = Object.values(team.testCategories)
            .sort((a, b) => b.averagePercentage - a.averagePercentage);
        
        // Durchschnittliche Leistung über alle Kategorien
        const categoryCount = sortedCategories.length;
        const averageCategoryPerformance = sortedCategories.reduce(
            (sum, cat) => sum + cat.averagePercentage, 0
        ) / categoryCount;
        
        // Stärken: Kategorien 10% über dem Durchschnitt
        const strengths = sortedCategories.filter(
            cat => cat.averagePercentage >= averageCategoryPerformance * 1.1
        );
        
        // Schwächen: Kategorien 10% unter dem Durchschnitt
        const weaknesses = sortedCategories.filter(
            cat => cat.averagePercentage <= averageCategoryPerformance * 0.9
        );
        
        // Benutzer nach Leistung sortieren
        const sortedUsers = Object.values(team.users)
            .sort((a, b) => b.averagePercentage - a.averagePercentage);
        
        // Top-Performer (obere 20%)
        const topPerformerCount = Math.max(1, Math.ceil(sortedUsers.length * 0.2));
        const topPerformers = sortedUsers.slice(0, topPerformerCount);
        
        // Verbesserungsbedürftige (untere 20%)
        const needsImprovementCount = Math.max(1, Math.ceil(sortedUsers.length * 0.2));
        const needsImprovement = sortedUsers.slice(-needsImprovementCount).reverse();
        
        return {
            strengths: strengths,
            weaknesses: weaknesses,
            topPerformers: topPerformers,
            needsImprovement: needsImprovement,
            averageCategoryPerformance: averageCategoryPerformance
        };
    }
    
    /**
     * Berechnet Leistungsvergleiche zwischen Teams
     * @param {Object} teamsData - Nach Teams gruppierte Ergebnisse
     * @returns {Object} - Vergleichsanalyse
     */
    function _compareTeamPerformance(teamsData) {
        if (!teamsData || Object.keys(teamsData).length < 2) {
            return {
                teams: [],
                rankings: {},
                comparisons: {}
            };
        }
        
        // Teams als Array umwandeln für die Sortierung
        const teams = Object.values(teamsData);
        
        // Vergleichsmetriken definieren
        const metrics = [
            { id: 'averagePercentage', name: 'Durchschnittliche Punktzahl' },
            { id: 'passRate', name: 'Bestehensquote' }
        ];
        
        // Rankings für jede Metrik erstellen
        const rankings = {};
        metrics.forEach(metric => {
            rankings[metric.id] = [...teams]
                .sort((a, b) => b[metric.id] - a[metric.id])
                .map((team, index) => ({
                    rank: index + 1,
                    teamId: team.teamId,
                    teamName: team.teamName,
                    value: team[metric.id]
                }));
        });
        
        // Paarweise Vergleiche berechnen
        const comparisons = {};
        for (let i = 0; i < teams.length; i++) {
            for (let j = i + 1; j < teams.length; j++) {
                const team1 = teams[i];
                const team2 = teams[j];
                const comparisonKey = `${team1.teamId}_vs_${team2.teamId}`;
                
                comparisons[comparisonKey] = metrics.map(metric => {
                    const difference = team1[metric.id] - team2[metric.id];
                    const percentDifference = team2[metric.id] !== 0 ? 
                        (difference / team2[metric.id]) * 100 : 
                        0;
                    
                    return {
                        metricId: metric.id,
                        metricName: metric.name,
                        team1Value: team1[metric.id],
                        team2Value: team2[metric.id],
                        difference: difference,
                        percentDifference: percentDifference,
                        team1Better: difference > 0
                    };
                });
            }
        }
        
        return {
            teams: teams,
            rankings: rankings,
            comparisons: comparisons
        };
    }
    
    /**
     * Generiert Erkenntnisse und Empfehlungen für ein Team
     * @param {Object} team - Team-Objekt mit Auswertungsdaten
     * @param {Object} analysis - Stärken-/Schwächen-Analyse
     * @returns {Array} - Liste von Erkenntnissen und Empfehlungen
     */
    function _generateTeamInsights(team, analysis) {
        if (!team || !analysis) {
            return [];
        }
        
        const insights = [];
        
        // Allgemeine Team-Leistung
        if (team.averagePercentage >= 80) {
            insights.push({
                type: 'performance',
                importance: 'positive',
                message: `Das Team zeigt insgesamt eine sehr gute Leistung mit einer durchschnittlichen Punktzahl von ${Math.round(team.averagePercentage)}%.`
            });
        } else if (team.averagePercentage < 60) {
            insights.push({
                type: 'performance',
                importance: 'negative',
                message: `Die Gesamtleistung des Teams liegt mit ${Math.round(team.averagePercentage)}% unter dem erwarteten Niveau.`
            });
        }
        
        // Bestehensquote
        if (team.passRate < 70) {
            insights.push({
                type: 'pass_rate',
                importance: 'warning',
                message: `Die Bestehensquote des Teams beträgt nur ${Math.round(team.passRate)}%. Gezielte Unterstützung könnte erforderlich sein.`
            });
        }
        
        // Stärken hervorheben
        if (analysis.strengths.length > 0) {
            const topStrength = analysis.strengths[0];
            insights.push({
                type: 'strength',
                importance: 'positive',
                message: `Das Team zeigt besondere Stärke in der Kategorie "${topStrength.category}" mit einer durchschnittlichen Punktzahl von ${Math.round(topStrength.averagePercentage)}%.`
            });
        }
        
        // Schwächen identifizieren
        if (analysis.weaknesses.length > 0) {
            const topWeakness = analysis.weaknesses[0];
            insights.push({
                type: 'weakness',
                importance: 'negative',
                message: `Die größte Herausforderung für das Team liegt in der Kategorie "${topWeakness.category}" mit nur ${Math.round(topWeakness.averagePercentage)}%.`
            });
            
            // Empfehlung für die Verbesserung
            insights.push({
                type: 'recommendation',
                importance: 'action',
                message: `Empfehlung: Planen Sie gezielte Schulungen für die Kategorie "${topWeakness.category}", um die Teamleistung zu verbessern.`
            });
        }
        
        // Leistungsunterschiede innerhalb des Teams
        if (analysis.topPerformers.length > 0 && analysis.needsImprovement.length > 0) {
            const topPerformer = analysis.topPerformers[0];
            const lowPerformer = analysis.needsImprovement[0];
            
            const performanceGap = topPerformer.averagePercentage - lowPerformer.averagePercentage;
            
            if (performanceGap > 30) {
                insights.push({
                    type: 'team_balance',
                    importance: 'warning',
                    message: `Es gibt erhebliche Leistungsunterschiede innerhalb des Teams (${Math.round(performanceGap)} Prozentpunkte zwischen Bestem und Schwächstem).`
                });
                
                // Empfehlung für Peer-Learning
                insights.push({
                    type: 'recommendation',
                    importance: 'action',
                    message: `Empfehlung: Fördern Sie Peer-Learning im Team, um Wissen auszutauschen und die Unterschiede zu verringern.`
                });
            }
        }
        
        return insights;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Analysiert Testergebnisse für ein Team
         * @param {string} teamId - ID des Teams
         * @param {Array} results - Liste von Testergebnissen
         * @returns {Object} - Teamanalyse
         */
        analyzeTeam: function(teamId, results) {
            if (!teamId || !results || results.length === 0) {
                return {
                    teamId: teamId,
                    error: 'Keine Daten für die Analyse verfügbar'
                };
            }
            
            // Für jedes Ergebnis Team-ID hinzufügen
            const resultsWithTeam = results.map(result => ({
                ...result,
                teamId: teamId
            }));
            
            // Nach Teams gruppieren
            const teamsData = _groupResultsByTeam(resultsWithTeam);
            
            // Team-Daten abrufen
            const teamData = teamsData[teamId];
            
            if (!teamData) {
                return {
                    teamId: teamId,
                    error: 'Keine Daten für dieses Team verfügbar'
                };
            }
            
            // Stärken und Schwächen analysieren
            const strengthsWeaknesses = _analyzeTeamStrengthsWeaknesses(teamData);
            
            // Erkenntnisse und Empfehlungen generieren
            const insights = _generateTeamInsights(teamData, strengthsWeaknesses);
            
            // Teamanalyse erstellen
            const teamAnalysis = {
                ...teamData,
                analysis: strengthsWeaknesses,
                insights: insights,
                timestamp: new Date().toISOString()
            };
            
            // Im Cache speichern
            _teamCache[teamId] = teamAnalysis;
            _lastUpdate[teamId] = Date.now();
            
            return teamAnalysis;
        },
        
        /**
         * Analysiert und vergleicht mehrere Teams
         * @param {Array} teamIds - Liste von Team-IDs
         * @param {Array} allResults - Liste aller Testergebnisse
         * @returns {Object} - Vergleichsanalyse für Teams
         */
        compareTeams: function(teamIds, allResults) {
            if (!teamIds || teamIds.length < 2 || !allResults || allResults.length === 0) {
                return {
                    error: 'Nicht genügend Daten für einen Teamvergleich'
                };
            }
            
            // Teamergebnisse filtern
            const teamResults = allResults.filter(result => 
                result.teamId && teamIds.includes(result.teamId)
            );
            
            if (teamResults.length === 0) {
                return {
                    error: 'Keine Ergebnisse für die angegebenen Teams gefunden'
                };
            }
            
            // Nach Teams gruppieren
            const teamsData = _groupResultsByTeam(teamResults);
            
            // Leistungsvergleiche berechnen
            const comparisons = _compareTeamPerformance(teamsData);
            
            // Teamanalysen für jedes Team
            const teamAnalyses = {};
            teamIds.forEach(teamId => {
                if (teamsData[teamId]) {
                    const analysis = _analyzeTeamStrengthsWeaknesses(teamsData[teamId]);
                    const insights = _generateTeamInsights(teamsData[teamId], analysis);
                    
                    teamAnalyses[teamId] = {
                        ...teamsData[teamId],
                        analysis: analysis,
                        insights: insights
                    };
                    
                    // Im Cache aktualisieren
                    _teamCache[teamId] = teamAnalyses[teamId];
                    _lastUpdate[teamId] = Date.now();
                }
            });
            
            return {
                teams: teamAnalyses,
                comparisons: comparisons,
                timestamp: new Date().toISOString()
            };
        },
        
        /**
         * Ruft eine gespeicherte Teamanalyse aus dem Cache ab
         * @param {string} teamId - ID des Teams
         * @returns {Object|null} - Die Teamanalyse oder null, wenn nicht im Cache
         */
        getCachedTeamAnalysis: function(teamId) {
            if (!teamId || !_teamCache[teamId]) {
                return null;
            }
            
            // Prüfen, ob der Cache noch gültig ist
            const now = Date.now();
            if (_lastUpdate[teamId] && (now - _lastUpdate[teamId] <= _cacheTimeout)) {
                return _teamCache[teamId];
            }
            
            return null;
        }
    };
})();

// Modul für Achievements und Badges
window.ImmoLern.Assessment.Scoring.AchievementSystem = (function() {
    // Private Variablen
    let _achievementDefinitions = {};
    let _badgeDefinitions = {};
    let _userAchievements = {};
    
    // Standarddefinitionen für Achievements
    const _defaultAchievements = {
        // Testbezogene Achievements
        'first_test_completed': {
            id: 'first_test_completed',
            name: 'Erster Test',
            description: 'Ersten Test abgeschlossen',
            type: 'milestone',
            icon: 'milestone_1',
            condition: (stats) => stats.testsTaken >= 1,
            points: 10
        },
        
        'perfect_score': {
            id: 'perfect_score',
            name: 'Perfektion',
            description: '100% in einem Test erreicht',
            type: 'performance',
            icon: 'star',
            condition: (stats) => stats.perfectTests >= 1,
            points: 50
        },
        
        'test_master': {
            id: 'test_master',
            name: 'Testmeister',
            description: '10 Tests bestanden',
            type: 'progression',
            icon: 'trophy',
            condition: (stats) => stats.testsPassed >= 10,
            points: 100
        },
        
        'quick_learner': {
            id: 'quick_learner',
            name: 'Schneller Lerner',
            description: 'Test unter 50% der durchschnittlichen Zeit abgeschlossen',
            type: 'performance',
            icon: 'clock',
            condition: (stats) => stats.fastCompletions >= 1,
            points: 30
        },
        
        // Kategorien-Achievements
        'category_expert': {
            id: 'category_expert',
            name: 'Kategorieexperte',
            description: 'Durchschnittlich über 90% in einer Kategorie',
            type: 'mastery',
            icon: 'medal',
            condition: (stats) => Object.keys(stats.categoryMastery).some(cat => stats.categoryMastery[cat] >= 90),
            points: 75
        },
        
        // Konsistenz-Achievements
        'consistent_performer': {
            id: 'consistent_performer',
            name: 'Beständiger Performer',
            description: '5 Tests in Folge bestanden',
            type: 'consistency',
            icon: 'streak',
            condition: (stats) => stats.consecutivePasses >= 5,
            points: 80
        },
        
        // Fortschritts-Achievements
        'improvement_king': {
            id: 'improvement_king',
            name: 'Verbesserungskönig',
            description: 'Mindestens 30% Verbesserung von einem Test zum nächsten',
            type: 'improvement',
            icon: 'growth',
            condition: (stats) => stats.biggestImprovement >= 30,
            points: 60
        }
    };
    
    // Standarddefinitionen für Badges
    const _defaultBadges = {
        'bronze_performer': {
            id: 'bronze_performer',
            name: 'Bronze-Performer',
            description: 'Stetige gute Leistung gezeigt',
            icon: 'badge_bronze',
            requiredAchievements: ['first_test_completed', 'consistent_performer'],
            requiredPoints: 100
        },
        
        'silver_performer': {
            id: 'silver_performer',
            name: 'Silber-Performer',
            description: 'Hervorragende Testleistungen',
            icon: 'badge_silver',
            requiredAchievements: ['test_master', 'category_expert'],
            requiredPoints: 200
        },
        
        'gold_performer': {
            id: 'gold_performer',
            name: 'Gold-Performer',
            description: 'Meisterhafte Beherrschung des Lernmaterials',
            icon: 'badge_gold',
            requiredAchievements: ['perfect_score', 'test_master', 'category_expert'],
            requiredPoints: 300
        },
        
        'speed_master': {
            id: 'speed_master',
            name: 'Geschwindigkeitsmeister',
            description: 'Schnell und präzise',
            icon: 'speed',
            requiredAchievements: ['quick_learner', 'perfect_score'],
            requiredPoints: 150
        },
        
        'improvement_badge': {
            id: 'improvement_badge',
            name: 'Verbesserungsabzeichen',
            description: 'Kontinuierliche Verbesserung gezeigt',
            icon: 'improvement',
            requiredAchievements: ['improvement_king'],
            requiredPoints: 80
        }
    };
    
    // Private Funktionen
    
    /**
     * Berechnet die Benutzerstatistik für die Achievement-Prüfung
     * @param {string} userId - ID des Benutzers
     * @param {Array} testResults - Liste von Testergebnissen
     * @returns {Object} - Benutzerstatistik
     */
    function _calculateUserStats(userId, testResults) {
        if (!userId || !testResults || testResults.length === 0) {
            return {
                userId: userId,
                testsTaken: 0,
                testsPassed: 0,
                perfectTests: 0,
                averageScore: 0,
                consecutivePasses: 0,
                fastCompletions: 0,
                biggestImprovement: 0,
                categoryMastery: {}
            };
        }
        
        // Nur die Ergebnisse dieses Benutzers filtern
        const userResults = testResults.filter(result => result.userId === userId);
        
        // Nach Datum sortieren (älteste zuerst)
        userResults.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Grundlegende Statistiken
        const stats = {
            userId: userId,
            testsTaken: userResults.length,
            testsPassed: userResults.filter(result => result.passed).length,
            perfectTests: userResults.filter(result => result.percentage >= 100).length,
            averageScore: userResults.reduce((sum, result) => sum + (result.percentage || 0), 0) / userResults.length,
            consecutivePasses: 0,
            fastCompletions: 0,
            biggestImprovement: 0,
            categoryMastery: {}
        };
        
        // Konsekutive bestandene Tests zählen
        let currentStreak = 0;
        userResults.forEach(result => {
            if (result.passed) {
                currentStreak++;
                stats.consecutivePasses = Math.max(stats.consecutivePasses, currentStreak);
            } else {
                currentStreak = 0;
            }
        });
        
        // Schnelle Abschlüsse zählen (schneller als 50% der durchschnittlichen Zeit)
        userResults.forEach(result => {
            if (result.timeSpent && result.expectedTime && result.timeSpent <= result.expectedTime * 0.5) {
                stats.fastCompletions++;
            }
        });
        
        // Größte Verbesserung zwischen aufeinanderfolgenden Tests berechnen
        for (let i = 1; i < userResults.length; i++) {
            const prevScore = userResults[i-1].percentage || 0;
            const currScore = userResults[i].percentage || 0;
            
            if (prevScore > 0) {
                const improvement = ((currScore - prevScore) / prevScore) * 100;
                stats.biggestImprovement = Math.max(stats.biggestImprovement, improvement);
            }
        }
        
        // Kategorie-Beherrschung berechnen
        const categoryScores = {};
        let categoryCounts = {};
        
        userResults.forEach(result => {
            if (result.categoryScores) {
                Object.keys(result.categoryScores).forEach(category => {
                    if (!categoryScores[category]) {
                        categoryScores[category] = 0;
                        categoryCounts[category] = 0;
                    }
                    
                    categoryScores[category] += result.categoryScores[category].percentage || 0;
                    categoryCounts[category]++;
                });
            }
        });
        
        // Durchschnittliche Punktzahl pro Kategorie
        Object.keys(categoryScores).forEach(category => {
            if (categoryCounts[category] > 0) {
                stats.categoryMastery[category] = categoryScores[category] / categoryCounts[category];
            }
        });
        
        return stats;
    }
    
    /**
     * Prüft, welche Achievements ein Benutzer erreicht hat
     * @param {Object} userStats - Benutzerstatistik
     * @returns {Array} - Liste erreichter Achievements
     */
    function _checkAchievements(userStats) {
        if (!userStats) {
            return [];
        }
        
        const achievedList = [];
        
        // Alle definierten Achievements prüfen
        Object.values(_achievementDefinitions).forEach(achievement => {
            try {
                // Bedingung prüfen
                if (achievement.condition && achievement.condition(userStats)) {
                    achievedList.push({
                        ...achievement,
                        achievedAt: new Date().toISOString()
                    });
                }
            } catch (error) {
                console.error(`Fehler bei der Prüfung des Achievements ${achievement.id}:`, error);
            }
        });
        
        return achievedList;
    }
    
    /**
     * Prüft, welche Badges ein Benutzer verdient hat
     * @param {string} userId - ID des Benutzers
     * @param {Array} achievements - Liste erreichter Achievements
     * @returns {Array} - Liste verdiente Badges
     */
    function _checkBadges(userId, achievements) {
        if (!userId || !achievements || achievements.length === 0) {
            return [];
        }
        
        const earnedBadges = [];
        const achievementIds = achievements.map(a => a.id);
        const totalPoints = achievements.reduce((sum, a) => sum + (a.points || 0), 0);
        
        // Alle Badge-Definitionen prüfen
        Object.values(_badgeDefinitions).forEach(badge => {
            // Prüfen, ob alle erforderlichen Achievements erreicht wurden
            const hasRequiredAchievements = badge.requiredAchievements.every(
                reqId => achievementIds.includes(reqId)
            );
            
            // Prüfen, ob die Mindestpunktzahl erreicht wurde
            const hasEnoughPoints = totalPoints >= badge.requiredPoints;
            
            if (hasRequiredAchievements && hasEnoughPoints) {
                earnedBadges.push({
                    ...badge,
                    earnedAt: new Date().toISOString()
                });
            }
        });
        
        return earnedBadges;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Achievement-System
         */
        init: function() {
            // Standarddefinitionen laden
            _achievementDefinitions = { ..._defaultAchievements };
            _badgeDefinitions = { ..._defaultBadges };
            
            return this;
        },
        
        /**
         * Fügt eine neue Achievement-Definition hinzu
         * @param {Object} achievement - Die Achievement-Definition
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addAchievement: function(achievement) {
            if (!achievement || !achievement.id || !achievement.condition) {
                return false;
            }
            
            _achievementDefinitions[achievement.id] = achievement;
            return true;
        },
        
        /**
         * Fügt eine neue Badge-Definition hinzu
         * @param {Object} badge - Die Badge-Definition
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addBadge: function(badge) {
            if (!badge || !badge.id || !badge.requiredAchievements) {
                return false;
            }
            
            _badgeDefinitions[badge.id] = badge;
            return true;
        },
        
        /**
         * Aktualisiert die Achievements eines Benutzers
         * @param {string} userId - ID des Benutzers
         * @param {Array} testResults - Liste von Testergebnissen
         * @returns {Object} - Die aktualisierten Benutzer-Achievements
         */
        updateUserAchievements: function(userId, testResults) {
            if (!userId || !testResults || testResults.length === 0) {
                return null;
            }
            
            // Benutzerstatistik berechnen
            const userStats = _calculateUserStats(userId, testResults);
            
            // Erreichte Achievements prüfen
            const achievements = _checkAchievements(userStats);
            
            // Verdiente Badges prüfen
            const badges = _checkBadges(userId, achievements);
            
            // Benutzer-Achievements aktualisieren
            _userAchievements[userId] = {
                userId: userId,
                stats: userStats,
                achievements: achievements,
                badges: badges,
                totalPoints: achievements.reduce((sum, a) => sum + (a.points || 0), 0),
                lastUpdated: new Date().toISOString()
            };
            
            return _userAchievements[userId];
        },
        
        /**
         * Ruft die Achievements eines Benutzers ab
         * @param {string} userId - ID des Benutzers
         * @returns {Object|null} - Die Benutzer-Achievements oder null, wenn nicht vorhanden
         */
        getUserAchievements: function(userId) {
            return _userAchievements[userId] || null;
        },
        
        /**
         * Gibt alle verfügbaren Achievement-Definitionen zurück
         * @returns {Object} - Die Achievement-Definitionen
         */
        getAchievementDefinitions: function() {
            return { ..._achievementDefinitions };
        },
        
        /**
         * Gibt alle verfügbaren Badge-Definitionen zurück
         * @returns {Object} - Die Badge-Definitionen
         */
        getBadgeDefinitions: function() {
            return { ..._badgeDefinitions };
        }
    };
})();

// Modul für Lernempfehlungen
window.ImmoLern.Assessment.Scoring.AdaptiveLearning = (function() {
    // Private Variablen
    let _learningPathTemplates = {};
    let _contentMapping = {};
    let _userRecommendations = {};
    
    // Private Funktionen
    
    /**
     * Erstellt personalisierte Lernempfehlungen basierend auf Testergebnissen
     * @param {string} userId - ID des Benutzers
     * @param {Array} testResults - Liste von Testergebnissen
     * @returns {Object} - Personalisierte Empfehlungen
     */
    function _createPersonalizedRecommendations(userId, testResults) {
        if (!userId || !testResults || testResults.length === 0) {
            return {
                userId: userId,
                recommendations: [],
                timestamp: new Date().toISOString()
            };
        }
        
        // Neuestes Testergebnis für Empfehlungen verwenden
        const latestResult = [...testResults]
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
        
        // Kategorien mit schwacher Leistung identifizieren (unter 70%)
        const weakCategories = [];
        if (latestResult.categoryScores) {
            Object.keys(latestResult.categoryScores).forEach(category => {
                const score = latestResult.categoryScores[category];
                if (score.percentage < 70) {
                    weakCategories.push({
                        category: category,
                        percentage: score.percentage
                    });
                }
            });
        }
        
        // Nach Leistung sortieren (schwächste zuerst)
        weakCategories.sort((a, b) => a.percentage - b.percentage);
        
        // Empfehlungen basierend auf schwachen Kategorien
        const recommendations = [];
        
        // Für jede schwache Kategorie Lernmaterial empfehlen
        weakCategories.forEach(weak => {
            // Relevante Inhalte für diese Kategorie finden
            const relevantContent = _findRelevantContent(weak.category);
            
            if (relevantContent.length > 0) {
                recommendations.push({
                    type: 'content',
                    reason: `Verbesserungsbedarf in ${weak.category} (${Math.round(weak.percentage)}%)`,
                    priority: _getPriorityByScore(weak.percentage),
                    content: relevantContent,
                    category: weak.category
                });
            }
        });
        
        // Praxis-Tests empfehlen, wenn verfügbar
        const relevantTests = _findRelevantTests(weakCategories.map(wc => wc.category));
        if (relevantTests.length > 0) {
            recommendations.push({
                type: 'practice',
                reason: 'Übungstests für Verbesserungsbereiche',
                priority: 'medium',
                tests: relevantTests
            });
        }
        
        // Wenn Benutzer den Test nicht bestanden hat, einen Lernpfad empfehlen
        if (!latestResult.passed) {
            const learningPath = _createLearningPath(userId, weakCategories);
            if (learningPath) {
                recommendations.push({
                    type: 'learning_path',
                    reason: 'Strukturierter Lernplan für nicht bestandenen Test',
                    priority: 'high',
                    learningPath: learningPath
                });
            }
        }
        
        return {
            userId: userId,
            testId: latestResult.testId,
            recommendationId: `rec_${userId}_${Date.now()}`,
            recommendations: recommendations,
            weakCategories: weakCategories,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Findet relevante Lerninhalte für eine Kategorie
     * @param {string} category - Die Kategorie
     * @returns {Array} - Relevante Lerninhalte
     */
    function _findRelevantContent(category) {
        if (!category || !_contentMapping[category]) {
            return [];
        }
        
        return _contentMapping[category].map(content => ({
            id: content.id,
            title: content.title,
            type: content.type,
            url: content.url,
            duration: content.duration
        }));
    }
    
    /**
     * Findet relevante Übungstests für bestimmte Kategorien
     * @param {Array} categories - Liste von Kategorien
     * @returns {Array} - Relevante Übungstests
     */
    function _findRelevantTests(categories) {
        if (!categories || categories.length === 0) {
            return [];
        }
        
        const relevantTests = [];
        
        // In allen Kategorien nach passenden Tests suchen
        categories.forEach(category => {
            if (_contentMapping[category]) {
                // Tests aus dieser Kategorie filtern
                const tests = _contentMapping[category]
                    .filter(content => content.type === 'test' || content.type === 'quiz')
                    .map(test => ({
                        id: test.id,
                        title: test.title,
                        category: category,
                        url: test.url,
                        estimatedTime: test.duration
                    }));
                
                relevantTests.push(...tests);
            }
        });
        
        return relevantTests;
    }
    
    /**
     * Bestimmt die Priorität basierend auf der Punktzahl
     * @param {number} score - Die Punktzahl
     * @returns {string} - Die Priorität (high, medium, low)
     */
    function _getPriorityByScore(score) {
        if (score < 50) return 'high';
        if (score < 65) return 'medium';
        return 'low';
    }
    
    /**
     * Erstellt einen personalisierten Lernpfad
     * @param {string} userId - ID des Benutzers
     * @param {Array} weakCategories - Liste schwacher Kategorien
     * @returns {Object} - Der Lernpfad
     */
    function _createLearningPath(userId, weakCategories) {
        if (!userId || !weakCategories || weakCategories.length === 0) {
            return null;
        }
        
        // Basisvorlage für Lernpfade verwenden
        const baseTemplate = _learningPathTemplates.basic || {
            name: 'Standard-Lernpfad',
            description: 'Strukturierter Lernplan zur Verbesserung',
            steps: []
        };
        
        // Lernpfad erstellen
        const learningPath = {
            id: `path_${userId}_${Date.now()}`,
            name: baseTemplate.name,
            description: baseTemplate.description,
            userId: userId,
            createdAt: new Date().toISOString(),
            steps: [],
            estimatedDuration: 0
        };
        
        // Schritte für jede schwache Kategorie hinzufügen
        weakCategories.forEach((weak, index) => {
            // Relevante Inhalte für diese Kategorie finden
            const relevantContent = _findRelevantContent(weak.category);
            
            if (relevantContent.length > 0) {
                // Bis zu 3 Inhalte pro Kategorie verwenden
                const selectedContent = relevantContent.slice(0, 3);
                
                // Lernpfad-Schritt erstellen
                const step = {
                    stepNumber: index + 1,
                    title: `Verbessere deine Kenntnisse in ${weak.category}`,
                    description: `Fokus auf Inhalte, die deine Leistung in ${weak.category} verbessern`,
                    content: selectedContent,
                    category: weak.category,
                    estimatedDuration: selectedContent.reduce((sum, content) => sum + (content.duration || 0), 0)
                };
                
                learningPath.steps.push(step);
                learningPath.estimatedDuration += step.estimatedDuration;
            }
        });
        
        // Abschließenden Test hinzufügen
        const relevantTests = _findRelevantTests(weakCategories.map(wc => wc.category));
        if (relevantTests.length > 0) {
            // Den ersten relevanten Test als finalen Schritt verwenden
            const finalTest = relevantTests[0];
            
            learningPath.steps.push({
                stepNumber: learningPath.steps.length + 1,
                title: 'Überprüfe dein Wissen',
                description: 'Teste deinen Lernfortschritt mit einem Übungstest',
                content: [finalTest],
                category: 'assessment',
                estimatedDuration: finalTest.estimatedTime || 30
            });
            
            learningPath.estimatedDuration += finalTest.estimatedTime || 30;
        }
        
        return learningPath;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul für adaptive Lernempfehlungen
         * @param {Object} options - Konfigurationsoptionen
         */
        init: function(options = {}) {
            // Content-Mapping initialisieren, falls vorhanden
            if (options.contentMapping) {
                _contentMapping = options.contentMapping;
            }
            
            // Lernpfad-Vorlagen initialisieren, falls vorhanden
            if (options.learningPathTemplates) {
                _learningPathTemplates = options.learningPathTemplates;
            } else {
                // Standard-Vorlage hinzufügen
                _learningPathTemplates = {
                    basic: {
                        name: 'Standard-Lernpfad',
                        description: 'Strukturierter Lernplan zur Verbesserung',
                        steps: []
                    }
                };
            }
            
            return this;
        },
        
        /**
         * Fügt einen Lerninhalt zum Content-Mapping hinzu
         * @param {string} category - Die Kategorie
         * @param {Object} content - Der Lerninhalt
         */
        addContent: function(category, content) {
            if (!category || !content || !content.id) {
                return false;
            }
            
            // Kategorie initialisieren, falls noch nicht vorhanden
            if (!_contentMapping[category]) {
                _contentMapping[category] = [];
            }
            
            // Prüfen, ob der Inhalt bereits existiert
            const existingIndex = _contentMapping[category].findIndex(c => c.id === content.id);
            
            if (existingIndex >= 0) {
                // Bestehenden Inhalt aktualisieren
                _contentMapping[category][existingIndex] = content;
            } else {
                // Neuen Inhalt hinzufügen
                _contentMapping[category].push(content);
            }
            
            return true;
        },
        
        /**
         * Erstellt personalisierte Lernempfehlungen für einen Benutzer
         * @param {string} userId - ID des Benutzers
         * @param {Array} testResults - Liste von Testergebnissen
         * @returns {Object} - Die personalisierten Empfehlungen
         */
        createRecommendations: function(userId, testResults) {
            if (!userId || !testResults || testResults.length === 0) {
                return null;
            }
            
            // Personalisierte Empfehlungen erstellen
            const recommendations = _createPersonalizedRecommendations(userId, testResults);
            
            // Empfehlungen für den Benutzer speichern
            _userRecommendations[userId] = recommendations;
            
            return recommendations;
        },
        
        /**
         * Ruft die gespeicherten Empfehlungen eines Benutzers ab
         * @param {string} userId - ID des Benutzers
         * @returns {Object|null} - Die Empfehlungen oder null, wenn nicht vorhanden
         */
        getUserRecommendations: function(userId) {
            return _userRecommendations[userId] || null;
        }
    };
})();

// Modul für Export-Funktionen
window.ImmoLern.Assessment.Scoring.ExportManager = (function() {
    // Private Variablen
    let _exportFormats = ['json', 'csv', 'pdf', 'html'];
    
    // Private Funktionen
    
    /**
     * Erstellt eine CSV-Datei aus Testergebnissen
     * @param {Array} results - Die zu exportierenden Testergebnisse
     * @returns {string} - CSV-Inhalt
     */
    function _createCSV(results) {
        if (!results || results.length === 0) {
            return '';
        }
        
        // Spaltenüberschriften basierend auf den vorhandenen Daten erstellen
        const headers = ['ID', 'Test-ID', 'Benutzer-ID', 'Datum', 'Punkte', 'Max. Punkte', 
                        'Prozent', 'Bestanden', 'Zeit (Min.)', 'Fragen gesamt', 'Richtige Fragen'];
        
        // Zusatzfelder für kategorisierte Daten
        const categories = new Set();
        
        // Alle Kategorien sammeln
        results.forEach(result => {
            if (result.categoryScores) {
                Object.keys(result.categoryScores).forEach(category => {
                    categories.add(category);
                });
            }
        });
        
        // Kategoriespalten hinzufügen
        categories.forEach(category => {
            headers.push(`${category} (%)`)
        });
        
        // CSV-Zeilen erstellen
        const rows = [headers];
        
        results.forEach(result => {
            const row = [
                result.id || '',
                result.testId || '',
                result.userId || '',
                result.timestamp ? new Date(result.timestamp).toLocaleString() : '',
                result.score || 0,
                result.maxScore || 0,
                result.percentage ? Math.round(result.percentage * 10) / 10 : 0,
                result.passed ? 'Ja' : 'Nein',
                result.timeSpent ? Math.round(result.timeSpent / 60000 * 10) / 10 : '',
                result.detailedStats?.totalQuestions || '',
                result.detailedStats?.correctQuestions || ''
            ];
            
            // Kategoriewerte hinzufügen
            categories.forEach(category => {
                const categoryScore = result.categoryScores && result.categoryScores[category] ?
                    Math.round(result.categoryScores[category].percentage * 10) / 10 : '';
                row.push(categoryScore);
            });
            
            rows.push(row);
        });
        
        // CSV erstellen
        return rows.map(row => 
            row.map(value => 
                // Werte mit Kommata oder Zeilenumbrüchen in Anführungszeichen setzen
                typeof value === 'string' && (value.includes(',') || value.includes('\n')) ? 
                    `"${value.replace(/"/g, '""')}"` : value
            ).join(',')
        ).join('\n');
    }
    
    /**
     * Erstellt ein JSON-Dokument aus Testergebnissen
     * @param {Array} results - Die zu exportierenden Testergebnisse
     * @param {boolean} prettyPrint - Ob das JSON formatiert werden soll
     * @returns {string} - JSON-Inhalt
     */
    function _createJSON(results, prettyPrint = true) {
        if (!results || results.length === 0) {
            return '[]';
        }
        
        return JSON.stringify(results, null, prettyPrint ? 2 : null);
    }
    
    /**
     * Erstellt ein HTML-Dokument aus Testergebnissen
     * @param {Array} results - Die zu exportierenden Testergebnisse
     * @param {Object} options - Exportoptionen
     * @returns {string} - HTML-Inhalt
     */
    function _createHTML(results, options = {}) {
        if (!results || results.length === 0) {
            return '<html><body><p>Keine Daten verfügbar</p></body></html>';
        }
        
        const title = options.title || 'Testergebnisse';
        let categoriesHTML = '';
        
        // Sammle alle Kategorien
        const categories = new Set();
        results.forEach(result => {
            if (result.categoryScores) {
                Object.keys(result.categoryScores).forEach(category => {
                    categories.add(category);
                });
            }
        });
        
        // Erstelle HTML für die Testergebnistabelle
        let tableHTML = `
            <table border="1" cellpadding="4" cellspacing="0" style="border-collapse: collapse; width: 100%;">
                <thead>
                    <tr style="background-color: #f2f2f2;">
                        <th>ID</th>
                        <th>Test</th>
                        <th>Benutzer</th>
                        <th>Datum</th>
                        <th>Punkte</th>
                        <th>Prozent</th>
                        <th>Bestanden</th>
                        <th>Zeit (Min.)</th>
                        ${Array.from(categories).map(category => `<th>${category}</th>`).join('')}
                    </tr>
                </thead>
                <tbody>
        `;
        
        // Zeilen für jedes Ergebnis hinzufügen
        results.forEach((result, index) => {
            const rowColor = index % 2 === 0 ? '#ffffff' : '#f9f9f9';
            
            tableHTML += `
                <tr style="background-color: ${rowColor};">
                    <td>${result.id || ''}</td>
                    <td>${result.testName || result.testId || ''}</td>
                    <td>${result.userName || result.userId || ''}</td>
                    <td>${result.timestamp ? new Date(result.timestamp).toLocaleString() : ''}</td>
                    <td>${result.score || 0} / ${result.maxScore || 0}</td>
                    <td>${result.percentage ? Math.round(result.percentage * 10) / 10 : 0}%</td>
                    <td style="color: ${result.passed ? 'green' : 'red'};">${result.passed ? 'Ja' : 'Nein'}</td>
                    <td>${result.timeSpent ? Math.round(result.timeSpent / 60000 * 10) / 10 : ''}</td>
                    ${Array.from(categories).map(category => {
                        const catScore = result.categoryScores && result.categoryScores[category] ?
                            Math.round(result.categoryScores[category].percentage * 10) / 10 : '';
                        return `<td>${catScore}${catScore ? '%' : ''}</td>`;
                    }).join('')}
                </tr>
            `;
        });
        
        tableHTML += `
                </tbody>
            </table>
        `;
        
        // Zusammenfassung erstellen
        const passedCount = results.filter(r => r.passed).length;
        const passRate = results.length > 0 ? (passedCount / results.length) * 100 : 0;
        const avgPercentage = results.length > 0 ? 
            results.reduce((sum, r) => sum + (r.percentage || 0), 0) / results.length : 0;
            
        const summaryHTML = `
            <div style="margin-bottom: 20px;">
                <h2>Zusammenfassung</h2>
                <p>Gesamtzahl der Tests: ${results.length}</p>
                <p>Bestandene Tests: ${passedCount} (${Math.round(passRate)}%)</p>
                <p>Durchschnittliche Punktzahl: ${Math.round(avgPercentage)}%</p>
            </div>
        `;
        
        // Bei kategorienbasierten Berichten auch Kategoriezusammenfassung hinzufügen
        if (categories.size > 0) {
            // Kategoriendurchschnitte berechnen
            const categoryAverages = {};
            
            categories.forEach(category => {
                let sum = 0;
                let count = 0;
                
                results.forEach(result => {
                    if (result.categoryScores && result.categoryScores[category]) {
                        sum += result.categoryScores[category].percentage || 0;
                        count++;
                    }
                });
                
                categoryAverages[category] = count > 0 ? sum / count : 0;
            });
            
            // Kategoriedurchschnitte als Tabelle darstellen
            categoriesHTML = `
                <div style="margin-top: 30px; margin-bottom: 20px;">
                    <h2>Kategorieauswertung</h2>
                    <table border="1" cellpadding="4" cellspacing="0" style="border-collapse: collapse; width: 50%;">
                        <thead>
                            <tr style="background-color: #f2f2f2;">
                                <th>Kategorie</th>
                                <th>Durchschnitt</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Array.from(categories).map((category, index) => `
                                <tr style="background-color: ${index % 2 === 0 ? '#ffffff' : '#f9f9f9'};">
                                    <td>${category}</td>
                                    <td>${Math.round(categoryAverages[category] * 10) / 10}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        // Vollständiges HTML-Dokument
        return `
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>${title}</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    h1 { color: #00FFD0; }
                    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    .header { display: flex; justify-content: space-between; align-items: center; }
                    .logo { height: 50px; }
                    .footer { margin-top: 30px; font-size: 0.8em; color: #666; text-align: center; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>${title}</h1>
                    <div>
                        <img class="logo" src="data:image/svg+xml;base64,..." alt="Logo">
                        <div>ImmoScout24 E-Learning</div>
                    </div>
                </div>
                
                ${summaryHTML}
                
                ${categoriesHTML}
                
                <h2>Detaillierte Ergebnisse</h2>
                ${tableHTML}
                
                <div class="footer">
                    <p>Erstellt am: ${new Date().toLocaleString()}</p>
                    <p>ImmoScout24 E-Learning Platform</p>
                </div>
            </body>
            </html>
        `;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Exportiert Testergebnisse in verschiedenen Formaten
         * @param {Array} results - Die zu exportierenden Testergebnisse
         * @param {string} format - Das Exportformat (json, csv, html, pdf)
         * @param {Object} options - Exportoptionen
         * @returns {Object} - Exportierter Inhalt mit Metadaten
         */
        exportResults: function(results, format = 'json', options = {}) {
            if (!results || results.length === 0) {
                return {
                    error: 'Keine Daten zum Exportieren vorhanden'
                };
            }
            
            // Standardoptionen mit benutzerdefinierten Optionen zusammenführen
            const exportOptions = {
                title: 'ImmoScout24 E-Learning - Testergebnisse',
                includeDetails: true,
                prettyPrint: true,
                ...options
            };
            
            let exportData, mimeType, filename;
            
            // Je nach Format unterschiedliche Exportfunktionen verwenden
            switch (format.toLowerCase()) {
                case 'csv':
                    exportData = _createCSV(results);
                    mimeType = 'text/csv';
                    filename = `test_results_${new Date().toISOString().slice(0, 10)}.csv`;
                    break;
                    
                case 'html':
                    exportData = _createHTML(results, exportOptions);
                    mimeType = 'text/html';
                    filename = `test_results_${new Date().toISOString().slice(0, 10)}.html`;
                    break;
                    
                case 'pdf':
                    // In dieser Implementierung wird nur ein HTML-Platzhalter zurückgegeben
                    // In einer vollständigen Implementierung würde hier PDF-Generierung stattfinden
                    exportData = _createHTML(results, exportOptions);
                    mimeType = 'text/html'; // Would be application/pdf in a real implementation
                    filename = `test_results_${new Date().toISOString().slice(0, 10)}.html`; // .pdf in reality
                    break;
                    
                case 'json':
                default:
                    exportData = _createJSON(results, exportOptions.prettyPrint);
                    mimeType = 'application/json';
                    filename = `test_results_${new Date().toISOString().slice(0, 10)}.json`;
                    break;
            }
            
            return {
                data: exportData,
                mimeType: mimeType,
                filename: filename,
                format: format.toLowerCase(),
                timestamp: new Date().toISOString(),
                recordCount: results.length
            };
        },
        
        /**
         * Gibt die verfügbaren Exportformate zurück
         * @returns {Array} - Liste der verfügbaren Formate
         */
        getAvailableFormats: function() {
            return [..._exportFormats];
        }
    };
})();

// Integrationsmodul für das Berichtssystem
window.ImmoLern.Assessment.Scoring.ReportingIntegration = (function() {
    // Private Variablen
    let _reportTemplates = {};
    let _userReports = {};
    let _teamReports = {};
    
    // Standardberichtsvorlagen
    const _defaultTemplates = {
        'user_performance': {
            id: 'user_performance',
            name: 'Benutzerleistungsbericht',
            description: 'Detaillierte Analyse der Benutzerleistung',
            sections: [
                {
                    id: 'summary',
                    title: 'Zusammenfassung',
                    dataSource: 'user_stats',
                    template: 'summary_template'
                },
                {
                    id: 'performance_analysis',
                    title: 'Leistungsanalyse',
                    dataSource: 'test_results',
                    template: 'performance_template'
                },
                {
                    id: 'category_breakdown',
                    title: 'Kategorieaufteilung',
                    dataSource: 'category_scores',
                    template: 'category_template'
                },
                {
                    id: 'recommendations',
                    title: 'Empfehlungen',
                    dataSource: 'learning_recommendations',
                    template: 'recommendations_template'
                }
            ]
        },
        
        'team_performance': {
            id: 'team_performance',
            name: 'Teamleistungsbericht',
            description: 'Überblick über die Leistung des Teams',
            sections: [
                {
                    id: 'team_summary',
                    title: 'Team-Zusammenfassung',
                    dataSource: 'team_stats',
                    template: 'team_summary_template'
                },
                {
                    id: 'member_comparison',
                    title: 'Mitgliedervergleich',
                    dataSource: 'team_members',
                    template: 'member_comparison_template'
                },
                {
                    id: 'category_performance',
                    title: 'Leistung nach Kategorie',
                    dataSource: 'team_categories',
                    template: 'team_category_template'
                },
                {
                    id: 'improvement_areas',
                    title: 'Verbesserungsbereiche',
                    dataSource: 'team_analysis',
                    template: 'improvement_areas_template'
                }
            ]
        }
    };
    
    // Private Funktionen
    
    /**
     * Sammelt Daten für einen Benutzerbericht
     * @param {string} userId - ID des Benutzers
     * @param {Array} testResults - Liste von Testergebnissen
     * @returns {Object} - Gesammelte Berichtsdaten
     */
    function _collectUserReportData(userId, testResults) {
        if (!userId || !testResults || testResults.length === 0) {
            return {
                error: 'Keine Daten für den Bericht verfügbar'
            };
        }
        
        // Nach Datum sortieren (neueste zuerst)
        const sortedResults = [...testResults]
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Grundlegende Benutzerstatistik
        const totalTests = sortedResults.length;
        const passedTests = sortedResults.filter(result => result.passed).length;
        const passRate = totalTests > 0 ? (passedTests / totalTests) * 100 : 0;
        const averageScore = totalTests > 0 ?
            sortedResults.reduce((sum, result) => sum + (result.percentage || 0), 0) / totalTests : 0;
        
        // Leistungstrend berechnen
        let trend = 'stable';
        if (totalTests >= 3) {
            const recentAvg = (sortedResults[0].percentage + sortedResults[1].percentage + sortedResults[2].percentage) / 3;
            
            if (sortedResults.length > 5) {
                const oldAvg = (sortedResults[sortedResults.length - 1].percentage + 
                                sortedResults[sortedResults.length - 2].percentage + 
                                sortedResults[sortedResults.length - 3].percentage) / 3;
                
                const difference = recentAvg - oldAvg;
                
                if (difference >= 10) trend = 'improving';
                else if (difference <= -10) trend = 'declining';
                else trend = 'stable';
            }
        }
        
        // Kategorieauswertung
        const categoryScores = {};
        
        sortedResults.forEach(result => {
            if (result.categoryScores) {
                Object.keys(result.categoryScores).forEach(category => {
                    if (!categoryScores[category]) {
                        categoryScores[category] = {
                            category: category,
                            scores: []
                        };
                    }
                    
                    categoryScores[category].scores.push(result.categoryScores[category].percentage || 0);
                });
            }
        });
        
        // Kategoriedurchschnitte berechnen
        Object.keys(categoryScores).forEach(category => {
            const scores = categoryScores[category].scores;
            const avgScore = scores.length > 0 ?
                scores.reduce((sum, score) => sum + score, 0) / scores.length : 0;
                
            categoryScores[category].averageScore = avgScore;
            
            // Trend pro Kategorie berechnen, falls genügend Daten
            if (scores.length >= 3) {
                const recentAvg = (scores[0] + scores[1] + scores[2]) / 3;
                const oldAvg = scores.length > 5 ?
                    (scores[scores.length - 1] + scores[scores.length - 2] + scores[scores.length - 3]) / 3 : recentAvg;
                    
                const difference = recentAvg - oldAvg;
                
                if (difference >= 5) categoryScores[category].trend = 'improving';
                else if (difference <= -5) categoryScores[category].trend = 'declining';
                else categoryScores[category].trend = 'stable';
            } else {
                categoryScores[category].trend = 'insufficient_data';
            }
        });
        
        // Lernempfehlungen abrufen, falls verfügbar
        const recommendations = window.ImmoLern.Assessment.Scoring.AdaptiveLearning.getUserRecommendations(userId);
        
        // Achievements abrufen, falls verfügbar
        const achievements = window.ImmoLern.Assessment.Scoring.AchievementSystem.getUserAchievements(userId);
        
        // Berichtsdaten zusammenstellen
        return {
            userId: userId,
            userName: sortedResults[0].userName || userId,
            timestamp: new Date().toISOString(),
            reportPeriod: {
                from: sortedResults[sortedResults.length - 1].timestamp,
                to: sortedResults[0].timestamp
            },
            userStats: {
                totalTests: totalTests,
                passedTests: passedTests,
                passRate: passRate,
                averageScore: averageScore,
                trend: trend,
                lastTest: {
                    testId: sortedResults[0].testId,
                    testName: sortedResults[0].testName || sortedResults[0].testId,
                    percentage: sortedResults[0].percentage,
                    passed: sortedResults[0].passed,
                    timestamp: sortedResults[0].timestamp
                }
            },
            categoryScores: categoryScores,
            testResults: sortedResults.map(result => ({
                testId: result.testId,
                testName: result.testName || result.testId,
                percentage: result.percentage,
                passed: result.passed,
                timestamp: result.timestamp
            })),
            recommendations: recommendations ? recommendations.recommendations : [],
            achievements: achievements ? {
                totalPoints: achievements.totalPoints,
                achievements: achievements.achievements,
                badges: achievements.badges
            } : null
        };
    }
    
    /**
     * Erstellt einen Bericht basierend auf einer Vorlage und Daten
     * @param {Object} template - Die Berichtsvorlage
     * @param {Object} data - Die Berichtsdaten
     * @returns {Object} - Der erstellte Bericht
     */
    function _generateReport(template, data) {
        if (!template || !template.sections || !data) {
            return {
                error: 'Ungültige Vorlage oder Daten für den Bericht'
            };
        }
        
        // Berichtsstruktur erstellen
        const report = {
            id: `report_${Date.now()}`,
            title: template.name,
            description: template.description,
            timestamp: new Date().toISOString(),
            sections: [],
            data: { ...data }
        };
        
        // Sektionen basierend auf der Vorlage erstellen
        template.sections.forEach(section => {
            // Abschnittsdaten abrufen
            const sectionData = data[section.dataSource] || {};
            
            // Abschnitt zum Bericht hinzufügen
            report.sections.push({
                id: section.id,
                title: section.title,
                content: _renderSectionContent(section.template, sectionData),
                data: sectionData
            });
        });
        
        return report;
    }
    
    /**
     * Rendert den Inhalt eines Berichtsabschnitts
     * @param {string} templateId - ID der Inhaltsvorlage
     * @param {Object} data - Die Abschnittsdaten
     * @returns {string} - Der gerenderte Inhalt (HTML)
     */
    function _renderSectionContent(templateId, data) {
        // Hier würde in einer vollständigen Implementierung eine Vorlagenengine
        // verwendet werden, um den Inhalt zu rendern. Für diese Implementierung
        // verwenden wir einfache Platzhalter-HTML.
        
        let content = '<div class="report-section-content">';
        
        switch (templateId) {
            case 'summary_template':
                content += _renderSummarySection(data);
                break;
                
            case 'performance_template':
                content += _renderPerformanceSection(data);
                break;
                
            case 'category_template':
                content += _renderCategorySection(data);
                break;
                
            case 'recommendations_template':
                content += _renderRecommendationsSection(data);
                break;
                
            case 'team_summary_template':
                content += _renderTeamSummarySection(data);
                break;
                
            case 'member_comparison_template':
                content += _renderMemberComparisonSection(data);
                break;
                
            case 'team_category_template':
                content += _renderTeamCategorySection(data);
                break;
                
            case 'improvement_areas_template':
                content += _renderImprovementAreasSection(data);
                break;
                
            default:
                content += '<p>Keine Inhaltsvorlage verfügbar</p>';
        }
        
        content += '</div>';
        return content;
    }
    
    /**
     * Rendert den Zusammenfassungsabschnitt
     * @param {Object} data - Die Abschnittsdaten
     * @returns {string} - Der gerenderte Inhalt (HTML)
     */
    function _renderSummarySection(data) {
        if (!data) return '<p>Keine Daten verfügbar</p>';
        
        return `
            <div class="summary-section">
                <div class="metrics-row">
                    <div class="metric-card">
                        <div class="metric-value">${data.totalTests}</div>
                        <div class="metric-label">Tests insgesamt</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${data.passedTests}</div>
                        <div class="metric-label">Bestanden</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${Math.round(data.passRate)}%</div>
                        <div class="metric-label">Bestehensquote</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${Math.round(data.averageScore)}%</div>
                        <div class="metric-label">Durchschnitt</div>
                    </div>
                </div>
                
                <div class="trend-indicator">
                    <div class="trend-label">Trend:</div>
                    <div class="trend-value ${data.trend}">
                        ${data.trend === 'improving' ? '↗️ Verbesserung' : 
                          data.trend === 'declining' ? '↘️ Rückgang' : '→ Stabil'}
                    </div>
                </div>
                
                <div class="last-test-info">
                    <h4>Letzter Test: ${data.lastTest?.testName || 'Unbekannt'}</h4>
                    <p>Ergebnis: ${Math.round(data.lastTest?.percentage || 0)}% (${data.lastTest?.passed ? 'Bestanden' : 'Nicht bestanden'})</p>
                    <p>Datum: ${data.lastTest?.timestamp ? new Date(data.lastTest.timestamp).toLocaleString() : 'Unbekannt'}</p>
                </div>
            </div>
        `;
    }
    
    /**
     * Rendert den Leistungsabschnitt
     * @param {Object} data - Die Abschnittsdaten
     * @returns {string} - Der gerenderte Inhalt (HTML)
     */
    function _renderPerformanceSection(data) {
        if (!data || data.length === 0) return '<p>Keine Leistungsdaten verfügbar</p>';
        
        let content = `
            <div class="performance-history">
                <h4>Testverlauf</h4>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Datum</th>
                            <th>Test</th>
                            <th>Ergebnis</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        
        // Zeilen für die letzten 10 Tests hinzufügen (oder alle, wenn weniger)
        const recentTests = data.slice(0, 10);
        recentTests.forEach(test => {
            content += `
                <tr>
                    <td>${test.timestamp ? new Date(test.timestamp).toLocaleDateString() : 'Unbekannt'}</td>
                    <td>${test.testName || test.testId || 'Unbekannt'}</td>
                    <td>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(100, Math.max(0, test.percentage || 0))}%;"></div>
                            <div class="progress-text">${Math.round(test.percentage || 0)}%</div>
                        </div>
                    </td>
                    <td class="${test.passed ? 'passed' : 'failed'}">${test.passed ? 'Bestanden' : 'Nicht bestanden'}</td>
                </tr>
            `;
        });
        
        content += `
                    </tbody>
                </table>
                
                <div class="performance-chart-placeholder">
                    <p>Hier wird ein Verlaufsdiagramm angezeigt</p>
                </div>
            </div>
        `;
        
        return content;
    }
    
    /**
     * Rendert den Kategorieabschnitt
     * @param {Object} data - Die Abschnittsdaten
     * @returns {string} - Der gerenderte Inhalt (HTML)
     */
    function _renderCategorySection(data) {
        if (!data || Object.keys(data).length === 0) return '<p>Keine Kategoriedaten verfügbar</p>';
        
        let content = `<div class="category-breakdown">`;
        
        // Kategorien nach Durchschnittspunktzahl sortieren (beste zuerst)
        const sortedCategories = Object.values(data)
            .sort((a, b) => b.averageScore - a.averageScore);
        
        content += `
            <h4>Leistung nach Kategorien</h4>
            <div class="category-bars">
        `;
        
        // Balkendiagramm für jede Kategorie
        sortedCategories.forEach(category => {
            const averageScore = Math.round(category.averageScore || 0);
            
            // Farbklasse basierend auf der Punktzahl
            let colorClass = 'low';
            if (averageScore >= 80) colorClass = 'high';
            else if (averageScore >= 60) colorClass = 'medium';
            
            // Trendindikator
            let trendIndicator = '';
            if (category.trend === 'improving') trendIndicator = '<span class="trend-up">↗️</span>';
            else if (category.trend === 'declining') trendIndicator = '<span class="trend-down">↘️</span>';
            
            content += `
                <div class="category-bar-item">
                    <div class="category-name">${category.category} ${trendIndicator}</div>
                    <div class="category-bar-container">
                        <div class="category-bar ${colorClass}" style="width: ${Math.min(100, Math.max(0, averageScore))}%;">
                            <span class="category-value">${averageScore}%</span>
                        </div>
                    </div>
                </div>
            `;
        });
        
        content += `
            </div>
            
            <div class="category-insights">
                <h4>Erkenntnisse</h4>
                <ul class="insights-list">
        `;
        
        // Stärken und Schwächen identifizieren
        if (sortedCategories.length > 0) {
            // Beste Kategorie
            const bestCategory = sortedCategories[0];
            if (bestCategory.averageScore >= 70) {
                content += `
                    <li class="insight insight-strength">
                        Stärke in <strong>${bestCategory.category}</strong> mit ${Math.round(bestCategory.averageScore)}%.
                    </li>
                `;
            }
            
            // Schwächste Kategorie
            const worstCategory = sortedCategories[sortedCategories.length - 1];
            if (worstCategory.averageScore < 60) {
                content += `
                    <li class="insight insight-weakness">
                        Verbesserungsbedarf in <strong>${worstCategory.category}</strong> mit ${Math.round(worstCategory.averageScore)}%.
                    </li>
                `;
            }
            
            // Kategorien mit Verbesserung
            const improvingCategories = sortedCategories.filter(c => c.trend === 'improving');
            if (improvingCategories.length > 0) {
                content += `
                    <li class="insight insight-improving">
                        Positive Entwicklung in ${improvingCategories.length} ${improvingCategories.length === 1 ? 'Kategorie' : 'Kategorien'}.
                    </li>
                `;
            }
            
            // Kategorien mit Rückgang
            const decliningCategories = sortedCategories.filter(c => c.trend === 'declining');
            if (decliningCategories.length > 0) {
                content += `
                    <li class="insight insight-declining">
                        Negative Entwicklung in ${decliningCategories.length} ${decliningCategories.length === 1 ? 'Kategorie' : 'Kategorien'}.
                    </li>
                `;
            }
        }
        
        content += `
                </ul>
            </div>
        </div>
        `;
        
        return content;
    }
    
    /**
     * Rendert den Empfehlungsabschnitt
     * @param {Object} data - Die Abschnittsdaten
     * @returns {string} - Der gerenderte Inhalt (HTML)
     */
    function _renderRecommendationsSection(data) {
        if (!data || data.length === 0) return '<p>Keine Empfehlungen verfügbar</p>';
        
        let content = `
            <div class="recommendations-section">
                <h4>Persönliche Lernempfehlungen</h4>
                <div class="recommendations-list">
        `;
        
        // Nach Priorität sortieren (hohe zuerst)
        const priorityOrder = { high: 1, medium: 2, low: 3 };
        const sortedRecommendations = [...data].sort((a, b) => 
            priorityOrder[a.priority] - priorityOrder[b.priority]
        );
        
        // Empfehlungen anzeigen
        sortedRecommendations.forEach(rec => {
            // Prioritätsklasse bestimmen
            const priorityClass = rec.priority === 'high' ? 'high-priority' : 
                                 rec.priority === 'medium' ? 'medium-priority' : 'low-priority';
                                 
            content += `
                <div class="recommendation-item ${priorityClass}">
                    <div class="recommendation-header">
                        <div class="recommendation-type">${rec.type === 'learning_path' ? 'Lernpfad' : 
                                                          rec.type === 'content' ? 'Lerninhalt' : 
                                                          rec.type === 'practice' ? 'Übung' : rec.type}</div>
                        <div class="recommendation-priority">${
                            rec.priority === 'high' ? 'Hohe Priorität' : 
                            rec.priority === 'medium' ? 'Mittlere Priorität' : 'Niedrige Priorität'
                        }</div>
                    </div>
                    <div class="recommendation-reason">${rec.reason}</div>
            `;
            
            // Je nach Empfehlungstyp unterschiedliche Inhalte anzeigen
            if (rec.type === 'content' && rec.content) {
                content += `
                    <div class="recommended-content">
                        <h5>Empfohlene Inhalte</h5>
                        <ul class="content-list">
                `;
                
                rec.content.forEach(item => {
                    content += `
                        <li>
                            <span class="content-title">${item.title}</span>
                            <span class="content-type">${item.type}</span>
                            <span class="content-duration">${item.duration || 0} Min.</span>
                        </li>
                    `;
                });
                
                content += `
                        </ul>
                    </div>
                `;
            } else if (rec.type === 'practice' && rec.tests) {
                content += `
                    <div class="recommended-tests">
                        <h5>Empfohlene Übungstests</h5>
                        <ul class="test-list">
                `;
                
                rec.tests.forEach(test => {
                    content += `
                        <li>
                            <span class="test-title">${test.title}</span>
                            <span class="test-category">${test.category}</span>
                            <span class="test-duration">${test.estimatedTime || 0} Min.</span>
                        </li>
                    `;
                });
                
                content += `
                        </ul>
                    </div>
                `;
            } else if (rec.type === 'learning_path' && rec.learningPath) {
                content += `
                    <div class="learning-path">
                        <h5>${rec.learningPath.name}</h5>
                        <p>${rec.learningPath.description}</p>
                        <div class="path-steps">
                            ${rec.learningPath.steps.length} Schritte (ca. ${rec.learningPath.estimatedDuration} Min.)
                        </div>
                    </div>
                `;
            }
            
            content += `</div>`;
        });
        
        content += `
                </div>
            </div>
        `;
        
        return content;
    }
    
    // Weitere Abschnittsrenderingfunktionen für Team-Berichte
    function _renderTeamSummarySection(data) {
        // Platzhalter für Team-Zusammenfassung
        return '<p>Team-Zusammenfassung würde hier angezeigt werden</p>';
    }
    
    function _renderMemberComparisonSection(data) {
        // Platzhalter für Mitgliedervergleich
        return '<p>Mitgliedervergleich würde hier angezeigt werden</p>';
    }
    
    function _renderTeamCategorySection(data) {
        // Platzhalter für Team-Kategorieauswertung
        return '<p>Team-Kategorieauswertung würde hier angezeigt werden</p>';
    }
    
    function _renderImprovementAreasSection(data) {
        // Platzhalter für Verbesserungsbereiche
        return '<p>Verbesserungsbereiche würde hier angezeigt werden</p>';
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Berichtsintegrations-Modul
         */
        init: function() {
            // Standardvorlagen laden
            _reportTemplates = { ..._defaultTemplates };
            
            return this;
        },
        
        /**
         * Erstellt einen Benutzerbericht
         * @param {string} userId - ID des Benutzers
         * @param {Array} testResults - Liste von Testergebnissen
         * @param {string} templateId - ID der Berichtsvorlage
         * @returns {Object} - Der erstellte Bericht
         */
        createUserReport: function(userId, testResults, templateId = 'user_performance') {
            if (!userId || !testResults || testResults.length === 0) {
                return {
                    error: 'Keine Daten für den Bericht verfügbar'
                };
            }
            
            // Berichtsvorlage abrufen
            const template = _reportTemplates[templateId];
            if (!template) {
                return {
                    error: 'Ungültige Berichtsvorlage'
                };
            }
            
            // Daten für den Bericht sammeln
            const reportData = _collectUserReportData(userId, testResults);
            
            // Bericht erstellen
            const report = _generateReport(template, reportData);
            
            // Bericht speichern
            _userReports[userId] = report;
            
            return report;
        },
        
        /**
         * Ruft einen gespeicherten Benutzerbericht ab
         * @param {string} userId - ID des Benutzers
         * @returns {Object|null} - Der Bericht oder null, wenn nicht vorhanden
         */
        getUserReport: function(userId) {
            return _userReports[userId] || null;
        },
        
        /**
         * Fügt eine neue Berichtsvorlage hinzu
         * @param {Object} template - Die Berichtsvorlage
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addReportTemplate: function(template) {
            if (!template || !template.id || !template.sections) {
                return false;
            }
            
            _reportTemplates[template.id] = template;
            return true;
        },
        
        /**
         * Gibt alle verfügbaren Berichtsvorlagen zurück
         * @returns {Object} - Die Berichtsvorlagen
         */
        getReportTemplates: function() {
            return { ..._reportTemplates };
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Einzelne Module initialisieren
    window.ImmoLern.Assessment.Scoring.AchievementSystem.init();
    window.ImmoLern.Assessment.Scoring.AdaptiveLearning.init();
    window.ImmoLern.Assessment.Scoring.ReportingIntegration.init();
    
    // Benutzerdefiniertes Ereignis auslösen, wenn die Module geladen sind
    document.dispatchEvent(new CustomEvent('assessmentExtensionsLoaded'));
});
/**
 * JS-Block 6.4.1: Bewertungsregeln
 * 
 * Dieses Modul implementiert die Bewertungsregeln für die Bestanden/Nicht-Bestanden-Logik:
 * - Konfigurierbare Bestehenskriterien für verschiedene Testtypen
 * - Bedingte Regeln und regelbasierte Entscheidungen
 * - Auswertungsrichtlinien für Tests und Zertifizierungen
 * - Mehrstufige Bewertungsskalen und Notensysteme
 * - Integration mit dem Scoring-System
 */

// Namespace für Bestanden/Nicht-Bestanden-Logik
if (!window.ImmoLern) window.ImmoLern = {};
if (!window.ImmoLern.Assessment) window.ImmoLern.Assessment = {};
if (!window.ImmoLern.Assessment.Evaluation) window.ImmoLern.Assessment.Evaluation = {};

// Hauptmodul für die Bewertungsregeln
window.ImmoLern.Assessment.Evaluation.PassFailSystem = (function() {
    // Private Variablen
    let _defaultPassingRules = {
        // Standardregel: Bestehen bei mindestens 50% der Punkte
        standardTest: {
            id: 'standardTest',
            name: 'Standard-Testregeln',
            description: 'Standardregeln für normale Tests',
            rules: [
                {
                    id: 'minimum_percentage',
                    type: 'percentage',
                    threshold: 50,
                    operator: 'gte', // greater than or equal
                    description: 'Mindestens 50% der maximalen Punktzahl erreichen'
                }
            ],
            combination: 'all', // Alle Regeln müssen erfüllt sein
            applyTo: 'all',    // Auf alle Tests anwenden, wenn kein spezifischer Typ definiert ist
            importance: 10     // Priorität für Konflikte (höhere Werte haben Vorrang)
        },
        
        // Regel für Zertifizierungstests: 75% und keine kritischen Fehler
        certification: {
            id: 'certification',
            name: 'Zertifizierungsregeln',
            description: 'Strengere Regeln für Zertifizierungstests',
            rules: [
                {
                    id: 'minimum_percentage',
                    type: 'percentage',
                    threshold: 75,
                    operator: 'gte',
                    description: 'Mindestens 75% der maximalen Punktzahl erreichen'
                },
                {
                    id: 'no_critical_failures',
                    type: 'criticalQuestions',
                    threshold: 0,
                    operator: 'eq',
                    description: 'Keine kritischen Fragen falsch beantworten'
                }
            ],
            combination: 'all',
            applyTo: 'certification',
            importance: 20
        },
        
        // Regel für Übungstests: Unbenoteter Durchführungsmodus
        practice: {
            id: 'practice',
            name: 'Übungsregeln',
            description: 'Regeln für Übungstests ohne Bestanden/Nicht-Bestanden-Bewertung',
            rules: [],
            combination: 'none',
            applyTo: 'practice',
            importance: 5,
            alwaysPass: true // Übungstests sind immer "bestanden"
        },
        
        // Regel für fortgeschrittene Tests: 65% insgesamt und mindestens 50% in jeder Kategorie
        advanced: {
            id: 'advanced',
            name: 'Fortgeschrittene Testregeln',
            description: 'Regeln für fortgeschrittene Tests mit Kategorieanforderungen',
            rules: [
                {
                    id: 'minimum_percentage',
                    type: 'percentage',
                    threshold: 65,
                    operator: 'gte',
                    description: 'Mindestens 65% der maximalen Punktzahl erreichen'
                },
                {
                    id: 'minimum_category_percentage',
                    type: 'categoryPercentage',
                    threshold: 50,
                    operator: 'gte',
                    description: 'Mindestens 50% in jeder Kategorie erreichen',
                    categories: 'all' // Auf alle Kategorien anwenden
                }
            ],
            combination: 'all',
            applyTo: 'advanced',
            importance: 15
        },
        
        // Regel für Team-Assessments: Durchschnittlich 60% und mindestens 40% pro Person
        teamAssessment: {
            id: 'teamAssessment',
            name: 'Team-Bewertungsregeln',
            description: 'Regeln für Team-Bewertungen mit Gruppen- und Individualkriterien',
            rules: [
                {
                    id: 'team_average',
                    type: 'teamAverage',
                    threshold: 60,
                    operator: 'gte',
                    description: 'Team muss durchschnittlich mindestens 60% erreichen'
                },
                {
                    id: 'minimum_individual',
                    type: 'individualMinimum',
                    threshold: 40,
                    operator: 'gte',
                    description: 'Jedes Teammitglied muss mindestens 40% erreichen'
                }
            ],
            combination: 'all',
            applyTo: 'team',
            importance: 25
        }
    };
    
    // Aktive Regelsätze (werden durch benutzerdefinierte Regeln ergänzt)
    let _passingRules = { ..._defaultPassingRules };
    
    // Zwischengespeicherte Testergebnisse für Leistungsoptimierung
    let _cachedResults = {};
    
    // Private Funktionen
    
    /**
     * Wendet eine Bewertungsregel auf ein Testergebnis an
     * @param {Object} rule - Die anzuwendende Regel
     * @param {Object} testResult - Das zu bewertende Testergebnis
     * @returns {Object} - Ergebnis der Regelauswertung
     */
    function _evaluateRule(rule, testResult) {
        if (!rule || !testResult) {
            return {
                passed: true, // Im Zweifelsfall bestanden
                ruleId: rule ? rule.id : 'unknown',
                error: 'Ungültige Regel oder Testergebnis'
            };
        }
        
        // Standardwerte für das Ergebnis
        const result = {
            ruleId: rule.id,
            type: rule.type,
            threshold: rule.threshold,
            passed: false,
            actualValue: null,
            description: rule.description || 'Keine Beschreibung'
        };
        
        try {
            // Je nach Regeltyp unterschiedliche Auswertung
            switch (rule.type) {
                case 'percentage':
                    // Auswertung basierend auf dem Prozentsatz der erreichten Punkte
                    result.actualValue = testResult.percentage;
                    result.passed = _compareValues(result.actualValue, rule.threshold, rule.operator);
                    break;
                    
                case 'absolutePoints':
                    // Auswertung basierend auf der absoluten Punktzahl
                    result.actualValue = testResult.score;
                    result.passed = _compareValues(result.actualValue, rule.threshold, rule.operator);
                    break;
                    
                case 'criticalQuestions':
                    // Prüfen, ob kritische Fragen richtig beantwortet wurden
                    const failedCritical = _countFailedCriticalQuestions(testResult);
                    result.actualValue = failedCritical;
                    result.passed = _compareValues(failedCritical, rule.threshold, rule.operator);
                    break;
                    
                case 'categoryPercentage':
                    // Prüfen, ob jede Kategorie einen Mindestwert erreicht
                    const categoryResults = _evaluateCategoryPercentages(testResult, rule.threshold, rule.categories);
                    result.actualValue = categoryResults.lowestPercentage;
                    result.passed = categoryResults.allPassed;
                    result.details = categoryResults;
                    break;
                    
                case 'completionTime':
                    // Auswertung basierend auf der Bearbeitungszeit
                    const timeInMinutes = (testResult.timeSpent || 0) / 60000; // Umrechnung in Minuten
                    result.actualValue = timeInMinutes;
                    result.passed = _compareValues(timeInMinutes, rule.threshold, rule.operator);
                    break;
                    
                case 'questionCount':
                    // Auswertung basierend auf der Anzahl korrekter Fragen
                    const correctCount = testResult.correctQuestions || 0;
                    result.actualValue = correctCount;
                    result.passed = _compareValues(correctCount, rule.threshold, rule.operator);
                    break;
                    
                case 'teamAverage':
                    // Auswertung basierend auf dem Teamdurchschnitt
                    if (testResult.teamResults && testResult.teamResults.averagePercentage !== undefined) {
                        result.actualValue = testResult.teamResults.averagePercentage;
                        result.passed = _compareValues(result.actualValue, rule.threshold, rule.operator);
                    } else {
                        result.passed = true; // Wenn keine Teamdaten, gilt als bestanden
                        result.actualValue = null;
                        result.note = 'Keine Teamdaten vorhanden';
                    }
                    break;
                    
                case 'individualMinimum':
                    // Auswertung basierend auf individuellen Mindestwerten im Team
                    if (testResult.teamResults && testResult.teamResults.individualScores) {
                        const lowestScore = Math.min(...testResult.teamResults.individualScores.map(s => s.percentage));
                        result.actualValue = lowestScore;
                        result.passed = _compareValues(lowestScore, rule.threshold, rule.operator);
                    } else {
                        result.passed = true; // Wenn keine Teamdaten, gilt als bestanden
                        result.actualValue = null;
                        result.note = 'Keine individuellen Teamdaten vorhanden';
                    }
                    break;
                    
                default:
                    // Unbekannter Regeltyp
                    result.passed = true; // Im Zweifelsfall bestanden
                    result.error = 'Unbekannter Regeltyp: ' + rule.type;
            }
        } catch (error) {
            console.error('Fehler bei der Auswertung der Regel:', error);
            result.passed = true; // Im Fehlerfall bestanden
            result.error = 'Fehler bei der Regelauswertung: ' + error.message;
        }
        
        return result;
    }
    
    /**
     * Vergleicht Werte gemäß dem angegebenen Operator
     * @param {number} actual - Tatsächlicher Wert
     * @param {number} threshold - Schwellenwert
     * @param {string} operator - Vergleichsoperator (lt, lte, eq, gte, gt)
     * @returns {boolean} - Ergebnis des Vergleichs
     */
    function _compareValues(actual, threshold, operator) {
        if (actual === null || actual === undefined) return false;
        
        switch (operator) {
            case 'lt':  return actual < threshold;
            case 'lte': return actual <= threshold;
            case 'eq':  return actual === threshold;
            case 'gte': return actual >= threshold;
            case 'gt':  return actual > threshold;
            default:    return actual >= threshold; // Standardoperator ist gte
        }
    }
    
    /**
     * Zählt die Anzahl der falsch beantworteten kritischen Fragen
     * @param {Object} testResult - Das Testergebnis
     * @returns {number} - Anzahl der falsch beantworteten kritischen Fragen
     */
    function _countFailedCriticalQuestions(testResult) {
        if (!testResult.questionResults) {
            return 0;
        }
        
        // Kritische Fragen filtern und falsch beantwortete zählen
        return testResult.questionResults.filter(question => 
            question.isCritical && !question.correct
        ).length;
    }
    
    /**
     * Wertet die Prozentsätze der Kategorien aus
     * @param {Object} testResult - Das Testergebnis
     * @param {number} threshold - Schwellenwert in Prozent
     * @param {string|Array} categories - Zu prüfende Kategorien ('all' oder Liste)
     * @returns {Object} - Auswertungsergebnis für Kategorien
     */
    function _evaluateCategoryPercentages(testResult, threshold, categories) {
        if (!testResult.categoryScores || Object.keys(testResult.categoryScores).length === 0) {
            return {
                allPassed: true,
                lowestPercentage: 100,
                categoryResults: {}
            };
        }
        
        const categoryResults = {};
        let lowestPercentage = 100;
        
        // Zu prüfende Kategorien ermitteln
        const categoriesToCheck = categories === 'all' ? 
            Object.keys(testResult.categoryScores) : 
            Array.isArray(categories) ? categories : [];
        
        // Jeden einzelnen Schwellenwert prüfen
        categoriesToCheck.forEach(category => {
            if (testResult.categoryScores[category]) {
                const percentage = testResult.categoryScores[category].percentage;
                const passed = percentage >= threshold;
                
                categoryResults[category] = {
                    percentage: percentage,
                    threshold: threshold,
                    passed: passed
                };
                
                if (percentage < lowestPercentage) {
                    lowestPercentage = percentage;
                }
            }
        });
        
        // Prüfen, ob alle Kategorien bestanden wurden
        const allPassed = Object.values(categoryResults).every(result => result.passed);
        
        return {
            allPassed: allPassed,
            lowestPercentage: lowestPercentage,
            categoryResults: categoryResults
        };
    }
    
    /**
     * Ermittelt den passenden Regelsatz für einen Test
     * @param {Object} test - Der zu bewertende Test
     * @returns {Object} - Der passende Regelsatz
     */
    function _getApplicableRuleSet(test) {
        if (!test) {
            return _passingRules.standardTest;
        }
        
        // Alle Regelsätze nach Anwendbarkeit und Wichtigkeit sortieren
        const applicableRuleSets = Object.values(_passingRules)
            .filter(ruleSet => {
                if (ruleSet.applyTo === 'all') return true;
                if (Array.isArray(ruleSet.applyTo)) return ruleSet.applyTo.includes(test.type);
                return ruleSet.applyTo === test.type;
            })
            .sort((a, b) => (b.importance || 0) - (a.importance || 0));
        
        // Den wichtigsten anwendbaren Regelsatz zurückgeben
        return applicableRuleSets.length > 0 ? 
            applicableRuleSets[0] : 
            _passingRules.standardTest;
    }
    
    /**
     * Wertet einen Regelsatz für ein Testergebnis aus
     * @param {Object} ruleSet - Der anzuwendende Regelsatz
     * @param {Object} testResult - Das zu bewertende Testergebnis
     * @returns {Object} - Auswertungsergebnis
     */
    function _evaluateRuleSet(ruleSet, testResult) {
        if (!ruleSet || !testResult) {
            return {
                passed: true,
                ruleSetId: ruleSet ? ruleSet.id : 'unknown',
                error: 'Ungültiger Regelsatz oder Testergebnis'
            };
        }
        
        // Wenn der Regelsatz immer bestanden ist
        if (ruleSet.alwaysPass) {
            return {
                passed: true,
                ruleSetId: ruleSet.id,
                name: ruleSet.name,
                description: ruleSet.description,
                ruleResults: [],
                note: 'Dieser Testtyp gilt immer als bestanden'
            };
        }
        
        // Wenn keine Regeln definiert sind
        if (!ruleSet.rules || ruleSet.rules.length === 0) {
            return {
                passed: true,
                ruleSetId: ruleSet.id,
                name: ruleSet.name,
                description: ruleSet.description,
                ruleResults: [],
                note: 'Keine Regeln definiert'
            };
        }
        
        // Alle Regeln des Regelsatzes auswerten
        const ruleResults = ruleSet.rules.map(rule => _evaluateRule(rule, testResult));
        
        // Bestanden/Nicht-Bestanden basierend auf der Kombinationsregel ermitteln
        let passed;
        
        switch (ruleSet.combination) {
            case 'any':
                // Bestanden, wenn mindestens eine Regel erfüllt ist
                passed = ruleResults.some(result => result.passed);
                break;
                
            case 'none':
                // Bestanden, wenn keine Regeln definiert sind
                passed = true;
                break;
                
            case 'all':
            default:
                // Bestanden, wenn alle Regeln erfüllt sind
                passed = ruleResults.every(result => result.passed);
        }
        
        // Detaillierte Dokumentation
        const failedRules = ruleResults.filter(result => !result.passed);
        
        return {
            passed: passed,
            ruleSetId: ruleSet.id,
            name: ruleSet.name,
            description: ruleSet.description,
            ruleResults: ruleResults,
            failedRules: failedRules,
            allRulesPassed: failedRules.length === 0,
            combination: ruleSet.combination
        };
    }
    
    /**
     * Generiert eine benutzerfreundliche Erklärung des Bewertungsergebnisses
     * @param {Object} evaluationResult - Das Bewertungsergebnis
     * @returns {Array} - Liste von Erklärungstexten
     */
    function _generateExplanations(evaluationResult) {
        if (!evaluationResult) return [];
        
        const explanations = [];
        
        // Allgemeine Erklärung basierend auf dem Gesamtergebnis
        explanations.push({
            type: 'summary',
            text: evaluationResult.passed ? 
                `Test bestanden: Die Anforderungen für "${evaluationResult.name}" wurden erfüllt.` :
                `Test nicht bestanden: Die Anforderungen für "${evaluationResult.name}" wurden nicht vollständig erfüllt.`
        });
        
        // Erklärungen für jede Regel hinzufügen
        evaluationResult.ruleResults.forEach(rule => {
            const explanation = {
                type: rule.passed ? 'success' : 'failure',
                ruleId: rule.ruleId,
                text: _generateRuleExplanation(rule)
            };
            
            explanations.push(explanation);
        });
        
        // Zusammenfassende Erklärung der Kombinationsregel
        if (evaluationResult.ruleResults.length > 1) {
            let combinationText;
            
            switch (evaluationResult.combination) {
                case 'any':
                    combinationText = 'Mindestens eine dieser Regeln musste erfüllt werden.';
                    break;
                    
                case 'all':
                    combinationText = 'Alle diese Regeln mussten erfüllt werden.';
                    break;
                    
                case 'none':
                    combinationText = 'Für diesen Test gelten keine spezifischen Bewertungsregeln.';
                    break;
                    
                default:
                    combinationText = 'Die Regeln wurden nach benutzerdefinierten Kriterien kombiniert.';
            }
            
            explanations.push({
                type: 'combination',
                text: combinationText
            });
        }
        
        return explanations;
    }
    
    /**
     * Generiert eine Erklärung für eine einzelne Regel
     * @param {Object} ruleResult - Das Ergebnis der Regelauswertung
     * @returns {string} - Erklärungstext
     */
    function _generateRuleExplanation(ruleResult) {
        if (!ruleResult) return 'Keine Erklärung verfügbar';
        
        let explanation = '';
        
        // Fehlermeldung, falls vorhanden
        if (ruleResult.error) {
            return `Fehler bei der Regelauswertung: ${ruleResult.error}`;
        }
        
        // Vorbereitung der Werte für die Erklärung
        const actualValueText = ruleResult.actualValue !== null ? 
            _formatValue(ruleResult.actualValue, ruleResult.type) : 'nicht verfügbar';
            
        const thresholdText = _formatValue(ruleResult.threshold, ruleResult.type);
        
        // Operatortext für die Erklärung
        let operatorText;
        switch (ruleResult.operator || 'gte') {
            case 'lt':  operatorText = 'weniger als'; break;
            case 'lte': operatorText = 'höchstens'; break;
            case 'eq':  operatorText = 'genau'; break;
            case 'gte': operatorText = 'mindestens'; break;
            case 'gt':  operatorText = 'mehr als'; break;
            default:    operatorText = 'mindestens';
        }
        
        // Spezifische Erklärung je nach Regeltyp
        switch (ruleResult.type) {
            case 'percentage':
                explanation = `Du hast ${actualValueText}% erreicht. Erforderlich waren ${operatorText} ${thresholdText}%.`;
                break;
                
            case 'absolutePoints':
                explanation = `Du hast ${actualValueText} Punkte erreicht. Erforderlich waren ${operatorText} ${thresholdText} Punkte.`;
                break;
                
            case 'criticalQuestions':
                explanation = `Du hast ${actualValueText} kritische Fragen falsch beantwortet. Erlaubt waren ${operatorText} ${thresholdText}.`;
                break;
                
            case 'categoryPercentage':
                if (ruleResult.details && ruleResult.details.categoryResults) {
                    const failedCategories = Object.entries(ruleResult.details.categoryResults)
                        .filter(([_, result]) => !result.passed)
                        .map(([category, result]) => `${category} (${Math.round(result.percentage)}%)`)
                        .join(', ');
                    
                    if (failedCategories) {
                        explanation = `Einige Kategorien haben den Mindestwert von ${thresholdText}% nicht erreicht: ${failedCategories}`;
                    } else {
                        explanation = `Alle Kategorien haben den Mindestwert von ${thresholdText}% erreicht.`;
                    }
                } else {
                    explanation = `Die niedrigste Kategoriepunktzahl beträgt ${actualValueText}%. Erforderlich waren ${operatorText} ${thresholdText}%.`;
                }
                break;
                
            case 'completionTime':
                explanation = `Du hast den Test in ${actualValueText} Minuten abgeschlossen. Das Zeitlimit war ${operatorText} ${thresholdText} Minuten.`;
                break;
                
            case 'questionCount':
                explanation = `Du hast ${actualValueText} Fragen richtig beantwortet. Erforderlich waren ${operatorText} ${thresholdText} richtige Antworten.`;
                break;
                
            case 'teamAverage':
                explanation = `Der Teamdurchschnitt liegt bei ${actualValueText}%. Erforderlich waren ${operatorText} ${thresholdText}%.`;
                break;
                
            case 'individualMinimum':
                explanation = `Die niedrigste individuelle Punktzahl im Team beträgt ${actualValueText}%. Erforderlich waren ${operatorText} ${thresholdText}%.`;
                break;
                
            default:
                explanation = ruleResult.description || 'Keine detaillierte Erklärung verfügbar';
        }
        
        // Statusindikator hinzufügen
        explanation = `${ruleResult.passed ? '✓' : '✗'} ${explanation}`;
        
        return explanation;
    }
    
    /**
     * Formatiert einen Wert basierend auf dem Regeltyp
     * @param {any} value - Der zu formatierende Wert
     * @param {string} type - Regeltyp für die Formatierung
     * @returns {string} - Formatierter Wert
     */
    function _formatValue(value, type) {
        if (value === null || value === undefined) return 'nicht verfügbar';
        
        switch (type) {
            case 'percentage':
            case 'categoryPercentage':
            case 'teamAverage':
            case 'individualMinimum':
                return Math.round(value * 10) / 10; // Auf eine Nachkommastelle runden
                
            case 'completionTime':
                return Math.round(value * 10) / 10;
                
            default:
                return value.toString();
        }
    }
    
    /**
     * Erzeugt eine eindeutige Test-ID für das Caching
     * @param {Object} testResult - Das Testergebnis
     * @returns {string} - Eindeutige ID
     */
    function _createCacheKey(testResult) {
        if (!testResult) return null;
        
        // Alle relevanten Eigenschaften für den Cache-Schlüssel kombinieren
        return `${testResult.testId || ''}_${testResult.userId || ''}_${testResult.submissionId || ''}_${testResult.timestamp || ''}`;
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das System mit benutzerdefinierten Regeln
         * @param {Object} customRules - Benutzerdefinierte Regelsätze
         */
        init: function(customRules = {}) {
            // Standard-Regelsätze laden
            _passingRules = { ..._defaultPassingRules };
            
            // Benutzerdefinierte Regelsätze hinzufügen
            Object.entries(customRules).forEach(([id, ruleSet]) => {
                _passingRules[id] = ruleSet;
            });
            
            // Cache zurücksetzen
            _cachedResults = {};
            
            return this;
        },
        
        /**
         * Fügt einen neuen Regelsatz hinzu oder aktualisiert einen bestehenden
         * @param {Object} ruleSet - Der hinzuzufügende Regelsatz
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addRuleSet: function(ruleSet) {
            if (!ruleSet || !ruleSet.id) {
                console.error('Ungültiger Regelsatz - ID erforderlich');
                return false;
            }
            
            _passingRules[ruleSet.id] = ruleSet;
            
            // Cache für diesen Regelsatz löschen
            Object.keys(_cachedResults).forEach(key => {
                if (_cachedResults[key].ruleSetId === ruleSet.id) {
                    delete _cachedResults[key];
                }
            });
            
            return true;
        },
        
        /**
         * Entfernt einen Regelsatz
         * @param {string} ruleSetId - ID des zu entfernenden Regelsatzes
         * @returns {boolean} - True, wenn erfolgreich entfernt
         */
        removeRuleSet: function(ruleSetId) {
            if (!ruleSetId || !_passingRules[ruleSetId]) {
                return false;
            }
            
            // Standardregeln können nicht entfernt werden
            if (Object.keys(_defaultPassingRules).includes(ruleSetId)) {
                console.warn(`Der Standardregelsatz "${ruleSetId}" kann nicht entfernt werden`);
                return false;
            }
            
            delete _passingRules[ruleSetId];
            
            // Cache für diesen Regelsatz löschen
            Object.keys(_cachedResults).forEach(key => {
                if (_cachedResults[key].ruleSetId === ruleSetId) {
                    delete _cachedResults[key];
                }
            });
            
            return true;
        },
        
        /**
         * Gibt alle verfügbaren Regelsätze zurück
         * @returns {Object} - Die verfügbaren Regelsätze
         */
        getAllRuleSets: function() {
            return { ..._passingRules };
        },
        
        /**
         * Gibt die Standardregelsätze zurück
         * @returns {Object} - Die Standardregelsätze
         */
        getDefaultRuleSets: function() {
            return { ..._defaultPassingRules };
        },
        
        /**
         * Wertet ein Testergebnis aus und bestimmt, ob der Test bestanden wurde
         * @param {Object} testResult - Das zu bewertende Testergebnis
         * @param {Object} test - Optionale Testdetails für die Regelauswahl
         * @returns {Object} - Auswertungsergebnis mit Bestanden/Nicht-Bestanden und Details
         */
        evaluateTestResult: function(testResult, test) {
            if (!testResult) {
                return {
                    passed: false,
                    error: 'Keine Testergebnisse vorhanden'
                };
            }
            
            // Caching: Prüfen, ob bereits im Cache
            const cacheKey = _createCacheKey(testResult);
            if (cacheKey && _cachedResults[cacheKey]) {
                return { ..._cachedResults[cacheKey] };
            }
            
            // Testdetails aus dem Ergebnis extrahieren, falls nicht angegeben
            const testDetails = test || {
                id: testResult.testId,
                type: testResult.testType
            };
            
            // Passenden Regelsatz ermitteln
            const ruleSet = _getApplicableRuleSet(testDetails);
            
            // Regelsatz auf das Testergebnis anwenden
            const evaluation = _evaluateRuleSet(ruleSet, testResult);
            
            // Benutzerfreundliche Erklärungen generieren
            const explanations = _generateExplanations(evaluation);
            
            // Gesamtergebnis
            const result = {
                passed: evaluation.passed,
                ruleSetId: ruleSet.id,
                ruleSetName: ruleSet.name,
                evaluation: evaluation,
                explanations: explanations,
                timestamp: new Date().toISOString()
            };
            
            // Im Cache speichern
            if (cacheKey) {
                _cachedResults[cacheKey] = { ...result };
            }
            
            return result;
        },
        
        /**
         * Generiert eine benutzerfreundliche Erklärung des Bewertungsergebnisses
         * @param {Object} evaluationResult - Das Bewertungsergebnis
         * @returns {Array} - Liste von Erklärungstexten
         */
        generateExplanations: function(evaluationResult) {
            return _generateExplanations(evaluationResult);
        },
        
        /**
         * Leert den Cache für Testergebnisse
         */
        clearCache: function() {
            _cachedResults = {};
        }
    };
})();

// Modul für Bewertungsskalen
window.ImmoLern.Assessment.Evaluation.GradingScale = (function() {
    // Private Variablen
    let _gradingScales = {
        // Standardskala: A-F
        default: {
            id: 'default',
            name: 'Standardnotenskala',
            description: 'Standardnotenskala A-F',
            levels: [
                { grade: 'A', minPercentage: 90, label: 'Hervorragend' },
                { grade: 'B', minPercentage: 80, label: 'Sehr gut' },
                { grade: 'C', minPercentage: 70, label: 'Gut' },
                { grade: 'D', minPercentage: 60, label: 'Befriedigend' },
                { grade: 'E', minPercentage: 50, label: 'Ausreichend' },
                { grade: 'F', minPercentage: 0, label: 'Nicht bestanden' }
            ]
        },
        
        // Deutsche Notenskala: 1-6
        german: {
            id: 'german',
            name: 'Deutsche Notenskala',
            description: 'Deutsche Schulnoten (1-6)',
            levels: [
                { grade: '1', minPercentage: 92, label: 'Sehr gut' },
                { grade: '2', minPercentage: 81, label: 'Gut' },
                { grade: '3', minPercentage: 67, label: 'Befriedigend' },
                { grade: '4', minPercentage: 50, label: 'Ausreichend' },
                { grade: '5', minPercentage: 30, label: 'Mangelhaft' },
                { grade: '6', minPercentage: 0, label: 'Ungenügend' }
            ]
        },
        
        // Einfache Skala: Bestanden/Nicht-Bestanden
        passFail: {
            id: 'passFail',
            name: 'Bestanden/Nicht-Bestanden',
            description: 'Einfache Bestanden/Nicht-Bestanden-Bewertung',
            levels: [
                { grade: 'Bestanden', minPercentage: 50, label: 'Bestanden' },
                { grade: 'Nicht bestanden', minPercentage: 0, label: 'Nicht bestanden' }
            ]
        },
        
        // Kompetenzskala: Fortgeschrittener/Experte
        competency: {
            id: 'competency',
            name: 'Kompetenzstufen',
            description: 'Detaillierte Kompetenzstufenbewertung',
            levels: [
                { grade: 'Experte', minPercentage: 90, label: 'Experte' },
                { grade: 'Fortgeschritten', minPercentage: 75, label: 'Fortgeschritten' },
                { grade: 'Kompetent', minPercentage: 60, label: 'Kompetent' },
                { grade: 'Grundkenntnisse', minPercentage: 40, label: 'Grundkenntnisse' },
                { grade: 'Anfänger', minPercentage: 20, label: 'Anfänger' },
                { grade: 'Keine Kenntnisse', minPercentage: 0, label: 'Keine Kenntnisse' }
            ]
        }
    };
    
    // Private Funktionen
    
    /**
     * Bestimmt die Note basierend auf einem Prozentsatz
     * @param {number} percentage - Der Prozentsatz
     * @param {string} scaleId - ID der zu verwendenden Notenskala
     * @returns {Object} - Die ermittelte Note
     */
    function _determineGrade(percentage, scaleId = 'default') {
        // Notenskala abrufen
        const scale = _gradingScales[scaleId] || _gradingScales.default;
        
        // Noten nach Mindestprozentsätzen sortieren (höchste zuerst)
        const sortedLevels = [...scale.levels].sort((a, b) => b.minPercentage - a.minPercentage);
        
        // Passende Note ermitteln
        for (const level of sortedLevels) {
            if (percentage >= level.minPercentage) {
                return {
                    grade: level.grade,
                    label: level.label,
                    percentage: percentage,
                    scaleId: scale.id,
                    scaleName: scale.name
                };
            }
        }
        
        // Fallback: Niedrigste Note zurückgeben
        const lowestLevel = sortedLevels[sortedLevels.length - 1];
        return {
            grade: lowestLevel.grade,
            label: lowestLevel.label,
            percentage: percentage,
            scaleId: scale.id,
            scaleName: scale.name
        };
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul mit benutzerdefinierten Notenskalen
         * @param {Object} customScales - Benutzerdefinierte Notenskalen
         */
        init: function(customScales = {}) {
            // Benutzerdefinierte Skalen hinzufügen
            Object.entries(customScales).forEach(([id, scale]) => {
                _gradingScales[id] = scale;
            });
            
            return this;
        },
        
        /**
         * Fügt eine neue Notenskala hinzu oder aktualisiert eine bestehende
         * @param {Object} scale - Die hinzuzufügende Notenskala
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addGradingScale: function(scale) {
            if (!scale || !scale.id || !Array.isArray(scale.levels)) {
                console.error('Ungültige Notenskala - ID und Levels erforderlich');
                return false;
            }
            
            _gradingScales[scale.id] = scale;
            return true;
        },
        
        /**
         * Entfernt eine Notenskala
         * @param {string} scaleId - ID der zu entfernenden Notenskala
         * @returns {boolean} - True, wenn erfolgreich entfernt
         */
        removeGradingScale: function(scaleId) {
            if (!scaleId || !_gradingScales[scaleId]) {
                return false;
            }
            
            // Standard-Notenskalen können nicht entfernt werden
            if (['default', 'german', 'passFail', 'competency'].includes(scaleId)) {
                console.warn(`Die Standardnotenskala "${scaleId}" kann nicht entfernt werden`);
                return false;
            }
            
            delete _gradingScales[scaleId];
            return true;
        },
        
        /**
         * Gibt alle verfügbaren Notenskalen zurück
         * @returns {Object} - Die verfügbaren Notenskalen
         */
        getAllGradingScales: function() {
            return { ..._gradingScales };
        },
        
        /**
         * Bewertet ein Testergebnis mit einer Notenskala
         * @param {Object} testResult - Das zu bewertende Testergebnis
         * @param {string} scaleId - ID der zu verwendenden Notenskala
         * @returns {Object} - Das Bewertungsergebnis mit Note
         */
        gradeTestResult: function(testResult, scaleId = 'default') {
            if (!testResult) {
                return {
                    error: 'Keine Testergebnisse vorhanden'
                };
            }
            
            // Prozentsatz aus dem Testergebnis extrahieren
            const percentage = testResult.percentage || 0;
            
            // Note bestimmen
            const grading = _determineGrade(percentage, scaleId);
            
            // Bewertungsergebnis erstellen
            return {
                testId: testResult.testId,
                userId: testResult.userId,
                percentage: percentage,
                passed: testResult.passed,
                grade: grading.grade,
                label: grading.label,
                scaleId: grading.scaleId,
                scaleName: grading.scaleName
            };
        },
        
        /**
         * Bestimmt die Note für einen Prozentsatz
         * @param {number} percentage - Der zu bewertende Prozentsatz
         * @param {string} scaleId - ID der zu verwendenden Notenskala
         * @returns {Object} - Die ermittelte Note
         */
        getGradeForPercentage: function(percentage, scaleId = 'default') {
            return _determineGrade(percentage, scaleId);
        }
    };
})();

// Modul für benutzerdefinierte Bewertungsrichtlinien
window.ImmoLern.Assessment.Evaluation.CustomPolicies = (function() {
    // Private Variablen
    let _policies = {};
    let _policyTriggers = {
        onPass: [],
        onFail: [],
        onGradeA: [],
        onGradeB: [],
        onGradeC: [],
        onGradeD: [],
        onGradeE: [],
        onGradeF: [],
        onScore: {}
    };
    
    // Private Funktionen
    
    /**
     * Führt eine Richtlinie aus
     * @param {Object} policy - Die auszuführende Richtlinie
     * @param {Object} testResult - Das Testergebnis
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @returns {Object} - Das Ergebnis der Richtlinienausführung
     */
    function _executePolicy(policy, testResult, evaluation) {
        if (!policy || !policy.action) {
            return {
                success: false,
                error: 'Ungültige Richtlinie'
            };
        }
        
        try {
            // Richtlinie ausführen
            const result = policy.action(testResult, evaluation);
            
            return {
                success: true,
                policyId: policy.id,
                result: result
            };
        } catch (error) {
            console.error('Fehler bei der Ausführung der Richtlinie:', error);
            
            return {
                success: false,
                policyId: policy.id,
                error: error.message
            };
        }
    }
    
    /**
     * Prüft, ob eine Richtlinie ausgeführt werden soll
     * @param {Object} policy - Die zu prüfende Richtlinie
     * @param {Object} testResult - Das Testergebnis
     * @param {Object} evaluation - Das Auswertungsergebnis
     * @returns {boolean} - True, wenn die Richtlinie ausgeführt werden soll
     */
    function _shouldExecutePolicy(policy, testResult, evaluation) {
        if (!policy || !policy.condition) {
            return true; // Standardmäßig ausführen
        }
        
        try {
            // Bedingung auswerten
            return policy.condition(testResult, evaluation);
        } catch (error) {
            console.error('Fehler bei der Auswertung der Richtlinienbedingung:', error);
            return false;
        }
    }
    
    // Öffentliche Methoden
    return {
        /**
         * Initialisiert das Modul
         */
        init: function() {
            // Richtlinien und Trigger zurücksetzen
            _policies = {};
            _policyTriggers = {
                onPass: [],
                onFail: [],
                onGradeA: [],
                onGradeB: [],
                onGradeC: [],
                onGradeD: [],
                onGradeE: [],
                onGradeF: [],
                onScore: {}
            };
            
            return this;
        },
        
        /**
         * Fügt eine neue Richtlinie hinzu
         * @param {Object} policy - Die hinzuzufügende Richtlinie
         * @returns {boolean} - True, wenn erfolgreich hinzugefügt
         */
        addPolicy: function(policy) {
            if (!policy || !policy.id || !policy.action) {
                console.error('Ungültige Richtlinie - ID und Action erforderlich');
                return false;
            }
            
            _policies[policy.id] = policy;
            
            // Trigger hinzufügen, falls angegeben
            if (policy.triggers) {
                policy.triggers.forEach(trigger => {
                    if (trigger === 'onPass') {
                        _policyTriggers.onPass.push(policy.id);
                    } else if (trigger === 'onFail') {
                        _policyTriggers.onFail.push(policy.id);
                    } else if (trigger.startsWith('onGrade')) {
                        const grade = trigger.substring(7);
                        const triggerKey = `onGrade${grade}`;
                        
                        if (_policyTriggers[triggerKey]) {
                            _policyTriggers[triggerKey].push(policy.id);
                        }
                    } else if (trigger.startsWith('onScore')) {
                        const scoreMatch = trigger.match(/onScore(\d+)/);
                        if (scoreMatch && scoreMatch[1]) {
                            const score = parseInt(scoreMatch[1]);
                            
                            if (!_policyTriggers.onScore[score]) {
                                _policyTriggers.onScore[score] = [];
                            }
                            
                            _policyTriggers.onScore[score].push(policy.id);
                        }
                    }
                });
            }
            
            return true;
        },
        
        /**
         * Entfernt eine Richtlinie
         * @param {string} policyId - ID der zu entfernenden Richtlinie
         * @returns {boolean} - True, wenn erfolgreich entfernt
         */
        removePolicy: function(policyId) {
            if (!policyId || !_policies[policyId]) {
                return false;
            }
            
            // Richtlinie entfernen
            delete _policies[policyId];
            
            // Aus allen Triggern entfernen
            Object.keys(_policyTriggers).forEach(trigger => {
                if (Array.isArray(_policyTriggers[trigger])) {
                    _policyTriggers[trigger] = _policyTriggers[trigger].filter(id => id !== policyId);
                } else if (typeof _policyTriggers[trigger] === 'object') {
                    Object.keys(_policyTriggers[trigger]).forEach(key => {
                        _policyTriggers[trigger][key] = _policyTriggers[trigger][key].filter(id => id !== policyId);
                    });
                }
            });
            
            return true;
        },
        
        /**
         * Führt alle passenden Richtlinien für ein Testergebnis aus
         * @param {Object} testResult - Das Testergebnis
         * @param {Object} evaluation - Das Auswertungsergebnis
         * @returns {Array} - Ergebnisse der Richtlinienausführung
         */
        applyPolicies: function(testResult, evaluation) {
            if (!testResult || !evaluation) {
                return [];
            }
            
            const results = [];
            const triggeredPolicies = new Set();
            
            // Bestandene/Nicht-bestandene Trigger
            if (evaluation.passed) {
                _policyTriggers.onPass.forEach(policyId => triggeredPolicies.add(policyId));
            } else {
                _policyTriggers.onFail.forEach(policyId => triggeredPolicies.add(policyId));
            }
            
            // Noten-Trigger
            if (evaluation.grade) {
                const triggerKey = `onGrade${evaluation.grade}`;
                if (_policyTriggers[triggerKey]) {
                    _policyTriggers[triggerKey].forEach(policyId => triggeredPolicies.add(policyId));
                }
            }
            
            // Punktzahl-Trigger
            const score = Math.round(testResult.percentage || 0);
            if (_policyTriggers.onScore[score]) {
                _policyTriggers.onScore[score].forEach(policyId => triggeredPolicies.add(policyId));
            }
            
            // Alle ausgelösten Richtlinien ausführen
            triggeredPolicies.forEach(policyId => {
                const policy = _policies[policyId];
                
                if (policy && _shouldExecutePolicy(policy, testResult, evaluation)) {
                    const result = _executePolicy(policy, testResult, evaluation);
                    results.push(result);
                }
            });
            
            return results;
        },
        
        /**
         * Gibt alle registrierten Richtlinien zurück
         * @returns {Object} - Die verfügbaren Richtlinien
         */
        getAllPolicies: function() {
            return { ..._policies };
        }
    };
})();

// Module initialisieren, wenn das Dokument geladen ist
document.addEventListener('DOMContentLoaded', () => {
    // Module initialisieren
    window.ImmoLern.Assessment.Evaluation.PassFailSystem.init();
    window.ImmoLern.Assessment.Evaluation.GradingScale.init();
    window.ImmoLern.Assessment.Evaluation.CustomPolicies.init();
    
    // Benutzerdefiniertes Ereignis auslösen, wenn die Module geladen sind
    document.dispatchEvent(new CustomEvent('evaluationSystemLoaded'));
});
/**
 * @fileoverview JS-Block 6.5.1-part1a - Ergebnisvisualisierung (Grundgerüst und Datenaufbereitung)
 * Dieser Code implementiert die grundlegende Struktur und Datenaufbereitung für die
 * visuelle Darstellung von Testergebnissen.
 * 
 * @module modules/resultVisualization
 * @requires modules/testEvaluation
 * @requires modules/dataProcessing
 * @requires utils/uiHelpers
 */

// Namespace für die Ergebnisvisualisierung
app.modules.resultVisualization = (function() {
    // Private Variablen
    let _currentTestResult = null;
    let _visualizationOptions = {
        showDetailedFeedback: true,
        animateResults: true,
        showComparison: false,
        colorScheme: 'default', // 'default', 'colorblind', 'highContrast'
        chartType: 'bar', // 'bar', 'pie', 'radar'
    };
    
    // Cache für bereits aufbereitete Daten
    const _dataCache = new Map();
    
    /**
     * Initialisiert die Ergebnisvisualisierungskomponente
     * @param {Object} options - Konfigurationsoptionen für die Visualisierung
     */
    function init(options = {}) {
        console.log('Initialisiere Ergebnisvisualisierung...');
        
        // Optionen mit Standardwerten zusammenführen
        _visualizationOptions = Object.assign(_visualizationOptions, options);
        
        // Event-Listener registrieren
        document.addEventListener('testEvaluationComplete', handleTestEvaluationComplete);
        
        // Benötigte DOM-Elemente vorbereiten
        _createVisualizationContainer();
        
        console.log('Ergebnisvisualisierung initialisiert mit Optionen:', _visualizationOptions);
    }
    
    /**
     * Erstellt den Container für die Visualisierungen im DOM
     * @private
     */
    function _createVisualizationContainer() {
        const appContainer = document.getElementById('app-container');
        
        // Prüfen, ob der Container bereits existiert
        let resultContainer = document.getElementById('test-result-visualization');
        if (!resultContainer) {
            resultContainer = document.createElement('div');
            resultContainer.id = 'test-result-visualization';
            resultContainer.className = 'result-container';
            resultContainer.style.display = 'none'; // Initial versteckt
            
            // Grundstruktur für die Ergebnisvisualisierung erstellen
            resultContainer.innerHTML = `
                <div class="result-header">
                    <h2 class="result-title">Test-Ergebnis</h2>
                    <div class="result-meta-info"></div>
                </div>
                <div class="result-summary-container"></div>
                <div class="result-details-container">
                    <div class="result-charts-container"></div>
                    <div class="result-feedback-container"></div>
                </div>
                <div class="result-actions">
                    <button class="btn btn-primary result-share-btn">Ergebnis teilen</button>
                    <button class="btn btn-secondary result-print-btn">Drucken</button>
                    <button class="btn btn-secondary result-export-btn">Exportieren</button>
                </div>
            `;
            
            appContainer.appendChild(resultContainer);
            
            // Event-Listener für Aktionsbuttons
            _attachActionButtonListeners(resultContainer);
        }
    }
    
    /**
     * Fügt Event-Listener für die Aktionsbuttons hinzu
     * @private
     * @param {HTMLElement} container - Der Container mit den Buttons
     */
    function _attachActionButtonListeners(container) {
        const shareBtn = container.querySelector('.result-share-btn');
        const printBtn = container.querySelector('.result-print-btn');
        const exportBtn = container.querySelector('.result-export-btn');
        
        if (shareBtn) {
            shareBtn.addEventListener('click', shareResults);
        }
        
        if (printBtn) {
            printBtn.addEventListener('click', printResults);
        }
        
        if (exportBtn) {
            exportBtn.addEventListener('click', exportResults);
        }
    }
    
    /**
     * Event-Handler für abgeschlossene Testauswertungen
     * @param {CustomEvent} event - Das Ereignis mit Testdaten
     */
    function handleTestEvaluationComplete(event) {
        console.log('Testauswertung abgeschlossen, starte Visualisierung...');
        
        if (event && event.detail && event.detail.testResult) {
            _currentTestResult = event.detail.testResult;
            
            // Daten für die Visualisierung aufbereiten
            const visualizationData = prepareDataForVisualization(_currentTestResult);
            
            // Visualisierung anzeigen
            showVisualization(visualizationData);
        } else {
            console.error('Keine gültigen Testdaten für die Visualisierung erhalten');
        }
    }
    
    /**
     * Bereitet die Testdaten für die Visualisierung auf
     * @param {Object} testResult - Das Ergebnisobjekt der Testauswertung
     * @returns {Object} Aufbereitete Daten für die Visualisierung
     */
    function prepareDataForVisualization(testResult) {
        // Prüfen, ob die Daten bereits im Cache sind
        const cacheKey = testResult.id + '-' + testResult.timestamp;
        if (_dataCache.has(cacheKey)) {
            console.log('Verwende zwischengespeicherte Visualisierungsdaten');
            return _dataCache.get(cacheKey);
        }
        
        console.log('Bereite Daten für Visualisierung auf...');
        
        // Grundlegende Testinformationen
        const visualizationData = {
            testInfo: {
                id: testResult.id,
                title: testResult.title || 'Unbenannter Test',
                timestamp: testResult.timestamp,
                duration: testResult.duration || 0,
                passThreshold: testResult.passThreshold || 0
            },
            summary: {
                totalPoints: testResult.totalPoints || 0,
                achievedPoints: testResult.achievedPoints || 0,
                percentageScore: testResult.percentageScore || 0,
                passed: testResult.passed || false,
                grade: testResult.grade || 'N/A',
                timeSpent: testResult.timeSpent || 0
            },
            categories: {},
            questionDetails: [],
            feedback: testResult.feedback || { general: 'Keine Rückmeldung verfügbar' }
        };
        
        // Kategoriedaten aggregieren
        if (testResult.categories && Object.keys(testResult.categories).length > 0) {
            visualizationData.categories = _processCategoryData(testResult.categories);
        }
        
        // Detaillierte Fragendaten aufbereiten
        if (testResult.questions && testResult.questions.length > 0) {
            visualizationData.questionDetails = _processQuestionData(testResult.questions);
        }
        
        // Vergleichsdaten aufbereiten, falls vorhanden
        if (testResult.comparisons) {
            visualizationData.comparisons = _processComparisonData(testResult.comparisons);
        }
        
        // Daten im Cache speichern
        _dataCache.set(cacheKey, visualizationData);
        
        console.log('Datenaufbereitung abgeschlossen:', visualizationData);
        return visualizationData;
    }
    
    /**
     * Verarbeitet Kategoriedaten für die Visualisierung
     * @private
     * @param {Object} categories - Kategoriedaten aus dem Testergebnis
     * @returns {Object} Aufbereitete Kategoriedaten
     */
    function _processCategoryData(categories) {
        const processedCategories = {};
        
        for (const [categoryName, categoryData] of Object.entries(categories)) {
            processedCategories[categoryName] = {
                total: categoryData.totalPoints || 0,
                achieved: categoryData.achievedPoints || 0,
                percentage: categoryData.percentageScore || 0,
                questions: categoryData.questionCount || 0,
                correctQuestions: categoryData.correctCount || 0,
                // Statuswert berechnen (rot, gelb, grün)
                status: _calculateStatusForPercentage(categoryData.percentageScore || 0)
            };
        }
        
        return processedCategories;
    }
    
    /**
     * Verarbeitet Fragendaten für die detaillierte Visualisierung
     * @private
     * @param {Array} questions - Fragendaten aus dem Testergebnis
     * @returns {Array} Aufbereitete Fragendaten
     */
    function _processQuestionData(questions) {
        return questions.map(question => {
            return {
                id: question.id,
                text: question.text,
                type: question.type,
                category: question.category || 'Allgemein',
                points: {
                    max: question.maxPoints || 0,
                    achieved: question.achievedPoints || 0,
                    percentage: question.maxPoints ? (question.achievedPoints / question.maxPoints) * 100 : 0
                },
                isCorrect: question.isCorrect || false,
                userAnswer: question.userAnswer,
                correctAnswer: question.correctAnswer,
                explanation: question.explanation || '',
                timeTaken: question.timeTaken || 0,
                // Detaillierte Analysedaten, falls vorhanden
                analysis: question.analysis || null
            };
        });
    }
    
    /**
     * Verarbeitet Vergleichsdaten für die Visualisierung
     * @private
     * @param {Object} comparisons - Vergleichsdaten aus dem Testergebnis
     * @returns {Object} Aufbereitete Vergleichsdaten
     */
    function _processComparisonData(comparisons) {
        const processedComparisons = {
            team: comparisons.team || null,
            department: comparisons.department || null,
            company: comparisons.company || null,
            history: comparisons.history || null
        };
        
        // Falls keine detaillierten Vergleichsdaten vorhanden sind, erstelle Dummy-Daten
        if (!processedComparisons.team && !processedComparisons.department) {
            processedComparisons.dummy = {
                averageScore: 75,
                medianScore: 78,
                topScore: 98,
                bottomScore: 45
            };
        }
        
        return processedComparisons;
    }
    
    /**
     * Berechnet einen Statuswert basierend auf einem Prozentwert
     * @private
     * @param {number} percentage - Prozentwert
     * @returns {string} Statuskategorie ('danger', 'warning', 'success')
     */
    function _calculateStatusForPercentage(percentage) {
        if (percentage < 50) {
            return 'danger';
        } else if (percentage < 75) {
            return 'warning';
        } else {
            return 'success';
        }
    }
    
    /**
     * Zeigt die visualisierten Testergebnisse an
     * @param {Object} visualizationData - Die aufbereiteten Daten für die Visualisierung
     */
    function showVisualization(visualizationData) {
        console.log('Zeige Ergebnisvisualisierung an...');
        
        const resultContainer = document.getElementById('test-result-visualization');
        if (!resultContainer) {
            console.error('Ergebnis-Container nicht gefunden');
            return;
        }
        
        // Container anzeigen
        resultContainer.style.display = 'block';
        
        // Basisdaten anzeigen (wird in Teil 1b und 1c vervollständigt)
        _populateBasicTestInfo(visualizationData.testInfo);
        
        // Grundlegende Zusammenfassung anzeigen
        _populateSummaryInfo(visualizationData.summary);
        
        console.log('Basisvisualisierung abgeschlossen, weitere Details folgen in den nächsten Implementierungsschritten');
    }
    
    /**
     * Füllt die Basis-Testinformationen aus
     * @private
     * @param {Object} testInfo - Grundlegende Testinformationen
     */
    function _populateBasicTestInfo(testInfo) {
        const headerElement = document.querySelector('.result-title');
        const metaInfoElement = document.querySelector('.result-meta-info');
        
        if (headerElement) {
            headerElement.textContent = `Ergebnis: ${testInfo.title}`;
        }
        
        if (metaInfoElement) {
            const date = new Date(testInfo.timestamp);
            const formattedDate = date.toLocaleDateString('de-DE', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            metaInfoElement.innerHTML = `
                <div class="meta-item">
                    <span class="meta-label">Test-ID:</span>
                    <span class="meta-value">${testInfo.id}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Datum:</span>
                    <span class="meta-value">${formattedDate}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Dauer:</span>
                    <span class="meta-value">${app.utils.formatTime(testInfo.duration)}</span>
                </div>
            `;
        }
    }
    
    /**
     * Füllt die Zusammenfassungsinformationen aus
     * @private
     * @param {Object} summary - Zusammenfassungsdaten des Testergebnisses
     */
    function _populateSummaryInfo(summary) {
        const summaryContainer = document.querySelector('.result-summary-container');
        
        if (summaryContainer) {
            const passStatusClass = summary.passed ? 'status-passed' : 'status-failed';
            const passStatusText = summary.passed ? 'Bestanden' : 'Nicht bestanden';
            
            summaryContainer.innerHTML = `
                <div class="result-overview">
                    <div class="result-score">
                        <div class="score-circle ${passStatusClass}">
                            <span class="score-value">${Math.round(summary.percentageScore)}%</span>
                        </div>
                        <div class="score-label">${passStatusText}</div>
                    </div>
                    <div class="result-details">
                        <div class="detail-item">
                            <span class="detail-label">Erreichte Punkte:</span>
                            <span class="detail-value">${summary.achievedPoints} von ${summary.totalPoints}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Note:</span>
                            <span class="detail-value">${summary.grade}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Zeit:</span>
                            <span class="detail-value">${app.utils.formatTime(summary.timeSpent)}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Animation für den Ergebniskreis, falls aktiviert
            if (_visualizationOptions.animateResults) {
                setTimeout(() => {
                    const scoreCircle = summaryContainer.querySelector('.score-circle');
                    if (scoreCircle) {
                        scoreCircle.classList.add('animate');
                    }
                }, 100);
            }
        }
    }
    
    /**
     * Teilt die Testergebnisse (z.B. per E-Mail oder Link)
     */
    function shareResults() {
        console.log('Teile Testergebnisse...');
        
        // Einfache Implementierung für Teil 1a
        alert('Teilen-Funktion wird in zukünftigen Versionen implementiert.');
        
        // Die vollständige Implementierung erfolgt in späteren Teilen
    }
    
    /**
     * Druckt die Testergebnisse
     */
    function printResults() {
        console.log('Drucke Testergebnisse...');
        
        // Einfache Implementierung für Teil 1a
        window.print();
        
        // Die vollständige Implementierung erfolgt in späteren Teilen
    }
    
    /**
     * Exportiert die Testergebnisse (z.B. als PDF oder JSON)
     */
    function exportResults() {
        console.log('Exportiere Testergebnisse...');
        
        // Einfache Implementierung für Teil 1a
        alert('Export-Funktion wird in zukünftigen Versionen implementiert.');
        
        // Die vollständige Implementierung erfolgt in späteren Teilen
    }
    
    // Öffentliche API
    return {
        init: init,
        prepareDataForVisualization: prepareDataForVisualization,
        showVisualization: showVisualization,
        shareResults: shareResults,
        printResults: printResults,
        exportResults: exportResults,
        
        // Konfigurationsfunktionen
        setVisualizationOptions: function(options) {
            _visualizationOptions = Object.assign(_visualizationOptions, options);
        },
        getVisualizationOptions: function() {
            return Object.assign({}, _visualizationOptions);
        }
    };
})();

// Initialisierung beim Laden der Anwendung
document.addEventListener('appInitialized', function() {
    app.modules.resultVisualization.init();
});
/**
 * @fileoverview JS-Block 6.5.1-part1b - Ergebnisvisualisierung (Diagramme und Charts)
 * Dieser Code implementiert die Funktionalität zur Erstellung von Charts und Diagrammen
 * für die visuelle Darstellung von Testergebnissen.
 * 
 * @module modules/resultVisualization
 * @requires modules/testEvaluation
 * @requires modules/dataProcessing
 * @requires utils/uiHelpers
 */

// Erweiterung des Ergebnisvisualisierungs-Moduls
(function() {
    // Private Hilfsfunktionen für Diagramme
    
    /**
     * Erstellt verschiedene Diagramme für die Ergebnisdarstellung
     * @param {Object} visualizationData - Aufbereitete Daten für die Visualisierung
     */
    function _createResultCharts(visualizationData) {
        console.log('Erstelle Ergebnis-Diagramme...');
        
        const chartsContainer = document.querySelector('.result-charts-container');
        if (!chartsContainer) {
            console.error('Charts-Container nicht gefunden');
            return;
        }
        
        // Container leeren
        chartsContainer.innerHTML = '';
        
        // Struktur für Charts erstellen
        chartsContainer.innerHTML = `
            <div class="charts-row">
                <div class="chart-container" id="overall-score-chart">
                    <h3 class="chart-title">Gesamtergebnis</h3>
                    <div class="chart-content"></div>
                </div>
                <div class="chart-container" id="category-performance-chart">
                    <h3 class="chart-title">Leistung nach Kategorien</h3>
                    <div class="chart-content"></div>
                </div>
            </div>
            <div class="charts-row">
                <div class="chart-container" id="question-type-chart">
                    <h3 class="chart-title">Leistung nach Fragetypen</h3>
                    <div class="chart-content"></div>
                </div>
                <div class="chart-container" id="time-distribution-chart">
                    <h3 class="chart-title">Zeitverteilung</h3>
                    <div class="chart-content"></div>
                </div>
            </div>
        `;
        
        // Einzelne Charts erstellen
        _createOverallScoreChart(visualizationData, document.querySelector('#overall-score-chart .chart-content'));
        _createCategoryPerformanceChart(visualizationData, document.querySelector('#category-performance-chart .chart-content'));
        _createQuestionTypeChart(visualizationData, document.querySelector('#question-type-chart .chart-content'));
        _createTimeDistributionChart(visualizationData, document.querySelector('#time-distribution-chart .chart-content'));
        
        // Falls Vergleichsdaten vorhanden sind, zusätzlichen Chart erstellen
        if (visualizationData.comparisons) {
            _createComparisonCharts(visualizationData, chartsContainer);
        }
    }
    
    /**
     * Erstellt ein Kreisdiagramm für das Gesamtergebnis
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createOverallScoreChart(data, container) {
        if (!container) return;
        
        const summary = data.summary;
        const passThreshold = data.testInfo.passThreshold || 60;
        
        // HTML für ein SVG-basiertes Kreisdiagramm
        container.innerHTML = `
            <div class="donut-chart">
                <svg width="150" height="150" viewBox="0 0 150 150">
                    <!-- Hintergrundkreis -->
                    <circle class="donut-ring" 
                            cx="75" cy="75" r="60" 
                            fill="transparent" 
                            stroke="#eeeeee" 
                            stroke-width="15">
                    </circle>
                    
                    <!-- Bestehensgrenze anzeigen -->
                    <circle class="donut-threshold" 
                            cx="75" cy="75" r="60" 
                            fill="transparent" 
                            stroke="#ffd700" 
                            stroke-width="2" 
                            stroke-dasharray="${passThreshold} ${100-passThreshold}" 
                            stroke-dashoffset="25">
                    </circle>
                    
                    <!-- Ergebniskreis -->
                    <circle class="donut-segment ${summary.passed ? 'passed' : 'failed'}" 
                            cx="75" cy="75" r="60" 
                            fill="transparent" 
                            stroke="${summary.passed ? '#00FFD0' : '#ff6b6b'}" 
                            stroke-width="15" 
                            stroke-dasharray="${summary.percentageScore} ${100-summary.percentageScore}" 
                            stroke-dashoffset="25">
                    </circle>
                    
                    <!-- Text in der Mitte -->
                    <text x="75" y="75" class="donut-number" 
                          text-anchor="middle" 
                          alignment-baseline="middle" 
                          font-size="30" 
                          font-weight="bold">
                        ${Math.round(summary.percentageScore)}%
                    </text>
                    <text x="75" y="95" class="donut-label" 
                          text-anchor="middle" 
                          alignment-baseline="middle" 
                          font-size="12">
                        ${summary.passed ? 'Bestanden' : 'Nicht bestanden'}
                    </text>
                </svg>
            </div>
            <div class="chart-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${summary.passed ? '#00FFD0' : '#ff6b6b'};"></div>
                    <div class="legend-text">Erreicht: ${Math.round(summary.percentageScore)}%</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ffd700;"></div>
                    <div class="legend-text">Bestehensgrenze: ${passThreshold}%</div>
                </div>
            </div>
        `;
        
        // Animation für den Donut-Chart
        setTimeout(() => {
            const donutSegment = container.querySelector('.donut-segment');
            if (donutSegment) {
                donutSegment.classList.add('animate');
            }
        }, 100);
    }
    
    /**
     * Erstellt ein Balkendiagramm für die Leistung nach Kategorien
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createCategoryPerformanceChart(data, container) {
        if (!container || !data.categories || Object.keys(data.categories).length === 0) {
            container.innerHTML = '<div class="no-data-message">Keine Kategoriedaten verfügbar</div>';
            return;
        }
        
        const categories = data.categories;
        const categoryNames = Object.keys(categories);
        const maxBarWidth = 100; // Maximale Breite der Balken in Prozent
        
        let chartHTML = '<div class="bar-chart">';
        
        // Für jede Kategorie einen Balken erstellen
        categoryNames.forEach(categoryName => {
            const category = categories[categoryName];
            const percentage = category.percentage;
            const statusClass = _getStatusClass(percentage);
            
            chartHTML += `
                <div class="bar-item">
                    <div class="bar-label">${categoryName}</div>
                    <div class="bar-container">
                        <div class="bar-background"></div>
                        <div class="bar-foreground ${statusClass}" style="width: ${percentage}%;">
                            <span class="bar-value">${Math.round(percentage)}%</span>
                        </div>
                    </div>
                    <div class="bar-details">
                        ${category.achieved} von ${category.total} Punkten
                    </div>
                </div>
            `;
        });
        
        chartHTML += '</div>';
        container.innerHTML = chartHTML;
        
        // Animation für die Balken
        setTimeout(() => {
            const bars = container.querySelectorAll('.bar-foreground');
            bars.forEach((bar, index) => {
                setTimeout(() => {
                    bar.classList.add('animate');
                }, index * 100);
            });
        }, 100);
    }
    
    /**
     * Erstellt ein Diagramm für die Leistung nach Fragetypen
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createQuestionTypeChart(data, container) {
        if (!container || !data.questionDetails || data.questionDetails.length === 0) {
            container.innerHTML = '<div class="no-data-message">Keine Fragendaten verfügbar</div>';
            return;
        }
        
        // Leistung nach Fragetypen aggregieren
        const questionTypes = {};
        data.questionDetails.forEach(question => {
            const type = _getReadableQuestionType(question.type);
            
            if (!questionTypes[type]) {
                questionTypes[type] = {
                    total: 0,
                    correct: 0,
                    percentage: 0
                };
            }
            
            questionTypes[type].total++;
            if (question.isCorrect) {
                questionTypes[type].correct++;
            }
        });
        
        // Prozentsätze berechnen
        Object.keys(questionTypes).forEach(type => {
            const typeData = questionTypes[type];
            typeData.percentage = (typeData.correct / typeData.total) * 100;
        });
        
        // Kreisdiagramm für Fragetypen erstellen
        const typeNames = Object.keys(questionTypes);
        const colors = ['#00FFD0', '#34ace0', '#33d9b2', '#706fd3', '#ff793f'];
        
        // Einfaches Säulendiagramm für Fragetypen
        let chartHTML = '<div class="column-chart">';
        
        typeNames.forEach((type, index) => {
            const typeData = questionTypes[type];
            const color = colors[index % colors.length];
            const height = typeData.percentage;
            
            chartHTML += `
                <div class="column-item">
                    <div class="column-container">
                        <div class="column-background"></div>
                        <div class="column-foreground" style="height: ${height}%; background-color: ${color};"></div>
                    </div>
                    <div class="column-label">${type}</div>
                    <div class="column-value">${Math.round(height)}%</div>
                    <div class="column-details">
                        ${typeData.correct} von ${typeData.total}
                    </div>
                </div>
            `;
        });
        
        chartHTML += '</div>';
        container.innerHTML = chartHTML;
        
        // Animation für die Säulen
        setTimeout(() => {
            const columns = container.querySelectorAll('.column-foreground');
            columns.forEach((column, index) => {
                setTimeout(() => {
                    column.classList.add('animate');
                }, index * 100);
            });
        }, 100);
    }
    
    /**
     * Erstellt ein Diagramm für die Zeitverteilung
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createTimeDistributionChart(data, container) {
        if (!container || !data.questionDetails || data.questionDetails.length === 0) {
            container.innerHTML = '<div class="no-data-message">Keine Zeitdaten verfügbar</div>';
            return;
        }
        
        // Daten für die Zeitverteilung vorbereiten
        // Fragen in Zeitkategorien gruppieren
        const timeData = {
            fast: { count: 0, label: 'Schnell (<30s)' },
            medium: { count: 0, label: 'Mittel (30-60s)' },
            slow: { count: 0, label: 'Langsam (>60s)' }
        };
        
        data.questionDetails.forEach(question => {
            const timeTaken = question.timeTaken || 0;
            
            if (timeTaken < 30) {
                timeData.fast.count++;
            } else if (timeTaken < 60) {
                timeData.medium.count++;
            } else {
                timeData.slow.count++;
            }
        });
        
        // Kreisdiagramm für Zeitverteilung
        const total = data.questionDetails.length;
        const colors = {
            fast: '#00FFD0',
            medium: '#ffd700',
            slow: '#ff6b6b'
        };
        
        // SVG für ein Kreisdiagramm generieren
        let svgHTML = `
            <svg width="150" height="150" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" fill="#f0f0f0" />
        `;
        
        let startAngle = 0;
        Object.keys(timeData).forEach(key => {
            const value = timeData[key].count;
            const percentage = (value / total) * 100;
            const angle = (percentage / 100) * 360;
            
            // Nur zeichnen, wenn Wert größer als 0
            if (value > 0) {
                // Berechnen der Koordinaten für den Kreisbogen
                const endAngle = startAngle + angle;
                const startRad = (startAngle - 90) * Math.PI / 180;
                const endRad = (endAngle - 90) * Math.PI / 180;
                
                const x1 = 50 + 45 * Math.cos(startRad);
                const y1 = 50 + 45 * Math.sin(startRad);
                const x2 = 50 + 45 * Math.cos(endRad);
                const y2 = 50 + 45 * Math.sin(endRad);
                
                // Flag für den großen Bogen (large-arc-flag)
                const largeArcFlag = angle > 180 ? 1 : 0;
                
                // Path für den Kreisbogen erstellen
                svgHTML += `
                    <path d="M 50 50 L ${x1} ${y1} A 45 45 0 ${largeArcFlag} 1 ${x2} ${y2} Z"
                          fill="${colors[key]}" class="pie-segment" data-category="${key}">
                    </path>
                `;
                
                startAngle += angle;
            }
        });
        
        svgHTML += `</svg>`;
        
        // Gesamtes Chart-HTML mit Legende
        let chartHTML = `
            <div class="pie-chart-container">
                <div class="pie-chart">
                    ${svgHTML}
                </div>
                <div class="chart-legend">
        `;
        
        // Legende hinzufügen
        Object.keys(timeData).forEach(key => {
            const item = timeData[key];
            const percentage = (item.count / total) * 100;
            
            // Nur in Legende aufnehmen, wenn Wert größer als 0
            if (item.count > 0) {
                chartHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${colors[key]};"></div>
                        <div class="legend-text">${item.label}: ${item.count} (${Math.round(percentage)}%)</div>
                    </div>
                `;
            }
        });
        
        chartHTML += `
                </div>
            </div>
        `;
        
        container.innerHTML = chartHTML;
        
        // Tooltip-Events für die Segmente hinzufügen
        const segments = container.querySelectorAll('.pie-segment');
        segments.forEach(segment => {
            segment.addEventListener('mouseover', (e) => {
                const category = e.target.dataset.category;
                e.target.style.opacity = 0.8;
                // Hier kann später ein Tooltip hinzugefügt werden
            });
            
            segment.addEventListener('mouseout', (e) => {
                e.target.style.opacity = 1;
            });
        });
    }
    
    /**
     * Erstellt Vergleichsdiagramme, falls Vergleichsdaten vorhanden sind
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {HTMLElement} container - Der Container für die Diagramme
     */
    function _createComparisonCharts(data, container) {
        // Prüfen, ob Vergleichsdaten vorhanden sind
        if (!data.comparisons || Object.keys(data.comparisons).length === 0) {
            return;
        }
        
        console.log('Erstelle Vergleichsdiagramme...');
        
        // Container für Vergleichsdiagramme erstellen
        const comparisonRow = document.createElement('div');
        comparisonRow.className = 'charts-row';
        comparisonRow.innerHTML = `
            <div class="chart-container full-width" id="performance-comparison-chart">
                <h3 class="chart-title">Leistungsvergleich</h3>
                <div class="chart-content"></div>
            </div>
        `;
        
        container.appendChild(comparisonRow);
        
        const comparisonContainer = document.querySelector('#performance-comparison-chart .chart-content');
        
        // Vergleichsdaten vorbereiten
        const userScore = data.summary.percentageScore;
        const comparisonData = [];
        
        // Eigene Leistung hinzufügen
        comparisonData.push({
            label: 'Ihre Leistung',
            value: userScore,
            color: '#00FFD0'
        });
        
        // Team-Vergleich hinzufügen, falls vorhanden
        if (data.comparisons.team) {
            comparisonData.push({
                label: 'Team-Durchschnitt',
                value: data.comparisons.team.averageScore || 0,
                color: '#34ace0'
            });
        }
        
        // Abteilungs-Vergleich hinzufügen, falls vorhanden
        if (data.comparisons.department) {
            comparisonData.push({
                label: 'Abteilung',
                value: data.comparisons.department.averageScore || 0,
                color: '#33d9b2'
            });
        }
        
        // Unternehmens-Vergleich hinzufügen, falls vorhanden
        if (data.comparisons.company) {
            comparisonData.push({
                label: 'Unternehmen',
                value: data.comparisons.company.averageScore || 0,
                color: '#706fd3'
            });
        }
        
        // Dummy-Daten hinzufügen, falls keine echten Vergleichsdaten vorhanden sind
        if (comparisonData.length === 1 && data.comparisons.dummy) {
            comparisonData.push({
                label: 'Durchschnitt',
                value: data.comparisons.dummy.averageScore || 0,
                color: '#34ace0'
            });
        }
        
        // Horizontales Balkendiagramm für den Vergleich erstellen
        let chartHTML = '<div class="horizontal-bar-chart">';
        
        comparisonData.forEach(item => {
            chartHTML += `
                <div class="h-bar-item">
                    <div class="h-bar-label">${item.label}</div>
                    <div class="h-bar-container">
                        <div class="h-bar-background"></div>
                        <div class="h-bar-foreground" style="width: ${item.value}%; background-color: ${item.color};">
                            <span class="h-bar-value">${Math.round(item.value)}%</span>
                        </div>
                    </div>
                </div>
            `;
        });
        
        chartHTML += '</div>';
        comparisonContainer.innerHTML = chartHTML;
        
        // Animation für die Balken
        setTimeout(() => {
            const bars = comparisonContainer.querySelectorAll('.h-bar-foreground');
            bars.forEach((bar, index) => {
                setTimeout(() => {
                    bar.classList.add('animate');
                }, index * 100);
            });
        }, 100);
    }
    
    /**
     * Gibt eine CSS-Klasse basierend auf dem Statuswert zurück
     * @private
     * @param {number} percentage - Prozentwert
     * @returns {string} CSS-Klassenname
     */
    function _getStatusClass(percentage) {
        if (percentage < 50) {
            return 'status-danger';
        } else if (percentage < 75) {
            return 'status-warning';
        } else {
            return 'status-success';
        }
    }
    
    /**
     * Konvertiert einen technischen Fragentyp in einen lesbaren Namen
     * @private
     * @param {string} type - Technischer Fragentyp
     * @returns {string} Lesbarer Fragentyp
     */
    function _getReadableQuestionType(type) {
        const typeMapping = {
            'multiple-choice': 'Multiple Choice',
            'single-choice': 'Single Choice',
            'true-false': 'Wahr/Falsch',
            'free-text': 'Freitext'
        };
        
        return typeMapping[type] || type;
    }
    
    // Die Funktionen dem resultVisualization-Modul hinzufügen
    app.modules.resultVisualization._createResultCharts = _createResultCharts;
    
    // Die showVisualization-Funktion erweitern
    const originalShowVisualization = app.modules.resultVisualization.showVisualization;
    app.modules.resultVisualization.showVisualization = function(visualizationData) {
        // Zuerst die Ursprungsfunktion aufrufen
        originalShowVisualization(visualizationData);
        
        // Dann die Charts erstellen
        this._createResultCharts(visualizationData);
    };
    
})();
/**
 * @fileoverview JS-Block 6.5.1-part1c - Ergebnisvisualisierung (Detaillierte Fragendarstellung und Feedback)
 * Dieser Code implementiert die detaillierte Anzeige von Fragen, Antworten und
 * personalisierten Feedback-Elementen für die Ergebnisvisualisierung.
 * 
 * @module modules/resultVisualization
 * @requires modules/testEvaluation
 * @requires modules/dataProcessing
 * @requires utils/uiHelpers
 */

// Erweiterung des Ergebnisvisualisierungs-Moduls
(function() {
    // Private Hilfsfunktionen für die detaillierte Fragendarstellung und Feedback
    
    /**
     * Erstellt eine detaillierte Anzeige aller beantworteten Fragen
     * @param {Object} visualizationData - Aufbereitete Daten für die Visualisierung
     */
    function _createDetailedQuestionDisplay(visualizationData) {
        console.log('Erstelle detaillierte Fragendarstellung...');
        
        const feedbackContainer = document.querySelector('.result-feedback-container');
        if (!feedbackContainer) {
            console.error('Feedback-Container nicht gefunden');
            return;
        }
        
        // Container leeren
        feedbackContainer.innerHTML = '';
        
        // Abschnitt für allgemeines Feedback erstellen
        const generalFeedback = _createGeneralFeedbackSection(visualizationData);
        feedbackContainer.appendChild(generalFeedback);
        
        // Abschnitt für detailliertes Fragen-Feedback erstellen
        const questionFeedback = _createQuestionFeedbackSection(visualizationData);
        feedbackContainer.appendChild(questionFeedback);
        
        // Lernempfehlungen erstellen
        const learningRecommendations = _createLearningRecommendationsSection(visualizationData);
        feedbackContainer.appendChild(learningRecommendations);
        
        // Event-Listener für interaktive Elemente hinzufügen
        _attachFeedbackEventListeners(feedbackContainer, visualizationData);
    }
    
    /**
     * Erstellt den Abschnitt für allgemeines Feedback
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {HTMLElement} Das erstellte DOM-Element
     */
    function _createGeneralFeedbackSection(data) {
        const section = document.createElement('section');
        section.className = 'feedback-section general-feedback';
        
        // Feedback-Nachricht basierend auf dem Testergebnis generieren
        const feedback = data.feedback && data.feedback.general 
            ? data.feedback.general 
            : _generateGeneralFeedback(data.summary);
        
        // Abschnittsinhalt erstellen
        section.innerHTML = `
            <h3 class="section-title">
                <span class="title-icon">💡</span>
                Gesamtbewertung
            </h3>
            <div class="feedback-content">
                <p class="feedback-message">${feedback}</p>
            </div>
        `;
        
        return section;
    }
    
    /**
     * Generiert eine allgemeine Feedback-Nachricht basierend auf dem Testergebnis
     * @private
     * @param {Object} summary - Die Zusammenfassungsdaten
     * @returns {string} Die generierte Feedback-Nachricht
     */
    function _generateGeneralFeedback(summary) {
        const score = summary.percentageScore;
        let feedback = '';
        
        // Feedback je nach Ergebnis generieren
        if (score >= 90) {
            feedback = 'Hervorragende Leistung! Sie haben die Inhalte des Tests ausgezeichnet verstanden und angewendet.';
        } else if (score >= 80) {
            feedback = 'Sehr gute Leistung! Sie haben die meisten Konzepte gut verstanden und umgesetzt.';
        } else if (score >= 70) {
            feedback = 'Gute Leistung! Sie haben viele wichtige Konzepte verstanden, es gibt aber noch Raum für Verbesserungen.';
        } else if (score >= 60) {
            feedback = 'Zufriedenstellende Leistung. Sie haben die grundlegenden Konzepte erfasst, sollten aber die detaillierten Themen noch einmal durchgehen.';
        } else if (score >= 50) {
            feedback = 'Sie haben die Mindestanforderungen erfüllt, sollten aber das Material gründlicher studieren, um Ihr Verständnis zu verbessern.';
        } else {
            feedback = 'Sie haben die Anforderungen leider nicht erfüllt. Wir empfehlen, die Inhalte noch einmal gründlich durchzuarbeiten, bevor Sie den Test wiederholen.';
        }
        
        return feedback;
    }
    
    /**
     * Erstellt den Abschnitt für detailliertes Fragen-Feedback
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {HTMLElement} Das erstellte DOM-Element
     */
    function _createQuestionFeedbackSection(data) {
        const section = document.createElement('section');
        section.className = 'feedback-section question-feedback';
        
        // Überschrift erstellen
        section.innerHTML = `
            <h3 class="section-title">
                <span class="title-icon">📋</span>
                Detaillierte Fragenübersicht
                <button class="toggle-all-btn" data-action="expand">Alle anzeigen</button>
            </h3>
            <div class="feedback-content">
                <div class="questions-filter">
                    <button class="filter-btn active" data-filter="all">Alle Fragen</button>
                    <button class="filter-btn" data-filter="correct">Korrekt</button>
                    <button class="filter-btn" data-filter="incorrect">Inkorrekt</button>
                </div>
                <div class="questions-list"></div>
            </div>
        `;
        
        // Liste mit Fragen füllen
        const questionsList = section.querySelector('.questions-list');
        if (data.questionDetails && data.questionDetails.length > 0) {
            data.questionDetails.forEach((question, index) => {
                const questionElement = _createQuestionElement(question, index + 1);
                questionsList.appendChild(questionElement);
            });
        } else {
            questionsList.innerHTML = '<div class="no-data-message">Keine Fragendaten verfügbar</div>';
        }
        
        return section;
    }
    
    /**
     * Erstellt ein Element für eine einzelne Frage
     * @private
     * @param {Object} question - Die Fragendaten
     * @param {number} index - Der Index der Frage
     * @returns {HTMLElement} Das erstellte DOM-Element
     */
    function _createQuestionElement(question, index) {
        const questionItem = document.createElement('div');
        questionItem.className = `question-item ${question.isCorrect ? 'correct' : 'incorrect'}`;
        questionItem.dataset.questionId = question.id;
        
        // Basisinformationen zur Frage
        questionItem.innerHTML = `
            <div class="question-header">
                <div class="question-number">${index}</div>
                <div class="question-title">${question.text}</div>
                <div class="question-status ${question.isCorrect ? 'correct' : 'incorrect'}">
                    <span class="status-icon">${question.isCorrect ? '✓' : '✗'}</span>
                </div>
                <div class="question-points">
                    ${question.points.achieved} / ${question.points.max} Punkte
                </div>
                <button class="toggle-details-btn" aria-label="Details anzeigen"></button>
            </div>
            <div class="question-details" style="display: none;">
                <!-- Details werden dynamisch gefüllt -->
            </div>
        `;
        
        // Details zur Frage hinzufügen (unterschiedlich je nach Fragentyp)
        const detailsContainer = questionItem.querySelector('.question-details');
        
        // Grundlegende Informationen für alle Fragetypen
        let detailsHTML = `
            <div class="question-info">
                <div class="info-item">
                    <span class="info-label">Kategorie:</span>
                    <span class="info-value">${question.category}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Typ:</span>
                    <span class="info-value">${_getReadableQuestionType(question.type)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Zeit:</span>
                    <span class="info-value">${app.utils.formatTime(question.timeTaken)}</span>
                </div>
            </div>
        `;
        
        // Spezifische Antwortanzeige je nach Fragentyp
        detailsHTML += _createAnswerDisplayForType(question);
        
        // Erklärung (falls vorhanden)
        if (question.explanation) {
            detailsHTML += `
                <div class="question-explanation">
                    <h4>Erklärung:</h4>
                    <p>${question.explanation}</p>
                </div>
            `;
        }
        
        // Analysedaten (falls vorhanden)
        if (question.analysis) {
            detailsHTML += _createAnalysisDisplay(question.analysis);
        }
        
        detailsContainer.innerHTML = detailsHTML;
        
        return questionItem;
    }
    
    /**
     * Erstellt die Anzeige für Antworten je nach Fragentyp
     * @private
     * @param {Object} question - Die Fragendaten
     * @returns {string} HTML für die Antwortanzeige
     */
    function _createAnswerDisplayForType(question) {
        let answersHTML = '<div class="question-answers">';
        
        // Je nach Fragentyp unterschiedliche Anzeige generieren
        switch (question.type) {
            case 'multiple-choice':
                answersHTML += _createMultipleChoiceAnswerDisplay(question);
                break;
                
            case 'single-choice':
                answersHTML += _createSingleChoiceAnswerDisplay(question);
                break;
                
            case 'true-false':
                answersHTML += _createTrueFalseAnswerDisplay(question);
                break;
                
            case 'free-text':
                answersHTML += _createFreeTextAnswerDisplay(question);
                break;
                
            default:
                answersHTML += `
                    <div class="answer-info">
                        <p>Ihre Antwort: ${_formatUserAnswer(question.userAnswer)}</p>
                        <p>Korrekte Antwort: ${_formatCorrectAnswer(question.correctAnswer)}</p>
                    </div>
                `;
        }
        
        answersHTML += '</div>';
        return answersHTML;
    }
    
    /**
     * Erstellt die Anzeige für Multiple-Choice-Antworten
     * @private
     * @param {Object} question - Die Fragendaten
     * @returns {string} HTML für die Antwortanzeige
     */
    function _createMultipleChoiceAnswerDisplay(question) {
        let html = '<h4>Antwortoptionen:</h4><ul class="answer-options">';
        
        const userAnswers = Array.isArray(question.userAnswer) ? question.userAnswer : [];
        const correctAnswers = Array.isArray(question.correctAnswer) ? question.correctAnswer : [];
        
        // Wir gehen davon aus, dass die Antwortoptionen in question.options enthalten sind
        // Falls nicht, extrahieren wir sie aus den korrekten Antworten
        const options = question.options || _extractOptionsFromAnswers(userAnswers, correctAnswers);
        
        options.forEach(option => {
            const isUserSelected = userAnswers.includes(option.id || option.value || option);
            const isCorrectAnswer = correctAnswers.includes(option.id || option.value || option);
            
            // CSS-Klassen für Styling
            let optionClass = '';
            if (isUserSelected && isCorrectAnswer) {
                optionClass = 'correct-selected';
            } else if (isUserSelected && !isCorrectAnswer) {
                optionClass = 'incorrect-selected';
            } else if (!isUserSelected && isCorrectAnswer) {
                optionClass = 'correct-not-selected';
            }
            
            // Icon je nach Auswahl und Korrektheit
            let icon = '';
            if (isUserSelected && isCorrectAnswer) {
                icon = '<span class="option-icon correct">✓</span>';
            } else if (isUserSelected && !isCorrectAnswer) {
                icon = '<span class="option-icon incorrect">✗</span>';
            } else if (!isUserSelected && isCorrectAnswer) {
                icon = '<span class="option-icon missed">•</span>';
            }
            
            const optionText = option.text || option;
            
            html += `
                <li class="option-item ${optionClass}">
                    ${icon}
                    <span class="option-text">${optionText}</span>
                </li>
            `;
        });
        
        html += '</ul>';
        return html;
    }
    
    /**
     * Extrahiert Optionen aus Antwortdaten (Fallback)
     * @private
     * @param {Array} userAnswers - Die Benutzerantworten
     * @param {Array} correctAnswers - Die korrekten Antworten
     * @returns {Array} Extrahierte Optionen
     */
    function _extractOptionsFromAnswers(userAnswers, correctAnswers) {
        // Kombiniere beide Arrays und entferne Duplikate
        const combinedOptions = [...new Set([...userAnswers, ...correctAnswers])];
        return combinedOptions.map(option => {
            return typeof option === 'object' ? option : { id: option, text: option };
        });
    }
    
    /**
     * Erstellt die Anzeige für Single-Choice-Antworten
     * @private
     * @param {Object} question - Die Fragendaten
     * @returns {string} HTML für die Antwortanzeige
     */
    function _createSingleChoiceAnswerDisplay(question) {
        // Sehr ähnlich zur Multiple-Choice-Anzeige, aber mit nur einer Benutzerantwort
        const userAnswer = question.userAnswer;
        const correctAnswer = question.correctAnswer;
        
        // Für Single-Choice in Array umwandeln, um den Code wiederzuverwenden
        const userAnswers = [userAnswer].filter(Boolean);
        const correctAnswers = [correctAnswer].filter(Boolean);
        
        // Multiple-Choice-Anzeige wiederverwenden
        return _createMultipleChoiceAnswerDisplay({
            ...question,
            userAnswer: userAnswers,
            correctAnswer: correctAnswers
        });
    }
    
    /**
     * Erstellt die Anzeige für Wahr/Falsch-Antworten
     * @private
     * @param {Object} question - Die Fragendaten
     * @returns {string} HTML für die Antwortanzeige
     */
    function _createTrueFalseAnswerDisplay(question) {
        const userAnswer = typeof question.userAnswer === 'boolean' ? question.userAnswer : null;
        const correctAnswer = typeof question.correctAnswer === 'boolean' ? question.correctAnswer : null;
        
        let html = '<h4>Antwort:</h4><div class="true-false-display">';
        
        // Wahr-Option
        let trueClass = '';
        if (userAnswer === true && correctAnswer === true) {
            trueClass = 'correct-selected';
        } else if (userAnswer === true && correctAnswer === false) {
            trueClass = 'incorrect-selected';
        } else if (userAnswer !== true && correctAnswer === true) {
            trueClass = 'correct-not-selected';
        }
        
        // Falsch-Option
        let falseClass = '';
        if (userAnswer === false && correctAnswer === false) {
            falseClass = 'correct-selected';
        } else if (userAnswer === false && correctAnswer === true) {
            falseClass = 'incorrect-selected';
        } else if (userAnswer !== false && correctAnswer === false) {
            falseClass = 'correct-not-selected';
        }
        
        html += `
            <div class="tf-option ${trueClass}">
                <span class="tf-indicator">${userAnswer === true ? '✓' : ''}</span>
                <span class="tf-text">Wahr</span>
                ${correctAnswer === true ? '<span class="tf-correct">Korrekt</span>' : ''}
            </div>
            <div class="tf-option ${falseClass}">
                <span class="tf-indicator">${userAnswer === false ? '✓' : ''}</span>
                <span class="tf-text">Falsch</span>
                ${correctAnswer === false ? '<span class="tf-correct">Korrekt</span>' : ''}
            </div>
        `;
        
        html += '</div>';
        return html;
    }
    
    /**
     * Erstellt die Anzeige für Freitext-Antworten
     * @private
     * @param {Object} question - Die Fragendaten
     * @returns {string} HTML für die Antwortanzeige
     */
    function _createFreeTextAnswerDisplay(question) {
        const userAnswer = question.userAnswer || '';
        const correctAnswer = question.correctAnswer || '';
        
        let html = `
            <h4>Ihre Antwort:</h4>
            <div class="free-text-answer user-answer">
                <pre>${userAnswer}</pre>
            </div>
        `;
        
        // Bei Freitext-Fragen zeigen wir die "korrekte" Antwort nur an, wenn sie explizit angegeben ist
        // und sich von der Benutzerantwort unterscheidet
        if (correctAnswer && correctAnswer !== userAnswer) {
            html += `
                <h4>Musterantwort:</h4>
                <div class="free-text-answer correct-answer">
                    <pre>${correctAnswer}</pre>
                </div>
            `;
        }
        
        // Bewertungsdetails anzeigen, falls vorhanden
        if (question.evaluation) {
            html += `
                <div class="evaluation-details">
                    <h4>Bewertung:</h4>
                    <div class="evaluation-comment">${question.evaluation.comment || 'Keine Kommentare vorhanden.'}</div>
                    <div class="evaluation-score">Bewertung: ${question.points.achieved} von ${question.points.max} Punkten</div>
                </div>
            `;
        }
        
        return html;
    }
    
    /**
     * Erstellt die Anzeige für Analysedaten, falls vorhanden
     * @private
     * @param {Object} analysis - Die Analysedaten
     * @returns {string} HTML für die Analyseanzeige
     */
    function _createAnalysisDisplay(analysis) {
        // Wenn keine Analysedaten vorhanden sind, leeren String zurückgeben
        if (!analysis) return '';
        
        let html = '<div class="question-analysis">';
        
        // Wenn Schwierigkeitsdaten vorhanden sind
        if (analysis.difficulty) {
            html += `
                <div class="analysis-item">
                    <h4>Schwierigkeitsgrad:</h4>
                    <div class="difficulty-indicator">
                        <div class="difficulty-bar" style="width: ${analysis.difficulty * 100}%;"></div>
                        <div class="difficulty-label">${_formatDifficulty(analysis.difficulty)}</div>
                    </div>
                </div>
            `;
        }
        
        // Wenn Erfolgsdaten vorhanden sind
        if (analysis.successRate !== undefined) {
            html += `
                <div class="analysis-item">
                    <h4>Erfolgsrate:</h4>
                    <div class="success-indicator">
                        <div class="success-bar" style="width: ${analysis.successRate * 100}%;"></div>
                        <div class="success-label">${Math.round(analysis.successRate * 100)}% der Teilnehmer beantworten diese Frage korrekt</div>
                    </div>
                </div>
            `;
        }
        
        // Wenn Lernkategorisierungsdaten vorhanden sind
        if (analysis.learningTags && analysis.learningTags.length > 0) {
            html += '<div class="analysis-item"><h4>Lernkategorien:</h4><div class="tag-list">';
            
            analysis.learningTags.forEach(tag => {
                html += `<span class="learning-tag">${tag}</span>`;
            });
            
            html += '</div></div>';
        }
        
        html += '</div>';
        return html;
    }
    
    /**
     * Formatiert einen Schwierigkeitswert (zwischen 0 und 1) als lesbaren Text
     * @private
     * @param {number} difficulty - Der Schwierigkeitswert
     * @returns {string} Die formatierte Schwierigkeitsbeschreibung
     */
    function _formatDifficulty(difficulty) {
        if (difficulty < 0.2) return 'Sehr einfach';
        if (difficulty < 0.4) return 'Einfach';
        if (difficulty < 0.6) return 'Mittel';
        if (difficulty < 0.8) return 'Schwer';
        return 'Sehr schwer';
    }
    
    /**
     * Erstellt den Abschnitt für Lernempfehlungen
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {HTMLElement} Das erstellte DOM-Element
     */
    function _createLearningRecommendationsSection(data) {
        const section = document.createElement('section');
        section.className = 'feedback-section learning-recommendations';
        
        // Lernempfehlungen generieren
        const recommendations = _generateLearningRecommendations(data);
        
        // Abschnittsinhalt erstellen
        section.innerHTML = `
            <h3 class="section-title">
                <span class="title-icon">📚</span>
                Lernempfehlungen
            </h3>
            <div class="feedback-content">
                <p class="recommendation-intro">Basierend auf Ihren Ergebnissen empfehlen wir folgende Lernbereiche:</p>
                <ul class="recommendation-list">
                    ${recommendations.map(rec => `
                        <li class="recommendation-item">
                            <div class="recommendation-header">
                                <h4 class="recommendation-title">${rec.title}</h4>
                                <div class="recommendation-priority ${rec.priority}">${_formatPriority(rec.priority)}</div>
                            </div>
                            <p class="recommendation-description">${rec.description}</p>
                        </li>
                    `).join('')}
                </ul>
            </div>
        `;
        
        return section;
    }
    
    /**
     * Formatiert eine Priorität als lesbaren Text
     * @private
     * @param {string} priority - Die Priorität ('high', 'medium', 'low')
     * @returns {string} Die formatierte Prioritätsbeschreibung
     */
    function _formatPriority(priority) {
        const priorityMapping = {
            'high': 'Hohe Priorität',
            'medium': 'Mittlere Priorität',
            'low': 'Niedrige Priorität'
        };
        
        return priorityMapping[priority] || priority;
    }
    
    /**
     * Generiert Lernempfehlungen basierend auf den Testergebnissen
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {Array} Die generierten Lernempfehlungen
     */
    function _generateLearningRecommendations(data) {
        const recommendations = [];
        
        // Wenn bereits Empfehlungen in den Daten vorhanden sind, diese verwenden
        if (data.recommendations && data.recommendations.length > 0) {
            return data.recommendations;
        }
        
        // Sonst Empfehlungen basierend auf den Kategorien generieren
        if (data.categories && Object.keys(data.categories).length > 0) {
            // Kategorien nach Leistung sortieren (schlechteste zuerst)
            const sortedCategories = Object.entries(data.categories)
                .sort(([, a], [, b]) => a.percentage - b.percentage);
            
            // Empfehlungen für die schlechtesten Kategorien erstellen
            sortedCategories.forEach(([categoryName, category], index) => {
                // Nur Empfehlungen für die schlechtesten 3 Kategorien erstellen und nur, wenn unter 80%
                if (index < 3 && category.percentage < 80) {
                    let priority, description;
                    
                    // Priorität basierend auf Leistung bestimmen
                    if (category.percentage < 50) {
                        priority = 'high';
                        description = `Sie sollten sich intensiv mit den Inhalten im Bereich "${categoryName}" auseinandersetzen. Ihre Leistung zeigt, dass hier grundlegende Konzepte noch nicht ausreichend verstanden wurden.`;
                    } else if (category.percentage < 70) {
                        priority = 'medium';
                        description = `Sie haben ein grundlegendes Verständnis im Bereich "${categoryName}", sollten aber die wichtigsten Konzepte noch einmal wiederholen, um Ihr Wissen zu festigen.`;
                    } else {
                        priority = 'low';
                        description = `Im Bereich "${categoryName}" haben Sie bereits gute Kenntnisse. Eine gezielte Wiederholung bestimmter Aspekte kann Ihr Verständnis noch verbessern.`;
                    }
                    
                    recommendations.push({
                        title: `${categoryName} vertiefen`,
                        priority: priority,
                        description: description
                    });
                }
            });
        }
        
        // Fallback-Empfehlung, falls keine Kategorien mit schlechter Leistung gefunden wurden
        if (recommendations.length === 0) {
            recommendations.push({
                title: 'Allgemeine Wiederholung',
                priority: 'low',
                description: 'Ihre Leistung in diesem Test war insgesamt zufriedenstellend. Wir empfehlen eine allgemeine Wiederholung der Themenbereiche, um Ihr Wissen zu festigen und zu vertiefen.'
            });
        }
        
        return recommendations;
    }
    
    /**
     * Formatiert eine Benutzerantwort für die Anzeige
     * @private
     * @param {*} answer - Die Benutzerantwort
     * @returns {string} Die formatierte Antwort
     */
    function _formatUserAnswer(answer) {
        if (answer === undefined || answer === null) {
            return 'Keine Antwort';
        }
        
        if (Array.isArray(answer)) {
            if (answer.length === 0) return 'Keine Auswahl';
            return answer.join(', ');
        }
        
        if (typeof answer === 'boolean') {
            return answer ? 'Wahr' : 'Falsch';
        }
        
        return String(answer);
    }
    
    /**
     * Formatiert eine korrekte Antwort für die Anzeige
     * @private
     * @param {*} answer - Die korrekte Antwort
     * @returns {string} Die formatierte Antwort
     */
    function _formatCorrectAnswer(answer) {
        // Ähnlich wie _formatUserAnswer
        if (answer === undefined || answer === null) {
            return 'Keine Antwort definiert';
        }
        
        if (Array.isArray(answer)) {
            if (answer.length === 0) return 'Keine Auswahl';
            return answer.join(', ');
        }
        
        if (typeof answer === 'boolean') {
            return answer ? 'Wahr' : 'Falsch';
        }
        
        return String(answer);
    }
    
    /**
     * Konvertiert einen technischen Fragentyp in einen lesbaren Namen
     * @private
     * @param {string} type - Technischer Fragentyp
     * @returns {string} Lesbarer Fragentyp
     */
    function _getReadableQuestionType(type) {
        const typeMapping = {
            'multiple-choice': 'Multiple Choice',
            'single-choice': 'Single Choice',
            'true-false': 'Wahr/Falsch',
            'free-text': 'Freitext'
        };
        
        return typeMapping[type] || type;
    }
    
    /**
     * Fügt Event-Listener für interaktive Elemente im Feedback-Bereich hinzu
     * @private
     * @param {HTMLElement} container - Der Container mit den interaktiven Elementen
     * @param {Object} data - Die Visualisierungsdaten
     */
    function _attachFeedbackEventListeners(container, data) {
        // Event-Listener für "Alle anzeigen/ausblenden"
        const toggleAllBtn = container.querySelector('.toggle-all-btn');
        if (toggleAllBtn) {
            toggleAllBtn.addEventListener('click', function() {
                const questionDetails = container.querySelectorAll('.question-details');
                const action = this.dataset.action;
                
                questionDetails.forEach(detail => {
                    detail.style.display = action === 'expand' ? 'block' : 'none';
                });
                
                // Button-Text und Action aktualisieren
                this.textContent = action === 'expand' ? 'Alle ausblenden' : 'Alle anzeigen';
                this.dataset.action = action === 'expand' ? 'collapse' : 'expand';
            });
        }
        
        // Event-Listener für Fragenfilterung
        const filterButtons = container.querySelectorAll('.filter-btn');
        if (filterButtons.length > 0) {
            filterButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Aktiven Button aktualisieren
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    const filter = this.dataset.filter;
                    const questionItems = container.querySelectorAll('.question-item');
                    
                    // Fragen nach Filter ein-/ausblenden
                    questionItems.forEach(item => {
                        if (filter === 'all' ||
                            (filter === 'correct' && item.classList.contains('correct')) ||
                            (filter === 'incorrect' && item.classList.contains('incorrect'))) {
                            item.style.display = 'block';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                });
            });
        }
        
        // Event-Listener für einzelne Fragen-Toggles
        const toggleButtons = container.querySelectorAll('.toggle-details-btn');
        if (toggleButtons.length > 0) {
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const detailsContainer = this.closest('.question-item').querySelector('.question-details');
                    const isVisible = detailsContainer.style.display === 'block';
                    
                    detailsContainer.style.display = isVisible ? 'none' : 'block';
                    this.setAttribute('aria-label', isVisible ? 'Details anzeigen' : 'Details ausblenden');
                    this.classList.toggle('expanded', !isVisible);
                });
            });
        }
    }
    
    // Die Funktionen dem resultVisualization-Modul hinzufügen
    app.modules.resultVisualization._createDetailedQuestionDisplay = _createDetailedQuestionDisplay;
    
    // Die showVisualization-Funktion erweitern
    const originalShowVisualization = app.modules.resultVisualization.showVisualization;
    app.modules.resultVisualization.showVisualization = function(visualizationData) {
        // Zuerst die bisher implementierten Funktionen aufrufen
        originalShowVisualization(visualizationData);
        
        // Dann die detaillierte Fragendarstellung hinzufügen
        this._createDetailedQuestionDisplay(visualizationData);
    };
    
})();
/**
 * @fileoverview JS-Block 6.5.1-part1d - Ergebnisvisualisierung (Export, Teilen und Integration)
 * Dieser Code implementiert erweiterte Funktionen für Export, Teilen und Integration
 * der Testergebnisse mit anderen Systemkomponenten.
 * 
 * @module modules/resultVisualization
 * @requires modules/testEvaluation
 * @requires modules/dataProcessing
 * @requires utils/uiHelpers
 */

// Erweiterung des Ergebnisvisualisierungs-Moduls
(function() {
    // Private Hilfsfunktionen für Export und Teilen
    
    /**
     * Erweiterte Funktion zum Teilen von Testergebnissen
     * @param {Object} visualizationData - Die Visualisierungsdaten
     */
    function _shareResults(visualizationData) {
        console.log('Teile Testergebnisse...');
        
        // Modal für Teilen-Optionen erstellen
        const modalHTML = `
            <div class="modal share-modal">
                <div class="modal-overlay"></div>
                <div class="modal-container">
                    <div class="modal-header">
                        <h3>Testergebnis teilen</h3>
                        <button class="modal-close-btn">&times;</button>
                    </div>
                    <div class="modal-content">
                        <p>Wählen Sie, wie Sie Ihr Testergebnis teilen möchten:</p>
                        
                        <div class="share-options">
                            <div class="share-option">
                                <button class="share-btn share-email">
                                    <span class="share-icon">📧</span>
                                    <span class="share-label">Per E-Mail</span>
                                </button>
                            </div>
                            <div class="share-option">
                                <button class="share-btn share-link">
                                    <span class="share-icon">🔗</span>
                                    <span class="share-label">Link kopieren</span>
                                </button>
                            </div>
                            <div class="share-option">
                                <button class="share-btn share-print">
                                    <span class="share-icon">🖨️</span>
                                    <span class="share-label">Drucken</span>
                                </button>
                            </div>
                        </div>
                        
                        <div class="share-settings">
                            <h4>Freigabeeinstellungen</h4>
                            <div class="setting-group">
                                <label class="setting-label">
                                    <input type="checkbox" class="setting-input" id="share-details" checked>
                                    Detaillierte Fragenergebnisse einschließen
                                </label>
                            </div>
                            <div class="setting-group">
                                <label class="setting-label">
                                    <input type="checkbox" class="setting-input" id="share-feedback" checked>
                                    Feedback und Empfehlungen einschließen
                                </label>
                            </div>
                            <div class="setting-group">
                                <label class="setting-label">
                                    <input type="checkbox" class="setting-input" id="share-comparison">
                                    Vergleich mit anderen Teilnehmern einschließen
                                </label>
                            </div>
                        </div>
                        
                        <div class="share-recipients" style="display: none;">
                            <h4>E-Mail-Empfänger</h4>
                            <div class="input-group">
                                <input type="email" class="recipient-input" placeholder="E-Mail-Adresse eingeben">
                                <button class="add-recipient-btn">Hinzufügen</button>
                            </div>
                            <div class="recipients-list"></div>
                        </div>
                        
                        <div class="share-link-container" style="display: none;">
                            <h4>Link zum Teilen</h4>
                            <div class="input-group">
                                <input type="text" class="share-link-input" readonly>
                                <button class="copy-link-btn">Kopieren</button>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary modal-cancel-btn">Abbrechen</button>
                        <button class="btn btn-primary modal-share-btn">Teilen</button>
                    </div>
                </div>
            </div>
        `;
        
        // Modal zum DOM hinzufügen
        const modalContainer = document.createElement('div');
        modalContainer.innerHTML = modalHTML;
        document.body.appendChild(modalContainer.firstElementChild);
        
        const modal = document.querySelector('.share-modal');
        
        // Event-Listener für die Teilen-Optionen
        _attachShareModalListeners(modal, visualizationData);
    }
    
    /**
     * Fügt Event-Listener zum Teilen-Modal hinzu
     * @private
     * @param {HTMLElement} modal - Das Modal-Element
     * @param {Object} data - Die Visualisierungsdaten
     */
    function _attachShareModalListeners(modal, data) {
        if (!modal) return;
        
        // Modal schließen
        const closeBtn = modal.querySelector('.modal-close-btn');
        const cancelBtn = modal.querySelector('.modal-cancel-btn');
        const overlay = modal.querySelector('.modal-overlay');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                modal.remove();
            });
        }
        
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                modal.remove();
            });
        }
        
        if (overlay) {
            overlay.addEventListener('click', () => {
                modal.remove();
            });
        }
        
        // Teilen-Optionen
        const emailBtn = modal.querySelector('.share-email');
        const linkBtn = modal.querySelector('.share-link');
        const printBtn = modal.querySelector('.share-print');
        
        if (emailBtn) {
            emailBtn.addEventListener('click', () => {
                // E-Mail-Bereich anzeigen
                const recipientsSection = modal.querySelector('.share-recipients');
                const linkSection = modal.querySelector('.share-link-container');
                
                if (recipientsSection) recipientsSection.style.display = 'block';
                if (linkSection) linkSection.style.display = 'none';
                
                // Aktiven Button markieren
                modal.querySelectorAll('.share-btn').forEach(btn => btn.classList.remove('active'));
                emailBtn.classList.add('active');
            });
        }
        
        if (linkBtn) {
            linkBtn.addEventListener('click', () => {
                // Link-Bereich anzeigen
                const recipientsSection = modal.querySelector('.share-recipients');
                const linkSection = modal.querySelector('.share-link-container');
                
                if (recipientsSection) recipientsSection.style.display = 'none';
                if (linkSection) linkSection.style.display = 'block';
                
                // Link generieren
                const shareLink = _generateShareLink(data);
                const linkInput = modal.querySelector('.share-link-input');
                if (linkInput) linkInput.value = shareLink;
                
                // Aktiven Button markieren
                modal.querySelectorAll('.share-btn').forEach(btn => btn.classList.remove('active'));
                linkBtn.classList.add('active');
            });
        }
        
        if (printBtn) {
            printBtn.addEventListener('click', () => {
                // Modal schließen und Druck starten
                modal.remove();
                _printResults(data);
                
                // Aktiven Button markieren
                modal.querySelectorAll('.share-btn').forEach(btn => btn.classList.remove('active'));
                printBtn.classList.add('active');
            });
        }
        
        // Link kopieren
        const copyLinkBtn = modal.querySelector('.copy-link-btn');
        if (copyLinkBtn) {
            copyLinkBtn.addEventListener('click', () => {
                const linkInput = modal.querySelector('.share-link-input');
                if (linkInput) {
                    linkInput.select();
                    document.execCommand('copy');
                    
                    // Feedback anzeigen
                    copyLinkBtn.textContent = 'Kopiert!';
                    setTimeout(() => {
                        copyLinkBtn.textContent = 'Kopieren';
                    }, 2000);
                }
            });
        }
        
        // E-Mail-Empfänger hinzufügen
        const addRecipientBtn = modal.querySelector('.add-recipient-btn');
        if (addRecipientBtn) {
            addRecipientBtn.addEventListener('click', () => {
                const recipientInput = modal.querySelector('.recipient-input');
                const recipientsList = modal.querySelector('.recipients-list');
                
                if (recipientInput && recipientsList) {
                    const email = recipientInput.value.trim();
                    if (email && _validateEmail(email)) {
                        const recipientElement = document.createElement('div');
                        recipientElement.className = 'recipient-item';
                        recipientElement.innerHTML = `
                            <span class="recipient-email">${email}</span>
                            <button class="remove-recipient-btn">&times;</button>
                        `;
                        
                        recipientsList.appendChild(recipientElement);
                        recipientInput.value = '';
                        
                        // Event-Listener zum Entfernen
                        const removeBtn = recipientElement.querySelector('.remove-recipient-btn');
                        if (removeBtn) {
                            removeBtn.addEventListener('click', () => {
                                recipientElement.remove();
                            });
                        }
                    } else {
                        // Fehler anzeigen
                        recipientInput.classList.add('error');
                        setTimeout(() => {
                            recipientInput.classList.remove('error');
                        }, 2000);
                    }
                }
            });
        }
        
        // Teilen-Button (E-Mail senden)
        const shareBtn = modal.querySelector('.modal-share-btn');
        if (shareBtn) {
            shareBtn.addEventListener('click', () => {
                // Aktuelle Teilen-Option ermitteln
                const activeOption = modal.querySelector('.share-btn.active');
                
                if (activeOption && activeOption.classList.contains('share-email')) {
                    // E-Mail senden
                    const recipients = Array.from(modal.querySelectorAll('.recipient-email'))
                        .map(el => el.textContent);
                        
                    if (recipients.length > 0) {
                        const includeDetails = modal.querySelector('#share-details').checked;
                        const includeFeedback = modal.querySelector('#share-feedback').checked;
                        const includeComparison = modal.querySelector('#share-comparison').checked;
                        
                        _sendResultsViaEmail(data, recipients, {
                            includeDetails,
                            includeFeedback,
                            includeComparison
                        });
                        
                        // Erfolgsmeldung anzeigen
                        alert('Die Ergebnisse wurden erfolgreich geteilt!');
                        modal.remove();
                    } else {
                        alert('Bitte fügen Sie mindestens einen Empfänger hinzu.');
                    }
                } else if (activeOption && activeOption.classList.contains('share-link')) {
                    // Link wurde bereits generiert und kann kopiert werden
                    const copyLinkBtn = modal.querySelector('.copy-link-btn');
                    if (copyLinkBtn) {
                        copyLinkBtn.click();
                    }
                } else {
                    // Standard: Drucken
                    modal.remove();
                    _printResults(data);
                }
            });
        }
    }
    
    /**
     * Validiert eine E-Mail-Adresse
     * @private
     * @param {string} email - Die zu validierende E-Mail-Adresse
     * @returns {boolean} true, wenn die E-Mail-Adresse gültig ist
     */
    function _validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }
    
    /**
     * Generiert einen Link zum Teilen der Ergebnisse
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {string} Der generierte Link
     */
    function _generateShareLink(data) {
        // In einer realen Implementierung würde hier ein eindeutiger Link generiert werden
        // In diesem Beispiel simulieren wir das mit einer einfachen ID
        
        // Kurze ID aus Testname und Zeitstempel generieren
        const testId = data.testInfo.id;
        const timestamp = data.testInfo.timestamp;
        const shortId = `${testId.substring(0, 8)}-${new Date(timestamp).getTime().toString(36)}`;
        
        // Basis-URL (in realer Implementierung anpassen)
        const baseUrl = window.location.origin + window.location.pathname;
        
        // Teilen-Link erstellen
        return `${baseUrl}?share=${shortId}`;
    }
    
    /**
     * Sendet die Testergebnisse per E-Mail
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @param {Array<string>} recipients - Die Empfänger-E-Mail-Adressen
     * @param {Object} options - Optionen für den E-Mail-Inhalt
     */
    function _sendResultsViaEmail(data, recipients, options) {
        console.log('Sende Ergebnisse per E-Mail an:', recipients);
        console.log('Mit Optionen:', options);
        
        // In einer realen Implementierung würde hier eine API aufgerufen werden
        // In diesem Beispiel simulieren wir den Erfolg
        
        // Für Demonstrationszwecke: Anzeige der zu sendenden Daten
        console.log('E-Mail-Daten:', {
            subject: `Testergebnis: ${data.testInfo.title}`,
            testInfo: data.testInfo,
            summary: data.summary,
            detailedResults: options.includeDetails ? data.questionDetails : null,
            feedback: options.includeFeedback ? data.feedback : null,
            comparison: options.includeComparison ? data.comparisons : null
        });
        
        // Erfolgsnachricht im Konsolen-Log
        console.log('E-Mail wurde simuliert. In einer realen Implementierung würde hier eine E-Mail gesendet werden.');
    }
    
    /**
     * Erweiterte Funktion zum Drucken von Testergebnissen
     * @param {Object} visualizationData - Die Visualisierungsdaten
     */
    function _printResults(visualizationData) {
        console.log('Drucke Testergebnisse...');
        
        // Druckoptimierte Version der Ergebnisse erstellen
        const printContent = _createPrintableContent(visualizationData);
        
        // Neues Fenster für den Druck öffnen
        const printWindow = window.open('', '_blank', 'width=800,height=600');
        
        if (printWindow) {
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Testergebnis: ${visualizationData.testInfo.title}</title>
                    <style>
                        ${_getPrintStyles()}
                    </style>
                </head>
                <body>
                    ${printContent}
                    <script>
                        window.onload = function() {
                            window.print();
                            // Optional: Nach dem Drucken schließen
                            // window.close();
                        }
                    </script>
                </body>
                </html>
            `);
            
            printWindow.document.close();
        } else {
            // Fallback, wenn kein neues Fenster geöffnet werden kann
            alert('Bitte erlauben Sie Pop-ups, um die Druckansicht zu öffnen.');
            
            // Direkter Druck (weniger kontrollierbar)
            window.print();
        }
    }
    
    /**
     * Erstellt druckoptimierte Inhalte für die Testergebnisse
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {string} HTML-Inhalt für die Druckansicht
     */
    function _createPrintableContent(data) {
        const testDate = new Date(data.testInfo.timestamp).toLocaleDateString('de-DE', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        // Überschrift und Metadaten
        let content = `
            <div class="print-header">
                <h1 class="print-title">Testergebnis: ${data.testInfo.title}</h1>
                <div class="print-meta">
                    <div class="meta-item">
                        <span class="meta-label">Datum:</span>
                        <span class="meta-value">${testDate}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Test-ID:</span>
                        <span class="meta-value">${data.testInfo.id}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Dauer:</span>
                        <span class="meta-value">${app.utils.formatTime(data.testInfo.duration)}</span>
                    </div>
                </div>
            </div>
        `;
        
        // Zusammenfassung
        content += `
            <div class="print-summary">
                <h2>Zusammenfassung</h2>
                <div class="summary-content">
                    <div class="summary-result ${data.summary.passed ? 'passed' : 'failed'}">
                        <div class="result-label">${data.summary.passed ? 'Bestanden' : 'Nicht bestanden'}</div>
                        <div class="result-score">${Math.round(data.summary.percentageScore)}%</div>
                    </div>
                    <div class="summary-details">
                        <div class="detail-item">
                            <span class="detail-label">Erreichte Punkte:</span>
                            <span class="detail-value">${data.summary.achievedPoints} von ${data.summary.totalPoints}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Note:</span>
                            <span class="detail-value">${data.summary.grade}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Zeit:</span>
                            <span class="detail-value">${app.utils.formatTime(data.summary.timeSpent)}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Kategorieübersicht
        if (data.categories && Object.keys(data.categories).length > 0) {
            content += `
                <div class="print-categories">
                    <h2>Leistung nach Kategorien</h2>
                    <table class="categories-table">
                        <thead>
                            <tr>
                                <th>Kategorie</th>
                                <th>Punkte</th>
                                <th>Prozent</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            for (const [categoryName, category] of Object.entries(data.categories)) {
                const statusClass = category.percentage < 50 ? 'danger' : (category.percentage < 75 ? 'warning' : 'success');
                const statusText = category.percentage < 50 ? 'Unzureichend' : (category.percentage < 75 ? 'Verbesserungswürdig' : 'Gut');
                
                content += `
                    <tr>
                        <td>${categoryName}</td>
                        <td>${category.achieved} / ${category.total}</td>
                        <td>${Math.round(category.percentage)}%</td>
                        <td class="status ${statusClass}">${statusText}</td>
                    </tr>
                `;
            }
            
            content += `
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        // Detaillierte Fragenübersicht
        if (data.questionDetails && data.questionDetails.length > 0) {
            content += `
                <div class="print-questions">
                    <h2>Detaillierte Fragenübersicht</h2>
                    <table class="questions-table">
                        <thead>
                            <tr>
                                <th>Nr.</th>
                                <th>Frage</th>
                                <th>Typ</th>
                                <th>Punkte</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            data.questionDetails.forEach((question, index) => {
                const questionType = _getReadableQuestionType(question.type);
                const statusClass = question.isCorrect ? 'success' : 'danger';
                const statusText = question.isCorrect ? 'Korrekt' : 'Inkorrekt';
                
                content += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${question.text}</td>
                        <td>${questionType}</td>
                        <td>${question.points.achieved} / ${question.points.max}</td>
                        <td class="status ${statusClass}">${statusText}</td>
                    </tr>
                `;
            });
            
            content += `
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        // Feedback und Empfehlungen
        if (data.feedback || (data.recommendations && data.recommendations.length > 0)) {
            content += `
                <div class="print-feedback">
                    <h2>Feedback und Empfehlungen</h2>
            `;
            
            if (data.feedback && data.feedback.general) {
                content += `
                    <div class="feedback-general">
                        <h3>Allgemeines Feedback</h3>
                        <p>${data.feedback.general}</p>
                    </div>
                `;
            }
            
            // Lernempfehlungen
            const recommendations = data.recommendations || _generateLearningRecommendations(data);
            if (recommendations && recommendations.length > 0) {
                content += `
                    <div class="learning-recommendations">
                        <h3>Lernempfehlungen</h3>
                        <ul class="recommendations-list">
                `;
                
                recommendations.forEach(rec => {
                    content += `
                        <li class="recommendation-item priority-${rec.priority}">
                            <div class="recommendation-title">${rec.title}</div>
                            <div class="recommendation-description">${rec.description}</div>
                        </li>
                    `;
                });
                
                content += `
                        </ul>
                    </div>
                `;
            }
            
            content += `
                </div>
            `;
        }
        
        // Fußzeile mit Datum und Copyright
        content += `
            <div class="print-footer">
                <div class="footer-date">Erstellt am ${new Date().toLocaleDateString('de-DE')}</div>
                <div class="footer-copyright">© ${new Date().getFullYear()} ImmoScout24 E-Learning</div>
            </div>
        `;
        
        return content;
    }
    
    /**
     * Liefert CSS-Stile für die Druckansicht
     * @private
     * @returns {string} CSS-Stile
     */
    function _getPrintStyles() {
        return `
            /* Basis-Stile */
            body {
                font-family: Arial, sans-serif;
                line-height: 1.5;
                color: #333;
                padding: 20px;
                margin: 0;
            }
            
            h1, h2, h3 {
                color: #333;
                margin-top: 1em;
                margin-bottom: 0.5em;
            }
            
            table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 1em;
            }
            
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            
            th {
                background-color: #f2f2f2;
            }
            
            /* Header-Stile */
            .print-header {
                border-bottom: 2px solid #00FFD0;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }
            
            .print-title {
                font-size: 24px;
                color: #333;
                margin: 0 0 10px 0;
            }
            
            .print-meta {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                font-size: 14px;
            }
            
            .meta-item {
                display: flex;
            }
            
            .meta-label {
                font-weight: bold;
                margin-right: 5px;
            }
            
            /* Zusammenfassungs-Stile */
            .print-summary {
                margin-bottom: 30px;
            }
            
            .summary-content {
                display: flex;
                align-items: center;
                gap: 30px;
                border: 1px solid #ddd;
                padding: 15px;
                border-radius: 5px;
            }
            
            .summary-result {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                width: 120px;
                height: 120px;
                border-radius: 50%;
                color: white;
                text-align: center;
            }
            
            .summary-result.passed {
                background-color: #00FFD0;
            }
            
            .summary-result.failed {
                background-color: #ff6b6b;
            }
            
            .result-label {
                font-size: 16px;
                font-weight: bold;
            }
            
            .result-score {
                font-size: 32px;
                font-weight: bold;
            }
            
            .summary-details {
                flex-grow: 1;
            }
            
            .detail-item {
                margin-bottom: 5px;
            }
            
            .detail-label {
                font-weight: bold;
                margin-right: 5px;
            }
            
            /* Tabellen-Stile */
            .categories-table, .questions-table {
                width: 100%;
                border-collapse: collapse;
            }
            
            .status {
                font-weight: bold;
            }
            
            .status.success {
                color: #28a745;
            }
            
            .status.warning {
                color: #ffc107;
            }
            
            .status.danger {
                color: #dc3545;
            }
            
            /* Feedback-Stile */
            .print-feedback {
                margin-top: 30px;
            }
            
            .recommendations-list {
                list-style-type: none;
                padding: 0;
            }
            
            .recommendation-item {
                margin-bottom: 15px;
                padding: 10px;
                border-left: 4px solid #ccc;
                background-color: #f9f9f9;
            }
            
            .recommendation-item.priority-high {
                border-left-color: #dc3545;
            }
            
            .recommendation-item.priority-medium {
                border-left-color: #ffc107;
            }
            
            .recommendation-item.priority-low {
                border-left-color: #28a745;
            }
            
            .recommendation-title {
                font-weight: bold;
                margin-bottom: 5px;
            }
            
            /* Fußzeile */
            .print-footer {
                margin-top: 30px;
                padding-top: 10px;
                border-top: 1px solid #ddd;
                display: flex;
                justify-content: space-between;
                font-size: 12px;
                color: #777;
            }
            
            /* Seitenumbrüche */
            @media print {
                .print-categories, .print-questions, .print-feedback {
                    page-break-inside: avoid;
                }
                
                h2 {
                    page-break-after: avoid;
                }
                
                h2, h3 {
                    page-break-after: avoid;
                }
                
                tr {
                    page-break-inside: avoid;
                }
            }
        `;
    }
    
    /**
     * Erweiterte Funktion zum Exportieren von Testergebnissen
     * @param {Object} visualizationData - Die Visualisierungsdaten
     * @param {string} format - Das gewünschte Exportformat ('json', 'csv', 'pdf')
     */
    function _exportResults(visualizationData, format = 'json') {
        console.log(`Exportiere Testergebnisse als ${format}...`);
        
        let exportedData;
        let fileName;
        let mimeType;
        
        // Basis-Dateiname generieren
        const testId = visualizationData.testInfo.id.substring(0, 8);
        const dateStr = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        const baseFileName = `testergebnis-${testId}-${dateStr}`;
        
        switch (format) {
            case 'json':
                // JSON-Export
                exportedData = JSON.stringify(_prepareDataForExport(visualizationData), null, 2);
                fileName = `${baseFileName}.json`;
                mimeType = 'application/json';
                break;
                
            case 'csv':
                // CSV-Export (vereinfacht)
                exportedData = _convertToCSV(visualizationData);
                fileName = `${baseFileName}.csv`;
                mimeType = 'text/csv';
                break;
                
            case 'pdf':
                // PDF-Export simulieren (nur Meldung, da PDF-Generierung komplex ist)
                alert('PDF-Export wird in einer zukünftigen Version implementiert.');
                return;
                
            default:
                alert(`Unbekanntes Exportformat: ${format}`);
                return;
        }
        
        // Download initiieren
        _downloadFile(exportedData, fileName, mimeType);
    }
    
    /**
     * Bereitet Daten für den Export vor
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {Object} Für den Export aufbereitete Daten
     */
    function _prepareDataForExport(data) {
        // Kopie der Daten erstellen und anpassen
        const exportData = {
            testInfo: data.testInfo,
            summary: data.summary,
            categories: data.categories,
            questions: data.questionDetails.map(q => ({
                id: q.id,
                text: q.text,
                type: q.type,
                category: q.category,
                isCorrect: q.isCorrect,
                achievedPoints: q.points.achieved,
                maxPoints: q.points.max,
                percentageScore: q.points.percentage,
                timeTaken: q.timeTaken
            }))
        };
        
        // Metadaten hinzufügen
        exportData.metadata = {
            exportDate: new Date().toISOString(),
            version: '1.0.0',
            source: 'ImmoScout24 E-Learning'
        };
        
        return exportData;
    }
    
    /**
     * Konvertiert die Testergebnisse in CSV-Format
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {string} CSV-formatierte Daten
     */
    function _convertToCSV(data) {
        // Grundlegende Informationen
        let csv = `"Test","${data.testInfo.title}"\n`;
        csv += `"Datum","${new Date(data.testInfo.timestamp).toLocaleString('de-DE')}"\n`;
        csv += `"Ergebnis","${Math.round(data.summary.percentageScore)}%"\n`;
        csv += `"Status","${data.summary.passed ? 'Bestanden' : 'Nicht bestanden'}"\n`;
        csv += `"Note","${data.summary.grade}"\n\n`;
        
        // Kategorien
        if (data.categories && Object.keys(data.categories).length > 0) {
            csv += '"Kategorie","Punkte","Maximal","Prozent"\n';
            
            for (const [categoryName, category] of Object.entries(data.categories)) {
                csv += `"${categoryName}","${category.achieved}","${category.total}","${Math.round(category.percentage)}%"\n`;
            }
            
            csv += '\n';
        }
        
        // Fragen
        if (data.questionDetails && data.questionDetails.length > 0) {
            csv += '"Nr.","Frage","Typ","Punkte","Maximal","Status","Zeit (s)"\n';
            
            data.questionDetails.forEach((question, index) => {
                const questionText = question.text.replace(/"/g, '""'); // Anführungszeichen escapen
                const questionType = _getReadableQuestionType(question.type);
                const status = question.isCorrect ? 'Korrekt' : 'Inkorrekt';
                const timeTaken = Math.round(question.timeTaken);
                
                csv += `"${index + 1}","${questionText}","${questionType}","${question.points.achieved}","${question.points.max}","${status}","${timeTaken}"\n`;
            });
        }
        
        return csv;
    }
    
    /**
     * Initiiert den Download einer Datei
     * @private
     * @param {string} content - Der Dateiinhalt
     * @param {string} fileName - Der Dateiname
     * @param {string} mimeType - Der MIME-Typ der Datei
     */
    function _downloadFile(content, fileName, mimeType) {
        // Blob erstellen
        const blob = new Blob([content], { type: mimeType });
        
        // Download-Link erstellen
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.style.display = 'none';
        
        // Link zum DOM hinzufügen und klicken
        document.body.appendChild(a);
        a.click();
        
        // Aufräumen
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }
    
    /**
     * Konvertiert einen technischen Fragentyp in einen lesbaren Namen
     * @private
     * @param {string} type - Technischer Fragentyp
     * @returns {string} Lesbarer Fragentyp
     */
    function _getReadableQuestionType(type) {
        const typeMapping = {
            'multiple-choice': 'Multiple Choice',
            'single-choice': 'Single Choice',
            'true-false': 'Wahr/Falsch',
            'free-text': 'Freitext'
        };
        
        return typeMapping[type] || type;
    }
    
    /**
     * Generiert Lernempfehlungen basierend auf den Testergebnissen
     * @private
     * @param {Object} data - Die Visualisierungsdaten
     * @returns {Array} Die generierten Lernempfehlungen
     */
    function _generateLearningRecommendations(data) {
        // Implementierung aus dem vorherigen Code wiederverwendet
        const recommendations = [];
        
        if (data.categories && Object.keys(data.categories).length > 0) {
            const sortedCategories = Object.entries(data.categories)
                .sort(([, a], [, b]) => a.percentage - b.percentage);
            
            sortedCategories.forEach(([categoryName, category], index) => {
                if (index < 3 && category.percentage < 80) {
                    let priority, description;
                    
                    if (category.percentage < 50) {
                        priority = 'high';
                        description = `Sie sollten sich intensiv mit den Inhalten im Bereich "${categoryName}" auseinandersetzen. Ihre Leistung zeigt, dass hier grundlegende Konzepte noch nicht ausreichend verstanden wurden.`;
                    } else if (category.percentage < 70) {
                        priority = 'medium';
                        description = `Sie haben ein grundlegendes Verständnis im Bereich "${categoryName}", sollten aber die wichtigsten Konzepte noch einmal wiederholen, um Ihr Wissen zu festigen.`;
                    } else {
                        priority = 'low';
                        description = `Im Bereich "${categoryName}" haben Sie bereits gute Kenntnisse. Eine gezielte Wiederholung bestimmter Aspekte kann Ihr Verständnis noch verbessern.`;
                    }
                    
                    recommendations.push({
                        title: `${categoryName} vertiefen`,
                        priority: priority,
                        description: description
                    });
                }
            });
        }
        
        if (recommendations.length === 0) {
            recommendations.push({
                title: 'Allgemeine Wiederholung',
                priority: 'low',
                description: 'Ihre Leistung in diesem Test war insgesamt zufriedenstellend. Wir empfehlen eine allgemeine Wiederholung der Themenbereiche, um Ihr Wissen zu festigen und zu vertiefen.'
            });
        }
        
        return recommendations;
    }
    
    /**
     * Integriert die Ergebnisvisualisierung mit anderen Modulen des Systems
     * @param {Object} visualizationData - Die Visualisierungsdaten
     */
    function _integrateWithOtherModules(visualizationData) {
        console.log('Integriere Ergebnisvisualisierung mit anderen Modulen...');
        
        // Event auslösen, damit andere Module auf die Ergebnisse reagieren können
        const resultEvent = new CustomEvent('resultVisualizationComplete', {
            detail: {
                testResult: visualizationData
            }
        });
        
        document.dispatchEvent(resultEvent);
        
        // Integration mit Benutzer-Profil (falls vorhanden)
        if (app.modules.userProfile && typeof app.modules.userProfile.updateTestHistory === 'function') {
            const testHistoryEntry = {
                testId: visualizationData.testInfo.id,
                testTitle: visualizationData.testInfo.title,
                timestamp: visualizationData.testInfo.timestamp,
                score: visualizationData.summary.percentageScore,
                passed: visualizationData.summary.passed,
                grade: visualizationData.summary.grade
            };
            
            app.modules.userProfile.updateTestHistory(testHistoryEntry);
        }
        
        // Integration mit Badges/Erfolgen (falls vorhanden)
        if (app.modules.achievements && typeof app.modules.achievements.checkForNewAchievements === 'function') {
            app.modules.achievements.checkForNewAchievements('test_completion', {
                testResult: visualizationData
            });
        }
        
        // Integration mit Teamleiter-Dashboard (falls vorhanden und Benutzer ist Teamleiter)
        if (app.modules.teamLeaderDashboard && 
            app.utils.hasRole('teamleader') && 
            typeof app.modules.teamLeaderDashboard.refreshTeamPerformance === 'function') {
            app.modules.teamLeaderDashboard.refreshTeamPerformance();
        }
    }
    
    // Die Funktionen dem resultVisualization-Modul hinzufügen
    Object.assign(app.modules.resultVisualization, {
        _exportResults: _exportResults,
        _printResults: _printResults,
        _shareResults: _shareResults,
        _integrateWithOtherModules: _integrateWithOtherModules
    });
    
    // Die öffentlichen Funktionen überschreiben
    app.modules.resultVisualization.shareResults = function(format) {
        // Wenn keine Visualisierungsdaten vorhanden sind, nichts tun
        if (!this._currentTestResult) {
            console.error('Keine Testergebnisse zum Teilen vorhanden');
            return;
        }
        
        // Daten für die Visualisierung vorbereiten (falls noch nicht geschehen)
        const visualizationData = this.prepareDataForVisualization(this._currentTestResult);
        
        // Teilen-Dialog anzeigen
        this._shareResults(visualizationData);
    };
    
    app.modules.resultVisualization.printResults = function() {
        // Wenn keine Visualisierungsdaten vorhanden sind, nichts tun
        if (!this._currentTestResult) {
            console.error('Keine Testergebnisse zum Drucken vorhanden');
            return;
        }
        
        // Daten für die Visualisierung vorbereiten (falls noch nicht geschehen)
        const visualizationData = this.prepareDataForVisualization(this._currentTestResult);
        
        // Drucken initiieren
        this._printResults(visualizationData);
    };
    
    app.modules.resultVisualization.exportResults = function(format = 'json') {
        // Wenn keine Visualisierungsdaten vorhanden sind, nichts tun
        if (!this._currentTestResult) {
            console.error('Keine Testergebnisse zum Exportieren vorhanden');
            return;
        }
        
        // Wenn kein Format angegeben wurde, Dialog anzeigen
        if (!format) {
            const selectedFormat = prompt('Wählen Sie ein Exportformat (json, csv):', 'json');
            if (!selectedFormat) return;
            format = selectedFormat.toLowerCase();
        }
        
        // Daten für die Visualisierung vorbereiten (falls noch nicht geschehen)
        const visualizationData = this.prepareDataForVisualization(this._currentTestResult);
        
        // Export initiieren
        this._exportResults(visualizationData, format);
    };
    
    // Die bestehende showVisualization-Funktion erweitern
    const originalShowVisualization = app.modules.resultVisualization.showVisualization;
    app.modules.resultVisualization.showVisualization = function(visualizationData) {
        // Zuerst die bisher implementierten Funktionen aufrufen
        originalShowVisualization.call(this, visualizationData);
        
        // Dann mit anderen Modulen integrieren
        this._integrateWithOtherModules(visualizationData);
        
        // Aktuelle Testdaten speichern
        this._currentTestResult = visualizationData.testInfo ? 
            visualizationData : 
            { testInfo: { id: 'unknown' }, ...visualizationData };
        
        console.log('Ergebnisvisualisierung vollständig angezeigt und integriert');
    };
    
})();
/**
 * @fileoverview JS-Block 6.5.2-part1b - Ergebnisvisualisierung (Historische Diagramme)
 * Dieser Code implementiert die Diagrammfunktionen für historische Leistungsdaten.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit Diagrammfunktionen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Rendert das Diagramm für historische Leistungsdaten
     * @param {Object} data - Die historischen Daten
     */
    function _renderHistoricalChart(data) {
        console.log('Rendere historisches Leistungsdiagramm...');
        
        const chartContainer = document.getElementById('historical-chart');
        if (!chartContainer) {
            console.error('Container für historisches Diagramm nicht gefunden');
            return;
        }
        
        // Container leeren
        chartContainer.innerHTML = '';
        
        // Diagrammtyp ermitteln
        const chartType = advancedAnalytics.getAnalyticsOptions().chartTypes.historical;
        
        // Je nach Diagrammtyp unterschiedliche Darstellung
        switch (chartType) {
            case 'line':
                _renderHistoricalLineChart(data, chartContainer);
                break;
                
            case 'bar':
                _renderHistoricalBarChart(data, chartContainer);
                break;
                
            case 'area':
                _renderHistoricalAreaChart(data, chartContainer);
                break;
                
            default:
                _renderHistoricalLineChart(data, chartContainer);
        }
        
        // Zusätzliche Informationen unter dem Diagramm anzeigen
        const infoContainer = document.createElement('div');
        infoContainer.className = 'chart-info';
        
        // Trend-Informationen
        const scoreDataset = data.datasets[0];
        const trendInfo = advancedAnalytics._analyzeHistoricalTrend(scoreDataset.data);
        
        infoContainer.innerHTML = `
            <div class="trend-info ${trendInfo.trendClass}">
                <span class="trend-icon">${trendInfo.icon}</span>
                <span class="trend-text">${trendInfo.message}</span>
            </div>
            <div class="additional-info">
                <div class="info-item">
                    <span class="info-label">Durchschnitt:</span>
                    <span class="info-value">${trendInfo.average}%</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Beste Leistung:</span>
                    <span class="info-value">${trendInfo.max}%</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Niedrigste Leistung:</span>
                    <span class="info-value">${trendInfo.min}%</span>
                </div>
            </div>
        `;
        
        chartContainer.appendChild(infoContainer);
    }
    
    /**
     * Rendert ein Liniendiagramm für historische Leistungsdaten
     * @private
     * @param {Object} data - Die historischen Daten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _renderHistoricalLineChart(data, container) {
        if (!container) return;
        
        const scoreData = data.datasets[0].data;
        const labels = data.labels;
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 50, left: 50 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'line-chart');
        
        // Skalen definieren
        const xScale = (svgWidth - padding.left - padding.right) / (labels.length - 1);
        const yScale = (svgHeight - padding.top - padding.bottom) / 100; // Punktzahl von 0-100
        
        // Linien-Pfad erstellen
        let linePath = `M ${padding.left} ${svgHeight - padding.bottom - scoreData[0] * yScale}`;
        for (let i = 1; i < scoreData.length; i++) {
            if (scoreData[i] !== null) {
                const x = padding.left + i * xScale;
                const y = svgHeight - padding.bottom - scoreData[i] * yScale;
                linePath += ` L ${x} ${y}`;
            }
        }
        
        // SVG-Elemente hinzufügen
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        for (let i = 0; i <= 100; i += 20) {
            const y = svgHeight - padding.bottom - i * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = i + '%';
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // X-Achsen-Beschriftungen
        for (let i = 0; i < labels.length; i++) {
            const x = padding.left + i * xScale;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = labels[i];
            label.setAttribute('transform', `rotate(45, ${x}, ${svgHeight - padding.bottom + 20})`);
            
            svg.appendChild(label);
        }
        
        // Linie zeichnen
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', linePath);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#00FFD0');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('class', 'line-path');
        
        svg.appendChild(path);
        
        // Datenpunkte zeichnen
        for (let i = 0; i < scoreData.length; i++) {
            if (scoreData[i] !== null) {
                const x = padding.left + i * xScale;
                const y = svgHeight - padding.bottom - scoreData[i] * yScale;
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#00FFD0');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('class', 'data-point');
                
                // Tooltip für den Datenpunkt
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = `${labels[i]}: ${scoreData[i]}%`;
                circle.appendChild(title);
                
                // Event-Listener für Hover-Effekt
                circle.addEventListener('mouseover', function() {
                    this.setAttribute('r', '7');
                    this.setAttribute('fill', '#00ccb0');
                });
                
                circle.addEventListener('mouseout', function() {
                    this.setAttribute('r', '5');
                    this.setAttribute('fill', '#00FFD0');
                });
                
                svg.appendChild(circle);
            }
        }
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für die Linie
        setTimeout(() => {
            const pathElement = container.querySelector('.line-path');
            if (pathElement) {
                const pathLength = pathElement.getTotalLength();
                
                pathElement.style.strokeDasharray = pathLength;
                pathElement.style.strokeDashoffset = pathLength;
                pathElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                pathElement.style.transition = 'stroke-dashoffset 1s ease-in-out';
                pathElement.style.strokeDashoffset = '0';
            }
        }, 100);
    }
    
    /**
     * Rendert ein Balkendiagramm für historische Leistungsdaten
     * @private
     * @param {Object} data - Die historischen Daten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _renderHistoricalBarChart(data, container) {
        if (!container) return;
        
        const scoreData = data.datasets[0].data;
        const labels = data.labels;
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 50, left: 50 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'bar-chart');
        
        // Skalen definieren
        const chartWidth = svgWidth - padding.left - padding.right;
        const chartHeight = svgHeight - padding.top - padding.bottom;
        
        const barWidth = chartWidth / scoreData.length * 0.8;
        const barSpacing = chartWidth / scoreData.length * 0.2;
        const yScale = chartHeight / 100; // Punktzahl von 0-100
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        for (let i = 0; i <= 100; i += 20) {
            const y = svgHeight - padding.bottom - i * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = i + '%';
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // Balken und X-Achsen-Beschriftungen erstellen
        for (let i = 0; i < scoreData.length; i++) {
            if (scoreData[i] !== null) {
                const barHeight = scoreData[i] * yScale;
                const x = padding.left + (i * (barWidth + barSpacing)) + barSpacing / 2;
                const y = svgHeight - padding.bottom - barHeight;
                
                // Balken zeichnen
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', barWidth);
                rect.setAttribute('height', barHeight);
                rect.setAttribute('fill', '#00FFD0');
                rect.setAttribute('class', 'bar');
                rect.setAttribute('data-index', i);
                
                // Tooltip für den Balken
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = `${labels[i]}: ${scoreData[i]}%`;
                rect.appendChild(title);
                
                // Event-Listener für Hover-Effekt
                rect.addEventListener('mouseover', function() {
                    this.setAttribute('fill', '#00ccb0');
                });
                
                rect.addEventListener('mouseout', function() {
                    this.setAttribute('fill', '#00FFD0');
                });
                
                svg.appendChild(rect);
                
                // X-Achsen-Beschriftung
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x + barWidth / 2);
                label.setAttribute('y', svgHeight - padding.bottom + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.textContent = labels[i];
                label.setAttribute('transform', `rotate(45, ${x + barWidth / 2}, ${svgHeight - padding.bottom + 20})`);
                
                svg.appendChild(label);
                
                // Wert über dem Balken anzeigen
                const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valueLabel.setAttribute('x', x + barWidth / 2);
                valueLabel.setAttribute('y', y - 5);
                valueLabel.setAttribute('text-anchor', 'middle');
                valueLabel.setAttribute('font-size', '12');
                valueLabel.setAttribute('font-weight', 'bold');
                valueLabel.textContent = scoreData[i] + '%';
                
                svg.appendChild(valueLabel);
            }
        }
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für die Balken
        setTimeout(() => {
            const bars = container.querySelectorAll('.bar');
            bars.forEach((bar, index) => {
                const originalHeight = bar.getAttribute('height');
                bar.setAttribute('height', '0');
                bar.setAttribute('y', svgHeight - padding.bottom);
                
                setTimeout(() => {
                    bar.style.transition = 'height 0.5s ease-out, y 0.5s ease-out';
                    bar.setAttribute('height', originalHeight);
                    bar.setAttribute('y', svgHeight - padding.bottom - originalHeight);
                }, index * 100);
            });
        }, 100);
    }
    
    /**
     * Rendert ein Flächendiagramm für historische Leistungsdaten
     * @private
     * @param {Object} data - Die historischen Daten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _renderHistoricalAreaChart(data, container) {
        if (!container) return;
        
        const scoreData = data.datasets[0].data;
        const labels = data.labels;
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 50, left: 50 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'area-chart');
        
        // Skalen definieren
        const xScale = (svgWidth - padding.left - padding.right) / (labels.length - 1);
        const yScale = (svgHeight - padding.top - padding.bottom) / 100; // Punktzahl von 0-100
        
        // Pfade für Linie und Fläche erstellen
        let linePath = '';
        let areaPath = '';
        
        // Ausgangspunkt für den Bereich (unten links)
        areaPath = `M ${padding.left} ${svgHeight - padding.bottom}`;
        
        // Obere Linie des Bereichs
        for (let i = 0; i < scoreData.length; i++) {
            if (scoreData[i] !== null) {
                const x = padding.left + i * xScale;
                const y = svgHeight - padding.bottom - scoreData[i] * yScale;
                
                if (i === 0) {
                    linePath = `M ${x} ${y}`;
                    areaPath += ` L ${x} ${y}`;
                } else {
                    linePath += ` L ${x} ${y}`;
                    areaPath += ` L ${x} ${y}`;
                }
            }
        }
        
        // Schließe den Bereich (unten rechts und zurück)
        const lastIndex = scoreData.length - 1;
        const lastX = padding.left + lastIndex * xScale;
        areaPath += ` L ${lastX} ${svgHeight - padding.bottom} L ${padding.left} ${svgHeight - padding.bottom} Z`;
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        for (let i = 0; i <= 100; i += 20) {
            const y = svgHeight - padding.bottom - i * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = i + '%';
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // X-Achsen-Beschriftungen
        for (let i = 0; i < labels.length; i++) {
            const x = padding.left + i * xScale;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = labels[i];
            label.setAttribute('transform', `rotate(45, ${x}, ${svgHeight - padding.bottom + 20})`);
            
            svg.appendChild(label);
        }
        
        // Bereich zeichnen
        const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        area.setAttribute('d', areaPath);
        area.setAttribute('fill', 'rgba(0, 255, 208, 0.3)');
        area.setAttribute('class', 'area-path');
        
        svg.appendChild(area);
        
        // Linie zeichnen
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', linePath);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#00FFD0');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('class', 'line-path');
        
        svg.appendChild(path);
        
        // Datenpunkte zeichnen
        for (let i = 0; i < scoreData.length; i++) {
            if (scoreData[i] !== null) {
                const x = padding.left + i * xScale;
                const y = svgHeight - padding.bottom - scoreData[i] * yScale;
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', '#00FFD0');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('class', 'data-point');
                
                // Tooltip für den Datenpunkt
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = `${labels[i]}: ${scoreData[i]}%`;
                circle.appendChild(title);
                
                // Event-Listener für Hover-Effekt
                circle.addEventListener('mouseover', function() {
                    this.setAttribute('r', '7');
                    this.setAttribute('fill', '#00ccb0');
                });
                
                circle.addEventListener('mouseout', function() {
                    this.setAttribute('r', '5');
                    this.setAttribute('fill', '#00FFD0');
                });
                
                svg.appendChild(circle);
            }
        }
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für den Bereich und die Linie
        setTimeout(() => {
            const areaElement = container.querySelector('.area-path');
            const pathElement = container.querySelector('.line-path');
            
            if (pathElement) {
                const pathLength = pathElement.getTotalLength();
                
                pathElement.style.strokeDasharray = pathLength;
                pathElement.style.strokeDashoffset = pathLength;
                pathElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                pathElement.style.transition = 'stroke-dashoffset 1s ease-in-out';
                pathElement.style.strokeDashoffset = '0';
            }
            
            if (areaElement) {
                areaElement.style.opacity = '0';
                areaElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                areaElement.style.transition = 'opacity 1.5s ease-in-out';
                areaElement.style.opacity = '1';
            }
        }, 100);
    }
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._renderHistoricalChart = _renderHistoricalChart;
    advancedAnalytics._renderHistoricalLineChart = _renderHistoricalLineChart;
    advancedAnalytics._renderHistoricalBarChart = _renderHistoricalBarChart;
    advancedAnalytics._renderHistoricalAreaChart = _renderHistoricalAreaChart;
})();
/**
 * @fileoverview JS-Block 6.5.2-part1c - Ergebnisvisualisierung (Vergleichsdiagramme)
 * Dieser Code implementiert die Diagrammfunktionen für Leistungsvergleiche zwischen
 * Benutzern, Teams und Abteilungen.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit Vergleichsdiagrammen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Rendert das Diagramm für Leistungsvergleiche
     * @param {Object} data - Die Vergleichsdaten
     */
    function _renderComparisonChart(data) {
        console.log('Rendere Vergleichsdiagramm...');
        
        const chartContainer = document.getElementById('comparison-chart');
        if (!chartContainer) {
            console.error('Container für Vergleichsdiagramm nicht gefunden');
            return;
        }
        
        // Container leeren
        chartContainer.innerHTML = '';
        
        // Daten für das Diagramm vorbereiten
        const scores = data.scores;
        const groups = advancedAnalytics.getAnalyticsOptions().comparisonGroups.filter(group => group !== 'user');
        
        // Gruppenbezeichnungen
        const groupLabels = {
            user: 'Sie',
            team: 'Team',
            department: 'Abteilung',
            company: 'Unternehmen'
        };
        
        // Balkendiagramm erstellen
        const chartContainer1 = document.createElement('div');
        chartContainer1.className = 'comparison-chart-container';
        chartContainer1.innerHTML = `
            <h4>Punktzahlvergleich</h4>
            <div class="chart-inner-container bar-comparison-chart"></div>
        `;
        
        // Radar-Diagramm für Kategorien (falls Kategoriedaten vorhanden)
        const chartContainer2 = document.createElement('div');
        chartContainer2.className = 'comparison-chart-container';
        chartContainer2.innerHTML = `
            <h4>Kategorien im Vergleich</h4>
            <div class="chart-inner-container category-comparison-chart"></div>
        `;
        
        // Container zum Hauptcontainer hinzufügen
        chartContainer.appendChild(chartContainer1);
        chartContainer.appendChild(chartContainer2);
        
        // Balkendiagramm für Punktzahlvergleich erstellen
        _createScoreComparisonChart(scores, groups, groupLabels, chartContainer1.querySelector('.bar-comparison-chart'));
        
        // Radar-Diagramm für Kategorienvergleich erstellen
        _createCategoryComparisonChart(data.categoryComparison, groups, groupLabels, chartContainer2.querySelector('.category-comparison-chart'));
        
        // Rangplatzierungen anzeigen
        const rankingsContainer = document.createElement('div');
        rankingsContainer.className = 'rankings-container';
        rankingsContainer.innerHTML = '<h4>Ihre Platzierungen</h4>';
        
        // Rangplatzierungen als Karten anzeigen
        const rankings = data.rankings;
        const rankingCards = document.createElement('div');
        rankingCards.className = 'ranking-cards';
        
        if (groups.includes('team')) {
            rankingCards.innerHTML += `
                <div class="ranking-card">
                    <div class="ranking-value">${rankings.team}</div>
                    <div class="ranking-label">von ${rankings.teamSize}</div>
                    <div class="ranking-context">im Team</div>
                </div>
            `;
        }
        
        if (groups.includes('department')) {
            rankingCards.innerHTML += `
                <div class="ranking-card">
                    <div class="ranking-value">${rankings.department}</div>
                    <div class="ranking-label">von ${rankings.departmentSize}</div>
                    <div class="ranking-context">in der Abteilung</div>
                </div>
            `;
        }
        
        if (groups.includes('company')) {
            rankingCards.innerHTML += `
                <div class="ranking-card">
                    <div class="ranking-value">${rankings.company}</div>
                    <div class="ranking-label">von ${rankings.companySize}</div>
                    <div class="ranking-context">im Unternehmen</div>
                </div>
            `;
        }
        
        rankingsContainer.appendChild(rankingCards);
        chartContainer.appendChild(rankingsContainer);
    }
    
    /**
     * Erstellt ein Balkendiagramm für den Punktzahlvergleich
     * @private
     * @param {Object} scores - Die Punktzahlen
     * @param {Array<string>} groups - Die zu vergleichenden Gruppen
     * @param {Object} groupLabels - Labels für die Gruppen
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createScoreComparisonChart(scores, groups, groupLabels, container) {
        if (!container) return;
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 50, left: 50 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'comparison-chart');
        
        // Alle Gruppen (inkl. Benutzer)
        const allGroups = ['user', ...groups];
        
        // Skalen definieren
        const chartWidth = svgWidth - padding.left - padding.right;
        const chartHeight = svgHeight - padding.top - padding.bottom;
        
        const barWidth = chartWidth / allGroups.length * 0.6;
        const barSpacing = chartWidth / allGroups.length * 0.4;
        const yScale = chartHeight / 100; // Punktzahl von 0-100
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        for (let i = 0; i <= 100; i += 20) {
            const y = svgHeight - padding.bottom - i * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = i + '%';
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // Farben für die Gruppen
        const colors = {
            user: '#00FFD0',
            team: '#34ace0',
            department: '#33d9b2',
            company: '#706fd3'
        };
        
        // Balken für jede Gruppe erstellen
        allGroups.forEach((group, i) => {
            const score = scores[group] || 0;
            const barHeight = score * yScale;
            const x = padding.left + (i * (barWidth + barSpacing)) + barSpacing / 2;
            const y = svgHeight - padding.bottom - barHeight;
            
            // Balken zeichnen
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', barWidth);
            rect.setAttribute('height', barHeight);
            rect.setAttribute('fill', colors[group] || '#ccc');
            rect.setAttribute('class', `bar ${group === 'user' ? 'highlighted' : ''}`);
            
            // Tooltip für den Balken
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            title.textContent = `${groupLabels[group]}: ${score}%`;
            rect.appendChild(title);
            
            // Event-Listener für Hover-Effekt
            rect.addEventListener('mouseover', function() {
                this.setAttribute('fill-opacity', '0.8');
            });
            
            rect.addEventListener('mouseout', function() {
                this.setAttribute('fill-opacity', '1');
            });
            
            svg.appendChild(rect);
            
            // Gruppenbezeichnung
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x + barWidth / 2);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = groupLabels[group] || group;
            
            svg.appendChild(label);
            
            // Wert über dem Balken anzeigen
            const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            valueLabel.setAttribute('x', x + barWidth / 2);
            valueLabel.setAttribute('y', y - 5);
            valueLabel.setAttribute('text-anchor', 'middle');
            valueLabel.setAttribute('font-size', '12');
            valueLabel.setAttribute('font-weight', 'bold');
            valueLabel.textContent = score + '%';
            
            svg.appendChild(valueLabel);
        });
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für die Balken
        setTimeout(() => {
            const bars = container.querySelectorAll('.bar');
            bars.forEach((bar, index) => {
                const originalHeight = bar.getAttribute('height');
                bar.setAttribute('height', '0');
                bar.setAttribute('y', svgHeight - padding.bottom);
                
                setTimeout(() => {
                    bar.style.transition = 'height 0.5s ease-out, y 0.5s ease-out';
                    bar.setAttribute('height', originalHeight);
                    bar.setAttribute('y', svgHeight - padding.bottom - originalHeight);
                }, index * 150);
            });
        }, 100);
    }
    
    /**
     * Erstellt ein Radar-Diagramm für den Kategorienvergleich
     * @private
     * @param {Object} categoryData - Die Kategoriedaten
     * @param {Array<string>} groups - Die zu vergleichenden Gruppen
     * @param {Object} groupLabels - Labels für die Gruppen
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createCategoryComparisonChart(categoryData, groups, groupLabels, container) {
        if (!container) return;
        
        // SVG-Container erstellen
        const size = Math.min(container.clientWidth || 300, 300);
        const svgSize = size;
        const center = svgSize / 2;
        const radius = center * 0.8;
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);
        svg.setAttribute('class', 'radar-chart');
        
        // Alle Kategorien ermitteln
        const categories = Object.keys(categoryData || {});
        
        // Wenn keine Kategoriedaten vorhanden sind, Hinweis anzeigen
        if (!categoryData || categories.length === 0) {
            const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            noDataText.setAttribute('x', center);
            noDataText.setAttribute('y', center);
            noDataText.setAttribute('text-anchor', 'middle');
            noDataText.setAttribute('font-size', '14');
            noDataText.textContent = 'Keine Kategoriedaten verfügbar';
            
            svg.appendChild(noDataText);
            container.appendChild(svg);
            return;
        }
        
        // Winkel für jede Kategorie berechnen
        const angleStep = (2 * Math.PI) / categories.length;
        
        // Hintergrundgitter zeichnen
        for (let level = 1; level <= 5; level++) {
            const levelRadius = (radius / 5) * level;
            
            // Kreise für die Level zeichnen
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', center);
            circle.setAttribute('cy', center);
            circle.setAttribute('r', levelRadius);
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', '#eee');
            circle.setAttribute('stroke-width', '1');
            
            svg.appendChild(circle);
            
            // Beschriftung für das Level hinzufügen (nur für ausgewählte Level)
            if (level % 2 === 0 || level === 5) {
                const levelValue = (level / 5) * 100;
                const levelLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                levelLabel.setAttribute('x', center);
                levelLabel.setAttribute('y', center - levelRadius - 5);
                levelLabel.setAttribute('text-anchor', 'middle');
                levelLabel.setAttribute('font-size', '10');
                levelLabel.setAttribute('fill', '#999');
                levelLabel.textContent = levelValue + '%';
                
                svg.appendChild(levelLabel);
            }
        }
        
        // Achsenlinien für jede Kategorie zeichnen
        categories.forEach((category, i) => {
            const angle = i * angleStep - Math.PI / 2; // -90° als Startpunkt (oben)
            const x = center + radius * Math.cos(angle);
            const y = center + radius * Math.sin(angle);
            
            // Achsenlinie zeichnen
            const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            axis.setAttribute('x1', center);
            axis.setAttribute('y1', center);
            axis.setAttribute('x2', x);
            axis.setAttribute('y2', y);
            axis.setAttribute('stroke', '#ddd');
            axis.setAttribute('stroke-width', '1');
            
            svg.appendChild(axis);
            
            // Kategoriebeschriftung
            const labelDistance = radius + 15;
            const labelX = center + labelDistance * Math.cos(angle);
            const labelY = center + labelDistance * Math.sin(angle);
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', angle > Math.PI / 2 && angle < 3 * Math.PI / 2 ? 'end' : (angle === Math.PI / 2 || angle === 3 * Math.PI / 2 ? 'middle' : 'start'));
            label.setAttribute('dominant-baseline', angle === 0 || angle === Math.PI ? 'middle' : (angle < Math.PI ? 'hanging' : 'auto'));
            label.setAttribute('font-size', '12');
            label.textContent = category;
            
            svg.appendChild(label);
        });
        
        // Farben für die Gruppen
        const colors = {
            user: '#00FFD0',
            team: '#34ace0',
            department: '#33d9b2',
            company: '#706fd3'
        };
        
        // Daten für jede Gruppe zeichnen
        const allGroups = ['user', ...groups];
        
        allGroups.forEach((group, groupIndex) => {
            // Pfad für den Polygonzug erstellen
            let pathData = '';
            
            categories.forEach((category, i) => {
                const categoryValues = categoryData[category] || {};
                const value = categoryValues[group] || 0;
                
                // Radius basierend auf dem Wert (0-100%) berechnen
                const valueRadius = (value / 100) * radius;
                
                // Position berechnen
                const angle = i * angleStep - Math.PI / 2; // -90° als Startpunkt (oben)
                const x = center + valueRadius * Math.cos(angle);
                const y = center + valueRadius * Math.sin(angle);
                
                // Pfad erstellen
                if (i === 0) {
                    pathData = `M ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                }
                
                // Datenpunkte zeichnen
                const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                point.setAttribute('cx', x);
                point.setAttribute('cy', y);
                point.setAttribute('r', '3');
                point.setAttribute('fill', colors[group] || '#ccc');
                point.setAttribute('class', `data-point ${group}`);
                
                // Tooltip für den Datenpunkt
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = `${groupLabels[group]} - ${category}: ${value}%`;
                point.appendChild(title);
                
                svg.appendChild(point);
            });
            
            // Polygonzug schließen
            pathData += ' Z';
            
            // Polygon zeichnen
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            polygon.setAttribute('d', pathData);
            polygon.setAttribute('fill', colors[group] || '#ccc');
            polygon.setAttribute('fill-opacity', '0.3');
            polygon.setAttribute('stroke', colors[group] || '#ccc');
            polygon.setAttribute('stroke-width', '2');
            polygon.setAttribute('class', `radar-polygon ${group}`);
            
            // Tooltip für das Polygon
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            title.textContent = groupLabels[group] || group;
            polygon.appendChild(title);
            
            // Das Polygon vor den Datenpunkten einfügen (damit die Punkte sichtbar bleiben)
            svg.insertBefore(polygon, svg.firstChild);
        });
        
        // Legende erstellen
        const legendContainer = document.createElement('div');
        legendContainer.className = 'chart-legend';
        
        allGroups.forEach(group => {
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
                <span class="legend-color" style="background-color: ${colors[group]};"></span>
                <span class="legend-text">${groupLabels[group] || group}</span>
            `;
            
            legendContainer.appendChild(legendItem);
        });
        
        // Diagramm und Legende zum Container hinzufügen
        container.appendChild(svg);
        container.appendChild(legendContainer);
        
        // Animation für die Polygone
        setTimeout(() => {
            const polygons = container.querySelectorAll('.radar-polygon');
            polygons.forEach((polygon, index) => {
                polygon.style.opacity = '0';
                
                setTimeout(() => {
                    polygon.style.transition = 'opacity 0.5s ease-in-out';
                    polygon.style.opacity = '1';
                }, index * 200);
            });
        }, 100);
    }
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._renderComparisonChart = _renderComparisonChart;
    advancedAnalytics._createScoreComparisonChart = _createScoreComparisonChart;
    advancedAnalytics._createCategoryComparisonChart = _createCategoryComparisonChart;
})();
/**
 * @fileoverview JS-Block 6.5.2-part1d - Ergebnisvisualisierung (Trenddiagramme)
 * Dieser Code implementiert die Diagrammfunktionen für Leistungstrends und
 * Zeitreihenanalysen.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit Trenddiagrammfunktionen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Rendert das Diagramm für Leistungstrends
     * @param {Object} data - Die Trenddaten
     */
    function _renderTrendChart(data) {
        console.log('Rendere Trenddiagramm...');
        
        const chartContainer = document.getElementById('trends-chart');
        if (!chartContainer) {
            console.error('Container für Trenddiagramm nicht gefunden');
            return;
        }
        
        // Container leeren
        chartContainer.innerHTML = '';
        
        // Metrik aus Auswahlfeld ermitteln
        const metricSelector = document.querySelector('.trend-metric-selector');
        const selectedMetric = metricSelector ? metricSelector.value : 'score';
        
        // Entsprechende Daten auswählen
        let trendData;
        let title;
        let yAxisLabel;
        
        if (selectedMetric === 'categories') {
            // Kategorietrends anzeigen
            trendData = data.categories;
            title = 'Kategorietrends über Zeit';
            yAxisLabel = 'Punktzahl';
            
            // Multi-Linien-Diagramm für Kategorien erstellen
            _createMultiLineTrendChart(trendData, chartContainer, title, yAxisLabel);
        } else {
            // Einzelne Metrik anzeigen
            trendData = data.metrics[selectedMetric] || [];
            
            switch (selectedMetric) {
                case 'score':
                    title = 'Entwicklung der Gesamtpunktzahl';
                    yAxisLabel = 'Punktzahl (%)';
                    break;
                case 'time':
                    title = 'Entwicklung der Bearbeitungszeit';
                    yAxisLabel = 'Zeit (min)';
                    break;
                case 'accuracy':
                    title = 'Entwicklung der Genauigkeit';
                    yAxisLabel = 'Genauigkeit (%)';
                    break;
                default:
                    title = 'Leistungsentwicklung';
                    yAxisLabel = 'Wert';
            }
            
            // Einzel-Linien-Diagramm erstellen
            _createSingleLineTrendChart(trendData, chartContainer, title, yAxisLabel);
        }
        
        // Trendanalyse anzeigen
        _createTrendAnalysisInfo(data.trends, selectedMetric, chartContainer);
    }
    
    /**
     * Erstellt ein Liniendiagramm für einen einzelnen Trendwert
     * @private
     * @param {Array} data - Die Zeitreihendaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     * @param {string} title - Der Titel des Diagramms
     * @param {string} yAxisLabel - Die Beschriftung der Y-Achse
     */
    function _createSingleLineTrendChart(data, container, title, yAxisLabel) {
        if (!container || !data || data.length === 0) return;
        
        // Titel hinzufügen
        const titleElement = document.createElement('h5');
        titleElement.className = 'chart-title';
        titleElement.textContent = title;
        container.appendChild(titleElement);
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 70, left: 60 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'trend-chart');
        
        // Daten vorbereiten
        const dates = data.map(d => d.date);
        const values = data.map(d => d.value);
        
        // Min und Max für die Y-Achse bestimmen
        const minValue = Math.floor(Math.min(...values) * 0.9);
        const maxValue = Math.ceil(Math.max(...values) * 1.1);
        
        // Skalen definieren
        const xScale = (svgWidth - padding.left - padding.right) / (dates.length - 1);
        const yScale = (svgHeight - padding.top - padding.bottom) / (maxValue - minValue);
        
        // Linien-Pfad erstellen
        let linePath = '';
        for (let i = 0; i < data.length; i++) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (data[i].value - minValue) * yScale;
            
            if (i === 0) {
                linePath = `M ${x} ${y}`;
            } else {
                linePath += ` L ${x} ${y}`;
            }
        }
        
        // Bereichs-Pfad erstellen (für die Fläche unter der Linie)
        let areaPath = linePath + ` L ${padding.left + (data.length - 1) * xScale} ${svgHeight - padding.bottom} L ${padding.left} ${svgHeight - padding.bottom} Z`;
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        const ySteps = 5;
        const yStepSize = (maxValue - minValue) / ySteps;
        
        for (let i = 0; i <= ySteps; i++) {
            const value = minValue + i * yStepSize;
            const y = svgHeight - padding.bottom - (value - minValue) * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = Math.round(value);
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // Y-Achsen-Beschriftung
        const yAxisLabelElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yAxisLabelElement.setAttribute('x', -svgHeight / 2);
        yAxisLabelElement.setAttribute('y', padding.left / 3);
        yAxisLabelElement.setAttribute('text-anchor', 'middle');
        yAxisLabelElement.setAttribute('font-size', '12');
        yAxisLabelElement.setAttribute('transform', 'rotate(-90)');
        yAxisLabelElement.textContent = yAxisLabel;
        
        svg.appendChild(yAxisLabelElement);
        
        // X-Achsen-Beschriftungen
        // Reduzierte Anzahl von Labels, um Überlappungen zu vermeiden
        const labelStep = Math.ceil(dates.length / 6); // Maximal 6 Labels
        
        for (let i = 0; i < dates.length; i += labelStep) {
            const x = padding.left + i * xScale;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = dates[i];
            label.setAttribute('transform', `rotate(45, ${x}, ${svgHeight - padding.bottom + 20})`);
            
            svg.appendChild(label);
        }
        
        // Bereich zeichnen
        const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        area.setAttribute('d', areaPath);
        area.setAttribute('fill', 'rgba(0, 255, 208, 0.2)');
        area.setAttribute('class', 'area-path');
        
        svg.appendChild(area);
        
        // Linie zeichnen
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', linePath);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#00FFD0');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('class', 'line-path');
        
        svg.appendChild(path);
        
        // Datenpunkte zeichnen
        for (let i = 0; i < data.length; i++) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (data[i].value - minValue) * yScale;
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', '5');
            circle.setAttribute('fill', '#00FFD0');
            circle.setAttribute('stroke', 'white');
            circle.setAttribute('stroke-width', '2');
            circle.setAttribute('class', 'data-point');
            
            // Tooltip für den Datenpunkt
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            title.textContent = `${dates[i]}: ${data[i].value}`;
            circle.appendChild(title);
            
            // Event-Listener für Hover-Effekt
            circle.addEventListener('mouseover', function() {
                this.setAttribute('r', '7');
                this.setAttribute('fill', '#00ccb0');
            });
            
            circle.addEventListener('mouseout', function() {
                this.setAttribute('r', '5');
                this.setAttribute('fill', '#00FFD0');
            });
            
            svg.appendChild(circle);
        }
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für Linie und Bereich
        setTimeout(() => {
            const pathElement = container.querySelector('.line-path');
            const areaElement = container.querySelector('.area-path');
            
            if (pathElement) {
                const pathLength = pathElement.getTotalLength();
                
                pathElement.style.strokeDasharray = pathLength;
                pathElement.style.strokeDashoffset = pathLength;
                pathElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                pathElement.style.transition = 'stroke-dashoffset 1s ease-in-out';
                pathElement.style.strokeDashoffset = '0';
            }
            
            if (areaElement) {
                areaElement.style.opacity = '0';
                areaElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                areaElement.style.transition = 'opacity 1.5s ease-in-out';
                areaElement.style.opacity = '1';
            }
        }, 100);
    }
    
    /**
     * Erstellt ein Liniendiagramm für mehrere Trenddatensätze (Kategorien)
     * @private
     * @param {Object} categoriesData - Die Kategoriezeitreihendaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     * @param {string} title - Der Titel des Diagramms
     * @param {string} yAxisLabel - Die Beschriftung der Y-Achse
     */
    function _createMultiLineTrendChart(categoriesData, container, title, yAxisLabel) {
        if (!container || !categoriesData) return;
        
        const categories = Object.keys(categoriesData);
        
        if (categories.length === 0) {
            container.innerHTML = '<div class="no-data-message">Keine Kategoriedaten verfügbar</div>';
            return;
        }
        
        // Titel hinzufügen
        const titleElement = document.createElement('h5');
        titleElement.className = 'chart-title';
        titleElement.textContent = title;
        container.appendChild(titleElement);
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 120, bottom: 70, left: 60 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'multi-line-chart');
        
        // Daten vorbereiten
        const firstCategory = categoriesData[categories[0]];
        const dates = firstCategory.map(d => d.date);
        
        // Alle Werte sammeln, um Min und Max zu bestimmen
        let allValues = [];
        categories.forEach(category => {
            categoriesData[category].forEach(d => {
                if (d.value !== null && d.value !== undefined) {
                    allValues.push(d.value);
                }
            });
        });
        
        // Min und Max für die Y-Achse bestimmen
        const minValue = Math.floor(Math.min(...allValues) * 0.9);
        const maxValue = Math.ceil(Math.max(...allValues) * 1.1);
        
        // Skalen definieren
        const xScale = (svgWidth - padding.left - padding.right) / (dates.length - 1);
        const yScale = (svgHeight - padding.top - padding.bottom) / (maxValue - minValue);
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        const ySteps = 5;
        const yStepSize = (maxValue - minValue) / ySteps;
        
        for (let i = 0; i <= ySteps; i++) {
            const value = minValue + i * yStepSize;
            const y = svgHeight - padding.bottom - (value - minValue) * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = Math.round(value);
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // Y-Achsen-Beschriftung
        const yAxisLabelElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yAxisLabelElement.setAttribute('x', -svgHeight / 2);
        yAxisLabelElement.setAttribute('y', padding.left / 3);
        yAxisLabelElement.setAttribute('text-anchor', 'middle');
        yAxisLabelElement.setAttribute('font-size', '12');
        yAxisLabelElement.setAttribute('transform', 'rotate(-90)');
        yAxisLabelElement.textContent = yAxisLabel;
        
        svg.appendChild(yAxisLabelElement);
        
        // X-Achsen-Beschriftungen
        // Reduzierte Anzahl von Labels, um Überlappungen zu vermeiden
        const labelStep = Math.ceil(dates.length / 6); // Maximal 6 Labels
        
        for (let i = 0; i < dates.length; i += labelStep) {
            const x = padding.left + i * xScale;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = dates[i];
            label.setAttribute('transform', `rotate(45, ${x}, ${svgHeight - padding.bottom + 20})`);
            
            svg.appendChild(label);
        }
        
        // Farben für die Kategorien
        const colors = [
            '#00FFD0', '#34ace0', '#33d9b2', '#706fd3',
            '#ff793f', '#ff5252', '#b8e994', '#78e08f'
        ];
        
        // Linien für jede Kategorie zeichnen
        categories.forEach((category, categoryIndex) => {
            const categoryData = categoriesData[category];
            const color = colors[categoryIndex % colors.length];
            
            // Linien-Pfad erstellen
            let linePath = '';
            
            for (let i = 0; i < categoryData.length; i++) {
                if (categoryData[i].value !== null && categoryData[i].value !== undefined) {
                    const x = padding.left + i * xScale;
                    const y = svgHeight - padding.bottom - (categoryData[i].value - minValue) * yScale;
                    
                    if (linePath === '') {
                        linePath = `M ${x} ${y}`;
                    } else {
                        linePath += ` L ${x} ${y}`;
                    }
                }
            }
            
            // Linie zeichnen
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', linePath);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('class', `line-path category-${categoryIndex}`);
            
            svg.appendChild(path);
            
            // Datenpunkte zeichnen
            for (let i = 0; i < categoryData.length; i++) {
                if (categoryData[i].value !== null && categoryData[i].value !== undefined) {
                    const x = padding.left + i * xScale;
                    const y = svgHeight - padding.bottom - (categoryData[i].value - minValue) * yScale;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', '4');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '1');
                    circle.setAttribute('class', `data-point category-${categoryIndex}`);
                    
                    // Tooltip für den Datenpunkt
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${category} - ${dates[i]}: ${categoryData[i].value}`;
                    circle.appendChild(title);
                    
                    svg.appendChild(circle);
                }
            }
            
            // Legende
            const legendY = padding.top + categoryIndex * 20;
            
            const legendColor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            legendColor.setAttribute('x', svgWidth - padding.right + 10);
            legendColor.setAttribute('y', legendY - 10);
            legendColor.setAttribute('width', '12');
            legendColor.setAttribute('height', '12');
            legendColor.setAttribute('fill', color);
            
            const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            legendText.setAttribute('x', svgWidth - padding.right + 30);
            legendText.setAttribute('y', legendY);
            legendText.setAttribute('font-size', '12');
            legendText.textContent = category;
            
            svg.appendChild(legendColor);
            svg.appendChild(legendText);
        });
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Animation für die Linien
        setTimeout(() => {
            const pathElements = container.querySelectorAll('.line-path');
            pathElements.forEach((pathElement, index) => {
                if (pathElement) {
                    const pathLength = pathElement.getTotalLength();
                    
                    pathElement.style.strokeDasharray = pathLength;
                    pathElement.style.strokeDashoffset = pathLength;
                    pathElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                    pathElement.style.transition = `stroke-dashoffset 1s ease-in-out ${index * 0.2}s`;
                    pathElement.style.strokeDashoffset = '0';
                }
            });
        }, 100);
    }
    
    /**
     * Erstellt eine Trendanalyse-Info-Box
     * @private
     * @param {Object} trends - Die Trenddaten
     * @param {string} selectedMetric - Die ausgewählte Metrik
     * @param {HTMLElement} container - Der Container für die Info-Box
     */
    function _createTrendAnalysisInfo(trends, selectedMetric, container) {
        if (!container || !trends) return;
        
        // Trend-Info-Container erstellen
        const infoContainer = document.createElement('div');
        infoContainer.className = 'trend-analysis-info';
        
        let trend, trendMessage, trendClass, icon;
        
        if (selectedMetric === 'categories') {
            // Aggregierten Trend für Kategorien bestimmen
            const categoryTrends = trends.categories || {};
            const categories = Object.keys(categoryTrends);
            
            if (categories.length === 0) {
                infoContainer.innerHTML = '<div class="trend-message">Keine Trenddaten für Kategorien verfügbar</div>';
                container.appendChild(infoContainer);
                return;
            }
            
            // Kategorie-Trends zählen
            let improving = 0;
            let declining = 0;
            let stable = 0;
            
            categories.forEach(category => {
                const catTrend = categoryTrends[category];
                if (catTrend && catTrend.includes('improving')) {
                    improving++;
                } else if (catTrend && catTrend.includes('declining')) {
                    declining++;
                } else {
                    stable++;
                }
            });
            
            // Überwiegenden Trend bestimmen
            if (improving > declining && improving > stable) {
                trend = 'improving';
                trendClass = 'trend-positive';
                icon = '📈';
                trendMessage = `Die meisten Kategorien (${improving} von ${categories.length}) zeigen eine positive Entwicklung.`;
            } else if (declining > improving && declining > stable) {
                trend = 'declining';
                trendClass = 'trend-negative';
                icon = '📉';
                trendMessage = `Die meisten Kategorien (${declining} von ${categories.length}) zeigen eine negative Entwicklung.`;
            } else {
                trend = 'mixed';
                trendClass = 'trend-neutral';
                icon = '📊';
                trendMessage = 'Die Kategorien zeigen unterschiedliche Entwicklungen.';
            }
            
            // Detaillierten Kategorietrend-Überblick erstellen
            let detailsHTML = '<div class="trend-details"><h5>Kategorie-Details:</h5><ul>';
            
            categories.forEach(category => {
                const catTrend = categoryTrends[category];
                let catTrendClass, catIcon;
                
                if (catTrend && catTrend.includes('improving')) {
                    catTrendClass = 'trend-positive';
                    catIcon = '📈';
                } else if (catTrend && catTrend.includes('declining')) {
                    catTrendClass = 'trend-negative';
                    catIcon = '📉';
                } else {
                    catTrendClass = 'trend-neutral';
                    catIcon = '➡️';
                }
                
                detailsHTML += `
                    <li class="${catTrendClass}">
                        <span class="category-name">${category}:</span>
                        <span class="category-trend">${catIcon} ${_formatTrendName(catTrend)}</span>
                    </li>
                `;
            });
            
            detailsHTML += '</ul></div>';
            
            infoContainer.innerHTML = `
                <div class="trend-summary ${trendClass}">
                    <span class="trend-icon">${icon}</span>
                    <div class="trend-content">
                        <div class="trend-message">${trendMessage}</div>
                    </div>
                </div>
                ${detailsHTML}
            `;
        } else {
            // Einzeltrend anzeigen
            trend = trends[selectedMetric];
            
            if (!trend) {
                infoContainer.innerHTML = '<div class="trend-message">Keine Trenddaten verfügbar</div>';
                container.appendChild(infoContainer);
                return;
            }
            
            if (trend.includes('improving')) {
                trendClass = 'trend-positive';
                icon = '📈';
                
                if (selectedMetric === 'time') {
                    // Für Zeit ist eine Verbesserung weniger Zeit
                    trendMessage = trend === 'improving' 
                        ? 'Sie werden deutlich schneller bei der Bearbeitung.'
                        : 'Sie werden etwas schneller bei der Bearbeitung.';
                } else {
                    trendMessage = trend === 'improving' 
                        ? 'Sie zeigen eine deutliche Leistungsverbesserung über Zeit.'
                        : 'Sie zeigen eine leichte Leistungsverbesserung über Zeit.';
                }
            } else if (trend.includes('declining')) {
                trendClass = 'trend-negative';
                icon = '📉';
                
                if (selectedMetric === 'time') {
                    // Für Zeit ist eine Verschlechterung mehr Zeit
                    trendMessage = trend === 'declining' 
                        ? 'Sie benötigen deutlich mehr Zeit für die Bearbeitung.'
                        : 'Sie benötigen etwas mehr Zeit für die Bearbeitung.';
                } else {
                    trendMessage = trend === 'declining' 
                        ? 'Ihre Leistung hat sich über Zeit verschlechtert.'
                        : 'Ihre Leistung zeigt eine leichte Abnahme über Zeit.';
                }
            } else {
                trendClass = 'trend-neutral';
                icon = '➡️';
                trendMessage = 'Ihre Leistung bleibt über Zeit stabil.';
            }
            
            // Empfehlungen basierend auf dem Trend
            let recommendationHTML = '';
            
            if (trend.includes('declining')) {
                recommendationHTML = `
                    <div class="trend-recommendation">
                        <h5>Empfehlung:</h5>
                        <p>Fokussieren Sie sich auf regelmäßiges Lernen und Üben im Bereich ${selectedMetric === 'time' ? 'Testbearbeitung' : selectedMetric === 'accuracy' ? 'Genauigkeit' : 'Gesamtleistung'}.</p>
                    </div>
                `;
            }
            
            infoContainer.innerHTML = `
                <div class="trend-summary ${trendClass}">
                    <span class="trend-icon">${icon}</span>
                    <div class="trend-content">
                        <div class="trend-message">${trendMessage}</div>
                        <div class="trend-description">Trend: ${_formatTrendName(trend)}</div>
                    </div>
                </div>
                ${recommendationHTML}
            `;
        }
        
        container.appendChild(infoContainer);
    }
    
    /**
     * Formatiert einen Trendnamen
     * @private
     * @param {string} trend - Der Trendname
     * @returns {string} Der formatierte Trendname
     */
    function _formatTrendName(trend) {
        if (!trend) return 'Unbekannt';
        
        switch (trend) {
            case 'improving': return 'Stark verbessernd';
            case 'slightly-improving': return 'Leicht verbessernd';
            case 'stable': return 'Stabil';
            case 'slightly-declining': return 'Leicht abnehmend';
            case 'declining': return 'Stark abnehmend';
            default: return trend;
        }
    }
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._renderTrendChart = _renderTrendChart;
    advancedAnalytics._createSingleLineTrendChart = _createSingleLineTrendChart;
    advancedAnalytics._createMultiLineTrendChart = _createMultiLineTrendChart;
    advancedAnalytics._createTrendAnalysisInfo = _createTrendAnalysisInfo;
    advancedAnalytics._formatTrendName = _formatTrendName;
})();
/**
 * @fileoverview JS-Block 6.5.2-part1e-1 - Ergebnisvisualisierung (Prognosediagramme - Teil 1)
 * Dieser Code implementiert die grundlegenden Diagrammfunktionen für Leistungsprognosen.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit Prognosediagrammfunktionen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Rendert das Diagramm für Leistungsprognosen
     * @param {Object} data - Die Prognosedaten
     */
    function _renderPredictionChart(data) {
        console.log('Rendere Prognosediagramm...');
        
        const chartContainer = document.getElementById('predictions-chart');
        if (!chartContainer) {
            console.error('Container für Prognosediagramm nicht gefunden');
            return;
        }
        
        // Container leeren
        chartContainer.innerHTML = '';
        
        // Prüfen, ob Prognosedaten vorhanden sind
        if (!data || !data.timePeriods || data.timePeriods.length === 0) {
            chartContainer.innerHTML = '<div class="no-data-message">Nicht genügend Daten für eine Prognose verfügbar</div>';
            return;
        }
        
        // Prognose-Liniendiagramm erstellen
        _createPredictionLineChart(data, chartContainer);
        
        // Meilensteine anzeigen, falls vorhanden
        if (data.milestones && data.milestones.length > 0) {
            _createMilestonesDisplay(data.milestones, chartContainer);
        }
    }
    
    /**
     * Erstellt ein Liniendiagramm für Prognosen (erster Teil)
     * @private
     * @param {Object} data - Die Prognosedaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _createPredictionLineChart(data, container) {
        if (!container) return;
        
        // Titel hinzufügen
        const titleElement = document.createElement('h5');
        titleElement.className = 'chart-title';
        titleElement.textContent = 'Leistungsprognose für die nächsten Monate';
        container.appendChild(titleElement);
        
        // SVG-Container erstellen
        const svgWidth = container.clientWidth || 600;
        const svgHeight = 300;
        const padding = { top: 30, right: 30, bottom: 70, left: 60 };
        
        // SVG-Element erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        svg.setAttribute('class', 'prediction-chart');
        
        // Daten vorbereiten
        const periods = data.timePeriods;
        const predictedValues = data.score.predicted;
        const lowerBounds = data.score.lower;
        const upperBounds = data.score.upper;
        
        // Min und Max für die Y-Achse bestimmen
        const allValues = [...predictedValues, ...lowerBounds, ...upperBounds];
        const minValue = Math.max(0, Math.floor(Math.min(...allValues) * 0.9));
        const maxValue = Math.min(100, Math.ceil(Math.max(...allValues) * 1.1));
        
        // Skalen definieren
        const xScale = (svgWidth - padding.left - padding.right) / (periods.length - 1);
        const yScale = (svgHeight - padding.top - padding.bottom) / (maxValue - minValue);
        
        // X- und Y-Achsen
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', svgHeight - padding.bottom);
        xAxis.setAttribute('x2', svgWidth - padding.right);
        xAxis.setAttribute('y2', svgHeight - padding.bottom);
        xAxis.setAttribute('stroke', '#ccc');
        xAxis.setAttribute('stroke-width', '1');
        
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', svgHeight - padding.bottom);
        yAxis.setAttribute('stroke', '#ccc');
        yAxis.setAttribute('stroke-width', '1');
        
        svg.appendChild(xAxis);
        svg.appendChild(yAxis);
        
        // Y-Achsen-Beschriftungen
        const ySteps = 5;
        const yStepSize = (maxValue - minValue) / ySteps;
        
        for (let i = 0; i <= ySteps; i++) {
            const value = minValue + i * yStepSize;
            const y = svgHeight - padding.bottom - (value - minValue) * yScale;
            
            const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gridLine.setAttribute('x1', padding.left);
            gridLine.setAttribute('y1', y);
            gridLine.setAttribute('x2', svgWidth - padding.right);
            gridLine.setAttribute('y2', y);
            gridLine.setAttribute('stroke', '#eee');
            gridLine.setAttribute('stroke-width', '1');
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', padding.left - 10);
            label.setAttribute('y', y + 5);
            label.setAttribute('text-anchor', 'end');
            label.setAttribute('font-size', '12');
            label.textContent = Math.round(value) + '%';
            
            svg.appendChild(gridLine);
            svg.appendChild(label);
        }
        
        // Y-Achsen-Beschriftung
        const yAxisLabelElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yAxisLabelElement.setAttribute('x', -svgHeight / 2);
        yAxisLabelElement.setAttribute('y', padding.left / 3);
        yAxisLabelElement.setAttribute('text-anchor', 'middle');
        yAxisLabelElement.setAttribute('font-size', '12');
        yAxisLabelElement.setAttribute('transform', 'rotate(-90)');
        yAxisLabelElement.textContent = 'Prognostizierte Punktzahl (%)';
        
        svg.appendChild(yAxisLabelElement);
        
        // X-Achsen-Beschriftungen
        for (let i = 0; i < periods.length; i++) {
            const x = padding.left + i * xScale;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', svgHeight - padding.bottom + 20);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '12');
            label.textContent = periods[i];
            label.setAttribute('transform', `rotate(45, ${x}, ${svgHeight - padding.bottom + 20})`);
            
            svg.appendChild(label);
        }
        
        // Die zweite Hälfte dieser Funktion wird in part1e-2 fortgesetzt
        // Jetzt speichern wir die Informationen als Daten-Attribute, um sie später zu verwenden
        svg.dataset.svgWidth = svgWidth;
        svg.dataset.svgHeight = svgHeight;
        svg.dataset.paddingLeft = padding.left;
        svg.dataset.paddingRight = padding.right;
        svg.dataset.paddingTop = padding.top;
        svg.dataset.paddingBottom = padding.bottom;
        svg.dataset.xScale = xScale;
        svg.dataset.yScale = yScale;
        svg.dataset.minValue = minValue;
        
        // Diagramm zum Container hinzufügen
        container.appendChild(svg);
        
        // Im zweiten Teil (part1e-2) wird dieses Diagramm mit der Konfidenzintervall-Fläche und
        // der Prognoselinie vervollständigt. Wir speichern einfach die Daten im
        // Container, damit sie dort verfügbar sind.
        container.dataset.predictionChartPrepared = 'true';
    }
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._renderPredictionChart = _renderPredictionChart;
    advancedAnalytics._createPredictionLineChart = _createPredictionLineChart;
})();
/**
 * @fileoverview JS-Block 6.5.2-part1e-2 - Ergebnisvisualisierung (Prognosediagramme - Teil 2)
 * Dieser Code vervollständigt die Diagrammfunktionen für Leistungsprognosen und
 * implementiert die Meilensteinanzeige.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit weiteren Prognosefunktionen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Vervollständigt ein Prognose-Liniendiagramm mit Konfidenzintervallen und Datenlinien
     * @private
     * @param {Object} data - Die Prognosedaten
     * @param {HTMLElement} container - Der Container für das Diagramm
     */
    function _completePredictionChart(data, container) {
        if (!container || !container.dataset.predictionChartPrepared) return;
        
        // Die im ersten Teil vorbereitete SVG finden
        const svg = container.querySelector('svg.prediction-chart');
        if (!svg) return;
        
        // Daten aus dem ersten Teil wiederherstellen
        const svgWidth = parseFloat(svg.dataset.svgWidth);
        const svgHeight = parseFloat(svg.dataset.svgHeight);
        const padding = {
            left: parseFloat(svg.dataset.paddingLeft),
            right: parseFloat(svg.dataset.paddingRight),
            top: parseFloat(svg.dataset.paddingTop),
            bottom: parseFloat(svg.dataset.paddingBottom)
        };
        const xScale = parseFloat(svg.dataset.xScale);
        const yScale = parseFloat(svg.dataset.yScale);
        const minValue = parseFloat(svg.dataset.minValue);
        
        // Daten abrufen
        const periods = data.timePeriods;
        const predictedValues = data.score.predicted;
        const lowerBounds = data.score.lower;
        const upperBounds = data.score.upper;
        
        // Konfidenzintervall-Bereich zeichnen
        let areaPath = '';
        
        // Obere Grenze
        for (let i = 0; i < periods.length; i++) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (upperBounds[i] - minValue) * yScale;
            
            if (i === 0) {
                areaPath = `M ${x} ${y}`;
            } else {
                areaPath += ` L ${x} ${y}`;
            }
        }
        
        // Untere Grenze (rückwärts)
        for (let i = periods.length - 1; i >= 0; i--) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (lowerBounds[i] - minValue) * yScale;
            
            areaPath += ` L ${x} ${y}`;
        }
        
        // Bereich schließen
        areaPath += ' Z';
        
        // Konfidenzintervall-Bereich zeichnen
        const confArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        confArea.setAttribute('d', areaPath);
        confArea.setAttribute('fill', 'rgba(0, 255, 208, 0.2)');
        confArea.setAttribute('class', 'confidence-area');
        
        svg.appendChild(confArea);
        
        // Prognoselinie zeichnen
        let linePath = '';
        
        for (let i = 0; i < periods.length; i++) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (predictedValues[i] - minValue) * yScale;
            
            if (i === 0) {
                linePath = `M ${x} ${y}`;
            } else {
                linePath += ` L ${x} ${y}`;
            }
        }
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', linePath);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#00FFD0');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-dasharray', '5,3');
        path.setAttribute('class', 'prediction-line');
        
        svg.appendChild(path);
        
        // Datenpunkte zeichnen
        for (let i = 0; i < periods.length; i++) {
            const x = padding.left + i * xScale;
            const y = svgHeight - padding.bottom - (predictedValues[i] - minValue) * yScale;
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', '5');
            circle.setAttribute('fill', '#00FFD0');
            circle.setAttribute('stroke', 'white');
            circle.setAttribute('stroke-width', '2');
            circle.setAttribute('class', 'data-point');
            
            // Tooltip für den Datenpunkt
            const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            tooltip.textContent = `${periods[i]}: ${predictedValues[i]}% (${lowerBounds[i]}% - ${upperBounds[i]}%)`;
            circle.appendChild(tooltip);
            
            svg.appendChild(circle);
        }
        
        // Legende erstellen
        const legendY = padding.top;
        
        // Prognose-Legende
        const legendPrediction = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        
        const legendPredictionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        legendPredictionLine.setAttribute('x1', svgWidth - padding.right + 10);
        legendPredictionLine.setAttribute('y1', legendY);
        legendPredictionLine.setAttribute('x2', svgWidth - padding.right + 30);
        legendPredictionLine.setAttribute('y2', legendY);
        legendPredictionLine.setAttribute('stroke', '#00FFD0');
        legendPredictionLine.setAttribute('stroke-width', '3');
        legendPredictionLine.setAttribute('stroke-dasharray', '5,3');
        
        const legendPredictionText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        legendPredictionText.setAttribute('x', svgWidth - padding.right + 35);
        legendPredictionText.setAttribute('y', legendY + 4);
        legendPredictionText.setAttribute('font-size', '12');
        legendPredictionText.textContent = 'Prognose';
        
        legendPrediction.appendChild(legendPredictionLine);
        legendPrediction.appendChild(legendPredictionText);
        
        // Konfidenzintervall-Legende
        const legendInterval = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        
        const legendIntervalRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        legendIntervalRect.setAttribute('x', svgWidth - padding.right + 10);
        legendIntervalRect.setAttribute('y', legendY + 15);
        legendIntervalRect.setAttribute('width', '20');
        legendIntervalRect.setAttribute('height', '10');
        legendIntervalRect.setAttribute('fill', 'rgba(0, 255, 208, 0.2)');
        
        const legendIntervalText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        legendIntervalText.setAttribute('x', svgWidth - padding.right + 35);
        legendIntervalText.setAttribute('y', legendY + 20);
        legendIntervalText.setAttribute('font-size', '12');
        legendIntervalText.textContent = 'Konfidenzintervall';
        
        legendInterval.appendChild(legendIntervalRect);
        legendInterval.appendChild(legendIntervalText);
        
        svg.appendChild(legendPrediction);
        svg.appendChild(legendInterval);
        
        // Datensatz-Attribute entfernen, da wir sie nicht mehr benötigen
        delete svg.dataset.svgWidth;
        delete svg.dataset.svgHeight;
        delete svg.dataset.paddingLeft;
        delete svg.dataset.paddingRight;
        delete svg.dataset.paddingTop;
        delete svg.dataset.paddingBottom;
        delete svg.dataset.xScale;
        delete svg.dataset.yScale;
        delete svg.dataset.minValue;
        
        delete container.dataset.predictionChartPrepared;
        
        // Animation für Linie und Konfidenzintervall
        setTimeout(() => {
            const pathElement = container.querySelector('.prediction-line');
            const areaElement = container.querySelector('.confidence-area');
            
            if (pathElement) {
                const pathLength = pathElement.getTotalLength();
                
                pathElement.style.strokeDasharray = `${pathLength}, ${pathLength}`;
                pathElement.style.strokeDashoffset = pathLength;
                pathElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                pathElement.style.transition = 'stroke-dashoffset 1.5s ease-in-out';
                pathElement.style.strokeDashoffset = '0';
            }
            
            if (areaElement) {
                areaElement.style.opacity = '0';
                areaElement.getBoundingClientRect(); // Layout-Reflow erzwingen
                areaElement.style.transition = 'opacity 1.5s ease-in-out';
                areaElement.style.opacity = '1';
            }
        }, 100);
    }
    
    /**
     * Erstellt eine Anzeige für Meilensteine
     * @private
     * @param {Array} milestones - Die Meilenstein-Daten
     * @param {HTMLElement} container - Der Container für die Anzeige
     */
    function _createMilestonesDisplay(milestones, container) {
        if (!container || !milestones || milestones.length === 0) return;
        
        // Container für Meilensteine erstellen
        const milestonesContainer = document.createElement('div');
        milestonesContainer.className = 'milestones-container';
        milestonesContainer.innerHTML = '<h5>Erwartete Meilensteine</h5>';
        
        // Zeitlinie für Meilensteine erstellen
        const timelineContainer = document.createElement('div');
        timelineContainer.className = 'milestones-timeline';
        
        // Meilensteine sortieren (nach Datum oder Wert)
        const sortedMilestones = [...milestones].sort((a, b) => {
            if (a.value && b.value) {
                return b.value - a.value; // Höhere Werte zuerst
            }
            return 0;
        });
        
        // Meilensteine zur Zeitlinie hinzufügen
        sortedMilestones.forEach(milestone => {
            const milestoneItem = document.createElement('div');
            milestoneItem.className = `milestone-item ${milestone.isWarning ? 'warning' : 'achievement'}`;
            
            const icon = milestone.isWarning ? '⚠️' : '🏆';
            
            milestoneItem.innerHTML = `
                <div class="milestone-icon">${icon}</div>
                <div class="milestone-content">
                    <div class="milestone-title">${milestone.description}</div>
                    <div class="milestone-date">Erwartet: ${milestone.expectedDate}</div>
                </div>
            `;
            
            timelineContainer.appendChild(milestoneItem);
        });
        
        milestonesContainer.appendChild(timelineContainer);
        container.appendChild(milestonesContainer);
        
        // Animation für die Meilensteine
        setTimeout(() => {
            const milestoneItems = container.querySelectorAll('.milestone-item');
            milestoneItems.forEach((item, index) => {
                item.style.opacity = '0';
                item.style.transform = 'translateY(20px)';
                
                setTimeout(() => {
                    item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    item.style.opacity = '1';
                    item.style.transform = 'translateY(0)';
                }, index * 200);
            });
        }, 500);
    }
    
    // Erweitere die _createPredictionLineChart-Funktion, um beide Teile zu verbinden
    const originalCreatePredictionLineChart = advancedAnalytics._createPredictionLineChart;
    advancedAnalytics._createPredictionLineChart = function(data, container) {
        // Der erste Teil erstellt die Grundstruktur und bereitet das SVG vor
        originalCreatePredictionLineChart(data, container);
        
        // Der zweite Teil vervollständigt das Diagramm mit Linien und Konfidenzintervallen
        _completePredictionChart(data, container);
    };
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._completePredictionChart = _completePredictionChart;
    advancedAnalytics._createMilestonesDisplay = _createMilestonesDisplay;
})();
/**
 * @fileoverview JS-Block 6.5.2-part1f - Ergebnisvisualisierung (Erkenntnisse und Integration)
 * Dieser Code implementiert die Erkenntnisanalysen und die Integration mit
 * dem Hauptmodule für die erweiterte Ergebnisvisualisierung.
 * 
 * @module modules/resultVisualization/advancedAnalytics
 * @requires modules/resultVisualization
 * @requires utils/analyticsHelpers
 */

// Erweiterung des advancedAnalytics-Moduls mit Erkenntnisfunktionen
(function() {
    // Referenz zum Hauptmodul
    const advancedAnalytics = app.modules.resultVisualization.advancedAnalytics;
    
    /**
     * Generiert Erkenntnisse und Empfehlungen basierend auf den Analysedaten
     * @param {Object} testResult - Die aktuellen Testergebnisse
     */
    function _generateInsights(testResult) {
        console.log('Generiere Erkenntnisse und Empfehlungen...');
        
        const insightsContainer = document.querySelector('.insights-container');
        if (!insightsContainer) {
            console.error('Container für Erkenntnisse nicht gefunden');
            return;
        }
        
        // Container leeren
        insightsContainer.innerHTML = '<div class="loading-insights">Analysiere Daten...</div>';
        
        // Daten laden
        Promise.all([
            advancedAnalytics._loadHistoricalData(),
            advancedAnalytics._loadComparisonData(),
            advancedAnalytics._loadTrendData(),
            advancedAnalytics._loadPredictionData()
        ]).then(([historicalData, comparisonData, trendData, predictionData]) => {
            // Erkenntnisse erstellen
            const insights = [];
            
            // Historische Trends analysieren
            if (historicalData && historicalData.datasets && historicalData.datasets[0] && historicalData.datasets[0].data) {
                const scoreData = historicalData.datasets[0].data.filter(score => score !== null);
                const trendInfo = advancedAnalytics._analyzeHistoricalTrend(scoreData);
                
                // Einsicht basierend auf dem Trend
                insights.push({
                    type: 'trend',
                    priority: trendInfo.trend.includes('improving') ? 'positive' : (trendInfo.trend.includes('declining') ? 'negative' : 'neutral'),
                    title: 'Trend der Gesamtleistung',
                    description: trendInfo.message,
                    details: `Durchschnittliche Leistung: ${trendInfo.average}%, Bestleistung: ${trendInfo.max}%`
                });
            }
            
            // Vergleichsdaten analysieren
            if (comparisonData && comparisonData.scores) {
                const userScore = comparisonData.scores.user;
                const teamScore = comparisonData.scores.team;
                const departmentScore = comparisonData.scores.department;
                
                // Vergleich mit Team
                if (teamScore) {
                    const diffTeam = userScore - teamScore;
                    const diffPercent = Math.round((diffTeam / teamScore) * 100);
                    
                    let comparisonMessage;
                    let priority;
                    
                    if (diffTeam > 5) {
                        comparisonMessage = `Sie liegen ${diffPercent}% über dem Team-Durchschnitt.`;
                        priority = 'positive';
                    } else if (diffTeam < -5) {
                        comparisonMessage = `Sie liegen ${Math.abs(diffPercent)}% unter dem Team-Durchschnitt.`;
                        priority = 'negative';
                    } else {
                        comparisonMessage = 'Ihre Leistung liegt nahe am Team-Durchschnitt.';
                        priority = 'neutral';
                    }
                    
                    insights.push({
                        type: 'comparison',
                        priority: priority,
                        title: 'Vergleich mit Team',
                        description: comparisonMessage,
                        details: `Ihre Punktzahl: ${userScore}%, Team-Durchschnitt: ${teamScore}%`
                    });
                }
                
                // Vergleich mit Abteilung
                if (departmentScore) {
                    const diffDept = userScore - departmentScore;
                    const diffPercent = Math.round((diffDept / departmentScore) * 100);
                    
                    if (Math.abs(diffDept) > 10) {
                        insights.push({
                            type: 'comparison',
                            priority: diffDept > 0 ? 'positive' : 'negative',
                            title: 'Vergleich mit Abteilung',
                            description: diffDept > 0 
                                ? `Sie gehören zu den überdurchschnittlichen Mitarbeitern in Ihrer Abteilung.`
                                : `Es besteht Potenzial, Ihre Position innerhalb der Abteilung zu verbessern.`,
                            details: `Ihre Punktzahl liegt ${diffDept > 0 ? 'über' : 'unter'} dem Abteilungsdurchschnitt.`
                        });
                    }
                }
                
                // Rangposition analysieren
                if (comparisonData.rankings && comparisonData.rankings.team) {
                    const teamRank = comparisonData.rankings.team;
                    const teamSize = comparisonData.rankings.teamSize;
                    
                    if (teamRank <= 3 && teamSize > 5) {
                        insights.push({
                            type: 'ranking',
                            priority: 'positive',
                            title: 'Herausragende Team-Position',
                            description: `Sie gehören zu den Top ${teamRank} in Ihrem Team!`,
                            details: `Rang ${teamRank} von ${teamSize} Team-Mitgliedern`
                        });
                    }
                }
            }
            
            // Kategoriedaten analysieren
            if (testResult && testResult.categories) {
                const categories = Object.entries(testResult.categories).sort(([, a], [, b]) => {
                    return a.percentageScore - b.percentageScore;
                });
                
                // Schwächste Kategorie identifizieren
                if (categories.length > 0) {
                    const [weakestCategory, weakestData] = categories[0];
                    
                    if (weakestData.percentageScore < 70) {
                        insights.push({
                            type: 'improvement',
                            priority: 'action',
                            title: 'Verbesserungspotenzial identifiziert',
                            description: `Fokussieren Sie Ihr Lernen auf den Bereich "${weakestCategory}".`,
                            details: `Aktuelle Leistung in diesem Bereich: ${Math.round(weakestData.percentageScore)}%`
                        });
                    }
                    
                    // Stärkste Kategorie identifizieren
                    const [strongestCategory, strongestData] = categories[categories.length - 1];
                    
                    if (strongestData.percentageScore > 85) {
                        insights.push({
                            type: 'strength',
                            priority: 'positive',
                            title: 'Identifizierte Stärke',
                            description: `Sie zeigen hervorragende Leistungen im Bereich "${strongestCategory}".`,
                            details: `Aktuelle Leistung in diesem Bereich: ${Math.round(strongestData.percentageScore)}%`
                        });
                    }
                }
            }
            
            // Prognosedaten analysieren
            if (predictionData && predictionData.score && predictionData.score.trend) {
                const trend = predictionData.score.trend;
                
                // Zukunftsprognose
                insights.push({
                    type: 'prediction',
                    priority: trend.includes('improving') ? 'positive' : (trend.includes('declining') ? 'negative' : 'neutral'),
                    title: 'Leistungsprognose',
                    description: trend.includes('improving')
                        ? 'Basierend auf Ihrem Lernverlauf wird sich Ihre Leistung voraussichtlich weiter verbessern.'
                        : (trend.includes('declining')
                            ? 'Ihre Leistungskurve zeigt einen leichten Abwärtstrend. Zusätzlicher Lernaufwand könnte hilfreich sein.'
                            : 'Ihre Leistung wird voraussichtlich auf dem aktuellen Niveau stabil bleiben.'),
                    details: predictionData.milestones && predictionData.milestones.length > 0
                        ? `Nächster Meilenstein: ${predictionData.milestones[0].description} voraussichtlich im ${predictionData.milestones[0].expectedDate}`
                        : 'Keine spezifischen Meilensteine prognostiziert.'
                });
            }
            
            // Fallback, wenn keine Erkenntnisse generiert wurden
            if (insights.length === 0) {
                insights.push({
                    type: 'general',
                    priority: 'neutral',
                    title: 'Erste Analysen',
                    description: 'Mit mehr Testdaten können wir detaillierte Erkenntnisse über Ihre Leistung gewinnen.',
                    details: 'Führen Sie weitere Tests durch, um Ihre Leistungsentwicklung zu verfolgen.'
                });
            }
            
            // Erkenntnisse anzeigen
            _renderInsights(insights, insightsContainer);
        }).catch(error => {
            console.error('Fehler beim Laden der Analysedaten:', error);
            insightsContainer.innerHTML = '<div class="error-message">Fehler beim Laden der Analysedaten</div>';
        });
    }
    
    /**
     * Rendert die generierten Erkenntnisse im UI
     * @private
     * @param {Array} insights - Die generierten Erkenntnisse
     * @param {HTMLElement} container - Der Container für die Erkenntnisse
     */
    function _renderInsights(insights, container) {
        // Container leeren
        container.innerHTML = '';
        
        // Erkenntnisse hinzufügen
        insights.forEach(insight => {
            const insightElement = document.createElement('div');
            insightElement.className = `insight-item ${insight.priority}`;
            
            // Icon basierend auf Typ und Priorität
            let icon;
            switch (insight.type) {
                case 'trend':
                    icon = insight.priority === 'positive' ? '📈' : (insight.priority === 'negative' ? '📉' : '📊');
                    break;
                case 'comparison':
                    icon = insight.priority === 'positive' ? '🏆' : (insight.priority === 'negative' ? '📋' : '📊');
                    break;
                case 'improvement':
                    icon = '🎯';
                    break;
                case 'strength':
                    icon = '💪';
                    break;
                case 'ranking':
                    icon = '🏅';
                    break;
                case 'prediction':
                    icon = insight.priority === 'positive' ? '🚀' : (insight.priority === 'negative' ? '⚠️' : '📆');
                    break;
                default:
                    icon = '💡';
            }
            
            insightElement.innerHTML = `
                <div class="insight-icon">${icon}</div>
                <div class="insight-content">
                    <h4 class="insight-title">${insight.title}</h4>
                    <p class="insight-description">${insight.description}</p>
                    <div class="insight-details">${insight.details || ''}</div>
                </div>
            `;
            
            container.appendChild(insightElement);
        });
        
        // Animation für die Erkenntnisse
        const insightItems = container.querySelectorAll('.insight-item');
        insightItems.forEach((item, index) => {
            item.style.opacity = '0';
            item.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                item.style.opacity = '1';
                item.style.transform = 'translateY(0)';
            }, index * 150);
        });
    }
    
    // Erweitere das Modul mit zusätzlichen Funktionalitäten
    
    /**
     * Aktualisiert alle Analysen bei Bedarf
     * @param {boolean} forceRefresh - Zwinge eine Aktualisierung, auch wenn Daten im Cache sind
     */
    function refreshAllAnalytics(forceRefresh = false) {
        console.log('Aktualisiere alle Analysen...');
        
        // Bei Bedarf Cache leeren
        if (forceRefresh) {
            advancedAnalytics._analyticsCache.historicalData.clear();
            advancedAnalytics._analyticsCache.comparisonData.clear();
            advancedAnalytics._analyticsCache.trendData.clear();
            advancedAnalytics._analyticsCache.predictionData.clear();
        }
        
        // Aktiven Tab ermitteln
        const activeTab = document.querySelector('.analytics-tabs .tab-btn.active');
        if (activeTab) {
            advancedAnalytics._updateTabContent(activeTab.dataset.tab);
        } else {
            // Standardmäßig den historischen Tab aktualisieren
            advancedAnalytics._updateTabContent('historical');
        }
        
        // Erkenntnisse aktualisieren
        if (advancedAnalytics._currentTestResult) {
            _generateInsights(advancedAnalytics._currentTestResult);
        }
    }
    
    /**
     * Exportiert Analysedaten als JSON
     */
    function exportAnalytics() {
        console.log('Exportiere Analysedaten...');
        
        // Analysedaten sammeln
        Promise.all([
            advancedAnalytics._loadHistoricalData(),
            advancedAnalytics._loadComparisonData(),
            advancedAnalytics._loadTrendData(),
            advancedAnalytics._loadPredictionData()
        ]).then(([historicalData, comparisonData, trendData, predictionData]) => {
            // Daten zusammenführen
            const exportData = {
                historicalData,
                comparisonData,
                trendData,
                predictionData,
                exportDate: new Date().toISOString(),
                user: app.getCurrentUser().id
            };
            
            // Als JSON exportieren
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            // Download initiieren
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(dataBlob);
            downloadLink.download = `analytics-export-${new Date().toISOString().slice(0, 10)}.json`;
            downloadLink.style.display = 'none';
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            
            // Aufräumen
            setTimeout(() => {
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(downloadLink.href);
            }, 100);
        }).catch(error => {
            console.error('Fehler beim Exportieren der Analysedaten:', error);
            alert('Fehler beim Exportieren der Analysedaten');
        });
    }
    
    // Integration mit dem Hauptmodul
    
    // Speichere das aktuelle Testergebnis
    advancedAnalytics._currentTestResult = null;
    
    // Event-Handler für abgeschlossene Visualisierungen aktualisieren
    const originalHandleVisualizationComplete = advancedAnalytics._handleVisualizationComplete;
    advancedAnalytics._handleVisualizationComplete = function(event) {
        // Zuerst den ursprünglichen Handler aufrufen
        originalHandleVisualizationComplete(event);
        
        // Dann das aktuelle Testergebnis speichern
        if (event && event.detail && event.detail.testResult) {
            advancedAnalytics._currentTestResult = event.detail.testResult;
            
            // Erkenntnisse generieren
            _generateInsights(event.detail.testResult);
        }
    };
    
    // Funktionen beim Modul registrieren
    advancedAnalytics._generateInsights = _generateInsights;
    advancedAnalytics._renderInsights = _renderInsights;
    advancedAnalytics.refreshAllAnalytics = refreshAllAnalytics;
    advancedAnalytics.exportAnalytics = exportAnalytics;
    
    // Zusätzliche UI-Elemente für Analysesteuerung hinzufügen
    function _addAnalyticsControls() {
        const analyticsContainer = document.getElementById('advanced-analytics-container');
        if (!analyticsContainer) return;
        
        // Container für Kontrolloptionen suchen oder erstellen
        let controlsContainer = analyticsContainer.querySelector('.analytics-controls');
        if (!controlsContainer) {
            controlsContainer = document.createElement('div');
            controlsContainer.className = 'analytics-controls';
            
            // Nach dem Header einfügen
            const header = analyticsContainer.querySelector('.analytics-header');
            if (header) {
                header.appendChild(controlsContainer);
            } else {
                analyticsContainer.insertBefore(controlsContainer, analyticsContainer.firstChild);
            }
        }
        
        // Export-Button hinzufügen
        const exportButton = document.createElement('button');
        exportButton.className = 'btn btn-secondary export-analytics-btn';
        exportButton.innerHTML = '<span class="icon">📤</span> Exportieren';
        exportButton.addEventListener('click', exportAnalytics);
        
        // Aktualisieren-Button hinzufügen
        const refreshButton = document.createElement('button');
        refreshButton.className = 'btn btn-secondary refresh-analytics-btn';
        refreshButton.innerHTML = '<span class="icon">🔄</span> Aktualisieren';
        refreshButton.addEventListener('click', () => refreshAllAnalytics(true));
        
        // Buttons zum Container hinzufügen
        controlsContainer.appendChild(exportButton);
        controlsContainer.appendChild(refreshButton);
    }
    
    // Bei Initialisierung die Analysesteuerungen hinzufügen
    const originalInit = advancedAnalytics.init;
    advancedAnalytics.init = function(options = {}) {
        // Zuerst die ursprüngliche Initialisierung durchführen
        originalInit(options);
        
        // Dann die Analysesteuerungen hinzufügen
        setTimeout(_addAnalyticsControls, 500);
    };
})();

// Initialisierung des gesamten Moduls
document.addEventListener('appInitialized', function() {
    // Starten des Haupt-Ergebnisvisualisierungsmoduls
    app.modules.resultVisualization.init();
    
    // Starten der erweiterten Analysen
    app.modules.resultVisualization.advancedAnalytics.init();
    
    console.log('Ergebnisvisualisierung und erweiterte Analysen initialisiert');
});
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.1 - Interaktiver Datenexplorer
 * @module js/modules/results/visualization/advanced-explorer
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/chart-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für den interaktiven Datenexplorer erstellen
App.Modules.Results = App.Modules.Results || {};
App.Modules.Results.Visualization = App.Modules.Results.Visualization || {};

/**
 * Interaktiver Datenexplorer für detaillierte Analysen und benutzerdefinierte Visualisierungen
 * @namespace
 */
App.Modules.Results.Visualization.Explorer = (function() {
    // Private Variablen
    let _currentDataset = null;
    let _filterSettings = {
        dateRange: {
            start: null,
            end: null
        },
        userGroups: [],
        testTypes: [],
        categories: [],
        performanceLevel: 'all', // 'all', 'high', 'medium', 'low'
        sortBy: 'date', // 'date', 'score', 'name'
        sortDirection: 'desc', // 'asc', 'desc'
        viewMode: 'chart', // 'chart', 'table', 'hybrid'
        chartType: 'bar' // 'bar', 'line', 'radar', 'pie', 'polar', 'heatmap'
    };
    let _activeChartInstances = [];
    let _dataCache = {};
    
    // DOM-Element-Referenzen
    let _elements = {
        container: null,
        filterPanel: null,
        chartContainer: null,
        tableContainer: null,
        controlPanel: null,
        loadingIndicator: null,
        errorMessage: null,
        noDataMessage: null
    };
    
    /**
     * Initialisiert den Datenexplorer und seine UI-Komponenten
     * @param {HTMLElement} container - Container-Element für den Explorer
     * @returns {void}
     */
    function initialize(container) {
        if (!container) {
            throw new Error('Container-Element ist erforderlich');
        }
        
        _elements.container = container;
        
        // Basisstruktur erstellen
        _createBaseStructure();
        
        // Event-Listener registrieren
        _setupEventListeners();
        
        // Standardfilter und -einstellungen laden
        _loadDefaultSettings();
        
        // Anfängliche Daten laden
        _loadInitialData();
        
        console.log('Datenexplorer initialisiert');
    }
    
    /**
     * Erstellt die grundlegende DOM-Struktur für den Explorer
     * @private
     * @returns {void}
     */
    function _createBaseStructure() {
        // CSS-Klassen für responsive Design und ImmoScout24 Styling
        _elements.container.classList.add('is24-data-explorer', 'is24-card', 'is24-shadow-md');
        
        // HTML-Struktur für den Explorer
        _elements.container.innerHTML = `
            <div class="is24-explorer-header">
                <h2 class="is24-heading-md">Datenexplorer</h2>
                <div class="is24-explorer-controls">
                    <button class="is24-btn is24-btn-sm is24-btn-secondary" id="explorerFullscreen">
                        <i class="is24-icon is24-icon-fullscreen"></i>
                    </button>
                    <button class="is24-btn is24-btn-sm is24-btn-secondary" id="explorerHelp">
                        <i class="is24-icon is24-icon-help"></i>
                    </button>
                </div>
            </div>
            
            <div class="is24-explorer-body">
                <div class="is24-explorer-sidebar" id="explorerFilterPanel">
                    <div class="is24-explorer-filter-section">
                        <h3 class="is24-heading-sm">Zeitraum</h3>
                        <div class="is24-form-group">
                            <label for="explorerDateStart">Von</label>
                            <input type="date" id="explorerDateStart" class="is24-form-control">
                        </div>
                        <div class="is24-form-group">
                            <label for="explorerDateEnd">Bis</label>
                            <input type="date" id="explorerDateEnd" class="is24-form-control">
                        </div>
                    </div>
                    
                    <div class="is24-explorer-filter-section">
                        <h3 class="is24-heading-sm">Benutzergruppen</h3>
                        <div class="is24-form-group" id="explorerUserGroups">
                            <!-- Dynamisch generierte Checkboxen -->
                        </div>
                    </div>
                    
                    <div class="is24-explorer-filter-section">
                        <h3 class="is24-heading-sm">Testtypen</h3>
                        <div class="is24-form-group" id="explorerTestTypes">
                            <!-- Dynamisch generierte Checkboxen -->
                        </div>
                    </div>
                    
                    <div class="is24-explorer-filter-section">
                        <h3 class="is24-heading-sm">Kategorien</h3>
                        <div class="is24-form-group" id="explorerCategories">
                            <!-- Dynamisch generierte Checkboxen -->
                        </div>
                    </div>
                    
                    <div class="is24-explorer-filter-section">
                        <h3 class="is24-heading-sm">Leistungsniveau</h3>
                        <div class="is24-form-group">
                            <select id="explorerPerformanceLevel" class="is24-form-control">
                                <option value="all">Alle Niveaus</option>
                                <option value="high">Hoch (≥80%)</option>
                                <option value="medium">Mittel (50-79%)</option>
                                <option value="low">Niedrig (<50%)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="is24-explorer-filter-section">
                        <button id="explorerApplyFilters" class="is24-btn is24-btn-primary is24-btn-block">
                            Filter anwenden
                        </button>
                        <button id="explorerResetFilters" class="is24-btn is24-btn-secondary is24-btn-block is24-mt-2">
                            Zurücksetzen
                        </button>
                    </div>
                </div>
                
                <div class="is24-explorer-content">
                    <div class="is24-explorer-toolbar">
                        <div class="is24-explorer-view-controls">
                            <button class="is24-btn is24-btn-icon is24-btn-active" data-view="chart">
                                <i class="is24-icon is24-icon-chart-bar"></i>
                            </button>
                            <button class="is24-btn is24-btn-icon" data-view="table">
                                <i class="is24-icon is24-icon-table"></i>
                            </button>
                            <button class="is24-btn is24-btn-icon" data-view="hybrid">
                                <i class="is24-icon is24-icon-split-view"></i>
                            </button>
                        </div>
                        
                        <div class="is24-explorer-chart-controls">
                            <select id="explorerChartType" class="is24-form-control is24-form-control-sm">
                                <option value="bar">Balkendiagramm</option>
                                <option value="line">Liniendiagramm</option>
                                <option value="radar">Radardiagramm</option>
                                <option value="pie">Kreisdiagramm</option>
                                <option value="polar">Polardiagramm</option>
                                <option value="heatmap">Heatmap</option>
                            </select>
                            
                            <select id="explorerSortBy" class="is24-form-control is24-form-control-sm">
                                <option value="date">Nach Datum</option>
                                <option value="score">Nach Punktzahl</option>
                                <option value="name">Nach Name</option>
                            </select>
                            
                            <button id="explorerSortDirection" class="is24-btn is24-btn-icon is24-btn-sm" title="Sortierreihenfolge umkehren">
                                <i class="is24-icon is24-icon-sort-desc"></i>
                            </button>
                        </div>
                        
                        <div class="is24-explorer-export-controls">
                            <button id="explorerExportPdf" class="is24-btn is24-btn-sm is24-btn-secondary">
                                PDF exportieren
                            </button>
                            <button id="explorerExportCsv" class="is24-btn is24-btn-sm is24-btn-secondary">
                                CSV exportieren
                            </button>
                            <button id="explorerShare" class="is24-btn is24-btn-sm is24-btn-secondary">
                                <i class="is24-icon is24-icon-share"></i> Teilen
                            </button>
                        </div>
                    </div>
                    
                    <div id="explorerVisualizationContainer" class="is24-explorer-visualization">
                        <div id="explorerChartContainer" class="is24-explorer-chart-container">
                            <!-- Diagramme werden hier gerendert -->
                        </div>
                        <div id="explorerTableContainer" class="is24-explorer-table-container is24-hidden">
                            <!-- Tabelle wird hier gerendert -->
                        </div>
                    </div>
                    
                    <div id="explorerLoadingIndicator" class="is24-explorer-loading is24-hidden">
                        <div class="is24-spinner"></div>
                        <p>Daten werden geladen...</p>
                    </div>
                    
                    <div id="explorerErrorMessage" class="is24-explorer-error is24-hidden">
                        <i class="is24-icon is24-icon-error is24-text-error"></i>
                        <p>Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.</p>
                    </div>
                    
                    <div id="explorerNoDataMessage" class="is24-explorer-no-data is24-hidden">
                        <i class="is24-icon is24-icon-info is24-text-info"></i>
                        <p>Keine Daten für die ausgewählten Filter gefunden.</p>
                    </div>
                </div>
            </div>
        `;
        
        // DOM-Element-Referenzen speichern
        _elements.filterPanel = document.getElementById('explorerFilterPanel');
        _elements.chartContainer = document.getElementById('explorerChartContainer');
        _elements.tableContainer = document.getElementById('explorerTableContainer');
        _elements.loadingIndicator = document.getElementById('explorerLoadingIndicator');
        _elements.errorMessage = document.getElementById('explorerErrorMessage');
        _elements.noDataMessage = document.getElementById('explorerNoDataMessage');
    }
    
    /**
     * Richtet Event-Listener für UI-Interaktionen ein
     * @private
     * @returns {void}
     */
    function _setupEventListeners() {
        // Filter anwenden
        const applyFiltersBtn = document.getElementById('explorerApplyFilters');
        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', _handleApplyFilters);
        }
        
        // Filter zurücksetzen
        const resetFiltersBtn = document.getElementById('explorerResetFilters');
        if (resetFiltersBtn) {
            resetFiltersBtn.addEventListener('click', _handleResetFilters);
        }
        
        // Ansichtsmodus wechseln
        const viewButtons = document.querySelectorAll('[data-view]');
        viewButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                _handleViewModeChange(e.currentTarget.getAttribute('data-view'));
            });
        });
        
        // Diagrammtyp ändern
        const chartTypeSelect = document.getElementById('explorerChartType');
        if (chartTypeSelect) {
            chartTypeSelect.addEventListener('change', (e) => {
                _handleChartTypeChange(e.target.value);
            });
        }
        
        // Sortierung ändern
        const sortBySelect = document.getElementById('explorerSortBy');
        if (sortBySelect) {
            sortBySelect.addEventListener('change', (e) => {
                _handleSortByChange(e.target.value);
            });
        }
        
        // Sortierrichtung umkehren
        const sortDirectionBtn = document.getElementById('explorerSortDirection');
        if (sortDirectionBtn) {
            sortDirectionBtn.addEventListener('click', _handleSortDirectionToggle);
        }
        
        // Vollbildmodus
        const fullscreenBtn = document.getElementById('explorerFullscreen');
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', _handleFullscreenToggle);
        }
        
        // Hilfe-Dialog
        const helpBtn = document.getElementById('explorerHelp');
        if (helpBtn) {
            helpBtn.addEventListener('click', _showHelpDialog);
        }
        
        // Export-Buttons
        const exportPdfBtn = document.getElementById('explorerExportPdf');
        if (exportPdfBtn) {
            exportPdfBtn.addEventListener('click', _handlePdfExport);
        }
        
        const exportCsvBtn = document.getElementById('explorerExportCsv');
        if (exportCsvBtn) {
            exportCsvBtn.addEventListener('click', _handleCsvExport);
        }
        
        // Teilen-Button
        const shareBtn = document.getElementById('explorerShare');
        if (shareBtn) {
            shareBtn.addEventListener('click', _handleShare);
        }
    }
    
    /**
     * Lädt Standardfilter und -einstellungen
     * @private
     * @returns {void}
     */
    function _loadDefaultSettings() {
        // Aktuelles Datum für Standardzeitraum verwenden
        const today = new Date();
        const threeMonthsAgo = new Date();
        threeMonthsAgo.setMonth(today.getMonth() - 3);
        
        // Formatieren für Datumseingabefelder
        const formatDate = (date) => {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        };
        
        // Datumsfelder mit Standardwerten füllen
        const startDateInput = document.getElementById('explorerDateStart');
        const endDateInput = document.getElementById('explorerDateEnd');
        
        if (startDateInput && endDateInput) {
            startDateInput.value = formatDate(threeMonthsAgo);
            endDateInput.value = formatDate(today);
            
            // Filtereinstellungen aktualisieren
            _filterSettings.dateRange.start = threeMonthsAgo;
            _filterSettings.dateRange.end = today;
        }
        
        // Verfügbare Benutzergruppen laden und Checkboxen erstellen
        _loadUserGroups();
        
        // Verfügbare Testtypen laden und Checkboxen erstellen
        _loadTestTypes();
        
        // Verfügbare Kategorien laden und Checkboxen erstellen
        _loadCategories();
    }
    
    /**
     * Lädt verfügbare Benutzergruppen und erstellt Checkboxen
     * @private
     * @returns {void}
     */
    function _loadUserGroups() {
        const container = document.getElementById('explorerUserGroups');
        if (!container) return;
        
        // Benutzergruppen aus der Datenverwaltung abrufen
        const userGroups = App.Modules.Results.DataManager.getUserGroups();
        
        if (userGroups && userGroups.length > 0) {
            // Checkboxen für jede Benutzergruppe erstellen
            userGroups.forEach(group => {
                const checkbox = document.createElement('div');
                checkbox.className = 'is24-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="userGroup_${group.id}" value="${group.id}" class="explorer-user-group">
                    <label for="userGroup_${group.id}">${group.name}</label>
                `;
                container.appendChild(checkbox);
            });
            
            // Event-Listener für Checkboxen hinzufügen
            const checkboxes = container.querySelectorAll('.explorer-user-group');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', _updateUserGroupFilters);
            });
        } else {
            // Keine Benutzergruppen gefunden
            container.innerHTML = '<p class="is24-text-muted">Keine Benutzergruppen verfügbar</p>';
        }
    }
    
    /**
     * Lädt verfügbare Testtypen und erstellt Checkboxen
     * @private
     * @returns {void}
     */
    function _loadTestTypes() {
        const container = document.getElementById('explorerTestTypes');
        if (!container) return;
        
        // Testtypen aus der Datenverwaltung abrufen
        const testTypes = App.Modules.Results.DataManager.getTestTypes();
        
        if (testTypes && testTypes.length > 0) {
            // Checkboxen für jeden Testtyp erstellen
            testTypes.forEach(type => {
                const checkbox = document.createElement('div');
                checkbox.className = 'is24-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="testType_${type.id}" value="${type.id}" class="explorer-test-type">
                    <label for="testType_${type.id}">${type.name}</label>
                `;
                container.appendChild(checkbox);
            });
            
            // Event-Listener für Checkboxen hinzufügen
            const checkboxes = container.querySelectorAll('.explorer-test-type');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', _updateTestTypeFilters);
            });
        } else {
            // Keine Testtypen gefunden
            container.innerHTML = '<p class="is24-text-muted">Keine Testtypen verfügbar</p>';
        }
    }
    
    /**
     * Lädt verfügbare Kategorien und erstellt Checkboxen
     * @private
     * @returns {void}
     */
    function _loadCategories() {
        const container = document.getElementById('explorerCategories');
        if (!container) return;
        
        // Kategorien aus der Datenverwaltung abrufen
        const categories = App.Modules.Results.DataManager.getCategories();
        
        if (categories && categories.length > 0) {
            // Checkboxen für jede Kategorie erstellen
            categories.forEach(category => {
                const checkbox = document.createElement('div');
                checkbox.className = 'is24-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox" id="category_${category.id}" value="${category.id}" class="explorer-category">
                    <label for="category_${category.id}">${category.name}</label>
                `;
                container.appendChild(checkbox);
            });
            
            // Event-Listener für Checkboxen hinzufügen
            const checkboxes = container.querySelectorAll('.explorer-category');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', _updateCategoryFilters);
            });
        } else {
            // Keine Kategorien gefunden
            container.innerHTML = '<p class="is24-text-muted">Keine Kategorien verfügbar</p>';
        }
    }
    
    /**
     * Lädt anfängliche Daten basierend auf Standardeinstellungen
     * @private
     * @returns {void}
     */
    function _loadInitialData() {
        _showLoading();
        
        // Daten basierend auf aktuellen Filtereinstellungen laden
        App.Modules.Results.DataManager.getFilteredResults(_filterSettings)
            .then(data => {
                _currentDataset = data;
                _renderVisualization();
                _hideLoading();
            })
            .catch(error => {
                console.error('Fehler beim Laden der Daten:', error);
                _showError();
            });
    }
    
    // Weitere Hilfsfunktionen
    
    /**
     * Aktualisiert die Benutzergruppen-Filter basierend auf Checkbox-Auswahl
     * @private
     * @returns {void}
     */
    function _updateUserGroupFilters() {
        const selectedGroups = [];
        const checkboxes = document.querySelectorAll('.explorer-user-group:checked');
        
        checkboxes.forEach(checkbox => {
            selectedGroups.push(checkbox.value);
        });
        
        _filterSettings.userGroups = selectedGroups;
    }
    
    /**
     * Aktualisiert die Testtyp-Filter basierend auf Checkbox-Auswahl
     * @private
     * @returns {void}
     */
    function _updateTestTypeFilters() {
        const selectedTypes = [];
        const checkboxes = document.querySelectorAll('.explorer-test-type:checked');
        
        checkboxes.forEach(checkbox => {
            selectedTypes.push(checkbox.value);
        });
        
        _filterSettings.testTypes = selectedTypes;
    }
    
    /**
     * Aktualisiert die Kategorie-Filter basierend auf Checkbox-Auswahl
     * @private
     * @returns {void}
     */
    function _updateCategoryFilters() {
        const selectedCategories = [];
        const checkboxes = document.querySelectorAll('.explorer-category:checked');
        
        checkboxes.forEach(checkbox => {
            selectedCategories.push(checkbox.value);
        });
        
        _filterSettings.categories = selectedCategories;
    }
    
    /**
     * Behandelt das Anwenden der Filter
     * @private
     * @returns {void}
     */
    function _handleApplyFilters() {
        // Datumsbereich aus Eingabefeldern holen
        const startDateInput = document.getElementById('explorerDateStart');
        const endDateInput = document.getElementById('explorerDateEnd');
        
        if (startDateInput && endDateInput) {
            _filterSettings.dateRange.start = startDateInput.value ? new Date(startDateInput.value) : null;
            _filterSettings.dateRange.end = endDateInput.value ? new Date(endDateInput.value) : null;
        }
        
        // Leistungsniveau aus Select holen
        const performanceLevelSelect = document.getElementById('explorerPerformanceLevel');
        if (performanceLevelSelect) {
            _filterSettings.performanceLevel = performanceLevelSelect.value;
        }
        
        // Benutzergruppen-, Testtyp- und Kategoriefilter aktualisieren
        _updateUserGroupFilters();
        _updateTestTypeFilters();
        _updateCategoryFilters();
        
        // Daten neu laden und Visualisierungen aktualisieren
        _refreshData();
    }
    
    /**
     * Setzt alle Filter auf Standardwerte zurück
     * @private
     * @returns {void}
     */
    function _handleResetFilters() {
        // Standardeinstellungen wiederherstellen
        _loadDefaultSettings();
        
        // Alle Checkboxen zurücksetzen
        document.querySelectorAll('.explorer-user-group, .explorer-test-type, .explorer-category').forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Leistungsniveau zurücksetzen
        const performanceLevelSelect = document.getElementById('explorerPerformanceLevel');
        if (performanceLevelSelect) {
            performanceLevelSelect.value = 'all';
        }
        
        // Filtereinstellungen zurücksetzen
        _filterSettings.userGroups = [];
        _filterSettings.testTypes = [];
        _filterSettings.categories = [];
        _filterSettings.performanceLevel = 'all';
        
        // Daten neu laden und Visualisierungen aktualisieren
        _refreshData();
    }
    
    // Setter- und Getter-Methoden, die öffentlich verfügbar sein sollen
    
    return {
        initialize: initialize,
        
        // Öffentliche API
        setFilterSettings: function(settings) {
            Object.assign(_filterSettings, settings);
            _refreshData();
        },
        
        getFilterSettings: function() {
            return Object.assign({}, _filterSettings);
        },
        
        getCurrentDataset: function() {
            return _currentDataset;
        },
        
        refreshData: _refreshData
    };
    
    /**
     * Lädt Daten basierend auf aktuellen Filtereinstellungen neu
     * @private
     * @returns {void}
     */
    function _refreshData() {
        _showLoading();
        
        App.Modules.Results.DataManager.getFilteredResults(_filterSettings)
            .then(data => {
                _currentDataset = data;
                _renderVisualization();
                _hideLoading();
            })
            .catch(error => {
                console.error('Fehler beim Laden der Daten:', error);
                _showError();
            });
    }
    
    /**
     * Rendert die Visualisierung basierend auf dem aktuellen Datensatz und den Einstellungen
     * @private
     * @returns {void}
     */
    function _renderVisualization() {
        // Aufräumen vorheriger Visualisierungen
        _cleanupCharts();
        
        if (!_currentDataset || _currentDataset.length === 0) {
            _showNoDataMessage();
            return;
        }
        
        _hideNoDataMessage();
        _hideError();
        
        // Je nach Ansichtsmodus die entsprechende Visualisierung rendern
        switch (_filterSettings.viewMode) {
            case 'chart':
                _renderChart();
                _hideTable();
                break;
            case 'table':
                _renderTable();
                _hideChart();
                break;
            case 'hybrid':
                _renderChart();
                _renderTable();
                _showHybridView();
                break;
            default:
                _renderChart();
                _hideTable();
        }
    }
    
    /**
     * Rendert das entsprechende Diagramm basierend auf dem gewählten Typ
     * @private
     * @returns {void}
     */
    function _renderChart() {
        const chartContainer = document.getElementById('explorerChartContainer');
        if (!chartContainer) return;
        
        // Diagramm-Container anzeigen
        chartContainer.classList.remove('is24-hidden');
        
        // Basierend auf dem gewählten Diagrammtyp das entsprechende Diagramm rendern
        switch (_filterSettings.chartType) {
            case 'bar':
                _renderBarChart(chartContainer);
                break;
            case 'line':
                _renderLineChart(chartContainer);
                break;
            case 'radar':
                _renderRadarChart(chartContainer);
                break;
            case 'pie':
                _renderPieChart(chartContainer);
                break;
            case 'polar':
                _renderPolarChart(chartContainer);
                break;
            case 'heatmap':
                _renderHeatmapChart(chartContainer);
                break;
            default:
                _renderBarChart(chartContainer);
        }
    }
    
    /**
     * Rendert das Balkendiagramm
     * @private
     * @param {HTMLElement} container - Container für das Diagramm
     * @returns {void}
     */
    function _renderBarChart(container) {
        // Implementierung des Balkendiagramms mit Chart.js
        // Mockup für die Implementierung
        const canvas = document.createElement('canvas');
        canvas.id = 'explorerBarChart';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'bar',
            data: _prepareBarChartData(),
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Ergebnisverteilung'
                    },
                    legend: {
                        position: 'top',
                    }
                }
            }
        });
        
        // Diagramminstanz für spätere Bereinigung speichern
        _activeChartInstances.push(chartInstance);
    }
    
    /**
     * Bereitet Daten für das Balkendiagramm vor
     * @private
     * @returns {Object} - Aufbereitete Daten für Chart.js
     */
    function _prepareBarChartData() {
        // Daten für das Balkendiagramm aufbereiten
        // Mockup für die Datenstruktur
        return {
            labels: _currentDataset.map(item => item.label || 'Unbenannt'),
            datasets: [{
                label: 'Ergebnisse',
                data: _currentDataset.map(item => item.score || 0),
                backgroundColor: 'rgba(0, 255, 208, 0.6)',
                borderColor: 'rgba(0, 255, 208, 1)',
                borderWidth: 1
            }]
        };
    }
    
    /**
     * Rendert eine Tabelle mit den Daten
     * @private
     * @returns {void}
     */
    function _renderTable() {
        const tableContainer = document.getElementById('explorerTableContainer');
        if (!tableContainer) return;
        
        // Tabellen-Container anzeigen
        tableContainer.classList.remove('is24-hidden');
        
        // Tabelle erstellen
        const table = document.createElement('table');
        table.className = 'is24-table is24-table-striped is24-table-hover is24-w-full';
        
        // Tabellen-Header erstellen
        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr>
                <th>Name</th>
                <th>Datum</th>
                <th>Testtyp</th>
                <th>Kategorie</th>
                <th>Punktzahl</th>
                <th>Status</th>
                <th>Aktionen</th>
            </tr>
        `;
        table.appendChild(thead);
        
        // Tabellen-Body erstellen
        const tbody = document.createElement('tbody');
        
        if (_currentDataset && _currentDataset.length > 0) {
            _currentDataset.forEach(item => {
                const row = document.createElement('tr');
                
                // Datum formatieren
                const date = new Date(item.date);
                const formattedDate = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()}`;
                
                // Status basierend auf Punktzahl bestimmen
                let status = 'Nicht bestanden';
                let statusClass = 'is24-badge-error';
                
                if (item.score >= 80) {
                    status = 'Bestanden';
                    statusClass = 'is24-badge-success';
                } else if (item.score >= 50) {
                    status = 'Teilweise bestanden';
                    statusClass = 'is24-badge-warning';
                }
                
                // Zeile mit Daten füllen
                row.innerHTML = `
                    <td>${item.username || 'Unbekannt'}</td>
                    <td>${formattedDate}</td>
                    <td>${item.testType || 'Unbekannt'}</td>
                    <td>${item.category || 'Keine Kategorie'}</td>
                    <td>${item.score ? item.score.toFixed(1) + '%' : '0%'}</td>
                    <td><span class="is24-badge ${statusClass}">${status}</span></td>
                    <td>
                        <button class="is24-btn is24-btn-icon is24-btn-sm" title="Details anzeigen" data-result-id="${item.id}">
                            <i class="is24-icon is24-icon-details"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        } else {
            // Keine Daten verfügbar
            const row = document.createElement('tr');
            row.innerHTML = `
                <td colspan="7" class="is24-text-center is24-text-muted">Keine Daten verfügbar</td>
            `;
            tbody.appendChild(row);
        }
        
        table.appendChild(tbody);
        
        // Bestehende Tabelle ersetzen
        tableContainer.innerHTML = '';
        tableContainer.appendChild(table);
        
        // Event-Listener für Detail-Buttons hinzufügen
        const detailButtons = tableContainer.querySelectorAll('[data-result-id]');
        detailButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const resultId = e.currentTarget.getAttribute('data-result-id');
                _showResultDetails(resultId);
            });
        });
    }
    
    /**
     * Zeigt die Ladeanimation an
     * @private
     * @returns {void}
     */
    function _showLoading() {
        if (_elements.loadingIndicator) {
            _elements.loadingIndicator.classList.remove('is24-hidden');
        }
    }
    
    /**
     * Verbirgt die Ladeanimation
     * @private
     * @returns {void}
     */
    function _hideLoading() {
        if (_elements.loadingIndicator) {
            _elements.loadingIndicator.classList.add('is24-hidden');
        }
    }
    
    /**
     * Zeigt eine Fehlermeldung an
     * @private
     * @returns {void}
     */
    function _showError() {
        if (_elements.errorMessage) {
            _elements.errorMessage.classList.remove('is24-hidden');
        }
    }
    
    /**
     * Verbirgt die Fehlermeldung
     * @private
     * @returns {void}
     */
    function _hideError() {
        if (_elements.errorMessage) {
            _elements.errorMessage.classList.add('is24-hidden');
        }
    }
    
    /**
     * Zeigt die "Keine Daten" Meldung an
     * @private
     * @returns {void}
     */
    function _showNoDataMessage() {
        if (_elements.noDataMessage) {
            _elements.noDataMessage.classList.remove('is24-hidden');
        }
    }
    
    /**
     * Verbirgt die "Keine Daten" Meldung
     * @private
     * @returns {void}
     */
    function _hideNoDataMessage() {
        if (_elements.noDataMessage) {
            _elements.noDataMessage.classList.add('is24-hidden');
        }
    }
    
    /**
     * Verbirgt das Diagramm
     * @private
     * @returns {void}
     */
    function _hideChart() {
        if (_elements.chartContainer) {
            _elements.chartContainer.classList.add('is24-hidden');
        }
    }
    
    /**
     * Verbirgt die Tabelle
     * @private
     * @returns {void}
     */
    function _hideTable() {
        if (_elements.tableContainer) {
            _elements.tableContainer.classList.add('is24-hidden');
        }
    }
    
    /**
     * Konfiguriert die Ansicht für den Hybrid-Modus
     * @private
     * @returns {void}
     */
    function _showHybridView() {
        if (_elements.chartContainer && _elements.tableContainer) {
            _elements.chartContainer.classList.remove('is24-hidden');
            _elements.tableContainer.classList.remove('is24-hidden');
            
            // Layout für Hybrid-Ansicht anpassen
            _elements.chartContainer.style.height = '50%';
            _elements.tableContainer.style.height = '50%';
        }
    }
    
    /**
     * Bereinigt aktive Chart.js-Instanzen
     * @private
     * @returns {void}
     */
    function _cleanupCharts() {
        _activeChartInstances.forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        
        _activeChartInstances = [];
        
        if (_elements.chartContainer) {
            _elements.chartContainer.innerHTML = '';
            _elements.chartContainer.style.height = '';
        }
        
        if (_elements.tableContainer) {
            _elements.tableContainer.style.height = '';
        }
    }
    
    /**
     * Behandelt den Wechsel des Ansichtsmodus
     * @private
     * @param {string} mode - Der neue Ansichtsmodus ('chart', 'table', 'hybrid')
     * @returns {void}
     */
    function _handleViewModeChange(mode) {
        if (!mode || !['chart', 'table', 'hybrid'].includes(mode)) {
            return;
        }
        
        // Aktuelle Schaltfläche deaktivieren
        const currentActiveButton = document.querySelector('[data-view].is24-btn-active');
        if (currentActiveButton) {
            currentActiveButton.classList.remove('is24-btn-active');
        }
        
        // Neue Schaltfläche aktivieren
        const newActiveButton = document.querySelector(`[data-view="${mode}"]`);
        if (newActiveButton) {
            newActiveButton.classList.add('is24-btn-active');
        }
        
        // Ansichtsmodus aktualisieren und Visualisierung neu rendern
        _filterSettings.viewMode = mode;
        _renderVisualization();
    }
    
    /**
     * Behandelt die Änderung des Diagrammtyps
     * @private
     * @param {string} chartType - Der neue Diagrammtyp
     * @returns {void}
     */
    function _handleChartTypeChange(chartType) {
        if (!chartType) return;
        
        _filterSettings.chartType = chartType;
        _renderVisualization();
    }
    
    /**
     * Behandelt die Änderung der Sortierkriterien
     * @private
     * @param {string} sortBy - Das neue Sortierkriterium
     * @returns {void}
     */
    function _handleSortByChange(sortBy) {
        if (!sortBy) return;
        
        _filterSettings.sortBy = sortBy;
        _renderVisualization();
    }
    
    /**
     * Wechselt die Sortierrichtung
     * @private
     * @returns {void}
     */
    function _handleSortDirectionToggle() {
        // Sortierrichtung umkehren
        _filterSettings.sortDirection = _filterSettings.sortDirection === 'asc' ? 'desc' : 'asc';
        
        // Icon aktualisieren
        const sortButton = document.getElementById('explorerSortDirection');
        if (sortButton) {
            const icon = sortButton.querySelector('i');
            if (icon) {
                if (_filterSettings.sortDirection === 'asc') {
                    icon.className = 'is24-icon is24-icon-sort-asc';
                } else {
                    icon.className = 'is24-icon is24-icon-sort-desc';
                }
            }
        }
        
        // Daten neu rendern
        _renderVisualization();
    }
    
    /**
     * Wechselt zwischen Vollbild- und normalem Modus
     * @private
     * @returns {void}
     */
    function _handleFullscreenToggle() {
        const container = _elements.container;
        
        if (!container) return;
        
        if (container.classList.contains('is24-fullscreen')) {
            // Vollbildmodus verlassen
            container.classList.remove('is24-fullscreen');
            
            // Icon anpassen
            const fullscreenBtn = document.getElementById('explorerFullscreen');
            if (fullscreenBtn) {
                const icon = fullscreenBtn.querySelector('i');
                if (icon) {
                    icon.className = 'is24-icon is24-icon-fullscreen';
                }
            }
        } else {
            // Vollbildmodus aktivieren
            container.classList.add('is24-fullscreen');
            
            // Icon anpassen
            const fullscreenBtn = document.getElementById('explorerFullscreen');
            if (fullscreenBtn) {
                const icon = fullscreenBtn.querySelector('i');
                if (icon) {
                    icon.className = 'is24-icon is24-icon-fullscreen-exit';
                }
            }
        }
        
        // Visualisierung neu rendern, um an die neue Größe anzupassen
        setTimeout(_renderVisualization, 300);
    }
    
    /**
     * Zeigt einen Hilfe-Dialog mit Erklärungen zur Benutzung des Datenexplorers
     * @private
     * @returns {void}
     */
    function _showHelpDialog() {
        // Hilfe-Dialog erstellen und anzeigen
        App.Modules.UI.Dialog.show({
            title: 'Datenexplorer - Hilfe',
            content: `
                <div class="is24-help-content">
                    <h3>Filter und Einstellungen</h3>
                    <p>Nutzen Sie die Filteroptionen auf der linken Seite, um die angezeigten Daten einzuschränken:</p>
                    <ul>
                        <li><strong>Zeitraum:</strong> Wählen Sie den Zeitraum für die Datenanalyse.</li>
                        <li><strong>Benutzergruppen:</strong> Filtern Sie nach bestimmten Benutzergruppen oder Teams.</li>
                        <li><strong>Testtypen:</strong> Wählen Sie bestimmte Arten von Tests aus.</li>
                        <li><strong>Kategorien:</strong> Filtern Sie nach inhaltlichen Kategorien oder Themen.</li>
                        <li><strong>Leistungsniveau:</strong> Filtern Sie nach Leistungsniveau der Teilnehmer.</li>
                    </ul>
                    
                    <h3>Visualisierungen</h3>
                    <p>Der Datenexplorer bietet verschiedene Visualisierungsoptionen:</p>
                    <ul>
                        <li><strong>Balkendiagramm:</strong> Vergleicht numerische Werte zwischen verschiedenen Kategorien.</li>
                        <li><strong>Liniendiagramm:</strong> Zeigt Trends und Entwicklungen über Zeit.</li>
                        <li><strong>Radardiagramm:</strong> Vergleicht mehrere quantitative Variablen.</li>
                        <li><strong>Kreisdiagramm:</strong> Zeigt die proportionale Zusammensetzung von Datenpunkten.</li>
                        <li><strong>Polardiagramm:</strong> Kombiniert radiale und kreisförmige Visualisierungen.</li>
                        <li><strong>Heatmap:</strong> Visualisiert Datenpunkte mit Farbintensität.</li>
                    </ul>
                    
                    <h3>Ansichtsmodi</h3>
                    <p>Wählen Sie zwischen verschiedenen Ansichtsmodi:</p>
                    <ul>
                        <li><strong>Diagramm:</strong> Zeigt nur die grafische Visualisierung.</li>
                        <li><strong>Tabelle:</strong> Zeigt die Daten in Tabellenform.</li>
                        <li><strong>Hybrid:</strong> Zeigt sowohl Diagramm als auch Tabelle.</li>
                    </ul>
                    
                    <h3>Export-Optionen</h3>
                    <p>Exportieren Sie Ihre Analyseergebnisse:</p>
                    <ul>
                        <li><strong>PDF exportieren:</strong> Erstellt ein PDF-Dokument mit der aktuellen Visualisierung.</li>
                        <li><strong>CSV exportieren:</strong> Speichert die Daten im CSV-Format zur weiteren Analyse.</li>
                        <li><strong>Teilen:</strong> Teilt die aktuelle Ansicht mit anderen Benutzern.</li>
                    </ul>
                </div>
            `,
            buttons: [
                {
                    text: 'Schließen',
                    type: 'primary',
                    action: 'close'
                }
            ],
            width: '600px'
        });
    }
    
    /**
     * Exportiert die aktuelle Visualisierung als PDF
     * @private
     * @returns {void}
     */
    function _handlePdfExport() {
        // PDF-Export-Funktionalität
        // Hier würde die tatsächliche PDF-Generierung implementiert werden
        console.log('PDF-Export wird durchgeführt...');
        
        // Benutzer informieren
        App.Modules.UI.Notification.show({
            type: 'info',
            message: 'PDF-Export wird vorbereitet...',
            duration: 2000
        });
        
        // Simulierter Export (in der tatsächlichen Implementierung würde hier die PDF-Generierung erfolgen)
        setTimeout(() => {
            App.Modules.UI.Notification.show({
                type: 'success',
                message: 'PDF erfolgreich exportiert',
                duration: 3000
            });
        }, 1500);
    }
    
    /**
     * Exportiert die aktuellen Daten als CSV
     * @private
     * @returns {void}
     */
    function _handleCsvExport() {
        // CSV-Export-Funktionalität
        // Hier würde die tatsächliche CSV-Generierung implementiert werden
        console.log('CSV-Export wird durchgeführt...');
        
        // Benutzer informieren
        App.Modules.UI.Notification.show({
            type: 'info',
            message: 'CSV-Export wird vorbereitet...',
            duration: 2000
        });
        
        // Simulierter Export (in der tatsächlichen Implementierung würde hier die CSV-Generierung erfolgen)
        setTimeout(() => {
            App.Modules.UI.Notification.show({
                type: 'success',
                message: 'CSV erfolgreich exportiert',
                duration: 3000
            });
        }, 1500);
    }
    
    /**
     * Teilt die aktuelle Ansicht
     * @private
     * @returns {void}
     */
    function _handleShare() {
        // Teilen-Funktionalität
        // Dialog zum Teilen der aktuellen Ansicht anzeigen
        App.Modules.UI.Dialog.show({
            title: 'Visualisierung teilen',
            content: `
                <div class="is24-share-options">
                    <div class="is24-form-group">
                        <label for="shareLink">Link zum Teilen:</label>
                        <div class="is24-input-group">
                            <input type="text" id="shareLink" class="is24-form-control" value="${_generateShareLink()}" readonly>
                            <button class="is24-btn is24-btn-secondary" id="copyShareLink">
                                <i class="is24-icon is24-icon-copy"></i> Kopieren
                            </button>
                        </div>
                    </div>
                    
                    <div class="is24-form-group">
                        <label>Per E-Mail teilen:</label>
                        <div class="is24-input-group">
                            <input type="email" id="shareEmail" class="is24-form-control" placeholder="E-Mail-Adresse eingeben">
                            <button class="is24-btn is24-btn-primary" id="sendShareEmail">
                                <i class="is24-icon is24-icon-send"></i> Senden
                            </button>
                        </div>
                    </div>
                </div>
            `,
            buttons: [
                {
                    text: 'Schließen',
                    type: 'secondary',
                    action: 'close'
                }
            ],
            onOpen: () => {
                // Event-Listener für "Kopieren"-Button
                const copyBtn = document.getElementById('copyShareLink');
                if (copyBtn) {
                    copyBtn.addEventListener('click', () => {
                        const linkInput = document.getElementById('shareLink');
                        if (linkInput) {
                            linkInput.select();
                            document.execCommand('copy');
                            
                            // Benutzer über erfolgreiches Kopieren informieren
                            App.Modules.UI.Notification.show({
                                type: 'success',
                                message: 'Link in die Zwischenablage kopiert',
                                duration: 2000
                            });
                        }
                    });
                }
                
                // Event-Listener für "Senden"-Button
                const sendBtn = document.getElementById('sendShareEmail');
                if (sendBtn) {
                    sendBtn.addEventListener('click', () => {
                        const emailInput = document.getElementById('shareEmail');
                        if (emailInput && emailInput.value) {
                            // E-Mail versenden (in der realen Implementierung)
                            console.log('Teilen per E-Mail an:', emailInput.value);
                            
                            // Benutzer informieren
                            App.Modules.UI.Notification.show({
                                type: 'success',
                                message: `Visualisierung per E-Mail an ${emailInput.value} geteilt`,
                                duration: 3000
                            });
                            
                            // Dialog schließen
                            App.Modules.UI.Dialog.close();
                        } else {
                            // Fehler anzeigen, wenn keine E-Mail-Adresse eingegeben wurde
                            App.Modules.UI.Notification.show({
                                type: 'error',
                                message: 'Bitte geben Sie eine gültige E-Mail-Adresse ein',
                                duration: 3000
                            });
                        }
                    });
                }
            }
        });
    }
    
    /**
     * Generiert einen teilbaren Link zur aktuellen Ansicht
     * @private
     * @returns {string} - URL zum Teilen
     */
    function _generateShareLink() {
        // Basis-URL der Anwendung
        const baseUrl = window.location.origin + window.location.pathname;
        
        // Filtereinstellungen in URL-Parameter konvertieren
        const params = new URLSearchParams();
        
        // Datumsbereich
        if (_filterSettings.dateRange.start) {
            params.append('start', _filterSettings.dateRange.start.toISOString().split('T')[0]);
        }
        if (_filterSettings.dateRange.end) {
            params.append('end', _filterSettings.dateRange.end.toISOString().split('T')[0]);
        }
        
        // Benutzergruppen
        if (_filterSettings.userGroups.length > 0) {
            params.append('userGroups', _filterSettings.userGroups.join(','));
        }
        
        // Testtypen
        if (_filterSettings.testTypes.length > 0) {
            params.append('testTypes', _filterSettings.testTypes.join(','));
        }
        
        // Kategorien
        if (_filterSettings.categories.length > 0) {
            params.append('categories', _filterSettings.categories.join(','));
        }
        
        // Weitere Einstellungen
        params.append('level', _filterSettings.performanceLevel);
        params.append('view', _filterSettings.viewMode);
        params.append('chart', _filterSettings.chartType);
        params.append('sort', _filterSettings.sortBy);
        params.append('dir', _filterSettings.sortDirection);
        
        // Vollständige URL zurückgeben
        return `${baseUrl}?${params.toString()}#explorer`;
    }
    
    /**
     * Zeigt die Detailansicht für ein bestimmtes Testergebnis an
     * @private
     * @param {string} resultId - ID des Testergebnisses
     * @returns {void}
     */
    function _showResultDetails(resultId) {
        if (!resultId) return;
        
        // Detaildaten abrufen
        App.Modules.Results.DataManager.getResultDetails(resultId)
            .then(details => {
                if (!details) {
                    App.Modules.UI.Notification.show({
                        type: 'error',
                        message: 'Ergebnisdetails konnten nicht gefunden werden',
                        duration: 3000
                    });
                    return;
                }
                
                // Details anzeigen
                App.Modules.Results.DetailView.show(details);
            })
            .catch(error => {
                console.error('Fehler beim Laden der Ergebnisdetails:', error);
                App.Modules.UI.Notification.show({
                    type: 'error',
                    message: 'Fehler beim Laden der Ergebnisdetails',
                    duration: 3000
                });
            });
    }
})();
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.2 - Detailansichten für individuelle Ergebnisse
 * @module js/modules/results/visualization/detail-view
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/chart-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für Detailansichten erstellen
App.Modules.Results = App.Modules.Results || {};
App.Modules.Results.Visualization = App.Modules.Results.Visualization || {};

/**
 * Detailansicht für individuelle Testergebnisse
 * @namespace
 */
App.Modules.Results.DetailView = (function() {
    // Private Variablen
    let _currentResult = null;
    let _compareData = null;
    let _activeCharts = [];
    let _printMode = false;
    
    // DOM-Element-Referenzen
    let _elements = {
        container: null,
        header: null,
        summarySection: null,
        questionSection: null,
        analysisSection: null,
        comparisonSection: null,
        feedbackSection: null,
        actionButtons: null
    };
    
    /**
     * Zeigt die Detailansicht für ein bestimmtes Testergebnis an
     * @param {Object} resultData - Daten des Testergebnisses
     * @returns {Promise<void>}
     */
    async function show(resultData) {
        if (!resultData || !resultData.id) {
            throw new Error('Ungültige Ergebnisdaten');
        }
        
        _currentResult = resultData;
        
        // Container erstellen, falls nicht vorhanden
        if (!document.getElementById('resultDetailContainer')) {
            const container = document.createElement('div');
            container.id = 'resultDetailContainer';
            container.className = 'is24-detail-view is24-card is24-shadow-lg';
            document.body.appendChild(container);
        }
        
        _elements.container = document.getElementById('resultDetailContainer');
        
        // UI zurücksetzen
        _resetDetailView();
        
        // Grundstruktur erstellen
        _createBaseStructure();
        
        // Daten laden und Abschnitte füllen
        await _loadAndPopulateData();
        
        // Event-Listener registrieren
        _setupEventListeners();
        
        // Detailansicht anzeigen
        _showDetailContainer();
        
        return true;
    }
    
    /**
     * Setzt die Detailansicht zurück
     * @private
     * @returns {void}
     */
    function _resetDetailView() {
        // Aktive Diagramme bereinigen
        _cleanupCharts();
        
        // Container zurücksetzen
        if (_elements.container) {
            _elements.container.innerHTML = '';
            _elements.container.style.display = 'none';
        }
        
        // Print-Modus zurücksetzen
        _printMode = false;
    }
    
    /**
     * Erstellt die Grundstruktur für die Detailansicht
     * @private
     * @returns {void}
     */
    function _createBaseStructure() {
        if (!_elements.container) return;
        
        _elements.container.innerHTML = `
            <div class="is24-detail-header" id="resultDetailHeader">
                <div class="is24-detail-title">
                    <h2>Testergebnis: <span id="resultTestName">...</span></h2>
                    <p class="is24-detail-subtitle">
                        Teilnehmer: <strong id="resultUserName">...</strong> | 
                        Datum: <span id="resultDate">...</span>
                    </p>
                </div>
                <div class="is24-detail-actions">
                    <button id="resultDetailClose" class="is24-btn is24-btn-icon is24-btn-secondary">
                        <i class="is24-icon is24-icon-close"></i>
                    </button>
                </div>
            </div>
            
            <div class="is24-detail-body">
                <!-- Zusammenfassung -->
                <section class="is24-detail-section" id="resultSummarySection">
                    <h3 class="is24-section-title">Zusammenfassung</h3>
                    <div class="is24-summary-content">
                        <div class="is24-summary-score-container">
                            <div class="is24-summary-score" id="resultScoreDisplay">
                                <span class="is24-score-value">...</span>
                                <span class="is24-score-label">Gesamtpunktzahl</span>
                            </div>
                            <div class="is24-summary-status" id="resultStatusDisplay">
                                <span class="is24-status-badge">...</span>
                            </div>
                        </div>
                        <div class="is24-summary-details">
                            <div class="is24-summary-stats">
                                <div class="is24-stat-item">
                                    <span class="is24-stat-label">Abgeschlossen in</span>
                                    <span class="is24-stat-value" id="resultCompletionTime">...</span>
                                </div>
                                <div class="is24-stat-item">
                                    <span class="is24-stat-label">Fragen</span>
                                    <span class="is24-stat-value" id="resultQuestionCount">...</span>
                                </div>
                                <div class="is24-stat-item">
                                    <span class="is24-stat-label">Korrekt</span>
                                    <span class="is24-stat-value" id="resultCorrectCount">...</span>
                                </div>
                                <div class="is24-stat-item">
                                    <span class="is24-stat-label">Teilweise korrekt</span>
                                    <span class="is24-stat-value" id="resultPartialCount">...</span>
                                </div>
                                <div class="is24-stat-item">
                                    <span class="is24-stat-label">Falsch</span>
                                    <span class="is24-stat-value" id="resultIncorrectCount">...</span>
                                </div>
                            </div>
                            <div class="is24-summary-charts">
                                <div class="is24-chart-container" id="summaryCategoryChart">
                                    <!-- Kategorie-Diagramm wird hier gerendert -->
                                </div>
                                <div class="is24-chart-container" id="summaryPerformanceChart">
                                    <!-- Leistungsdiagramm wird hier gerendert -->
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Stärken und Schwächen Analyse -->
                <section class="is24-detail-section" id="resultAnalysisSection">
                    <h3 class="is24-section-title">Stärken & Schwächen Analyse</h3>
                    <div class="is24-analysis-content">
                        <div class="is24-analysis-charts">
                            <div class="is24-chart-container" id="strengthsWeaknessesChart">
                                <!-- Stärken/Schwächen-Diagramm wird hier gerendert -->
                            </div>
                        </div>
                        <div class="is24-analysis-lists">
                            <div class="is24-strengths-list">
                                <h4>Stärken</h4>
                                <ul id="strengthsList">
                                    <!-- Stärken werden hier aufgelistet -->
                                </ul>
                            </div>
                            <div class="is24-weaknesses-list">
                                <h4>Verbesserungspotenzial</h4>
                                <ul id="weaknessesList">
                                    <!-- Schwächen werden hier aufgelistet -->
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Vergleichsdaten -->
                <section class="is24-detail-section" id="resultComparisonSection">
                    <h3 class="is24-section-title">Vergleich</h3>
                    <div class="is24-comparison-controls">
                        <div class="is24-form-group">
                            <label for="comparisonSelect">Vergleichen mit:</label>
                            <select id="comparisonSelect" class="is24-form-control">
                                <option value="team">Teammitglieder</option>
                                <option value="department">Abteilung</option>
                                <option value="company">Unternehmen</option>
                                <option value="selfHistory">Eigene Historie</option>
                            </select>
                        </div>
                    </div>
                    <div class="is24-comparison-content">
                        <div class="is24-chart-container" id="comparisonChart">
                            <!-- Vergleichsdiagramm wird hier gerendert -->
                        </div>
                        <div class="is24-comparison-stats" id="comparisonStats">
                            <!-- Vergleichsstatistiken werden hier angezeigt -->
                        </div>
                    </div>
                </section>
                
                <!-- Feedback & Empfehlungen -->
                <section class="is24-detail-section" id="resultFeedbackSection">
                    <h3 class="is24-section-title">Feedback & Empfehlungen</h3>
                    <div class="is24-feedback-content" id="feedbackContent">
                        <!-- Feedback und Empfehlungen werden hier angezeigt -->
                    </div>
                </section>
                
                <!-- Fragedetails -->
                <section class="is24-detail-section" id="resultQuestionsSection">
                    <h3 class="is24-section-title">Fragenübersicht</h3>
                    <div class="is24-questions-filter">
                        <div class="is24-filter-buttons">
                            <button class="is24-btn is24-btn-sm is24-btn-secondary is24-btn-active" data-filter="all">Alle Fragen</button>
                            <button class="is24-btn is24-btn-sm is24-btn-secondary" data-filter="correct">Korrekt</button>
                            <button class="is24-btn is24-btn-sm is24-btn-secondary" data-filter="partial">Teilweise korrekt</button>
                            <button class="is24-btn is24-btn-sm is24-btn-secondary" data-filter="incorrect">Falsch</button>
                        </div>
                        <div class="is24-search-container">
                            <input type="text" id="questionSearch" class="is24-form-control is24-form-control-sm" placeholder="Suche nach Fragen...">
                        </div>
                    </div>
                    <div class="is24-questions-list" id="questionsList">
                        <!-- Fragen werden hier angezeigt -->
                    </div>
                </section>
            </div>
            
            <div class="is24-detail-footer">
                <div class="is24-detail-actions-primary">
                    <button id="printResultBtn" class="is24-btn is24-btn-secondary">
                        <i class="is24-icon is24-icon-print"></i> Drucken
                    </button>
                    <button id="exportPdfBtn" class="is24-btn is24-btn-secondary">
                        <i class="is24-icon is24-icon-download"></i> Als PDF exportieren
                    </button>
                    <button id="shareResultBtn" class="is24-btn is24-btn-secondary">
                        <i class="is24-icon is24-icon-share"></i> Teilen
                    </button>
                </div>
                <div class="is24-detail-actions-secondary">
                    <button id="closeDetailBtn" class="is24-btn is24-btn-primary">Schließen</button>
                </div>
            </div>
        `;
        
        // DOM-Element-Referenzen speichern
        _elements.header = document.getElementById('resultDetailHeader');
        _elements.summarySection = document.getElementById('resultSummarySection');
        _elements.analysisSection = document.getElementById('resultAnalysisSection');
        _elements.comparisonSection = document.getElementById('resultComparisonSection');
        _elements.questionSection = document.getElementById('resultQuestionsSection');
        _elements.feedbackSection = document.getElementById('resultFeedbackSection');
    }
    
    /**
     * Lädt Daten und füllt die UI-Abschnitte
     * @private
     * @returns {Promise<void>}
     */
    async function _loadAndPopulateData() {
        if (!_currentResult) return;
        
        try {
            // Vergleichsdaten laden
            _compareData = await App.Modules.Results.DataManager.getComparisonData(_currentResult.id, 'team');
            
            // UI mit Daten füllen
            _populateHeaderData();
            _populateSummarySection();
            _populateAnalysisSection();
            _populateComparisonSection();
            _populateFeedbackSection();
            _populateQuestionsSection();
            
        } catch (error) {
            console.error('Fehler beim Laden und Anzeigen der Detaildaten:', error);
            App.Modules.UI.Notification.show({
                type: 'error',
                message: 'Es gab ein Problem beim Laden der Detaildaten',
                duration: 3000
            });
        }
    }
    
    /**
     * Füllt den Header-Bereich mit Daten
     * @private
     * @returns {void}
     */
    function _populateHeaderData() {
        // Testnamen anzeigen
        const testNameElement = document.getElementById('resultTestName');
        if (testNameElement) {
            testNameElement.textContent = _currentResult.testName || 'Unbenannter Test';
        }
        
        // Benutzernamen anzeigen
        const userNameElement = document.getElementById('resultUserName');
        if (userNameElement) {
            userNameElement.textContent = _currentResult.userName || 'Unbekannter Benutzer';
        }
        
        // Datum formatieren und anzeigen
        const dateElement = document.getElementById('resultDate');
        if (dateElement && _currentResult.completedAt) {
            const date = new Date(_currentResult.completedAt);
            const formattedDate = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            dateElement.textContent = formattedDate;
        } else if (dateElement) {
            dateElement.textContent = 'Unbekanntes Datum';
        }
    }
    
    /**
     * Füllt die Zusammenfassungssektion mit Daten
     * @private
     * @returns {void}
     */
    function _populateSummarySection() {
        // Gesamtpunktzahl anzeigen
        const scoreElement = document.querySelector('.is24-score-value');
        if (scoreElement) {
            const score = _currentResult.score || 0;
            scoreElement.textContent = `${score.toFixed(1)}%`;
            
            // Farbliche Markierung basierend auf Punktzahl
            if (score >= 80) {
                scoreElement.classList.add('is24-score-high');
            } else if (score >= 50) {
                scoreElement.classList.add('is24-score-medium');
            } else {
                scoreElement.classList.add('is24-score-low');
            }
        }
        
        // Status-Badge anzeigen
        const statusElement = document.querySelector('.is24-status-badge');
        if (statusElement) {
            const score = _currentResult.score || 0;
            let status, statusClass;
            
            if (score >= 80) {
                status = 'Bestanden';
                statusClass = 'is24-badge-success';
            } else if (score >= 50) {
                status = 'Teilweise bestanden';
                statusClass = 'is24-badge-warning';
            } else {
                status = 'Nicht bestanden';
                statusClass = 'is24-badge-error';
            }
            
            statusElement.textContent = status;
            statusElement.className = 'is24-status-badge ' + statusClass;
        }
        
        // Statistiken anzeigen
        // Bearbeitungszeit
        const completionTimeElement = document.getElementById('resultCompletionTime');
        if (completionTimeElement) {
            let duration = '...';
            if (_currentResult.startedAt && _currentResult.completedAt) {
                const start = new Date(_currentResult.startedAt);
                const end = new Date(_currentResult.completedAt);
                const diffMs = end - start;
                const diffMins = Math.floor(diffMs / 60000);
                const diffSecs = Math.floor((diffMs % 60000) / 1000);
                duration = `${diffMins}:${diffSecs.toString().padStart(2, '0')} Min.`;
            }
            completionTimeElement.textContent = duration;
        }
        
        // Fragenanzahl
        const questionCountElement = document.getElementById('resultQuestionCount');
        if (questionCountElement) {
            questionCountElement.textContent = _currentResult.totalQuestions || 0;
        }
        
        // Korrekte Antworten
        const correctCountElement = document.getElementById('resultCorrectCount');
        if (correctCountElement) {
            correctCountElement.textContent = _currentResult.correctAnswers || 0;
        }
        
        // Teilweise korrekte Antworten
        const partialCountElement = document.getElementById('resultPartialCount');
        if (partialCountElement) {
            partialCountElement.textContent = _currentResult.partialAnswers || 0;
        }
        
        // Falsche Antworten
        const incorrectCountElement = document.getElementById('resultIncorrectCount');
        if (incorrectCountElement) {
            incorrectCountElement.textContent = _currentResult.incorrectAnswers || 0;
        }
        
        // Kategorie-Diagramm erstellen
        _createCategoryChart();
        
        // Leistungsdiagramm erstellen
        _createPerformanceChart();
    }
    
    /**
     * Erstellt ein Diagramm zur Kategorieleistung
     * @private
     * @returns {void}
     */
    function _createCategoryChart() {
        const container = document.getElementById('summaryCategoryChart');
        if (!container || !_currentResult.categoryScores || Object.keys(_currentResult.categoryScores).length === 0) {
            return;
        }
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = 'categoryScoreChart';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Daten für das Diagramm vorbereiten
        const categories = Object.keys(_currentResult.categoryScores);
        const scores = Object.values(_currentResult.categoryScores);
        
        // Farben basierend auf Punktzahl
        const backgroundColors = scores.map(score => {
            if (score >= 80) return 'rgba(0, 255, 208, 0.6)';
            if (score >= 50) return 'rgba(255, 193, 7, 0.6)';
            return 'rgba(255, 87, 34, 0.6)';
        });
        
        const borderColors = scores.map(score => {
            if (score >= 80) return 'rgba(0, 255, 208, 1)';
            if (score >= 50) return 'rgba(255, 193, 7, 1)';
            return 'rgba(255, 87, 34, 1)';
        });
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: categories,
                datasets: [{
                    label: 'Kategorieleistung',
                    data: scores,
                    backgroundColor: 'rgba(0, 255, 208, 0.2)',
                    borderColor: 'rgba(0, 255, 208, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: borderColors,
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgba(0, 255, 208, 1)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: {
                            display: true
                        },
                        suggestedMin: 0,
                        suggestedMax: 100
                    }
                }
            }
        });
        
        // Diagramminstanz für spätere Bereinigung speichern
        _activeCharts.push(chartInstance);
    }
    
    /**
     * Erstellt ein Leistungsdiagramm
     * @private
     * @returns {void}
     */
    function _createPerformanceChart() {
        const container = document.getElementById('summaryPerformanceChart');
        if (!container) return;
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = 'performanceChart';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Daten für das Diagramm vorbereiten
        const correctPercentage = (_currentResult.correctAnswers / _currentResult.totalQuestions) * 100;
        const partialPercentage = (_currentResult.partialAnswers / _currentResult.totalQuestions) * 100;
        const incorrectPercentage = (_currentResult.incorrectAnswers / _currentResult.totalQuestions) * 100;
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Korrekt', 'Teilweise korrekt', 'Falsch'],
                datasets: [{
                    data: [correctPercentage, partialPercentage, incorrectPercentage],
                    backgroundColor: [
                        'rgba(0, 255, 208, 0.6)',
                        'rgba(255, 193, 7, 0.6)',
                        'rgba(255, 87, 34, 0.6)'
                    ],
                    borderColor: [
                        'rgba(0, 255, 208, 1)',
                        'rgba(255, 193, 7, 1)',
                        'rgba(255, 87, 34, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw.toFixed(1) + '%';
                                return `${label}: ${value}`;
                            }
                        }
                    }
                }
            }
        });
        
        // Diagramminstanz für spätere Bereinigung speichern
        _activeCharts.push(chartInstance);
    }
    
    /**
     * Füllt die Analysesektion mit Daten
     * @private
     * @returns {void}
     */
    function _populateAnalysisSection() {
        // Stärken und Schwächen analysieren
        const strengths = [];
        const weaknesses = [];
        
        // Bei Kategorien mit Scores über 80% handelt es sich um Stärken
        // Bei Kategorien mit Scores unter 50% handelt es sich um Schwächen
        if (_currentResult.categoryScores) {
            for (const [category, score] of Object.entries(_currentResult.categoryScores)) {
                if (score >= 80) {
                    strengths.push({ category, score });
                } else if (score < 50) {
                    weaknesses.push({ category, score });
                }
            }
        }
        
        // Stärken nach absteigender Punktzahl sortieren
        strengths.sort((a, b) => b.score - a.score);
        
        // Schwächen nach aufsteigender Punktzahl sortieren
        weaknesses.sort((a, b) => a.score - b.score);
        
        // Stärkenliste füllen
        const strengthsListElement = document.getElementById('strengthsList');
        if (strengthsListElement) {
            if (strengths.length > 0) {
                strengthsListElement.innerHTML = strengths.map(item => 
                    `<li class="is24-strength-item">
                        <span class="is24-category-name">${item.category}</span>
                        <div class="is24-score-bar">
                            <div class="is24-score-fill" style="width: ${item.score}%;"></div>
                            <span class="is24-score-value">${item.score.toFixed(1)}%</span>
                        </div>
                    </li>`
                ).join('');
            } else {
                strengthsListElement.innerHTML = '<li class="is24-empty-list">Keine ausgeprägten Stärken gefunden</li>';
            }
        }
        
        // Schwächenliste füllen
        const weaknessesListElement = document.getElementById('weaknessesList');
        if (weaknessesListElement) {
            if (weaknesses.length > 0) {
                weaknessesListElement.innerHTML = weaknesses.map(item => 
                    `<li class="is24-weakness-item">
                        <span class="is24-category-name">${item.category}</span>
                        <div class="is24-score-bar">
                            <div class="is24-score-fill is24-score-low" style="width: ${item.score}%;"></div>
                            <span class="is24-score-value">${item.score.toFixed(1)}%</span>
                        </div>
                    </li>`
                ).join('');
            } else {
                weaknessesListElement.innerHTML = '<li class="is24-empty-list">Keine signifikanten Schwächen gefunden</li>';
            }
        }
        
        // Stärken/Schwächen-Diagramm erstellen
        _createStrengthsWeaknessesChart(strengths, weaknesses);
    }
    
    /**
     * Erstellt ein Diagramm für Stärken und Schwächen
     * @private
     * @param {Array} strengths - Liste der Stärken
     * @param {Array} weaknesses - Liste der Schwächen
     * @returns {void}
     */
    function _createStrengthsWeaknessesChart(strengths, weaknesses) {
        const container = document.getElementById('strengthsWeaknessesChart');
        if (!container) return;
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = 'strengthsWeaknessesChartCanvas';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Daten kombinieren und vorbereiten
        const allItems = [...strengths, ...weaknesses].sort((a, b) => b.score - a.score);
        
        // Nicht zu viele Einträge anzeigen
        const displayItems = allItems.slice(0, Math.min(10, allItems.length));
        
        // Farben basierend auf Punktzahl
        const backgroundColors = displayItems.map(item => {
            if (item.score >= 80) return 'rgba(0, 255, 208, 0.6)';
            if (item.score >= 50) return 'rgba(255, 193, 7, 0.6)';
            return 'rgba(255, 87, 34, 0.6)';
        });
        
        const borderColors = displayItems.map(item => {
            if (item.score >= 80) return 'rgba(0, 255, 208, 1)';
            if (item.score >= 50) return 'rgba(255, 193, 7, 1)';
            return 'rgba(255, 87, 34, 1)';
        });
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: displayItems.map(item => item.category),
                datasets: [{
                    label: 'Kategorieanalyse',
                    data: displayItems.map(item => item.score),
                    backgroundColor: backgroundColors,
                    borderColor: borderColors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                scales: {
                    x: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Punktzahl (%)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Kategorie'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Stärken- und Schwächenanalyse'
                    }
                }
            }
        });
        
        // Diagramminstanz für spätere Bereinigung speichern
        _activeCharts.push(chartInstance);
    }
    
    /**
     * Füllt die Vergleichssektion mit Daten
     * @private
     * @returns {void}
     */
    function _populateComparisonSection() {
        if (!_compareData) return;
        
        // Event-Listener für den Vergleichstyp-Selektor
        const comparisonSelect = document.getElementById('comparisonSelect');
        if (comparisonSelect) {
            comparisonSelect.addEventListener('change', async (e) => {
                const compareType = e.target.value;
                
                try {
                    // Neue Vergleichsdaten laden
                    _compareData = await App.Modules.Results.DataManager.getComparisonData(_currentResult.id, compareType);
                    
                    // Vergleichsdiagramm aktualisieren
                    _updateComparisonChart();
                    
                    // Vergleichsstatistiken aktualisieren
                    _updateComparisonStats();
                } catch (error) {
                    console.error('Fehler beim Laden der Vergleichsdaten:', error);
                    App.Modules.UI.Notification.show({
                        type: 'error',
                        message: 'Fehler beim Laden der Vergleichsdaten',
                        duration: 3000
                    });
                }
            });
        }
        
        // Initial Vergleichsdiagramm erstellen
        _createComparisonChart();
        
        // Vergleichsstatistiken anzeigen
        _updateComparisonStats();
    }
    
    /**
     * Erstellt ein Vergleichsdiagramm
     * @private
     * @returns {void}
     */
    function _createComparisonChart() {
        const container = document.getElementById('comparisonChart');
        if (!container || !_compareData) return;
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = 'comparisonChartCanvas';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Daten vorbereiten
        const compareType = document.getElementById('comparisonSelect').value || 'team';
        let labels, userData, compareData, compareLabel;
        
        switch (compareType) {
            case 'team':
                labels = Object.keys(_compareData.categoryScores || {});
                userData = labels.map(category => _currentResult.categoryScores[category] || 0);
                compareData = labels.map(category => _compareData.categoryScores[category] || 0);
                compareLabel = 'Team-Durchschnitt';
                break;
            case 'department':
                labels = Object.keys(_compareData.categoryScores || {});
                userData = labels.map(category => _currentResult.categoryScores[category] || 0);
                compareData = labels.map(category => _compareData.categoryScores[category] || 0);
                compareLabel = 'Abteilungs-Durchschnitt';
                break;
            case 'company':
                labels = Object.keys(_compareData.categoryScores || {});
                userData = labels.map(category => _currentResult.categoryScores[category] || 0);
                compareData = labels.map(category => _compareData.categoryScores[category] || 0);
                compareLabel = 'Unternehmens-Durchschnitt';
                break;
            case 'selfHistory':
                labels = _compareData.historyLabels || [];
                userData = _compareData.historyScores || [];
                compareData = [];
                compareLabel = '';
                break;
            default:
                labels = Object.keys(_compareData.categoryScores || {});
                userData = labels.map(category => _currentResult.categoryScores[category] || 0);
                compareData = labels.map(category => _compareData.categoryScores[category] || 0);
                compareLabel = 'Team-Durchschnitt';
        }
        
        // Chart-Konfiguration basierend auf Vergleichstyp
        let chartConfig;
        
        if (compareType === 'selfHistory') {
            // Liniendiagramm für historische Entwicklung
            chartConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Entwicklung über Zeit',
                        data: userData,
                        borderColor: 'rgba(0, 255, 208, 1)',
                        backgroundColor: 'rgba(0, 255, 208, 0.1)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Punktzahl (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Testzeitpunkt'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Persönliche Entwicklung über Zeit'
                        }
                    }
                }
            };
        } else {
            // Radar-Diagramm für Kategorienvergleich
            chartConfig = {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Aktuelles Ergebnis',
                            data: userData,
                            backgroundColor: 'rgba(0, 255, 208, 0.2)',
                            borderColor: 'rgba(0, 255, 208, 1)',
                            borderWidth: 2,
                            pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                            pointBorderColor: '#fff',
                            pointRadius: 4
                        },
                        {
                            label: compareLabel,
                            data: compareData,
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            borderColor: 'rgba(153, 102, 255, 1)',
                            borderWidth: 1,
                            pointBackgroundColor: 'rgba(153, 102, 255, 1)',
                            pointBorderColor: '#fff',
                            pointRadius: 3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Vergleich mit ${compareLabel}`
                        }
                    }
                }
            };
        }
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, chartConfig);
        
        // Diagramminstanz für spätere Bereinigung speichern
        _activeCharts.push(chartInstance);
    }
    
    /**
     * Aktualisiert das Vergleichsdiagramm mit neuen Daten
     * @private
     * @returns {void}
     */
    function _updateComparisonChart() {
        // Altes Diagramm entfernen
        const container = document.getElementById('comparisonChart');
        if (container) {
            container.innerHTML = '';
        }
        
        // Neues Diagramm erstellen
        _createComparisonChart();
    }
    
    /**
     * Aktualisiert die Vergleichsstatistiken
     * @private
     * @returns {void}
     */
    function _updateComparisonStats() {
        const container = document.getElementById('comparisonStats');
        if (!container || !_compareData) return;
        
        const compareType = document.getElementById('comparisonSelect').value || 'team';
        let statsHtml = '';
        
        // Statistische Zusammenfassung erstellen
        if (compareType === 'selfHistory') {
            // Vergleich mit eigener Historie
            statsHtml = `
                <div class="is24-comparison-summary">
                    <h4>Entwicklungsanalyse</h4>
                    <div class="is24-stat-grid">
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Anzahl der Tests</span>
                            <span class="is24-stat-value">${_compareData.totalTests || 0}</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Durchschnittliche Punktzahl</span>
                            <span class="is24-stat-value">${(_compareData.averageScore || 0).toFixed(1)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Höchste Punktzahl</span>
                            <span class="is24-stat-value">${(_compareData.maxScore || 0).toFixed(1)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Niedrigste Punktzahl</span>
                            <span class="is24-stat-value">${(_compareData.minScore || 0).toFixed(1)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Letzter Test vor diesem</span>
                            <span class="is24-stat-value">${_compareData.lastTestDate || 'N/A'}</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Verbesserung zum letzten Test</span>
                            <span class="is24-stat-value ${_compareData.improvement >= 0 ? 'is24-positive' : 'is24-negative'}">
                                ${(_compareData.improvement || 0).toFixed(1)}%
                            </span>
                        </div>
                    </div>
                </div>
            `;
        } else {
            // Vergleich mit Gruppe (Team, Abteilung, Unternehmen)
            const compareLabel = compareType === 'team' ? 'Team' : 
                                compareType === 'department' ? 'Abteilung' : 'Unternehmen';
            
            statsHtml = `
                <div class="is24-comparison-summary">
                    <h4>Vergleich mit ${compareLabel}</h4>
                    <div class="is24-stat-grid">
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">${compareLabel}-Durchschnitt</span>
                            <span class="is24-stat-value">${(_compareData.averageScore || 0).toFixed(1)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Ihre Punktzahl</span>
                            <span class="is24-stat-value">${(_currentResult.score || 0).toFixed(1)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Unterschied</span>
                            <span class="is24-stat-value ${(_currentResult.score >= _compareData.averageScore) ? 'is24-positive' : 'is24-negative'}">
                                ${((_currentResult.score || 0) - (_compareData.averageScore || 0)).toFixed(1)}%
                            </span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Rang im ${compareLabel}</span>
                            <span class="is24-stat-value">${_compareData.rank || 'N/A'} von ${_compareData.totalParticipants || 0}</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Perzentil</span>
                            <span class="is24-stat-value">${(_compareData.percentile || 0).toFixed(0)}%</span>
                        </div>
                        <div class="is24-stat-item">
                            <span class="is24-stat-label">Beste Kategorie gegenüber ${compareLabel}</span>
                            <span class="is24-stat-value">${_compareData.bestCategory || 'N/A'}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // HTML in Container einfügen
        container.innerHTML = statsHtml;
    }
    
    /**
     * Füllt die Feedback- und Empfehlungssektion mit Daten
     * @private
     * @returns {void}
     */
    function _populateFeedbackSection() {
        const container = document.getElementById('feedbackContent');
        if (!container || !_currentResult) return;
        
        // Feedback und Empfehlungen basierend auf der Analyse generieren
        let feedbackHtml = `
            <div class="is24-feedback-summary">
                <h4>Zusammenfassung</h4>
                <p>${_generateFeedbackSummary()}</p>
            </div>
            
            <div class="is24-feedback-recommendations">
                <h4>Empfehlungen zur Verbesserung</h4>
                <ul>
        `;
        
        // Empfehlungen basierend auf Schwächen generieren
        const recommendations = _generateRecommendations();
        
        if (recommendations.length > 0) {
            feedbackHtml += recommendations.map(rec => `<li>${rec}</li>`).join('');
        } else {
            feedbackHtml += '<li>Keine spezifischen Empfehlungen verfügbar</li>';
        }
        
        feedbackHtml += `
                </ul>
            </div>
            
            <div class="is24-feedback-resources">
                <h4>Weiterführende Ressourcen</h4>
                <ul>
        `;
        
        // Ressourcen basierend auf Schwächen generieren
        const resources = _generateResources();
        
        if (resources.length > 0) {
            feedbackHtml += resources.map(res => `<li>${res}</li>`).join('');
        } else {
            feedbackHtml += '<li>Keine spezifischen Ressourcen verfügbar</li>';
        }
        
        feedbackHtml += `
                </ul>
            </div>
        `;
        
        // HTML in Container einfügen
        container.innerHTML = feedbackHtml;
    }
    
    /**
     * Generiert eine Feedback-Zusammenfassung
     * @private
     * @returns {string} - Zusammenfassung als formatierter Text
     */
    function _generateFeedbackSummary() {
        if (!_currentResult) return '';
        
        const score = _currentResult.score || 0;
        let summary = '';
        
        if (score >= 90) {
            summary = `Sie haben mit ${score.toFixed(1)}% ein ausgezeichnetes Ergebnis erzielt. Sie demonstrieren ein umfassendes Verständnis in allen getesteten Bereichen. Besonders hervorzuheben sind Ihre Stärken in `;
            
            // Stärken identifizieren (Top 2 Kategorien)
            const strengths = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => b - a)
                .slice(0, 2)
                .map(([category]) => category);
            
            summary += strengths.join(' und ') + '.';
            
            summary += ' Halten Sie Ihr Wissen auf dem aktuellen Stand und teilen Sie Ihre Expertise mit Ihren Teammitgliedern.';
            
        } else if (score >= 80) {
            summary = `Sie haben mit ${score.toFixed(1)}% ein sehr gutes Ergebnis erzielt. Sie haben ein solides Verständnis der getesteten Inhalte bewiesen. Besonders gut waren Ihre Leistungen in `;
            
            // Stärken identifizieren (Top 2 Kategorien)
            const strengths = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => b - a)
                .slice(0, 2)
                .map(([category]) => category);
            
            summary += strengths.join(' und ') + '.';
            
            // Eine Schwäche identifizieren, falls vorhanden
            const weaknesses = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => a - b)
                .slice(0, 1)
                .filter(([, score]) => score < 70)
                .map(([category]) => category);
            
            if (weaknesses.length > 0) {
                summary += ` Es gibt geringes Verbesserungspotenzial im Bereich ${weaknesses[0]}.`;
            }
            
        } else if (score >= 60) {
            summary = `Sie haben mit ${score.toFixed(1)}% ein gutes Ergebnis erzielt. Sie verfügen über ein grundlegendes Verständnis der meisten Inhalte. Gut waren Ihre Leistungen in `;
            
            // Stärken identifizieren (Top Kategorie)
            const strengths = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => b - a)
                .slice(0, 1)
                .map(([category]) => category);
            
            summary += strengths[0] + '.';
            
            summary += ' Es gibt jedoch Bereiche mit Verbesserungspotenzial, insbesondere in ';
            
            // Schwächen identifizieren (Niedrigste 2 Kategorien)
            const weaknesses = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => a - b)
                .slice(0, 2)
                .map(([category]) => category);
            
            summary += weaknesses.join(' und ') + '.';
            
        } else if (score >= 40) {
            summary = `Sie haben mit ${score.toFixed(1)}% ein mäßiges Ergebnis erzielt. Es gibt mehrere Bereiche, in denen Verbesserungsbedarf besteht. Besonders wichtig wäre eine Vertiefung in `;
            
            // Schwächen identifizieren (Niedrigste 3 Kategorien)
            const weaknesses = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => a - b)
                .slice(0, 3)
                .map(([category]) => category);
            
            summary += weaknesses.join(', ') + '.';
            
            summary += ' Nutzen Sie die empfohlenen Ressourcen und sprechen Sie mit Ihrem Trainer über gezielte Lernmöglichkeiten.';
            
        } else {
            summary = `Sie haben mit ${score.toFixed(1)}% das Lernziel noch nicht erreicht. Es ist wichtig, dass Sie sich mit den grundlegenden Konzepten intensiver beschäftigen. Konzentrieren Sie sich zunächst auf die Bereiche `;
            
            // Schwächen identifizieren (Niedrigste 2 Kategorien)
            const weaknesses = Object.entries(_currentResult.categoryScores || {})
                .sort(([, a], [, b]) => a - b)
                .slice(0, 2)
                .map(([category]) => category);
            
            summary += weaknesses.join(' und ') + '.';
            
            summary += ' Bitte wenden Sie sich an Ihren Trainer für zusätzliche Unterstützung und maßgeschneiderte Lernmaterialien.';
        }
        
        return summary;
    }
    
    /**
     * Generiert Empfehlungen zur Verbesserung
     * @private
     * @returns {Array<string>} - Liste der Empfehlungen
     */
    function _generateRecommendations() {
        if (!_currentResult || !_currentResult.categoryScores) return [];
        
        const recommendations = [];
        const weakCategories = Object.entries(_currentResult.categoryScores)
            .filter(([, score]) => score < 70)
            .sort(([, a], [, b]) => a - b)
            .map(([category]) => category);
        
        // Generische Empfehlungen basierend auf Schwächen
        if (weakCategories.length > 0) {
            weakCategories.forEach(category => {
                recommendations.push(`Fokussieren Sie sich auf das Vertiefen Ihres Wissens in ${category}. Nutzen Sie die verfügbaren Lernunterlagen und Online-Ressourcen.`);
            });
        }
        
        // Allgemeine Empfehlungen
        if (_currentResult.score < 80) {
            recommendations.push('Nehmen Sie sich regelmäßig Zeit zum Üben und Wiederholen der Lerninhalte.');
        }
        
        if (_currentResult.score < 60) {
            recommendations.push('Bilden Sie Lerngruppen mit Kollegen, um schwierige Konzepte zu diskutieren und verschiedene Perspektiven zu gewinnen.');
            recommendations.push('Vereinbaren Sie einen Termin mit Ihrem Trainer für eine individuelle Beratung und zusätzliche Unterstützung.');
        }
        
        return recommendations;
    }
    
    /**
     * Generiert Ressourcenempfehlungen
     * @private
     * @returns {Array<string>} - Liste der Ressourcen
     */
    function _generateResources() {
        if (!_currentResult || !_currentResult.categoryScores) return [];
        
        const resources = [];
        const weakCategories = Object.entries(_currentResult.categoryScores)
            .filter(([, score]) => score < 70)
            .sort(([, a], [, b]) => a - b)
            .map(([category]) => category);
        
        // Beispielressourcen basierend auf Schwächen
        if (weakCategories.length > 0) {
            weakCategories.forEach(category => {
                resources.push(`E-Learning-Kurs: "${category} - Grundlagen und Fortgeschrittene Konzepte"`);
                resources.push(`Praxisleitfaden: "${category} in der täglichen Arbeit"`);
            });
        }
        
        // Allgemeine Ressourcen
        resources.push('ImmoScout24 Wissensportal: Umfassende Sammlung von Lernmaterialien und Best Practices');
        resources.push('Interne Schulungen: Terminplan für kommende Schulungen und Workshops');
        
        return resources;
    }
    
    /**
     * Füllt die Fragenübersicht mit den Ergebnissen der einzelnen Fragen
     * @private
     * @returns {void}
     */
    function _populateQuestionsSection() {
        const container = document.getElementById('questionsList');
        if (!container || !_currentResult || !_currentResult.questions) return;
        
        // Fragenübersicht erstellen
        let questionsHtml = '';
        
        _currentResult.questions.forEach((question, index) => {
            const questionNumber = index + 1;
            let statusClass = '';
            let statusIcon = '';
            
            // Status basierend auf der Punktzahl bestimmen
            if (question.score === 100) {
                statusClass = 'is24-question-correct';
                statusIcon = '<i class="is24-icon is24-icon-check is24-text-success"></i>';
            } else if (question.score > 0) {
                statusClass = 'is24-question-partial';
                statusIcon = '<i class="is24-icon is24-icon-partial is24-text-warning"></i>';
            } else {
                statusClass = 'is24-question-incorrect';
                statusIcon = '<i class="is24-icon is24-icon-cross is24-text-error"></i>';
            }
            
            // Fragetyp bestimmen
            let questionTypeLabel = '';
            switch (question.type) {
                case 'multiple-choice':
                    questionTypeLabel = 'Multiple Choice';
                    break;
                case 'single-choice':
                    questionTypeLabel = 'Single Choice';
                    break;
                case 'true-false':
                    questionTypeLabel = 'Wahr/Falsch';
                    break;
                case 'text':
                    questionTypeLabel = 'Freitext';
                    break;
                default:
                    questionTypeLabel = 'Unbekannter Typ';
            }
            
            // HTML für Frage erstellen
            questionsHtml += `
                <div class="is24-question-item ${statusClass}" data-question-id="${question.id}" data-score="${question.score}" data-category="${question.category || ''}">
                    <div class="is24-question-header">
                        <div class="is24-question-number">
                            ${statusIcon} Frage ${questionNumber}
                        </div>
                        <div class="is24-question-meta">
                            <span class="is24-question-type">${questionTypeLabel}</span>
                            <span class="is24-question-category">${question.category || 'Keine Kategorie'}</span>
                            <span class="is24-question-score">${question.score}%</span>
                        </div>
                    </div>
                    <div class="is24-question-body">
                        <div class="is24-question-text">${question.text}</div>
                        <div class="is24-question-details">
                            <button class="is24-btn is24-btn-sm is24-btn-link is24-question-details-toggle">
                                Details anzeigen
                            </button>
                        </div>
                        <div class="is24-question-detail-content is24-hidden">
                            <!-- Details werden dynamisch geladen -->
                        </div>
                    </div>
                </div>
            `;
        });
        
        // HTML in Container einfügen
        container.innerHTML = questionsHtml;
        
        // Event-Listener für Filter-Buttons
        const filterButtons = document.querySelectorAll('.is24-questions-filter .is24-btn');
        filterButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                // Aktiven Button markieren
                filterButtons.forEach(btn => btn.classList.remove('is24-btn-active'));
                e.currentTarget.classList.add('is24-btn-active');
                
                // Fragen entsprechend filtern
                const filter = e.currentTarget.getAttribute('data-filter');
                _filterQuestions(filter);
            });
        });
        
        // Event-Listener für Suchfeld
        const searchInput = document.getElementById('questionSearch');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                _searchQuestions(e.target.value);
            });
        }
        
        // Event-Listener für Details-Buttons
        const detailButtons = document.querySelectorAll('.is24-question-details-toggle');
        detailButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const questionItem = e.currentTarget.closest('.is24-question-item');
                if (questionItem) {
                    const detailContent = questionItem.querySelector('.is24-question-detail-content');
                    const questionId = questionItem.getAttribute('data-question-id');
                    
                    if (detailContent.classList.contains('is24-hidden')) {
                        // Details anzeigen
                        detailContent.classList.remove('is24-hidden');
                        e.currentTarget.textContent = 'Details ausblenden';
                        
                        // Details laden, falls noch nicht geschehen
                        if (detailContent.innerHTML.trim() === '') {
                            _loadQuestionDetails(questionId, detailContent);
                        }
                    } else {
                        // Details ausblenden
                        detailContent.classList.add('is24-hidden');
                        e.currentTarget.textContent = 'Details anzeigen';
                    }
                }
            });
        });
    }
    
    /**
     * Filtert Fragen nach Status
     * @private
     * @param {string} filter - Der anzuwendende Filter ('all', 'correct', 'partial', 'incorrect')
     * @returns {void}
     */
    function _filterQuestions(filter) {
        const questions = document.querySelectorAll('.is24-question-item');
        
        questions.forEach(question => {
            const score = parseInt(question.getAttribute('data-score') || '0');
            
            switch (filter) {
                case 'correct':
                    question.style.display = score === 100 ? '' : 'none';
                    break;
                case 'partial':
                    question.style.display = score > 0 && score < 100 ? '' : 'none';
                    break;
                case 'incorrect':
                    question.style.display = score === 0 ? '' : 'none';
                    break;
                default:
                    question.style.display = '';
            }
        });
    }
    
    /**
     * Durchsucht Fragen nach Suchbegriff
     * @private
     * @param {string} searchTerm - Der Suchbegriff
     * @returns {void}
     */
    function _searchQuestions(searchTerm) {
        if (!searchTerm) {
            // Bei leerem Suchbegriff alle Fragen anzeigen
            document.querySelectorAll('.is24-question-item').forEach(question => {
                question.style.display = '';
            });
            return;
        }
        
        const searchLower = searchTerm.toLowerCase();
        
        // Alle Fragen durchsuchen
        document.querySelectorAll('.is24-question-item').forEach(question => {
            const questionText = question.querySelector('.is24-question-text').textContent.toLowerCase();
            const category = question.getAttribute('data-category').toLowerCase();
            
            // Frage anzeigen, wenn der Suchbegriff im Text oder in der Kategorie vorkommt
            if (questionText.includes(searchLower) || category.includes(searchLower)) {
                question.style.display = '';
            } else {
                question.style.display = 'none';
            }
        });
    }
    
    /**
     * Lädt und zeigt Details zu einer Frage
     * @private
     * @param {string} questionId - ID der Frage
     * @param {HTMLElement} container - Container für die Details
     * @returns {void}
     */
    function _loadQuestionDetails(questionId, container) {
        if (!questionId || !container || !_currentResult || !_currentResult.questions) return;
        
        // Frage anhand der ID finden
        const question = _currentResult.questions.find(q => q.id === questionId);
        
        if (!question) {
            container.innerHTML = '<p class="is24-text-error">Fragedetails konnten nicht geladen werden.</p>';
            return;
        }
        
        // HTML für Details basierend auf Fragetyp erstellen
        let detailsHtml = '';
        
        switch (question.type) {
            case 'multiple-choice':
            case 'single-choice':
                detailsHtml = _generateChoiceQuestionDetails(question);
                break;
            case 'true-false':
                detailsHtml = _generateTrueFalseQuestionDetails(question);
                break;
            case 'text':
                detailsHtml = _generateTextQuestionDetails(question);
                break;
            default:
                detailsHtml = '<p class="is24-text-muted">Keine Details für diesen Fragetyp verfügbar.</p>';
        }
        
        // HTML in Container einfügen
        container.innerHTML = detailsHtml;
    }
    
    /**
     * Generiert HTML für die Details einer Multiple/Single-Choice-Frage
     * @private
     * @param {Object} question - Die Fragedaten
     * @returns {string} - HTML für die Fragedetails
     */
    function _generateChoiceQuestionDetails(question) {
        if (!question || !question.options || !question.userAnswer) return '';
        
        let detailsHtml = `
            <div class="is24-question-explanation">
                <h4>Erklärung</h4>
                <p>${question.explanation || 'Keine Erklärung verfügbar.'}</p>
            </div>
            
            <div class="is24-answer-comparison">
                <h4>Antwortvergleich</h4>
                <div class="is24-options-list">
        `;
        
        // Optionen mit Markierungen für korrekte Antwort und Benutzerantwort anzeigen
        question.options.forEach((option, index) => {
            const isCorrect = question.correctAnswer.includes(option.id);
            const isUserSelected = question.userAnswer.includes(option.id);
            
            let optionClass = 'is24-option-item';
            let statusIcon = '';
            
            if (isCorrect && isUserSelected) {
                optionClass += ' is24-option-correct';
                statusIcon = '<i class="is24-icon is24-icon-check is24-text-success"></i>';
            } else if (!isCorrect && isUserSelected) {
                optionClass += ' is24-option-incorrect';
                statusIcon = '<i class="is24-icon is24-icon-cross is24-text-error"></i>';
            } else if (isCorrect) {
                optionClass += ' is24-option-missed';
                statusIcon = '<i class="is24-icon is24-icon-info is24-text-info"></i>';
            } else {
                statusIcon = '<i class="is24-icon is24-icon-circle"></i>';
            }
            
            detailsHtml += `
                <div class="${optionClass}">
                    <div class="is24-option-status">
                        ${statusIcon}
                    </div>
                    <div class="is24-option-text">
                        ${option.text}
                    </div>
                </div>
            `;
        });
        
        detailsHtml += `
                </div>
            </div>
            
            <div class="is24-point-breakdown">
                <h4>Punkteverteilung</h4>
                <p>Erzielte Punkte: ${question.score}%</p>
            </div>
        `;
        
        return detailsHtml;
    }
    
    /**
     * Generiert HTML für die Details einer Wahr/Falsch-Frage
     * @private
     * @param {Object} question - Die Fragedaten
     * @returns {string} - HTML für die Fragedetails
     */
    function _generateTrueFalseQuestionDetails(question) {
        if (!question || !question.userAnswer) return '';
        
        const isCorrect = question.userAnswer === question.correctAnswer;
        
        let detailsHtml = `
            <div class="is24-question-explanation">
                <h4>Erklärung</h4>
                <p>${question.explanation || 'Keine Erklärung verfügbar.'}</p>
            </div>
            
            <div class="is24-answer-comparison">
                <h4>Antwortvergleich</h4>
                <div class="is24-true-false-container">
                    <div class="is24-true-false-item">
                        <div class="is24-option-status">
                            <strong>Richtige Antwort:</strong>
                        </div>
                        <div class="is24-option-text">
                            ${question.correctAnswer ? 'Wahr' : 'Falsch'}
                        </div>
                    </div>
                    <div class="is24-true-false-item">
                        <div class="is24-option-status">
                            <strong>Ihre Antwort:</strong>
                        </div>
                        <div class="is24-option-text ${isCorrect ? 'is24-text-success' : 'is24-text-error'}">
                            ${question.userAnswer ? 'Wahr' : 'Falsch'}
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="is24-point-breakdown">
                <h4>Punkteverteilung</h4>
                <p>Erzielte Punkte: ${question.score}%</p>
            </div>
        `;
        
        return detailsHtml;
    }
    
    /**
     * Generiert HTML für die Details einer Freitext-Frage
     * @private
     * @param {Object} question - Die Fragedaten
     * @returns {string} - HTML für die Fragedetails
     */
    function _generateTextQuestionDetails(question) {
        if (!question || !question.userAnswer) return '';
        
        let detailsHtml = `
            <div class="is24-question-explanation">
                <h4>Erklärung</h4>
                <p>${question.explanation || 'Keine Erklärung verfügbar.'}</p>
            </div>
            
            <div class="is24-answer-comparison">
                <h4>Antwortvergleich</h4>
                <div class="is24-text-answer-container">
                    <div class="is24-text-answer-item">
                        <h5>Musterantwort</h5>
                        <div class="is24-text-answer-content">
                            ${question.correctAnswer || 'Keine Musterantwort verfügbar.'}
                        </div>
                    </div>
                    <div class="is24-text-answer-item">
                        <h5>Ihre Antwort</h5>
                        <div class="is24-text-answer-content">
                            ${question.userAnswer || 'Keine Antwort gegeben.'}
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="is24-point-breakdown">
                <h4>Punkteverteilung</h4>
                <p>Erzielte Punkte: ${question.score}%</p>
                ${question.feedback ? `<p><strong>Feedback:</strong> ${question.feedback}</p>` : ''}
            </div>
        `;
        
        return detailsHtml;
    }
    
    /**
     * Richtet Event-Listener für die Detailansicht ein
     * @private
     * @returns {void}
     */
    function _setupEventListeners() {
        // Schließen-Button im Header
        const closeHeaderBtn = document.getElementById('resultDetailClose');
        if (closeHeaderBtn) {
            closeHeaderBtn.addEventListener('click', hide);
        }
        
        // Schließen-Button im Footer
        const closeFooterBtn = document.getElementById('closeDetailBtn');
        if (closeFooterBtn) {
            closeFooterBtn.addEventListener('click', hide);
        }
        
        // Drucken-Button
        const printBtn = document.getElementById('printResultBtn');
        if (printBtn) {
            printBtn.addEventListener('click', _handlePrint);
        }
        
        // PDF-Export-Button
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        if (exportPdfBtn) {
            exportPdfBtn.addEventListener('click', _handlePdfExport);
        }
        
        // Teilen-Button
        const shareBtn = document.getElementById('shareResultBtn');
        if (shareBtn) {
            shareBtn.addEventListener('click', _handleShare);
        }
    }
    
    /**
     * Zeigt den Detailansichts-Container an
     * @private
     * @returns {void}
     */
    function _showDetailContainer() {
        if (_elements.container) {
            // Container anzeigen
            _elements.container.style.display = 'flex';
            
            // Animation hinzufügen
            setTimeout(() => {
                _elements.container.classList.add('is24-detail-view-active');
            }, 10);
            
            // Scrollen verhindern
            document.body.style.overflow = 'hidden';
        }
    }
    
    /**
     * Behandelt den Druckvorgang
     * @private
     * @returns {void}
     */
    function _handlePrint() {
        // Print-Modus aktivieren
        _printMode = true;
        _elements.container.classList.add('is24-print-mode');
        
        // Timeout für die Druckvorschau
        setTimeout(() => {
            window.print();
            
            // Nach dem Drucken Print-Modus deaktivieren
            setTimeout(() => {
                _printMode = false;
                _elements.container.classList.remove('is24-print-mode');
            }, 1000);
        }, 300);
    }
    
    /**
     * Behandelt den PDF-Export
     * @private
     * @returns {void}
     */
    function _handlePdfExport() {
        // Benutzer informieren
        App.Modules.UI.Notification.show({
            type: 'info',
            message: 'PDF-Export wird vorbereitet...',
            duration: 2000
        });
        
        // PDF-Export simulieren (würde in der realen Implementierung mit einer PDF-Bibliothek erfolgen)
        setTimeout(() => {
            App.Modules.UI.Notification.show({
                type: 'success',
                message: 'PDF erfolgreich erstellt und heruntergeladen',
                duration: 3000
            });
        }, 2000);
    }
    
    /**
     * Behandelt die Teilen-Funktion
     * @private
     * @returns {void}
     */
    function _handleShare() {
        // Dialog zum Teilen anzeigen
        App.Modules.UI.Dialog.show({
            title: 'Testergebnis teilen',
            content: `
                <div class="is24-share-options">
                    <div class="is24-form-group">
                        <label>Mit Trainer teilen:</label>
                        <button id="shareWithTrainer" class="is24-btn is24-btn-primary is24-btn-block">
                            <i class="is24-icon is24-icon-share"></i> An Trainer senden
                        </button>
                    </div>
                    
                    <div class="is24-form-group">
                        <label>Per E-Mail teilen:</label>
                        <div class="is24-input-group">
                            <input type="email" id="shareEmail" class="is24-form-control" placeholder="E-Mail-Adresse eingeben">
                            <button class="is24-btn is24-btn-primary" id="sendShareEmail">
                                <i class="is24-icon is24-icon-send"></i> Senden
                            </button>
                        </div>
                    </div>
                    
                    <div class="is24-form-group">
                        <label>Link kopieren:</label>
                        <div class="is24-input-group">
                            <input type="text" id="shareLink" class="is24-form-control" value="${_generateShareLink()}" readonly>
                            <button class="is24-btn is24-btn-secondary" id="copyShareLink">
                                <i class="is24-icon is24-icon-copy"></i> Kopieren
                            </button>
                        </div>
                    </div>
                </div>
            `,
            buttons: [
                {
                    text: 'Schließen',
                    type: 'secondary',
                    action: 'close'
                }
            ],
            onOpen: () => {
                // Event-Listener für "Mit Trainer teilen"-Button
                const trainerBtn = document.getElementById('shareWithTrainer');
                if (trainerBtn) {
                    trainerBtn.addEventListener('click', () => {
                        // Teilen mit Trainer simulieren
                        App.Modules.UI.Notification.show({
                            type: 'success',
                            message: 'Ergebnis wurde an Ihren Trainer gesendet',
                            duration: 3000
                        });
                        
                        // Dialog schließen
                        App.Modules.UI.Dialog.close();
                    });
                }
                
                // Event-Listener für "Kopieren"-Button
                const copyBtn = document.getElementById('copyShareLink');
                if (copyBtn) {
                    copyBtn.addEventListener('click', () => {
                        const linkInput = document.getElementById('shareLink');
                        if (linkInput) {
                            linkInput.select();
                            document.execCommand('copy');
                            
                            // Benutzer über erfolgreiches Kopieren informieren
                            App.Modules.UI.Notification.show({
                                type: 'success',
                                message: 'Link in die Zwischenablage kopiert',
                                duration: 2000
                            });
                        }
                    });
                }
                
                // Event-Listener für "Senden"-Button
                const sendBtn = document.getElementById('sendShareEmail');
                if (sendBtn) {
                    sendBtn.addEventListener('click', () => {
                        const emailInput = document.getElementById('shareEmail');
                        if (emailInput && emailInput.value) {
                            // E-Mail versenden (in der realen Implementierung)
                            console.log('Teilen per E-Mail an:', emailInput.value);
                            
                            // Benutzer informieren
                            App.Modules.UI.Notification.show({
                                type: 'success',
                                message: `Ergebnis per E-Mail an ${emailInput.value} geteilt`,
                                duration: 3000
                            });
                            
                            // Dialog schließen
                            App.Modules.UI.Dialog.close();
                        } else {
                            // Fehler anzeigen, wenn keine E-Mail-Adresse eingegeben wurde
                            App.Modules.UI.Notification.show({
                                type: 'error',
                                message: 'Bitte geben Sie eine gültige E-Mail-Adresse ein',
                                duration: 3000
                            });
                        }
                    });
                }
            }
        });
    }
    
    /**
     * Generiert einen teilbaren Link für das Testergebnis
     * @private
     * @returns {string} - URL zum Teilen
     */
    function _generateShareLink() {
        if (!_currentResult || !_currentResult.id) return '';
        
        // Basis-URL der Anwendung
        const baseUrl = window.location.origin + window.location.pathname;
        
        // URL mit Ergebnis-ID erstellen
        return `${baseUrl}?view=result&id=${_currentResult.id}`;
    }
    
    /**
     * Bereinigt aktive Chart.js-Instanzen
     * @private
     * @returns {void}
     */
    function _cleanupCharts() {
        _activeCharts.forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        
        _activeCharts = [];
    }
    
    /**
     * Schließt die Detailansicht
     * @returns {void}
     */
    function hide() {
        if (_elements.container) {
            // Animation entfernen
            _elements.container.classList.remove('is24-detail-view-active');
            
            // Nach der Animation Container ausblenden
            setTimeout(() => {
                _elements.container.style.display = 'none';
                
                // Scrollen wieder ermöglichen
                document.body.style.overflow = '';
                
                // Ressourcen freigeben
                _resetDetailView();
            }, 300);
        }
    }
    
    // Öffentliche API
    return {
        show: show,
        hide: hide
    };
})();
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.3 - Erweiterte Visualisierungsoptionen
 * @module js/modules/results/visualization/advanced-visualizations
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/chart-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für erweiterte Visualisierungen erstellen
App.Modules.Results = App.Modules.Results || {};
App.Modules.Results.Visualization = App.Modules.Results.Visualization || {};

/**
 * Modul für erweiterte Visualisierungsoptionen und spezialisierte Diagrammtypen
 * @namespace
 */
App.Modules.Results.Visualization.Advanced = (function() {
    // Private Variablen
    let _currentDataset = null;
    let _activeCharts = [];
    let _containerRegistry = {};
    let _colorSchemes = {
        default: {
            background: ['rgba(0, 255, 208, 0.6)', 'rgba(153, 102, 255, 0.6)', 'rgba(255, 159, 64, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(255, 205, 86, 0.6)'],
            border: ['rgba(0, 255, 208, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 205, 86, 1)']
        },
        performance: {
            background: ['rgba(255, 87, 34, 0.6)', 'rgba(255, 193, 7, 0.6)', 'rgba(0, 255, 208, 0.6)'],
            border: ['rgba(255, 87, 34, 1)', 'rgba(255, 193, 7, 1)', 'rgba(0, 255, 208, 1)']
        },
        categorical: {
            background: ['rgba(33, 150, 243, 0.6)', 'rgba(156, 39, 176, 0.6)', 'rgba(76, 175, 80, 0.6)', 'rgba(255, 87, 34, 0.6)', 'rgba(63, 81, 181, 0.6)'],
            border: ['rgba(33, 150, 243, 1)', 'rgba(156, 39, 176, 1)', 'rgba(76, 175, 80, 1)', 'rgba(255, 87, 34, 1)', 'rgba(63, 81, 181, 1)']
        },
        monochrome: {
            background: ['rgba(0, 255, 208, 0.3)', 'rgba(0, 255, 208, 0.4)', 'rgba(0, 255, 208, 0.5)', 'rgba(0, 255, 208, 0.6)', 'rgba(0, 255, 208, 0.7)'],
            border: ['rgba(0, 255, 208, 0.8)', 'rgba(0, 255, 208, 0.85)', 'rgba(0, 255, 208, 0.9)', 'rgba(0, 255, 208, 0.95)', 'rgba(0, 255, 208, 1)']
        }
    };
    
    /**
     * Initialisiert das erweiterte Visualisierungsmodul
     * @param {Object} dataset - Der zu visualisierende Datensatz
     * @returns {void}
     */
    function initialize(dataset) {
        if (!dataset) {
            throw new Error('Dataset ist erforderlich für die Initialisierung');
        }
        
        _currentDataset = dataset;
        
        // Bestehende Charts bereinigen
        _cleanupCharts();
        
        // Container-Registry zurücksetzen
        _containerRegistry = {};
        
        console.log('Erweitertes Visualisierungsmodul initialisiert');
    }
    
    /**
     * Bereinigt alle aktiven Chart-Instanzen
     * @private
     * @returns {void}
     */
    function _cleanupCharts() {
        _activeCharts.forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        
        _activeCharts = [];
    }
    
    /**
     * Registriert einen Container für eine Visualisierung
     * @param {string} id - Eindeutige ID für die Visualisierung
     * @param {HTMLElement} container - DOM-Element, das als Container dient
     * @param {Object} options - Konfigurationsoptionen für die Visualisierung
     * @returns {void}
     */
    function registerContainer(id, container, options = {}) {
        if (!id || !container) {
            throw new Error('ID und Container sind erforderlich');
        }
        
        _containerRegistry[id] = {
            container: container,
            options: options
        };
    }
    
    /**
     * Erstellt eine Heatmap-Visualisierung für Leistungsmuster
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Chart-Instanz
     */
    function createHeatmap(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = `heatmap-${containerId}`;
        container.innerHTML = '';
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Standardoptionen für Heatmap
        const defaultOptions = {
            title: 'Leistungsmuster-Heatmap',
            colorScheme: 'performance',
            xAxisLabel: 'Kategorien',
            yAxisLabel: 'Teilnehmer',
            showLegend: true
        };
        
        // Optionen kombinieren
        const chartOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const chartData = _prepareHeatmapData(data);
        
        // Farbskala basierend auf Leistung
        const getColor = (value) => {
            if (value >= 80) return 'rgba(0, 255, 208, 0.8)';
            if (value >= 70) return 'rgba(0, 255, 208, 0.6)';
            if (value >= 60) return 'rgba(255, 193, 7, 0.6)';
            if (value >= 50) return 'rgba(255, 193, 7, 0.8)';
            if (value >= 40) return 'rgba(255, 87, 34, 0.6)';
            return 'rgba(255, 87, 34, 0.8)';
        };
        
        // Plugin für Heatmap-Rendering
        const heatmapPlugin = {
            id: 'heatmapPlugin',
            beforeDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                
                // Zellenbreite und -höhe berechnen
                const cellWidth = (chartArea.right - chartArea.left) / chartData.labels.length;
                const cellHeight = (chartArea.bottom - chartArea.top) / chartData.datasets.length;
                
                // Heatmap-Zellen zeichnen
                chartData.datasets.forEach((dataset, y) => {
                    dataset.data.forEach((value, x) => {
                        const cellX = xAxis.getPixelForTick(x);
                        const cellY = yAxis.getPixelForTick(y);
                        
                        ctx.fillStyle = getColor(value);
                        ctx.fillRect(
                            cellX - cellWidth / 2,
                            cellY - cellHeight / 2,
                            cellWidth,
                            cellHeight
                        );
                        
                        // Wert in die Zelle zeichnen, wenn genug Platz ist
                        if (cellWidth > 30 && cellHeight > 20) {
                            ctx.fillStyle = 'black';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(
                                value.toFixed(0),
                                cellX,
                                cellY
                            );
                        }
                    });
                });
            }
        };
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'scatter', // Basistyp, wird durch Plugin überschrieben
            data: {
                labels: chartData.labels,
                datasets: [{
                    data: [], // Leeres Array, da wir manuell zeichnen
                    backgroundColor: 'rgba(0, 0, 0, 0)' // Transparent
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: chartOptions.title
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const datasetIndex = context.datasetIndex;
                                const dataIndex = context.dataIndex;
                                const value = chartData.datasets[datasetIndex].data[dataIndex];
                                const category = chartData.labels[dataIndex];
                                const participant = chartData.datasets[datasetIndex].label;
                                return `${participant} - ${category}: ${value}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: chartOptions.xAxisLabel
                        }
                    },
                    y: {
                        type: 'category',
                        position: 'left',
                        title: {
                            display: true,
                            text: chartOptions.yAxisLabel
                        },
                        labels: chartData.datasets.map(dataset => dataset.label)
                    }
                }
            },
            plugins: [heatmapPlugin]
        });
        
        // Chart-Instanz speichern
        _activeCharts.push(chartInstance);
        
        return chartInstance;
    }
    
    /**
     * Bereitet Daten für eine Heatmap vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für die Heatmap
     */
    function _prepareHeatmapData(data) {
        // Aufbereitungslogik für Heatmap-Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier 
        // die tatsächliche Datenaufbereitung erfolgen
        
        return {
            labels: data.categories || ['Kategorie 1', 'Kategorie 2', 'Kategorie 3', 'Kategorie 4', 'Kategorie 5'],
            datasets: data.participants ? data.participants.map(participant => ({
                label: participant.name,
                data: participant.scores
            })) : [
                { label: 'Teilnehmer 1', data: [95, 80, 75, 85, 90] },
                { label: 'Teilnehmer 2', data: [70, 65, 60, 75, 80] },
                { label: 'Teilnehmer 3', data: [85, 90, 80, 65, 75] },
                { label: 'Teilnehmer 4', data: [60, 55, 40, 70, 65] },
                { label: 'Teilnehmer 5', data: [50, 45, 35, 40, 55] }
            ]
        };
    }
    
    /**
     * Erstellt ein Netzwerkdiagramm für Zusammenhänge zwischen Themen
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Visualisierungs-Instanz
     */
    function createNetworkGraph(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Container vorbereiten
        container.innerHTML = '';
        container.classList.add('is24-network-graph-container');
        
        // Standardoptionen für Netzwerkdiagramm
        const defaultOptions = {
            title: 'Themen-Korrelationsdiagramm',
            colorScheme: 'default',
            nodeSize: 'score', // 'score' oder 'fixed'
            edgeThickness: 'correlation', // 'correlation' oder 'fixed'
            interactive: true
        };
        
        // Optionen kombinieren
        const graphOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const graphData = _prepareNetworkData(data);
        
        // SVG für das Netzwerkdiagramm erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 800 600');
        container.appendChild(svg);
        
        // Titel hinzufügen
        const titleElement = document.createElement('h3');
        titleElement.className = 'is24-graph-title';
        titleElement.textContent = graphOptions.title;
        container.insertBefore(titleElement, svg);
        
        // D3.js-Force-Layout für das Netzwerkdiagramm
        const width = 800;
        const height = 600;
        
        // Knoten- und Kantengruppen erstellen
        const g = d3.select(svg).append('g');
        const linkGroup = g.append('g').attr('class', 'links');
        const nodeGroup = g.append('g').attr('class', 'nodes');
        const labelGroup = g.append('g').attr('class', 'labels');
        
        // Farbskala basierend auf der gewählten Farbpalette
        const colorScheme = _colorSchemes[graphOptions.colorScheme] || _colorSchemes.default;
        const colorScale = d3.scaleOrdinal()
            .domain(graphData.nodes.map(node => node.group))
            .range(colorScheme.background);
        
        // Simulation für Knoten und Kanten
        const simulation = d3.forceSimulation(graphData.nodes)
            .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => d.radius + 10));
        
        // Kanten zeichnen
        const links = linkGroup.selectAll('line')
            .data(graphData.links)
            .enter()
            .append('line')
            .attr('stroke-width', d => graphOptions.edgeThickness === 'correlation' ? d.value * 5 : 2)
            .attr('stroke', 'rgba(120, 120, 120, 0.5)');
        
        // Knoten zeichnen
        const nodes = nodeGroup.selectAll('circle')
            .data(graphData.nodes)
            .enter()
            .append('circle')
            .attr('r', d => graphOptions.nodeSize === 'score' ? (d.score * 0.4 + 10) : 20)
            .attr('fill', d => colorScale(d.group))
            .attr('stroke', d => d3.rgb(colorScale(d.group)).darker(0.5))
            .attr('stroke-width', 2);
        
        // Beschriftungen hinzufügen
        const labels = labelGroup.selectAll('text')
            .data(graphData.nodes)
            .enter()
            .append('text')
            .text(d => d.name)
            .attr('font-size', '12px')
            .attr('font-family', 'Arial')
            .attr('text-anchor', 'middle')
            .attr('dy', 4);
        
        // Tooltips für Knoten
        if (graphOptions.interactive) {
            nodes.append('title')
                .text(d => `${d.name}\nScore: ${d.score}%\nGruppe: ${d.group}`);
        }
        
        // Interaktives Ziehen der Knoten
        if (graphOptions.interactive) {
            nodes.call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
        }
        
        // Simulation aktualisieren
        simulation.on('tick', () => {
            links
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            nodes
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
                
            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y - (graphOptions.nodeSize === 'score' ? (d.score * 0.4 + 15) : 25));
        });
        
        // Drag-Funktionen
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Zoom-Funktionalität hinzufügen
        if (graphOptions.interactive) {
            const zoom = d3.zoom()
                .scaleExtent([0.5, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            d3.select(svg).call(zoom);
        }
        
        // Legende hinzufügen
        if (graphOptions.showLegend) {
            const uniqueGroups = [...new Set(graphData.nodes.map(node => node.group))];
            
            const legendContainer = document.createElement('div');
            legendContainer.className = 'is24-graph-legend';
            
            const legend = document.createElement('ul');
            legend.className = 'is24-legend-list';
            
            uniqueGroups.forEach((group, index) => {
                const legendItem = document.createElement('li');
                legendItem.className = 'is24-legend-item';
                
                const colorBox = document.createElement('span');
                colorBox.className = 'is24-legend-color';
                colorBox.style.backgroundColor = colorScheme.background[index % colorScheme.background.length];
                
                const label = document.createElement('span');
                label.className = 'is24-legend-label';
                label.textContent = group;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legend.appendChild(legendItem);
            });
            
            legendContainer.appendChild(legend);
            container.appendChild(legendContainer);
        }
        
        // Instanz für späteres Referenzieren zurückgeben
        return {
            svg: svg,
            simulation: simulation,
            nodes: nodes,
            links: links,
            labels: labels
        };
    }
    
    /**
     * Bereitet Daten für ein Netzwerkdiagramm vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für das Netzwerkdiagramm
     */
    function _prepareNetworkData(data) {
        // Aufbereitungslogik für Netzwerkdiagramm-Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier
        // die tatsächliche Datenaufbereitung erfolgen
        
        return data.network || {
            nodes: [
                { id: 'cat1', name: 'Grundlagen', group: 'Basis', score: 85 },
                { id: 'cat2', name: 'Immobilienbewertung', group: 'Kernkompetenz', score: 78 },
                { id: 'cat3', name: 'Marktanalyse', group: 'Kernkompetenz', score: 65 },
                { id: 'cat4', name: 'Rechtliches', group: 'Spezialwissen', score: 72 },
                { id: 'cat5', name: 'Finanzierung', group: 'Spezialwissen', score: 80 },
                { id: 'cat6', name: 'Verkaufsprozesse', group: 'Anwendung', score: 88 },
                { id: 'cat7', name: 'Kundenkommunikation', group: 'Anwendung', score: 92 },
                { id: 'cat8', name: 'Digitale Tools', group: 'Technologie', score: 75 }
            ],
            links: [
                { source: 'cat1', target: 'cat2', value: 0.7 },
                { source: 'cat1', target: 'cat3', value: 0.6 },
                { source: 'cat1', target: 'cat4', value: 0.5 },
                { source: 'cat2', target: 'cat5', value: 0.8 },
                { source: 'cat2', target: 'cat6', value: 0.7 },
                { source: 'cat3', target: 'cat6', value: 0.9 },
                { source: 'cat4', target: 'cat6', value: 0.4 },
                { source: 'cat5', target: 'cat6', value: 0.6 },
                { source: 'cat6', target: 'cat7', value: 0.8 },
                { source: 'cat7', target: 'cat8', value: 0.5 },
                { source: 'cat3', target: 'cat8', value: 0.3 }
            ]
        };
    }
    
    /**
     * Erstellt einen hierarchischen Baum für Kompetenzstrukturen
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Visualisierungs-Instanz
     */
    function createHierarchyTree(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Container vorbereiten
        container.innerHTML = '';
        container.classList.add('is24-hierarchy-tree-container');
        
        // Standardoptionen für hierarchischen Baum
        const defaultOptions = {
            title: 'Kompetenzstruktur',
            colorScheme: 'categorical',
            layout: 'tree', // 'tree' oder 'cluster'
            direction: 'vertical', // 'vertical' oder 'horizontal'
            interactive: true,
            showValues: true
        };
        
        // Optionen kombinieren
        const treeOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const treeData = _prepareHierarchyData(data);
        
        // Titel hinzufügen
        const titleElement = document.createElement('h3');
        titleElement.className = 'is24-graph-title';
        titleElement.textContent = treeOptions.title;
        container.appendChild(titleElement);
        
        // SVG für den hierarchischen Baum erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 1000 600');
        container.appendChild(svg);
        
        // D3.js für den hierarchischen Baum
        const width = 1000;
        const height = 600;
        const margin = { top: 40, right: 120, bottom: 40, left: 120 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        // Baumstruktur erstellen
        const root = d3.hierarchy(treeData);
        
        // Layout festlegen
        let treeLayout;
        if (treeOptions.layout === 'cluster') {
            treeLayout = d3.cluster().size(
                treeOptions.direction === 'vertical' ? [innerWidth, innerHeight] : [innerHeight, innerWidth]
            );
        } else {
            treeLayout = d3.tree().size(
                treeOptions.direction === 'vertical' ? [innerWidth, innerHeight] : [innerHeight, innerWidth]
            );
        }
        
        // Layoutberechnung anwenden
        treeLayout(root);
        
        // Hauptgruppe mit Randabstand
        const g = d3.select(svg)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Farbskala basierend auf der gewählten Farbpalette
        const colorScheme = _colorSchemes[treeOptions.colorScheme] || _colorSchemes.default;
        const colorScale = d3.scaleOrdinal(colorScheme.background);
        
        // Links (Verbindungen) zeichnen
        const link = g.selectAll('.link')
            .data(root.links())
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', 1.5)
            .attr('d', d => {
                if (treeOptions.direction === 'vertical') {
                    return d3.linkVertical()
                        .x(d => d.x)
                        .y(d => d.y)(d);
                } else {
                    return d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x)(d);
                }
            });
        
        // Knotengruppe für jeden Knoten
        const node = g.selectAll('.node')
            .data(root.descendants())
            .enter()
            .append('g')
            .attr('class', d => `node ${d.children ? 'node-internal' : 'node-leaf'}`)
            .attr('transform', d => {
                if (treeOptions.direction === 'vertical') {
                    return `translate(${d.x},${d.y})`;
                } else {
                    return `translate(${d.y},${d.x})`;
                }
            });
        
        // Kreise für Knoten zeichnen
        node.append('circle')
            .attr('r', d => {
                // Größe basierend auf Wert und Tiefe
                const baseSize = 4;
                const valueMultiplier = d.data.value ? d.data.value / 25 : 1;
                const depthMultiplier = 1 - (d.depth * 0.1);
                return baseSize + (valueMultiplier * depthMultiplier * baseSize);
            })
            .attr('fill', d => colorScale(d.depth))
            .attr('stroke', d => d3.rgb(colorScale(d.depth)).darker(0.5))
            .attr('stroke-width', 1.5);
        
        // Labels für Knoten hinzufügen
        node.append('text')
            .attr('dy', d => d.children ? -12 : 4)
            .attr('dx', d => d.children ? 0 : (treeOptions.direction === 'vertical' ? 8 : -8))
            .attr('text-anchor', d => {
                if (treeOptions.direction === 'vertical') {
                    return d.children ? 'middle' : 'start';
                } else {
                    return d.children ? 'middle' : 'end';
                }
            })
            .text(d => d.data.name)
            .attr('font-size', '12px')
            .attr('font-family', 'Arial');
        
        // Werte anzeigen, wenn Option aktiviert
        if (treeOptions.showValues) {
            node.filter(d => d.data.value !== undefined)
                .append('text')
                .attr('dy', d => d.children ? 4 : 20)
                .attr('dx', d => d.children ? 0 : (treeOptions.direction === 'vertical' ? 8 : -8))
                .attr('text-anchor', d => {
                    if (treeOptions.direction === 'vertical') {
                        return d.children ? 'middle' : 'start';
                    } else {
                        return d.children ? 'middle' : 'end';
                    }
                })
                .text(d => `${d.data.value}%`)
                .attr('font-size', '10px')
                .attr('font-family', 'Arial')
                .attr('fill', '#666');
        }
        
        // Interaktivität hinzufügen
        if (treeOptions.interactive) {
            // Tooltip für detaillierte Infos
            node.append('title')
                .text(d => {
                    let tooltip = `${d.data.name}`;
                    if (d.data.value !== undefined) {
                        tooltip += `\nWert: ${d.data.value}%`;
                    }
                    if (d.data.description) {
                        tooltip += `\n${d.data.description}`;
                    }
                    return tooltip;
                });
            
            // Zoom-Funktionalität
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3])
                .on('zoom', (event) => {
                    g.attr('transform', `translate(${event.transform.x + margin.left},${event.transform.y + margin.top}) scale(${event.transform.k})`);
                });
                
            d3.select(svg).call(zoom);
        }
        
        // Legende für Tiefenstufen
        const maxDepth = d3.max(root.descendants(), d => d.depth);
        if (maxDepth > 0) {
            const legendContainer = document.createElement('div');
            legendContainer.className = 'is24-graph-legend';
            
            const legend = document.createElement('ul');
            legend.className = 'is24-legend-list';
            
            for (let depth = 0; depth <= maxDepth; depth++) {
                const legendItem = document.createElement('li');
                legendItem.className = 'is24-legend-item';
                
                const colorBox = document.createElement('span');
                colorBox.className = 'is24-legend-color';
                colorBox.style.backgroundColor = colorScale(depth);
                
                const label = document.createElement('span');
                label.className = 'is24-legend-label';
                label.textContent = `Ebene ${depth}`;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legend.appendChild(legendItem);
            }
            
            legendContainer.appendChild(legend);
            container.appendChild(legendContainer);
        }
        
        // Instanz für späteres Referenzieren zurückgeben
        return {
            svg: svg,
            root: root,
            nodes: node,
            links: link
        };
    }
    
    /**
     * Bereitet Daten für eine hierarchische Baumstruktur vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für die Baumstruktur
     */
    function _prepareHierarchyData(data) {
        // Aufbereitungslogik für hierarchische Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier
        // die tatsächliche Datenaufbereitung erfolgen
        
        return data.hierarchy || {
            name: "Immobilienwissen",
            value: 82,
            description: "Gesamtwissen im Immobilienbereich",
            children: [
                {
                    name: "Grundlagen",
                    value: 90,
                    description: "Basiswissen zur Immobilienbranche",
                    children: [
                        { name: "Marktstruktur", value: 95, description: "Aufbau und Struktur des Immobilienmarktes" },
                        { name: "Akteure", value: 88, description: "Wichtige Akteure auf dem Immobilienmarkt" },
                        { name: "Grundbegriffe", value: 92, description: "Zentrale Begriffe und Definitionen" }
                    ]
                },
                {
                    name: "Immobilienbewertung",
                    value: 75,
                    description: "Methoden zur Wertermittlung",
                    children: [
                        { name: "Vergleichswertverfahren", value: 80, description: "Bewertung anhand von Vergleichsobjekten" },
                        { name: "Ertragswertverfahren", value: 72, description: "Bewertung basierend auf erwarteten Erträgen" },
                        { name: "Sachwertverfahren", value: 68, description: "Bewertung auf Basis der Herstellungskosten" }
                    ]
                },
                {
                    name: "Rechtliches",
                    value: 78,
                    description: "Rechtliche Grundlagen",
                    children: [
                        { name: "Mietrecht", value: 82, description: "Rechtliche Grundlagen zur Vermietung" },
                        { name: "Kaufvertragsrecht", value: 76, description: "Rechtliche Aspekte beim Immobilienkauf" },
                        { name: "Maklerrecht", value: 74, description: "Rechtliche Grundlagen für Maklerdienstleistungen" }
                    ]
                },
                {
                    name: "Verkaufsprozesse",
                    value: 85,
                    description: "Prozesse im Immobilienverkauf",
                    children: [
                        { name: "Kundenakquise", value: 88, description: "Gewinnung von potenziellen Käufern" },
                        { name: "Immobilienpräsentation", value: 90, description: "Effektive Darstellung von Immobilien" },
                        { name: "Verkaufsabschluss", value: 82, description: "Erfolgreiche Abwicklung des Verkaufs" }
                    ]
                }
            ]
        };
    }
    
    /**
     * Erstellt eine animierte Zeitachsen-Visualisierung
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Visualisierungs-Instanz
     */
    function createTimelineVisualization(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Container vorbereiten
        container.innerHTML = '';
        container.classList.add('is24-timeline-container');
        
        // Standardoptionen für Zeitachsen-Visualisierung
        const defaultOptions = {
            title: 'Leistungsentwicklung über Zeit',
            colorScheme: 'default',
            animate: true,
            showLabels: true,
            showAxis: true,
            showGrid: true,
            autoPlay: false,
            playDuration: 3000
        };
        
        // Optionen kombinieren
        const timelineOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const timelineData = _prepareTimelineData(data);
        
        // Titel hinzufügen
        const titleElement = document.createElement('h3');
        titleElement.className = 'is24-graph-title';
        titleElement.textContent = timelineOptions.title;
        container.appendChild(titleElement);
        
        // Steuerelemente für Animation
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'is24-timeline-controls';
        
        const playButton = document.createElement('button');
        playButton.className = 'is24-btn is24-btn-sm is24-btn-primary';
        playButton.innerHTML = '<i class="is24-icon is24-icon-play"></i> Abspielen';
        controlsContainer.appendChild(playButton);
        
        const resetButton = document.createElement('button');
        resetButton.className = 'is24-btn is24-btn-sm is24-btn-secondary';
        resetButton.innerHTML = '<i class="is24-icon is24-icon-reset"></i> Zurücksetzen';
        controlsContainer.appendChild(resetButton);
        
        const timeSlider = document.createElement('input');
        timeSlider.type = 'range';
        timeSlider.min = 0;
        timeSlider.max = timelineData.timePoints.length - 1;
        timeSlider.value = 0;
        timeSlider.className = 'is24-timeline-slider';
        controlsContainer.appendChild(timeSlider);
        
        const timeLabel = document.createElement('span');
        timeLabel.className = 'is24-timeline-label';
        timeLabel.textContent = timelineData.timePoints[0] || '';
        controlsContainer.appendChild(timeLabel);
        
        container.appendChild(controlsContainer);
        
        // SVG für die Zeitachsen-Visualisierung erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '70%'); // Platz für Steuerelemente lassen
        svg.setAttribute('viewBox', '0 0 800 400');
        container.appendChild(svg);
        
        // D3.js für die Zeitachsen-Visualisierung
        const width = 800;
        const height = 400;
        const margin = { top: 20, right: 80, bottom: 30, left: 50 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        // Hauptgruppe mit Randabstand
        const g = d3.select(svg)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Skalierung für x-Achse (Zeit)
        const x = d3.scalePoint()
            .domain(timelineData.timePoints)
            .range([0, innerWidth]);
        
        // Skalierung für y-Achse (Werte)
        const y = d3.scaleLinear()
            .domain([0, 100]) // Prozentuale Werte
            .range([innerHeight, 0]);
        
        // Farbskala basierend auf der gewählten Farbpalette
        const colorScheme = _colorSchemes[timelineOptions.colorScheme] || _colorSchemes.default;
        const colorScale = d3.scaleOrdinal()
            .domain(timelineData.series.map(s => s.name))
            .range(colorScheme.background);
        
        // Achsen hinzufügen
        if (timelineOptions.showAxis) {
            // X-Achse
            const xAxis = g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0, ${innerHeight})`)
                .call(d3.axisBottom(x));
            
            // Y-Achse
            const yAxis = g.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(y).ticks(5));
            
            // Beschriftung der Y-Achse
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 15)
                .attr('x', -innerHeight / 2)
                .attr('dy', '1em')
                .attr('text-anchor', 'middle')
                .text('Punktzahl (%)');
        }
        
        // Gitternetzlinien hinzufügen
        if (timelineOptions.showGrid) {
            // Horizontale Gitternetzlinien
            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickSize(-innerWidth)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove())
                .call(g => g.selectAll('.tick line')
                    .attr('stroke', '#e0e0e0')
                    .attr('stroke-dasharray', '3,3'));
                    
            // Vertikale Gitternetzlinien
            g.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0, ${innerHeight})`)
                .call(d3.axisBottom(x)
                    .tickSize(-innerHeight)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove())
                .call(g => g.selectAll('.tick line')
                    .attr('stroke', '#e0e0e0')
                    .attr('stroke-dasharray', '3,3'));
        }
        
        // Liniengenerator
        const line = d3.line()
            .x((d, i) => x(timelineData.timePoints[i]))
            .y(d => y(d))
            .curve(d3.curveMonotoneX); // Glatte Kurven
        
        // Linien für jede Serie zeichnen
        const seriesGroup = g.append('g').attr('class', 'series');
        
        // Kreise für Datenpunkte zeichnen
        const pointsGroup = g.append('g').attr('class', 'data-points');
        
        // Animation steuern
        let currentTimeIndex = 0;
        let animationTimer = null;
        
        // Funktion zum Zeichnen des Diagramms bis zu einem bestimmten Zeitpunkt
        function drawUpToTimePoint(timeIndex) {
            currentTimeIndex = timeIndex;
            timeSlider.value = timeIndex;
            timeLabel.textContent = timelineData.timePoints[timeIndex];
            
            // Alle vorherigen Linien und Punkte entfernen
            seriesGroup.selectAll('*').remove();
            pointsGroup.selectAll('*').remove();
            
            // Teilmenge der Daten bis zum aktuellen Zeitpunkt
            const visibleTimePoints = timelineData.timePoints.slice(0, timeIndex + 1);
            
            // Für jede Serie die Linie zeichnen
            timelineData.series.forEach((series, seriesIndex) => {
                const seriesData = series.data.slice(0, timeIndex + 1);
                
                // Linie zeichnen
                seriesGroup.append('path')
                    .datum(seriesData)
                    .attr('class', 'line')
                    .attr('fill', 'none')
                    .attr('stroke', colorScale(series.name))
                    .attr('stroke-width', 2.5)
                    .attr('d', line);
                
                // Datenpunkte zeichnen
                pointsGroup.selectAll(`.point-${seriesIndex}`)
                    .data(seriesData)
                    .enter()
                    .append('circle')
                    .attr('class', `point-${seriesIndex}`)
                    .attr('cx', (d, i) => x(visibleTimePoints[i]))
                    .attr('cy', d => y(d))
                    .attr('r', 5)
                    .attr('fill', colorScale(series.name))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);
            });
        }
        
        // Animation starten
        function startAnimation() {
            // Animation zurücksetzen
            stopAnimation();
            currentTimeIndex = 0;
            
            // Status des Play-Buttons aktualisieren
            playButton.innerHTML = '<i class="is24-icon is24-icon-pause"></i> Pause';
            
            // Animation starten
            function animate() {
                drawUpToTimePoint(currentTimeIndex);
                
                currentTimeIndex++;
                
                if (currentTimeIndex >= timelineData.timePoints.length) {
                    stopAnimation();
                    return;
                }
                
                // Nächsten Frame planen
                const frameDuration = timelineOptions.playDuration / timelineData.timePoints.length;
                animationTimer = setTimeout(animate, frameDuration);
            }
            
            animate();
        }
        
        // Animation stoppen
        function stopAnimation() {
            if (animationTimer) {
                clearTimeout(animationTimer);
                animationTimer = null;
            }
            
            // Status des Play-Buttons aktualisieren
            playButton.innerHTML = '<i class="is24-icon is24-icon-play"></i> Abspielen';
        }
        
        // Diagramm zurücksetzen
        function resetVisualization() {
            stopAnimation();
            currentTimeIndex = 0;
            drawUpToTimePoint(currentTimeIndex);
        }
        
        // Event-Listener für Steuerelemente
        playButton.addEventListener('click', () => {
            if (animationTimer) {
                stopAnimation();
            } else {
                if (currentTimeIndex >= timelineData.timePoints.length - 1) {
                    resetVisualization();
                }
                startAnimation();
            }
        });
        
        resetButton.addEventListener('click', resetVisualization);
        
        timeSlider.addEventListener('input', (e) => {
            stopAnimation();
            drawUpToTimePoint(parseInt(e.target.value));
        });
        
        // Legende hinzufügen
        const legendContainer = document.createElement('div');
        legendContainer.className = 'is24-graph-legend';
        
        const legend = document.createElement('ul');
        legend.className = 'is24-legend-list';
        
        timelineData.series.forEach((series, index) => {
            const legendItem = document.createElement('li');
            legendItem.className = 'is24-legend-item';
            
            const colorBox = document.createElement('span');
            colorBox.className = 'is24-legend-color';
            colorBox.style.backgroundColor = colorScale(series.name);
            
            const label = document.createElement('span');
            label.className = 'is24-legend-label';
            label.textContent = series.name;
            
            legendItem.appendChild(colorBox);
            legendItem.appendChild(label);
            legend.appendChild(legendItem);
        });
        
        legendContainer.appendChild(legend);
        container.appendChild(legendContainer);
        
        // Anfängliches Zeichnen
        drawUpToTimePoint(0);
        
        // Autoplay, wenn aktiviert
        if (timelineOptions.autoPlay) {
            setTimeout(startAnimation, 500);
        }
        
        // Instanz für späteres Referenzieren zurückgeben
        return {
            svg: svg,
            play: startAnimation,
            stop: stopAnimation,
            reset: resetVisualization,
            jumpToTime: drawUpToTimePoint
        };
    }
    
    /**
     * Bereitet Daten für eine Zeitachsen-Visualisierung vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für die Zeitachsen-Visualisierung
     */
    function _prepareTimelineData(data) {
        // Aufbereitungslogik für Zeitachsen-Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier
        // die tatsächliche Datenaufbereitung erfolgen
        
        return data.timeline || {
            timePoints: ['Jan 2023', 'Feb 2023', 'Mär 2023', 'Apr 2023', 'Mai 2023', 'Jun 2023'],
            series: [
                {
                    name: 'Teilnehmer',
                    data: [45, 58, 62, 70, 75, 82]
                },
                {
                    name: 'Team-Durchschnitt',
                    data: [60, 62, 65, 68, 70, 72]
                },
                {
                    name: 'Unternehmens-Durchschnitt',
                    data: [65, 66, 67, 68, 69, 70]
                }
            ]
        };
    }
    
    /**
     * Erstellt ein Sankey-Diagramm für Lernpfade und Übergänge
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Visualisierungs-Instanz
     */
    function createSankeyDiagram(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Container vorbereiten
        container.innerHTML = '';
        container.classList.add('is24-sankey-container');
        
        // Standardoptionen für Sankey-Diagramm
        const defaultOptions = {
            title: 'Lernpfad-Analyse',
            colorScheme: 'categorical',
            nodeWidth: 15,
            nodePadding: 10,
            interactive: true,
            showValues: true
        };
        
        // Optionen kombinieren
        const sankeyOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const sankeyData = _prepareSankeyData(data);
        
        // Titel hinzufügen
        const titleElement = document.createElement('h3');
        titleElement.className = 'is24-graph-title';
        titleElement.textContent = sankeyOptions.title;
        container.appendChild(titleElement);
        
        // SVG für das Sankey-Diagramm erstellen
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 900 500');
        container.appendChild(svg);
        
        // D3.js für das Sankey-Diagramm
        const width = 900;
        const height = 500;
        const margin = { top: 10, right: 10, bottom: 10, left: 10 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        // Hauptgruppe mit Randabstand
        const g = d3.select(svg)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // Sankey-Generator
        const sankey = d3.sankey()
            .nodeWidth(sankeyOptions.nodeWidth)
            .nodePadding(sankeyOptions.nodePadding)
            .extent([[0, 0], [innerWidth, innerHeight]]);
        
        // Farbskala basierend auf der gewählten Farbpalette
        const colorScheme = _colorSchemes[sankeyOptions.colorScheme] || _colorSchemes.default;
        const colorScale = d3.scaleOrdinal(colorScheme.background);
        
        // Sankey-Layout anwenden
        const { nodes, links } = sankey({
            nodes: sankeyData.nodes.map(d => Object.assign({}, d)),
            links: sankeyData.links.map(d => Object.assign({}, d))
        });
        
        // Linkpfad-Generator
        const linkGenerator = d3.sankeyLinkHorizontal();
        
        // Links (Verbindungen) zeichnen
        const link = g.append('g')
            .attr('class', 'links')
            .selectAll('path')
            .data(links)
            .enter()
            .append('path')
            .attr('d', linkGenerator)
            .attr('fill', 'none')
            .attr('stroke', d => {
                return d3.color(colorScale(d.source.name)).darker(0.5);
            })
            .attr('stroke-width', d => Math.max(1, d.width))
            .attr('stroke-opacity', 0.5)
            .style('mix-blend-mode', 'multiply');
        
        // Tooltip für Links hinzufügen
        if (sankeyOptions.interactive) {
            link.append('title')
                .text(d => `${d.source.name} → ${d.target.name}\nFluss: ${d.value}`);
        }
        
        // Knoten zeichnen
        const node = g.append('g')
            .attr('class', 'nodes')
            .selectAll('g')
            .data(nodes)
            .enter()
            .append('g');
        
        // Rechtecke für Knoten
        node.append('rect')
            .attr('x', d => d.x0)
            .attr('y', d => d.y0)
            .attr('height', d => d.y1 - d.y0)
            .attr('width', d => d.x1 - d.x0)
            .attr('fill', d => colorScale(d.name))
            .attr('stroke', d => d3.rgb(colorScale(d.name)).darker(0.5));
        
        // Labels für Knoten
        node.append('text')
            .attr('x', d => d.x0 < innerWidth / 2 ? d.x1 + 6 : d.x0 - 6)
            .attr('y', d => (d.y1 + d.y0) / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', d => d.x0 < innerWidth / 2 ? 'start' : 'end')
            .text(d => d.name)
            .attr('font-size', '10px')
            .attr('font-family', 'Arial');
        
        // Tooltip für Knoten hinzufügen
        if (sankeyOptions.interactive) {
            node.append('title')
                .text(d => `${d.name}\nWert: ${d.value}`);
        }
        
        // Werte anzeigen, wenn Option aktiviert
        if (sankeyOptions.showValues) {
            node.append('text')
                .attr('x', d => d.x0 < innerWidth / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr('y', d => (d.y1 + d.y0) / 2 + 14)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.x0 < innerWidth / 2 ? 'start' : 'end')
                .text(d => `${d.value}%`)
                .attr('font-size', '9px')
                .attr('font-family', 'Arial')
                .attr('fill', '#666');
        }
        
        // Interaktivität hinzufügen
        if (sankeyOptions.interactive) {
            // Zoom-Funktionalität
            const zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .on('zoom', (event) => {
                    g.attr('transform', `translate(${event.transform.x + margin.left},${event.transform.y + margin.top}) scale(${event.transform.k})`);
                });
                
            d3.select(svg).call(zoom);
            
            // Hover-Effekt für Knoten
            node.select('rect')
                .on('mouseover', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('fill-opacity', 0.8)
                        .attr('stroke-width', 2);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('fill-opacity', 1)
                        .attr('stroke-width', 1);
                });
            
            // Hover-Effekt für Links
            link.on('mouseover', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('stroke-opacity', 0.8)
                        .attr('stroke-width', d => Math.max(3, d.width));
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('stroke-opacity', 0.5)
                        .attr('stroke-width', d => Math.max(1, d.width));
                });
        }
        
        // Instanz für späteres Referenzieren zurückgeben
        return {
            svg: svg,
            nodes: node,
            links: link
        };
    }
    
    /**
     * Bereitet Daten für ein Sankey-Diagramm vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für das Sankey-Diagramm
     */
    function _prepareSankeyData(data) {
        // Aufbereitungslogik für Sankey-Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier
        // die tatsächliche Datenaufbereitung erfolgen
        
        return data.sankey || {
            nodes: [
                { name: 'Grundlagenkurs', group: 'Einführung', value: 100 },
                { name: 'Immobilienbewertung', group: 'Kernkompetenz', value: 75 },
                { name: 'Rechtlicher Rahmen', group: 'Kernkompetenz', value: 65 },
                { name: 'Verkaufstraining', group: 'Anwendung', value: 60 },
                { name: 'Finanzierungsberatung', group: 'Anwendung', value: 50 },
                { name: 'Digitale Werkzeuge', group: 'Technologie', value: 40 },
                { name: 'Abschlussprüfung', group: 'Zertifizierung', value: 85 }
            ],
            links: [
                { source: 0, target: 1, value: 40 },
                { source: 0, target: 2, value: 35 },
                { source: 0, target: 5, value: 25 },
                { source: 1, target: 3, value: 25 },
                { source: 1, target: 4, value: 15 },
                { source: 2, target: 3, value: 20 },
                { source: 2, target: 4, value: 15 },
                { source: 3, target: 6, value: 45 },
                { source: 4, target: 6, value: 30 },
                { source: 5, target: 3, value: 15 },
                { source: 5, target: 6, value: 10 }
            ]
        };
    }
    
    /**
     * Erstellt ein Kompetenzradar für detaillierte Kompetenzanalysen
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} data - Daten für die Visualisierung
     * @param {Object} options - Zusätzliche Konfigurationsoptionen
     * @returns {Object} Chart-Instanz
     */
    function createCompetencyRadar(containerId, data, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        const mergedOptions = Object.assign({}, containerInfo.options, options);
        
        // Container vorbereiten
        container.innerHTML = '';
        
        // Standardoptionen für Kompetenzradar
        const defaultOptions = {
            title: 'Kompetenzprofil',
            colorScheme: 'default',
            showTargetLevel: true,
            showAverageComparison: true,
            showLabels: true,
            interactive: true
        };
        
        // Optionen kombinieren
        const radarOptions = Object.assign({}, defaultOptions, mergedOptions);
        
        // Daten vorbereiten
        const radarData = _prepareCompetencyRadarData(data);
        
        // Titel hinzufügen
        const titleElement = document.createElement('h3');
        titleElement.className = 'is24-graph-title';
        titleElement.textContent = radarOptions.title;
        container.appendChild(titleElement);
        
        // Canvas für Chart.js erstellen
        const canvas = document.createElement('canvas');
        canvas.id = `competency-radar-${containerId}`;
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // Farbschema
        const colorScheme = _colorSchemes[radarOptions.colorScheme] || _colorSchemes.default;
        
        // Datensätze für das Radar-Diagramm
        const datasets = [
            {
                label: 'Aktuelle Kompetenz',
                data: radarData.currentLevels,
                backgroundColor: 'rgba(0, 255, 208, 0.3)',
                borderColor: 'rgba(0, 255, 208, 1)',
                borderWidth: 2,
                pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgba(0, 255, 208, 1)',
                pointRadius: 4
            }
        ];
        
        // Zielkompetenzlevel hinzufügen, falls aktiviert
        if (radarOptions.showTargetLevel && radarData.targetLevels) {
            datasets.push({
                label: 'Zielkompetenz',
                data: radarData.targetLevels,
                backgroundColor: 'rgba(255, 159, 64, 0.1)',
                borderColor: 'rgba(255, 159, 64, 1)',
                borderWidth: 1,
                borderDash: [5, 5],
                pointBackgroundColor: 'rgba(255, 159, 64, 1)',
                pointBorderColor: '#fff',
                pointRadius: 3
            });
        }
        
        // Durchschnittsvergleich hinzufügen, falls aktiviert
        if (radarOptions.showAverageComparison && radarData.averageLevels) {
            datasets.push({
                label: 'Team-Durchschnitt',
                data: radarData.averageLevels,
                backgroundColor: 'rgba(153, 102, 255, 0.1)',
                borderColor: 'rgba(153, 102, 255, 1)',
                borderWidth: 1,
                pointBackgroundColor: 'rgba(153, 102, 255, 1)',
                pointBorderColor: '#fff',
                pointRadius: 3
            });
        }
        
        // Chart.js-Instanz erstellen
        const chartInstance = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: radarData.competencies,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: {
                            display: true
                        },
                        suggestedMin: 0,
                        suggestedMax: 100,
                        ticks: {
                            stepSize: 20,
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        pointLabels: {
                            font: {
                                size: 12
                            }
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false // Titel bereits als HTML hinzugefügt
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.r !== null) {
                                    label += context.parsed.r + '%';
                                }
                                return label;
                            }
                        }
                    }
                },
                elements: {
                    line: {
                        tension: 0.1 // Etwas glattere Linien
                    }
                }
            }
        });
        
        // Chart-Instanz speichern
        _activeCharts.push(chartInstance);
        
        // Kompetenzlücken analysieren und anzeigen
        if (radarData.targetLevels) {
            const gapAnalysisContainer = document.createElement('div');
            gapAnalysisContainer.className = 'is24-competency-gap-analysis';
            
            // Titel für Lückenanalyse
            const gapTitle = document.createElement('h4');
            gapTitle.textContent = 'Kompetenzlückenanalyse';
            gapAnalysisContainer.appendChild(gapTitle);
            
            // Tabelle für Lückenanalyse
            const table = document.createElement('table');
            table.className = 'is24-table is24-table-striped is24-table-compact';
            
            // Tabellen-Header
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th>Kompetenz</th>
                    <th>Aktuell</th>
                    <th>Ziel</th>
                    <th>Lücke</th>
                    <th>Priorität</th>
                </tr>
            `;
            table.appendChild(thead);
            
            // Tabellen-Körper
            const tbody = document.createElement('tbody');
            
            // Kompetenzlücken berechnen und sortieren (nach Größe der Lücke)
            const gaps = radarData.competencies.map((competency, index) => {
                const current = radarData.currentLevels[index];
                const target = radarData.targetLevels[index];
                const gap = target - current;
                
                // Priorität basierend auf der Lückengröße
                let priority;
                if (gap <= 0) {
                    priority = 'Erreicht';
                } else if (gap < 10) {
                    priority = 'Niedrig';
                } else if (gap < 20) {
                    priority = 'Mittel';
                } else {
                    priority = 'Hoch';
                }
                
                return {
                    competency,
                    current,
                    target,
                    gap,
                    priority
                };
            }).sort((a, b) => b.gap - a.gap);
            
            // Nur die größten Lücken anzeigen (maximal 5)
            gaps.slice(0, 5).forEach(item => {
                const row = document.createElement('tr');
                
                // CSS-Klasse basierend auf Priorität
                let priorityClass = '';
                if (item.priority === 'Hoch') {
                    priorityClass = 'is24-priority-high';
                } else if (item.priority === 'Mittel') {
                    priorityClass = 'is24-priority-medium';
                } else if (item.priority === 'Niedrig') {
                    priorityClass = 'is24-priority-low';
                } else {
                    priorityClass = 'is24-priority-none';
                }
                
                row.innerHTML = `
                    <td>${item.competency}</td>
                    <td>${item.current.toFixed(1)}%</td>
                    <td>${item.target.toFixed(1)}%</td>
                    <td>${item.gap > 0 ? '+' + item.gap.toFixed(1) + '%' : item.gap.toFixed(1) + '%'}</td>
                    <td class="${priorityClass}">${item.priority}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            gapAnalysisContainer.appendChild(table);
            
            // Bei positiven Lücken Empfehlungen anzeigen
            if (gaps.some(item => item.gap > 0)) {
                const recommendationsContainer = document.createElement('div');
                recommendationsContainer.className = 'is24-recommendations';
                
                const recommendationsTitle = document.createElement('h4');
                recommendationsTitle.textContent = 'Entwicklungsempfehlungen';
                recommendationsContainer.appendChild(recommendationsTitle);
                
                const recommendationsList = document.createElement('ul');
                recommendationsList.className = 'is24-recommendations-list';
                
                // Priorisierte Empfehlungen für die größten Lücken
                gaps.filter(item => item.gap > 0)
                    .slice(0, 3) // Top 3 Lücken
                    .forEach(item => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `<strong>${item.competency}:</strong> ${_generateRecommendation(item.competency, item.gap)}`;
                        recommendationsList.appendChild(listItem);
                    });
                
                recommendationsContainer.appendChild(recommendationsList);
                gapAnalysisContainer.appendChild(recommendationsContainer);
            }
            
            container.appendChild(gapAnalysisContainer);
        }
        
        return chartInstance;
    }
    
    /**
     * Bereitet Daten für ein Kompetenzradar vor
     * @private
     * @param {Object} data - Rohdaten
     * @returns {Object} Aufbereitete Daten für das Kompetenzradar
     */
    function _prepareCompetencyRadarData(data) {
        // Aufbereitungslogik für Kompetenzradar-Daten
        // Dies ist ein vereinfachtes Beispiel, in der realen Implementierung würde hier
        // die tatsächliche Datenaufbereitung erfolgen
        
        return data.competencyRadar || {
            competencies: [
                'Immobilienbewertung',
                'Rechtliches Fachwissen',
                'Verkaufstechniken',
                'Kundenberatung',
                'Marktanalyse',
                'Digitale Tools',
                'Verhandlung',
                'Dokumentation'
            ],
            currentLevels: [75, 68, 82, 90, 65, 72, 80, 88],
            targetLevels: [85, 80, 90, 95, 80, 85, 90, 90],
            averageLevels: [70, 72, 75, 78, 68, 70, 75, 80]
        };
    }
    
    /**
     * Generiert eine Entwicklungsempfehlung für eine Kompetenz
     * @private
     * @param {string} competency - Name der Kompetenz
     * @param {number} gap - Größe der Kompetenzlücke
     * @returns {string} Empfehlungstext
     */
    function _generateRecommendation(competency, gap) {
        // Vereinfachte Empfehlungslogik basierend auf Kompetenz und Lückengröße
        // In der realen Implementierung würde hier eine differenziertere Logik stehen
        
        let recommendation = '';
        
        if (gap >= 20) {
            recommendation = `Dringender Entwicklungsbedarf. Intensives Training im Bereich ${competency} empfohlen.`;
        } else if (gap >= 10) {
            recommendation = `Gezielte Weiterbildung zur Verbesserung Ihrer ${competency}-Fähigkeiten.`;
        } else {
            recommendation = `Feinschliff für ${competency} durch ergänzende Übungen und Praxisanwendung.`;
        }
        
        return recommendation;
    }
    
    /**
     * Bereitet einen Container zum Drucken oder Exportieren vor
     * @param {string} containerId - ID des registrierten Containers
     * @param {Object} options - Konfigurationsoptionen für den Export
     * @returns {void}
     */
    function prepareContainerForExport(containerId, options = {}) {
        const containerInfo = _containerRegistry[containerId];
        
        if (!containerInfo) {
            throw new Error(`Container mit ID ${containerId} nicht gefunden`);
        }
        
        const container = containerInfo.container;
        
        // Standardoptionen für Export
        const defaultOptions = {
            mode: 'print', // 'print' oder 'export'
            width: '210mm', // A4-Breite
            height: 'auto',
            addPageBreak: true,
            addTimestamp: true
        };
        
        // Optionen kombinieren
        const exportOptions = Object.assign({}, defaultOptions, options);
        
        // Exportklasse hinzufügen/entfernen
        if (exportOptions.mode === 'print') {
            container.classList.add('is24-print-ready');
        } else {
            container.classList.remove('is24-print-ready');
        }
        
        // Dimensionen setzen
        if (exportOptions.mode === 'export') {
            container.style.width = exportOptions.width;
            container.style.height = exportOptions.height;
        }
        
        // Seitenumbruch hinzufügen
        if (exportOptions.addPageBreak) {
            container.style.pageBreakAfter = 'always';
        } else {
            container.style.pageBreakAfter = '';
        }
        
        // Zeitstempel hinzufügen
        if (exportOptions.addTimestamp) {
            let timestampElem = container.querySelector('.is24-export-timestamp');
            
            if (!timestampElem) {
                timestampElem = document.createElement('div');
                timestampElem.className = 'is24-export-timestamp';
                container.appendChild(timestampElem);
            }
            
            const now = new Date();
            const formattedDate = `${now.getDate().toString().padStart(2, '0')}.${(now.getMonth() + 1).toString().padStart(2, '0')}.${now.getFullYear()} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            
            timestampElem.textContent = `Erstellt am: ${formattedDate}`;
        } else {
            const timestampElem = container.querySelector('.is24-export-timestamp');
            if (timestampElem) {
                timestampElem.remove();
            }
        }
        
        // Canvas in Bilder umwandeln für besseren Druck/Export
        const canvases = container.querySelectorAll('canvas');
        
        canvases.forEach((canvas, index) => {
            try {
                // Canvas als Bild rendern
                const imgData = canvas.toDataURL('image/png');
                
                // Bild-Element erstellen
                const img = document.createElement('img');
                img.src = imgData;
                img.className = 'is24-export-image';
                img.style.width = '100%';
                img.style.display = 'none'; // Zunächst verstecken
                
                // Nach dem Canvas einfügen
                canvas.parentNode.insertBefore(img, canvas.nextSibling);
                
                // Bei Druck Canvas verstecken und Bild anzeigen
                if (exportOptions.mode === 'print') {
                    canvas.classList.add('is24-print-hide');
                    img.classList.add('is24-print-show');
                }
            } catch (error) {
                console.error('Fehler beim Umwandeln des Canvas in ein Bild:', error);
            }
        });
    }
    
    /**
     * Aktualisiert alle Visualisierungen mit neuen Daten
     * @param {Object} newData - Die neuen Daten
     * @returns {void}
     */
    function updateAllVisualizations(newData) {
        if (!newData) return;
        
        // Daten aktualisieren
        _currentDataset = newData;
        
        // Alle aktiven Charts bereinigen
        _cleanupCharts();
        
        // Für jeden registrierten Container die entsprechende Visualisierung neu erstellen
        Object.keys(_containerRegistry).forEach(containerId => {
            const containerInfo = _containerRegistry[containerId];
            
            if (containerInfo.options.visualizationType) {
                // Basierend auf dem Visualisierungstyp die entsprechende Methode aufrufen
                switch (containerInfo.options.visualizationType) {
                    case 'heatmap':
                        createHeatmap(containerId, newData, containerInfo.options);
                        break;
                    case 'network':
                        createNetworkGraph(containerId, newData, containerInfo.options);
                        break;
                    case 'hierarchy':
                        createHierarchyTree(containerId, newData, containerInfo.options);
                        break;
                    case 'timeline':
                        createTimelineVisualization(containerId, newData, containerInfo.options);
                        break;
                    case 'sankey':
                        createSankeyDiagram(containerId, newData, containerInfo.options);
                        break;
                    case 'competencyRadar':
                        createCompetencyRadar(containerId, newData, containerInfo.options);
                        break;
                    default:
                        console.warn(`Unbekannter Visualisierungstyp für Container ${containerId}: ${containerInfo.options.visualizationType}`);
                }
            }
        });
    }
    
    // Öffentliche API
    return {
        initialize,
        registerContainer,
        createHeatmap,
        createNetworkGraph,
        createHierarchyTree,
        createTimelineVisualization,
        createSankeyDiagram,
        createCompetencyRadar,
        prepareContainerForExport,
        updateAllVisualizations,
        get colorSchemes() {
            return Object.keys(_colorSchemes);
        }
    };
})();
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.4-1 - Export-Funktionen
 * @module js/modules/results/visualization/export-share
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/file-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für Export- und Freigabefunktionen erstellen
App.Modules.Results = App.Modules.Results || {};
App.Modules.Results.Visualization = App.Modules.Results.Visualization || {};

/**
 * Modul für Export- und Freigabefunktionen für Testergebnisse und Visualisierungen
 * @namespace
 */
App.Modules.Results.Export = (function() {
    // Private Variablen
    let _exportFormats = {
        pdf: {
            name: 'PDF-Dokument',
            icon: 'is24-icon-pdf',
            extension: '.pdf',
            mimeType: 'application/pdf'
        },
        csv: {
            name: 'CSV-Datei',
            icon: 'is24-icon-table',
            extension: '.csv',
            mimeType: 'text/csv'
        },
        xlsx: {
            name: 'Excel-Datei',
            icon: 'is24-icon-excel',
            extension: '.xlsx',
            mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        },
        json: {
            name: 'JSON-Datei',
            icon: 'is24-icon-code',
            extension: '.json',
            mimeType: 'application/json'
        },
        png: {
            name: 'PNG-Bild',
            icon: 'is24-icon-image',
            extension: '.png',
            mimeType: 'image/png'
        },
        html: {
            name: 'HTML-Datei',
            icon: 'is24-icon-html',
            extension: '.html',
            mimeType: 'text/html'
        }
    };
    
    let _defaultExportSettings = {
        includeVisualizations: true,
        includeRawData: false,
        includeComments: true,
        includeMeta: true,
        qualityLevel: 'high', // 'low', 'medium', 'high'
        orientation: 'portrait', // 'portrait', 'landscape'
        paperSize: 'a4', // 'a4', 'a3', 'letter'
        maxImageWidth: 1200,
        maxImageHeight: 800,
        compression: 'medium', // 'low', 'medium', 'high'
        dateFormat: 'DD.MM.YYYY'
    };
    
    let _activeJobs = [];
    let _jobCounter = 0;
    
    /**
     * Zeigt einen Export-Dialog an, der die verfügbaren Exportoptionen darstellt
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Exports
     */
    function showExportDialog(data, options = {}) {
        return new Promise((resolve, reject) => {
            if (!data) {
                reject(new Error('Keine Daten zum Exportieren angegeben'));
                return;
            }
            
            // Standardoptionen mit benutzerdefinierten Optionen zusammenführen
            const exportOptions = Object.assign({}, _defaultExportSettings, options);
            
            // Verfügbare Exportformate basierend auf Datentyp filtern
            const availableFormats = _getAvailableFormats(data, exportOptions);
            
            if (availableFormats.length === 0) {
                reject(new Error('Keine geeigneten Exportformate für diese Daten verfügbar'));
                return;
            }
            
            // Dialog erstellen
            const dialogHtml = `
                <div class="is24-export-dialog">
                    <div class="is24-export-header">
                        <h3>Daten exportieren</h3>
                        <p>Wählen Sie das gewünschte Format und die Exportoptionen</p>
                    </div>
                    
                    <div class="is24-export-body">
                        <div class="is24-export-formats">
                            <h4>Format auswählen</h4>
                            <div class="is24-format-buttons">
                                ${availableFormats.map(format => `
                                    <button class="is24-format-button" data-format="${format}">
                                        <i class="${_exportFormats[format].icon}"></i>
                                        <span>${_exportFormats[format].name}</span>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="is24-export-options">
                            <h4>Exportoptionen</h4>
                            <div class="is24-option-grid">
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="includeVisualizations" 
                                        ${exportOptions.includeVisualizations ? 'checked' : ''}>
                                    <label for="includeVisualizations">Visualisierungen einbeziehen</label>
                                </div>
                                
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="includeRawData" 
                                        ${exportOptions.includeRawData ? 'checked' : ''}>
                                    <label for="includeRawData">Rohdaten einbeziehen</label>
                                </div>
                                
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="includeComments" 
                                        ${exportOptions.includeComments ? 'checked' : ''}>
                                    <label for="includeComments">Kommentare einbeziehen</label>
                                </div>
                                
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="includeMeta" 
                                        ${exportOptions.includeMeta ? 'checked' : ''}>
                                    <label for="includeMeta">Metadaten einbeziehen</label>
                                </div>
                            </div>
                            
                            <div class="is24-export-quality">
                                <h5>Qualität</h5>
                                <div class="is24-radio-group">
                                    <div class="is24-radio">
                                        <input type="radio" id="qualityLow" name="quality" value="low"
                                            ${exportOptions.qualityLevel === 'low' ? 'checked' : ''}>
                                        <label for="qualityLow">Niedrig (kleinere Dateigröße)</label>
                                    </div>
                                    
                                    <div class="is24-radio">
                                        <input type="radio" id="qualityMedium" name="quality" value="medium"
                                            ${exportOptions.qualityLevel === 'medium' ? 'checked' : ''}>
                                        <label for="qualityMedium">Mittel</label>
                                    </div>
                                    
                                    <div class="is24-radio">
                                        <input type="radio" id="qualityHigh" name="quality" value="high"
                                            ${exportOptions.qualityLevel === 'high' ? 'checked' : ''}>
                                        <label for="qualityHigh">Hoch (größere Dateigröße)</label>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="is24-export-paper" id="paperOptionsContainer">
                                <h5>Papierformat</h5>
                                <div class="is24-form-group">
                                    <select id="paperSize" class="is24-form-control">
                                        <option value="a4" ${exportOptions.paperSize === 'a4' ? 'selected' : ''}>A4</option>
                                        <option value="a3" ${exportOptions.paperSize === 'a3' ? 'selected' : ''}>A3</option>
                                        <option value="letter" ${exportOptions.paperSize === 'letter' ? 'selected' : ''}>US Letter</option>
                                    </select>
                                </div>
                                
                                <div class="is24-radio-group">
                                    <div class="is24-radio">
                                        <input type="radio" id="orientationPortrait" name="orientation" value="portrait"
                                            ${exportOptions.orientation === 'portrait' ? 'checked' : ''}>
                                        <label for="orientationPortrait">Hochformat</label>
                                    </div>
                                    
                                    <div class="is24-radio">
                                        <input type="radio" id="orientationLandscape" name="orientation" value="landscape"
                                            ${exportOptions.orientation === 'landscape' ? 'checked' : ''}>
                                        <label for="orientationLandscape">Querformat</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="is24-export-preview">
                            <h4>Vorschau</h4>
                            <div class="is24-preview-container" id="exportPreview">
                                <div class="is24-preview-placeholder">
                                    <i class="is24-icon-preview"></i>
                                    <p>Vorschau wird geladen...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="is24-export-footer">
                        <button id="exportCancel" class="is24-btn is24-btn-secondary">Abbrechen</button>
                        <button id="exportPrint" class="is24-btn is24-btn-secondary">
                            <i class="is24-icon-print"></i> Drucken
                        </button>
                        <button id="exportDownload" class="is24-btn is24-btn-primary" disabled>
                            <i class="is24-icon-download"></i> Exportieren
                        </button>
                    </div>
                </div>
            `;
            
            // Dialog anzeigen
            App.Modules.UI.Dialog.show({
                content: dialogHtml,
                width: '800px',
                height: '600px',
                showClose: true,
                onOpen: () => {
                    // Formatauswahl-Listener hinzufügen
                    const formatButtons = document.querySelectorAll('.is24-format-button');
                    formatButtons.forEach(button => {
                        button.addEventListener('click', (e) => {
                            // Aktiven Button markieren
                            document.querySelectorAll('.is24-format-button').forEach(btn => {
                                btn.classList.remove('is24-active');
                            });
                            e.currentTarget.classList.add('is24-active');
                            
                            // Format speichern
                            const selectedFormat = e.currentTarget.getAttribute('data-format');
                            exportOptions.format = selectedFormat;
                            
                            // Papieroptionen anzeigen/verstecken basierend auf Format
                            const paperOptionsContainer = document.getElementById('paperOptionsContainer');
                            if (paperOptionsContainer) {
                                if (selectedFormat === 'pdf' || selectedFormat === 'html') {
                                    paperOptionsContainer.style.display = 'block';
                                } else {
                                    paperOptionsContainer.style.display = 'none';
                                }
                            }
                            
                            // Vorschau aktualisieren
                            _updateExportPreview(data, exportOptions);
                            
                            // Export-Button aktivieren
                            document.getElementById('exportDownload').removeAttribute('disabled');
                        });
                    });
                    
                    // Option-Listeners hinzufügen
                    const optionCheckboxes = document.querySelectorAll('.is24-export-options input[type="checkbox"]');
                    optionCheckboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            exportOptions[e.target.id] = e.target.checked;
                            
                            // Vorschau aktualisieren, wenn ein Format ausgewählt ist
                            if (exportOptions.format) {
                                _updateExportPreview(data, exportOptions);
                            }
                        });
                    });
                    
                    // Qualitäts-Listener hinzufügen
                    const qualityRadios = document.querySelectorAll('input[name="quality"]');
                    qualityRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                exportOptions.qualityLevel = e.target.value;
                                
                                // Vorschau aktualisieren, wenn ein Format ausgewählt ist
                                if (exportOptions.format) {
                                    _updateExportPreview(data, exportOptions);
                                }
                            }
                        });
                    });
                    
                    // Papierformat-Listener hinzufügen
                    const paperSizeSelect = document.getElementById('paperSize');
                    if (paperSizeSelect) {
                        paperSizeSelect.addEventListener('change', (e) => {
                            exportOptions.paperSize = e.target.value;
                            
                            // Vorschau aktualisieren, wenn ein Format ausgewählt ist
                            if (exportOptions.format) {
                                _updateExportPreview(data, exportOptions);
                            }
                        });
                    }
                    
                    // Orientierungs-Listener hinzufügen
                    const orientationRadios = document.querySelectorAll('input[name="orientation"]');
                    orientationRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                exportOptions.orientation = e.target.value;
                                
                                // Vorschau aktualisieren, wenn ein Format ausgewählt ist
                                if (exportOptions.format) {
                                    _updateExportPreview(data, exportOptions);
                                }
                            }
                        });
                    });
                    
                    // Export-Button-Listener hinzufügen
                    const exportButton = document.getElementById('exportDownload');
                    if (exportButton) {
                        exportButton.addEventListener('click', () => {
                            // Export durchführen
                            _performExport(data, exportOptions)
                                .then(result => {
                                    resolve(result);
                                    App.Modules.UI.Dialog.close();
                                })
                                .catch(error => {
                                    App.Modules.UI.Notification.show({
                                        type: 'error',
                                        message: 'Export fehlgeschlagen: ' + error.message,
                                        duration: 5000
                                    });
                                    reject(error);
                                });
                        });
                    }
                    
                    // Druck-Button-Listener hinzufügen
                    const printButton = document.getElementById('exportPrint');
                    if (printButton) {
                        printButton.addEventListener('click', () => {
                            _printData(data, exportOptions)
                                .then(() => {
                                    App.Modules.UI.Notification.show({
                                        type: 'success',
                                        message: 'Druckvorschau wurde geöffnet',
                                        duration: 3000
                                    });
                                })
                                .catch(error => {
                                    App.Modules.UI.Notification.show({
                                        type: 'error',
                                        message: 'Drucken fehlgeschlagen: ' + error.message,
                                        duration: 5000
                                    });
                                });
                        });
                    }
                    
                    // Abbrechen-Button-Listener hinzufügen
                    const cancelButton = document.getElementById('exportCancel');
                    if (cancelButton) {
                        cancelButton.addEventListener('click', () => {
                            App.Modules.UI.Dialog.close();
                            reject(new Error('Export abgebrochen'));
                        });
                    }
                    
                    // Ersten Format-Button automatisch auswählen
                    if (formatButtons.length > 0) {
                        formatButtons[0].click();
                    }
                }
            });
        });
    }
    
    /**
     * Aktualisiert die Exportvorschau basierend auf den ausgewählten Optionen
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @returns {void}
     */
    function _updateExportPreview(data, options) {
        const previewContainer = document.getElementById('exportPreview');
        if (!previewContainer) return;
        
        // Lade-Anzeige
        previewContainer.innerHTML = `
            <div class="is24-preview-loading">
                <div class="is24-spinner"></div>
                <p>Vorschau wird generiert...</p>
            </div>
        `;
        
        // Vorschau basierend auf Format generieren
        switch (options.format) {
            case 'pdf':
                _generatePdfPreview(data, options, previewContainer);
                break;
            case 'csv':
                _generateCsvPreview(data, options, previewContainer);
                break;
            case 'xlsx':
                _generateExcelPreview(data, options, previewContainer);
                break;
            case 'json':
                _generateJsonPreview(data, options, previewContainer);
                break;
            case 'png':
                _generateImagePreview(data, options, previewContainer);
                break;
            case 'html':
                _generateHtmlPreview(data, options, previewContainer);
                break;
            default:
                previewContainer.innerHTML = `
                    <div class="is24-preview-unavailable">
                        <i class="is24-icon-warning"></i>
                        <p>Keine Vorschau für dieses Format verfügbar</p>
                    </div>
                `;
        }
    }
    
    /**
     * Generiert eine PDF-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generatePdfPreview(data, options, container) {
        // In einer realen Implementierung würde hier ein PDF-Renderer verwendet
        // Hier wird eine vereinfachte Vorschau generiert
        
        const orientation = options.orientation === 'landscape' ? 'Querformat' : 'Hochformat';
        const paperSize = options.paperSize.toUpperCase();
        
        container.innerHTML = `
            <div class="is24-pdf-preview" style="aspect-ratio: ${options.orientation === 'landscape' ? '1.414' : '0.707'}">
                <div class="is24-pdf-header">
                    <div class="is24-pdf-logo">
                        <i class="is24-icon-logo"></i> ImmoScout24
                    </div>
                    <div class="is24-pdf-title">
                        ${data.title || 'Testergebnis'}
                    </div>
                    <div class="is24-pdf-date">
                        ${new Date().toLocaleDateString()}
                    </div>
                </div>
                
                <div class="is24-pdf-body">
                    <div class="is24-pdf-section is24-pdf-summary">
                        <h3>Zusammenfassung</h3>
                        <div class="is24-pdf-summary-content">
                            <div class="is24-pdf-score">
                                <div class="is24-score-circle">${data.score ? data.score + '%' : 'N/A'}</div>
                                <div class="is24-score-label">Gesamtergebnis</div>
                            </div>
                            
                            <div class="is24-pdf-meta">
                                <div class="is24-meta-item">
                                    <strong>Teilnehmer:</strong> ${data.userName || 'Unbekannt'}
                                </div>
                                <div class="is24-meta-item">
                                    <strong>Test:</strong> ${data.testName || 'Unbekannt'}
                                </div>
                                <div class="is24-meta-item">
                                    <strong>Datum:</strong> ${data.date ? new Date(data.date).toLocaleDateString() : 'Unbekannt'}
                                </div>
                                <div class="is24-meta-item">
                                    <strong>Dauer:</strong> ${data.duration || 'Unbekannt'}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    ${options.includeVisualizations ? `
                        <div class="is24-pdf-section is24-pdf-visualizations">
                            <h3>Visualisierungen</h3>
                            <div class="is24-pdf-visualizations-placeholder">
                                <div class="is24-visualization-item"></div>
                                <div class="is24-visualization-item"></div>
                            </div>
                        </div>
                    ` : ''}
                    
                    ${options.includeComments ? `
                        <div class="is24-pdf-section is24-pdf-comments">
                            <h3>Kommentare</h3>
                            <div class="is24-pdf-comments-placeholder">
                                <div class="is24-comment-item"></div>
                                <div class="is24-comment-item"></div>
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <div class="is24-pdf-footer">
                    <div class="is24-pdf-page-number">Seite 1 von 1</div>
                    <div class="is24-pdf-format">${paperSize} - ${orientation}</div>
                </div>
                
                <div class="is24-pdf-watermark">Vorschau</div>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> PDF (${paperSize}, ${orientation})</p>
                <p><strong>Qualität:</strong> ${options.qualityLevel === 'high' ? 'Hoch' : options.qualityLevel === 'medium' ? 'Mittel' : 'Niedrig'}</p>
            </div>
        `;
    }
    
    /**
     * Generiert eine CSV-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generateCsvPreview(data, options, container) {
        // CSV-Daten generieren
        let csvContent = '';
        
        // Header-Zeile
        const headers = ['Kategorie', 'Wert', 'Referenz', 'Differenz'];
        csvContent += headers.join(',') + '\n';
        
        // Beispieldaten basierend auf den tatsächlichen Daten
        if (data.categoryScores) {
            Object.entries(data.categoryScores).forEach(([category, score]) => {
                const reference = data.referenceScores && data.referenceScores[category] ? data.referenceScores[category] : '';
                const diff = reference ? (score - reference).toFixed(1) : '';
                csvContent += `"${category}",${score},${reference},${diff}\n`;
            });
        } else {
            // Platzhalter-Daten, wenn keine echten Daten vorhanden sind
            csvContent += '"Kategorie 1",85,80,5\n';
            csvContent += '"Kategorie 2",72,75,-3\n';
            csvContent += '"Kategorie 3",90,85,5\n';
        }
        
        // Vorschau anzeigen
        container.innerHTML = `
            <div class="is24-csv-preview">
                <table class="is24-preview-table">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th>${header}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${csvContent.split('\n').slice(1, -1).map(row => {
                            const cells = row.split(',');
                            return `
                                <tr>
                                    ${cells.map((cell, i) => {
                                        // Formatierung basierend auf Zellentyp
                                        if (i === 0) {
                                            // Kategoriename - erste Anführungszeichen entfernen
                                            return `<td>${cell.replace(/"/g, '')}</td>`;
                                        } else if (i === 3) {
                                            // Differenz - farbliche Markierung
                                            const value = parseFloat(cell);
                                            const colorClass = value > 0 ? 'is24-positive' : value < 0 ? 'is24-negative' : '';
                                            return `<td class="${colorClass}">${cell}</td>`;
                                        } else {
                                            return `<td>${cell}</td>`;
                                        }
                                    }).join('')}
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
            
            <div class="is24-preview-code">
                <pre>${csvContent}</pre>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> CSV</p>
                <p><strong>Trennzeichen:</strong> Komma</p>
                <p><strong>Kodierung:</strong> UTF-8</p>
            </div>
        `;
    }
    
    // Weitere Funktionen zur Vorschaugenerierung für andere Formate folgen im nächsten Teil
	/**
 * @fileOverview Ergebnisvisualisierung Teil 2.4-2 - Export-Vorschaufunktionen und Exportdurchführung
 * @module js/modules/results/visualization/export-share
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/file-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Fortsetzung von JS-Block 6.5.2-part2d-1
// Diese Funktionen gehören weiterhin zum App.Modules.Results.Export Namespace

    /**
     * Generiert eine Excel-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generateExcelPreview(data, options, container) {
        // In einer realen Implementierung würde hier Excel-spezifischer Code stehen
        // Hier wird eine vereinfachte Vorschau generiert, ähnlich zu CSV aber mit Excel-Styling
        
        container.innerHTML = `
            <div class="is24-excel-preview">
                <div class="is24-excel-header">
                    <div class="is24-excel-tab is24-active">Ergebnisse</div>
                    <div class="is24-excel-tab">Kategorien</div>
                    <div class="is24-excel-tab">Vergleiche</div>
                </div>
                
                <div class="is24-excel-sheet">
                    <table class="is24-excel-table">
                        <thead>
                            <tr>
                                <th>Kategorie</th>
                                <th>Punktzahl</th>
                                <th>Referenz</th>
                                <th>Differenz</th>
                                <th>Bewertung</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.categoryScores ? Object.entries(data.categoryScores).map(([category, score]) => {
                                const reference = data.referenceScores && data.referenceScores[category] ? data.referenceScores[category] : 75;
                                const diff = (score - reference).toFixed(1);
                                let rating;
                                if (score >= 80) rating = 'Sehr gut';
                                else if (score >= 70) rating = 'Gut';
                                else if (score >= 60) rating = 'Befriedigend';
                                else if (score >= 50) rating = 'Ausreichend';
                                else rating = 'Mangelhaft';
                                
                                const colorClass = diff > 0 ? 'is24-positive' : diff < 0 ? 'is24-negative' : '';
                                
                                return `
                                    <tr>
                                        <td>${category}</td>
                                        <td>${score.toFixed(1)}%</td>
                                        <td>${reference.toFixed(1)}%</td>
                                        <td class="${colorClass}">${diff}%</td>
                                        <td>${rating}</td>
                                    </tr>
                                `;
                            }).join('') : `
                                <tr>
                                    <td>Kategorie 1</td>
                                    <td>85.0%</td>
                                    <td>80.0%</td>
                                    <td class="is24-positive">5.0%</td>
                                    <td>Sehr gut</td>
                                </tr>
                                <tr>
                                    <td>Kategorie 2</td>
                                    <td>72.0%</td>
                                    <td>75.0%</td>
                                    <td class="is24-negative">-3.0%</td>
                                    <td>Gut</td>
                                </tr>
                                <tr>
                                    <td>Kategorie 3</td>
                                    <td>90.0%</td>
                                    <td>85.0%</td>
                                    <td class="is24-positive">5.0%</td>
                                    <td>Sehr gut</td>
                                </tr>
                            `}
                        </tbody>
                    </table>
                </div>
                
                <div class="is24-excel-footer">
                    <div class="is24-excel-sheets">
                        <span class="is24-excel-sheet-tab is24-active">Ergebnisse</span>
                        <span class="is24-excel-sheet-tab">Kategorien</span>
                        <span class="is24-excel-sheet-tab">Vergleiche</span>
                    </div>
                </div>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> Excel (.xlsx)</p>
                <p><strong>Tabellenblätter:</strong> 3</p>
                <p><strong>Enthält Formeln:</strong> Ja</p>
            </div>
        `;
    }
    
    /**
     * Generiert eine JSON-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generateJsonPreview(data, options, container) {
        // JSON-Daten vorbereiten (nur relevante Felder basierend auf Optionen)
        const exportData = {
            title: data.title || 'Testergebnis',
            user: data.userName || 'Unbekannt',
            test: data.testName || 'Unbekannt',
            date: data.date ? new Date(data.date).toISOString() : new Date().toISOString(),
            score: data.score || 0
        };
        
        if (options.includeVisualizations && data.categoryScores) {
            exportData.categoryScores = data.categoryScores;
        }
        
        if (options.includeMeta) {
            exportData.meta = {
                exportDate: new Date().toISOString(),
                exportFormat: 'json',
                exportOptions: options
            };
        }
        
        if (options.includeRawData && data.questions) {
            exportData.questions = data.questions;
        }
        
        if (options.includeComments && data.comments) {
            exportData.comments = data.comments;
        }
        
        // JSON formatieren
        const jsonString = JSON.stringify(exportData, null, 2);
        
        // Vorschau anzeigen
        container.innerHTML = `
            <div class="is24-json-preview">
                <pre>${_syntaxHighlight(jsonString)}</pre>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> JSON</p>
                <p><strong>Größe:</strong> ca. ${Math.round(jsonString.length / 1024)} KB</p>
                <p><strong>Einrückung:</strong> 2 Leerzeichen</p>
            </div>
        `;
    }
    
    /**
     * Führt die Syntax-Hervorhebung für JSON durch
     * @private
     * @param {string} json - JSON-String
     * @returns {string} HTML mit hervorgehobenem Syntax
     */
    function _syntaxHighlight(json) {
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
            let cls = 'is24-json-number';
            if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                    cls = 'is24-json-key';
                } else {
                    cls = 'is24-json-string';
                }
            } else if (/true|false/.test(match)) {
                cls = 'is24-json-boolean';
            } else if (/null/.test(match)) {
                cls = 'is24-json-null';
            }
            return '<span class="' + cls + '">' + match + '</span>';
        });
    }
    
    /**
     * Generiert eine Bild-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generateImagePreview(data, options, container) {
        // In einer realen Implementierung würde hier ein Canvas-basierter Renderer verwendet
        // Hier wird eine vereinfachte Vorschau generiert
        
        container.innerHTML = `
            <div class="is24-image-preview">
                <div class="is24-image-container">
                    <div class="is24-image-placeholder">
                        <div class="is24-image-header">
                            <div class="is24-image-logo">
                                <i class="is24-icon-logo"></i>
                            </div>
                            <div class="is24-image-title">
                                ${data.title || 'Testergebnis'}
                            </div>
                        </div>
                        
                        <div class="is24-image-body">
                            <div class="is24-image-chart">
                                <!-- Hier würde in einer echten Implementierung ein Chart gerendert -->
                                <div class="is24-chart-placeholder"></div>
                            </div>
                            
                            <div class="is24-image-data">
                                <div class="is24-score-display">
                                    <div class="is24-score-circle">${data.score ? data.score + '%' : 'N/A'}</div>
                                </div>
                                
                                <div class="is24-meta-info">
                                    <p><strong>Teilnehmer:</strong> ${data.userName || 'Unbekannt'}</p>
                                    <p><strong>Test:</strong> ${data.testName || 'Unbekannt'}</p>
                                    <p><strong>Datum:</strong> ${data.date ? new Date(data.date).toLocaleDateString() : 'Unbekannt'}</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="is24-image-footer">
                            <div class="is24-image-watermark">ImmoScout24 E-Learning</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> PNG</p>
                <p><strong>Auflösung:</strong> ${options.maxImageWidth}x${options.maxImageHeight}</p>
                <p><strong>Qualität:</strong> ${options.qualityLevel === 'high' ? 'Hoch' : options.qualityLevel === 'medium' ? 'Mittel' : 'Niedrig'}</p>
            </div>
        `;
    }
    
    /**
     * Generiert eine HTML-Vorschau
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @param {HTMLElement} container - Container für die Vorschau
     * @returns {void}
     */
    function _generateHtmlPreview(data, options, container) {
        // Vereinfachte HTML-Vorschau
        container.innerHTML = `
            <div class="is24-html-preview">
                <div class="is24-html-browser">
                    <div class="is24-browser-header">
                        <div class="is24-browser-controls">
                            <span class="is24-browser-circle"></span>
                            <span class="is24-browser-circle"></span>
                            <span class="is24-browser-circle"></span>
                        </div>
                        <div class="is24-browser-url">file:///Testergebnis_${data.userName || 'Benutzer'}.html</div>
                    </div>
                    
                    <div class="is24-browser-body">
                        <div class="is24-report-page">
                            <div class="is24-report-header">
                                <img src="data:image/svg+xml;base64,..." alt="ImmoScout24 Logo" class="is24-logo" />
                                <h1>Testergebnis: ${data.testName || 'Unbekannter Test'}</h1>
                                <p class="is24-report-meta">
                                    <strong>Teilnehmer:</strong> ${data.userName || 'Unbekannt'} |
                                    <strong>Datum:</strong> ${data.date ? new Date(data.date).toLocaleDateString() : 'Unbekannt'}
                                </p>
                            </div>
                            
                            <div class="is24-report-summary">
                                <div class="is24-report-score">
                                    <div class="is24-score-display">${data.score ? data.score + '%' : 'N/A'}</div>
                                    <p>Gesamtergebnis</p>
                                </div>
                                
                                <div class="is24-report-charts">
                                    <div class="is24-chart-placeholder"></div>
                                </div>
                            </div>
                            
                            ${options.includeVisualizations ? `
                                <div class="is24-report-section">
                                    <h2>Detaillierte Analyse</h2>
                                    <div class="is24-visualization-grid">
                                        <div class="is24-chart-placeholder"></div>
                                        <div class="is24-chart-placeholder"></div>
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${options.includeComments ? `
                                <div class="is24-report-section">
                                    <h2>Kommentare & Feedback</h2>
                                    <div class="is24-comments-placeholder">
                                        <div class="is24-comment-item"></div>
                                        <div class="is24-comment-item"></div>
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div class="is24-report-footer">
                                <p>Erstellt mit ImmoScout24 E-Learning Platform</p>
                                <p>${new Date().toLocaleString()}</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="is24-preview-info">
                <p><strong>Format:</strong> HTML</p>
                <p><strong>Layout:</strong> ${options.orientation === 'landscape' ? 'Querformat' : 'Hochformat'}</p>
                <p><strong>Responsiv:</strong> Ja</p>
            </div>
        `;
    }
    
    /**
     * Führt den tatsächlichen Export durch
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Exports
     */
    function _performExport(data, options) {
        return new Promise((resolve, reject) => {
            // Neue Job-ID generieren
            const jobId = `export-${Date.now()}-${++_jobCounter}`;
            
            // Job in aktive Jobs aufnehmen
            _activeJobs.push({
                id: jobId,
                type: 'export',
                status: 'running',
                progress: 0,
                options: options,
                data: data,
                startTime: new Date()
            });
            
            // Benachrichtigung anzeigen
            App.Modules.UI.Notification.show({
                type: 'info',
                message: `Export wird vorbereitet...`,
                duration: 3000
            });
            
            // Exportvorgang simulieren
            let progress = 0;
            const updateInterval = setInterval(() => {
                progress += 10;
                _updateJobProgress(jobId, progress);
                
                if (progress >= 100) {
                    clearInterval(updateInterval);
                    
                    // Export abschließen
                    setTimeout(() => {
                        _completeExport(jobId, options)
                            .then(result => {
                                resolve(result);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }, 500);
                }
            }, 200);
        });
    }
    
    /**
     * Aktualisiert den Fortschritt eines Jobs
     * @private
     * @param {string} jobId - ID des Jobs
     * @param {number} progress - Fortschritt in Prozent
     * @returns {void}
     */
    function _updateJobProgress(jobId, progress) {
        const job = _activeJobs.find(job => job.id === jobId);
        if (job) {
            job.progress = progress;
        }
    }
    
    /**
     * Schließt einen Export-Job ab
     * @private
     * @param {string} jobId - ID des Jobs
     * @param {Object} options - Exportoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Exports
     */
    function _completeExport(jobId, options) {
        return new Promise((resolve, reject) => {
            const job = _activeJobs.find(job => job.id === jobId);
            if (!job) {
                reject(new Error('Job nicht gefunden'));
                return;
            }
            
            // Export-Typ bestimmen
            const exportType = options.format;
            const format = _exportFormats[exportType];
            
            if (!format) {
                reject(new Error(`Exportformat ${exportType} nicht unterstützt`));
                return;
            }
            
            // In einer realen Implementierung würde hier die tatsächliche Datei generiert werden
            // Hier wird eine erfolgreiche Simulation durchgeführt
            
            // Dateiname generieren
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const fileName = `Testergebnis_${job.data.userName || 'Benutzer'}_${timestamp}${format.extension}`;
            
            // Job als abgeschlossen markieren
            job.status = 'completed';
            job.endTime = new Date();
            job.result = {
                fileName: fileName,
                fileSize: Math.floor(Math.random() * 1000) + 100, // Simulierte Dateigröße in KB
                format: exportType,
                mimeType: format.mimeType,
                url: `data:${format.mimeType};base64,SIMULATED_FILE_CONTENT` // Simulierter Download-Link
            };
            
            // Erfolgsbenachrichtigung anzeigen
            App.Modules.UI.Notification.show({
                type: 'success',
                message: `${format.name} erfolgreich erstellt: ${fileName}`,
                duration: 5000
            });
            
            // Simulierten Download initiieren
            _triggerDownload(fileName, job.result.url);
            
            // Job-Ergebnis zurückgeben
            resolve(job.result);
        });
    }
    
    /**
     * Löst einen Download aus
     * @private
     * @param {string} fileName - Name der Datei
     * @param {string} url - URL der Datei
     * @returns {void}
     */
    function _triggerDownload(fileName, url) {
        // In einer realen Implementierung würde hier tatsächlich eine Datei heruntergeladen werden
        // Hier wird nur ein simulierter Download durchgeführt
        console.log(`Download gestartet: ${fileName}`);
        
        // Simulierten "Speichern unter"-Dialog anzeigen
        setTimeout(() => {
            console.log(`Datei wurde gespeichert: ${fileName}`);
        }, 1000);
    }
    
    /**
     * Druckt die Daten
     * @private
     * @param {Object} data - Zu druckende Daten
     * @param {Object} options - Druckoptionen
     * @returns {Promise<void>} - Promise, der nach dem Drucken aufgelöst wird
     */
    function _printData(data, options) {
        return new Promise((resolve, reject) => {
            try {
                // In einer realen Implementierung würde hier der Druckdialog geöffnet werden
                // Hier wird nur eine Simulation durchgeführt
                
                console.log('Druckvorschau wird geöffnet...');
                
                // Drucken simulieren
                setTimeout(() => {
                    console.log('Druck abgeschlossen oder abgebrochen');
                    resolve();
                }, 1000);
            } catch (error) {
                reject(error);
            }
        });
    }
    
    /**
     * Bestimmt die verfügbaren Exportformate basierend auf den Daten und Optionen
     * @private
     * @param {Object} data - Zu exportierende Daten
     * @param {Object} options - Exportoptionen
     * @returns {Array<string>} - Liste der verfügbaren Formate
     */
    function _getAvailableFormats(data, options) {
        // In einer realen Implementierung würde hier eine differenzierte Logik stehen
        // Hier werden alle Formate zurückgegeben
        return Object.keys(_exportFormats);
    }
	/**
 * @fileOverview Ergebnisvisualisierung Teil 2.4-3 - Freigabe- und Batch-Export-Funktionen
 * @module js/modules/results/visualization/export-share
 * @requires js/modules/results/data-manager
 * @requires js/modules/utils/file-helpers
 * @requires js/modules/results/visualization/base
 * @version 1.0.0
 */

// Fortsetzung von JS-Block 6.5.2-part2d-2
// Diese Funktionen gehören weiterhin zum App.Modules.Results.Export Namespace

    // Private Variablen für die Freigabe
    let _shareOptions = {
        email: {
            name: 'E-Mail',
            icon: 'is24-icon-email',
            description: 'Per E-Mail teilen'
        },
        link: {
            name: 'Link',
            icon: 'is24-icon-link',
            description: 'Link kopieren'
        },
        colleague: {
            name: 'Kollegen',
            icon: 'is24-icon-user',
            description: 'Mit Kollegen teilen'
        },
        trainer: {
            name: 'Trainer',
            icon: 'is24-icon-teacher',
            description: 'Mit Trainer teilen'
        },
        team: {
            name: 'Team',
            icon: 'is24-icon-users',
            description: 'Mit Team teilen'
        }
    };
    
    let _accessLevels = {
        view: {
            name: 'Ansehen',
            icon: 'is24-icon-eye',
            description: 'Nur Ansehen'
        },
        comment: {
            name: 'Kommentieren',
            icon: 'is24-icon-comment',
            description: 'Ansehen und Kommentieren'
        },
        export: {
            name: 'Exportieren',
            icon: 'is24-icon-download',
            description: 'Ansehen, Kommentieren und Exportieren'
        },
        edit: {
            name: 'Bearbeiten',
            icon: 'is24-icon-edit',
            description: 'Vollständiger Zugriff'
        }
    };
    
    let _defaultShareSettings = {
        expiryDays: 30,
        accessLevel: 'view',
        notifyOnAccess: false,
        password: null,
        trackShares: true,
        allowReSharing: false
    };

    /**
     * Zeigt einen Freigabe-Dialog an, der die verfügbaren Freigabeoptionen darstellt
     * @param {Object} data - Zu teilende Daten
     * @param {Object} options - Konfigurationsoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis der Freigabe
     */
    function showShareDialog(data, options = {}) {
        return new Promise((resolve, reject) => {
            if (!data) {
                reject(new Error('Keine Daten zum Teilen angegeben'));
                return;
            }
            
            // Standardoptionen mit benutzerdefinierten Optionen zusammenführen
            const shareOptions = Object.assign({}, _defaultShareSettings, options);
            
            // Dialog erstellen
            const dialogHtml = `
                <div class="is24-share-dialog">
                    <div class="is24-share-header">
                        <h3>Ergebnisse teilen</h3>
                        <p>Wählen Sie aus, wie und mit wem Sie Ihre Ergebnisse teilen möchten</p>
                    </div>
                    
                    <div class="is24-share-body">
                        <div class="is24-share-preview">
                            <div class="is24-preview-header">
                                <h4>Vorschau des geteilten Inhalts</h4>
                            </div>
                            
                            <div class="is24-preview-container">
                                <div class="is24-result-summary">
                                    <div class="is24-result-title">
                                        <h5>${data.testName || 'Testergebnis'}</h5>
                                        <span class="is24-result-date">${data.date ? new Date(data.date).toLocaleDateString() : 'Unbekanntes Datum'}</span>
                                    </div>
                                    
                                    <div class="is24-result-score">
                                        <div class="is24-score-badge">${data.score ? data.score + '%' : 'N/A'}</div>
                                    </div>
                                    
                                    <div class="is24-result-meta">
                                        <p><strong>Teilnehmer:</strong> ${data.userName || 'Unbekannt'}</p>
                                        <p><strong>Test:</strong> ${data.testName || 'Unbekannt'}</p>
                                        <p><strong>Dauer:</strong> ${data.duration || 'Unbekannt'}</p>
                                    </div>
                                </div>
                                
                                <div class="is24-preview-message">
                                    <p>Der Empfänger sieht eine detaillierte Ansicht dieser Ergebnisse, 
                                    basierend auf den ausgewählten Freigabeoptionen.</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="is24-share-options">
                            <div class="is24-share-section">
                                <h4>Mit wem möchten Sie teilen?</h4>
                                
                                <div class="is24-share-targets">
                                    ${Object.entries(_shareOptions).map(([key, option]) => `
                                        <div class="is24-share-target-card" data-share-target="${key}">
                                            <div class="is24-target-icon">
                                                <i class="${option.icon}"></i>
                                            </div>
                                            <div class="is24-target-name">${option.name}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="is24-share-section is24-share-recipients is24-hidden" id="shareRecipientsSection">
                                <h4>Empfänger auswählen</h4>
                                
                                <div class="is24-form-group" id="emailRecipients">
                                    <label for="shareEmails">E-Mail-Adressen (durch Komma getrennt)</label>
                                    <input type="text" id="shareEmails" class="is24-form-control" 
                                        placeholder="max.mustermann@example.com, johanna.beispiel@example.com">
                                </div>
                                
                                <div class="is24-form-group is24-hidden" id="colleagueRecipients">
                                    <label>Kollegen auswählen</label>
                                    <div class="is24-user-picker">
                                        <div class="is24-user-search">
                                            <input type="text" class="is24-form-control" placeholder="Nach Kollegen suchen...">
                                        </div>
                                        <div class="is24-user-list">
                                            <div class="is24-user-item">
                                                <input type="checkbox" id="user1" value="user1">
                                                <label for="user1">Maria Schmidt</label>
                                            </div>
                                            <div class="is24-user-item">
                                                <input type="checkbox" id="user2" value="user2">
                                                <label for="user2">Thomas Müller</label>
                                            </div>
                                            <div class="is24-user-item">
                                                <input type="checkbox" id="user3" value="user3">
                                                <label for="user3">Sarah Weber</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="is24-form-group is24-hidden" id="trainerRecipients">
                                    <label>Trainer auswählen</label>
                                    <div class="is24-trainer-list">
                                        <div class="is24-trainer-item">
                                            <input type="radio" name="trainer" id="trainer1" value="trainer1">
                                            <label for="trainer1">Frank Lehmann (Haupttrainer)</label>
                                        </div>
                                        <div class="is24-trainer-item">
                                            <input type="radio" name="trainer" id="trainer2" value="trainer2">
                                            <label for="trainer2">Julia Fischer (Fachtrainerin)</label>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="is24-form-group is24-hidden" id="teamRecipients">
                                    <label>Team auswählen</label>
                                    <select class="is24-form-control" id="teamSelect">
                                        <option value="">-- Team auswählen --</option>
                                        <option value="team1">Verkaufsteam Nord</option>
                                        <option value="team2">Verkaufsteam Süd</option>
                                        <option value="team3">Bewertungsteam</option>
                                    </select>
                                </div>
                                
                                <div class="is24-form-group is24-hidden" id="linkRecipients">
                                    <label for="shareLink">Link zum Teilen</label>
                                    <div class="is24-input-group">
                                        <input type="text" id="shareLink" class="is24-form-control" 
                                            value="${_generateShareLink(data.id)}" readonly>
                                        <button class="is24-btn is24-btn-secondary" id="copyShareLink">
                                            <i class="is24-icon-copy"></i> Kopieren
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="is24-share-section is24-share-advanced">
                                <h4>Erweiterte Optionen</h4>
                                
                                <div class="is24-form-group">
                                    <label for="shareAccessLevel">Zugriffsebene</label>
                                    <select class="is24-form-control" id="shareAccessLevel">
                                        ${Object.entries(_accessLevels).map(([key, level]) => `
                                            <option value="${key}" ${key === shareOptions.accessLevel ? 'selected' : ''}>
                                                ${level.name} - ${level.description}
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                                
                                <div class="is24-form-group">
                                    <label for="shareExpiry">Gültigkeitsdauer</label>
                                    <select class="is24-form-control" id="shareExpiry">
                                        <option value="7" ${shareOptions.expiryDays === 7 ? 'selected' : ''}>7 Tage</option>
                                        <option value="14" ${shareOptions.expiryDays === 14 ? 'selected' : ''}>14 Tage</option>
                                        <option value="30" ${shareOptions.expiryDays === 30 ? 'selected' : ''}>30 Tage</option>
                                        <option value="90" ${shareOptions.expiryDays === 90 ? 'selected' : ''}>90 Tage</option>
                                        <option value="0" ${shareOptions.expiryDays === 0 ? 'selected' : ''}>Kein Ablaufdatum</option>
                                    </select>
                                </div>
                                
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="shareNotify" 
                                        ${shareOptions.notifyOnAccess ? 'checked' : ''}>
                                    <label for="shareNotify">Bei Zugriff benachrichtigen</label>
                                </div>
                                
                                <div class="is24-checkbox">
                                    <input type="checkbox" id="shareReSharing" 
                                        ${shareOptions.allowReSharing ? 'checked' : ''}>
                                    <label for="shareReSharing">Weiterteilen erlauben</label>
                                </div>
                                
                                <div class="is24-form-group">
                                    <label for="sharePassword">Passwortschutz (optional)</label>
                                    <input type="password" id="sharePassword" class="is24-form-control" 
                                        placeholder="Passwort eingeben">
                                </div>
                                
                                <div class="is24-form-group">
                                    <label for="shareMessage">Persönliche Nachricht (optional)</label>
                                    <textarea id="shareMessage" class="is24-form-control" rows="3" 
                                        placeholder="Geben Sie eine persönliche Nachricht ein..."></textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="is24-share-footer">
                        <button id="shareCancel" class="is24-btn is24-btn-secondary">Abbrechen</button>
                        <button id="shareSubmit" class="is24-btn is24-btn-primary" disabled>Teilen</button>
                    </div>
                </div>
            `;
            
            // Dialog anzeigen
            App.Modules.UI.Dialog.show({
                content: dialogHtml,
                width: '800px',
                height: '600px',
                showClose: true,
                onOpen: () => {
                    let selectedTarget = null;
                    
                    // Ziel-Buttons mit Event-Listenern ausstatten
                    const targetButtons = document.querySelectorAll('.is24-share-target-card');
                    targetButtons.forEach(button => {
                        button.addEventListener('click', (e) => {
                            // Vorherige Auswahl deaktivieren
                            document.querySelectorAll('.is24-share-target-card').forEach(btn => {
                                btn.classList.remove('is24-active');
                            });
                            
                            // Neue Auswahl aktivieren
                            e.currentTarget.classList.add('is24-active');
                            
                            // Ausgewähltes Ziel speichern
                            selectedTarget = e.currentTarget.getAttribute('data-share-target');
                            
                            // Empfängerbereich anzeigen
                            const recipientsSection = document.getElementById('shareRecipientsSection');
                            if (recipientsSection) {
                                recipientsSection.classList.remove('is24-hidden');
                            }
                            
                            // Alle Empfängerfelder ausblenden
                            document.querySelectorAll('#shareRecipientsSection .is24-form-group').forEach(group => {
                                group.classList.add('is24-hidden');
                            });
                            
                            // Entsprechendes Empfängerfeld anzeigen
                            const recipientField = document.getElementById(`${selectedTarget}Recipients`);
                            if (recipientField) {
                                recipientField.classList.remove('is24-hidden');
                            }
                            
                            // Teilen-Button aktivieren
                            document.getElementById('shareSubmit').removeAttribute('disabled');
                        });
                    });
                    
                    // Link-Kopieren-Button
                    const copyLinkButton = document.getElementById('copyShareLink');
                    if (copyLinkButton) {
                        copyLinkButton.addEventListener('click', () => {
                            const linkInput = document.getElementById('shareLink');
                            if (linkInput) {
                                linkInput.select();
                                document.execCommand('copy');
                                
                                // Nutzer benachrichtigen
                                App.Modules.UI.Notification.show({
                                    type: 'success',
                                    message: 'Link in die Zwischenablage kopiert',
                                    duration: 3000
                                });
                            }
                        });
                    }
                    
                    // Abbrechen-Button
                    const cancelButton = document.getElementById('shareCancel');
                    if (cancelButton) {
                        cancelButton.addEventListener('click', () => {
                            App.Modules.UI.Dialog.close();
                            reject(new Error('Teilen abgebrochen'));
                        });
                    }
                    
                    // Teilen-Button
                    const submitButton = document.getElementById('shareSubmit');
                    if (submitButton) {
                        submitButton.addEventListener('click', () => {
                            if (!selectedTarget) {
                                App.Modules.UI.Notification.show({
                                    type: 'error',
                                    message: 'Bitte wählen Sie ein Ziel für die Freigabe',
                                    duration: 3000
                                });
                                return;
                            }
                            
                            // Freigabeoptionen sammeln
                            const shareConfig = {
                                target: selectedTarget,
                                accessLevel: document.getElementById('shareAccessLevel').value,
                                expiryDays: parseInt(document.getElementById('shareExpiry').value),
                                notifyOnAccess: document.getElementById('shareNotify').checked,
                                allowReSharing: document.getElementById('shareReSharing').checked,
                                password: document.getElementById('sharePassword').value || null,
                                message: document.getElementById('shareMessage').value || null
                            };
                            
                            // Empfänger basierend auf Ziel-Typ sammeln
                            switch (selectedTarget) {
                                case 'email':
                                    shareConfig.recipients = document.getElementById('shareEmails').value.split(',').map(email => email.trim());
                                    break;
                                case 'colleague':
                                    shareConfig.recipients = Array.from(document.querySelectorAll('#colleagueRecipients input[type="checkbox"]:checked')).map(cb => cb.value);
                                    break;
                                case 'trainer':
                                    shareConfig.recipients = Array.from(document.querySelectorAll('#trainerRecipients input[type="radio"]:checked')).map(radio => radio.value);
                                    break;
                                case 'team':
                                    shareConfig.recipients = [document.getElementById('teamSelect').value];
                                    break;
                                case 'link':
                                    shareConfig.recipients = ['link'];
                                    break;
                            }
                            
                            // Teilen durchführen
                            _performShare(data, shareConfig)
                                .then(result => {
                                    resolve(result);
                                    App.Modules.UI.Dialog.close();
                                })
                                .catch(error => {
                                    App.Modules.UI.Notification.show({
                                        type: 'error',
                                        message: 'Teilen fehlgeschlagen: ' + error.message,
                                        duration: 5000
                                    });
                                    reject(error);
                                });
                        });
                    }
                }
            });
        });
    }
    
    /**
     * Führt den tatsächlichen Teilen-Vorgang durch
     * @private
     * @param {Object} data - Zu teilende Daten
     * @param {Object} options - Freigabeoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Teilens
     */
    function _performShare(data, options) {
        return new Promise((resolve, reject) => {
            // Neue Job-ID generieren
            const jobId = `share-${Date.now()}-${++_jobCounter}`;
            
            // Job in aktive Jobs aufnehmen
            _activeJobs.push({
                id: jobId,
                type: 'share',
                status: 'running',
                progress: 0,
                options: options,
                data: data,
                startTime: new Date()
            });
            
            // Benachrichtigung anzeigen
            App.Modules.UI.Notification.show({
                type: 'info',
                message: `Freigabe wird vorbereitet...`,
                duration: 3000
            });
            
            // Teilvorgang simulieren
            setTimeout(() => {
                _updateJobProgress(jobId, 100);
                
                // Teilen abschließen
                _completeShare(jobId, options)
                    .then(result => {
                        resolve(result);
                    })
                    .catch(error => {
                        reject(error);
                    });
            }, 1500);
        });
    }
    
    /**
     * Schließt einen Freigabe-Job ab
     * @private
     * @param {string} jobId - ID des Jobs
     * @param {Object} options - Freigabeoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis der Freigabe
     */
    function _completeShare(jobId, options) {
        return new Promise((resolve, reject) => {
            const job = _activeJobs.find(job => job.id === jobId);
            if (!job) {
                reject(new Error('Job nicht gefunden'));
                return;
            }
            
            // Simulierter Erfolg
            job.status = 'completed';
            job.endTime = new Date();
            
            // Ergebnis je nach Freigabeziel
            let result = null;
            
            switch (options.target) {
                case 'email':
                    result = {
                        shareType: 'email',
                        recipients: options.recipients,
                        shareId: `share-${Math.random().toString(36).substring(2, 10)}`,
                        expiry: options.expiryDays > 0 ? new Date(Date.now() + options.expiryDays * 86400000) : null,
                        accessLevel: options.accessLevel
                    };
                    
                    // Erfolgsbenachrichtigung
                    App.Modules.UI.Notification.show({
                        type: 'success',
                        message: `Ergebnis per E-Mail an ${options.recipients.length} Empfänger geteilt`,
                        duration: 5000
                    });
                    break;
                
                case 'colleague':
                case 'trainer':
                case 'team':
                    result = {
                        shareType: options.target,
                        recipients: options.recipients,
                        shareId: `share-${Math.random().toString(36).substring(2, 10)}`,
                        expiry: options.expiryDays > 0 ? new Date(Date.now() + options.expiryDays * 86400000) : null,
                        accessLevel: options.accessLevel
                    };
                    
                    // Erfolgsbenachrichtigung
                    const targetName = {
                        'colleague': 'Kollegen',
                        'trainer': 'Trainer',
                        'team': 'Team'
                    }[options.target];
                    
                    App.Modules.UI.Notification.show({
                        type: 'success',
                        message: `Ergebnis mit ${targetName} geteilt`,
                        duration: 5000
                    });
                    break;
                
                case 'link':
                    result = {
                        shareType: 'link',
                        shareLink: _generateShareLink(job.data.id),
                        shareId: `share-${Math.random().toString(36).substring(2, 10)}`,
                        expiry: options.expiryDays > 0 ? new Date(Date.now() + options.expiryDays * 86400000) : null,
                        accessLevel: options.accessLevel
                    };
                    
                    // Erfolgsbenachrichtigung
                    App.Modules.UI.Notification.show({
                        type: 'success',
                        message: `Link zum Teilen erstellt`,
                        duration: 5000
                    });
                    break;
                
                default:
                    reject(new Error(`Unbekanntes Freigabeziel: ${options.target}`));
                    return;
            }
            
            job.result = result;
            resolve(result);
        });
    }
    
    /**
     * Generiert einen Link zum Teilen von Ergebnissen
     * @private
     * @param {string} resultId - ID des Ergebnisses
     * @returns {string} - Link zum Teilen
     */
    function _generateShareLink(resultId) {
        // Basis-URL der Anwendung
        const baseUrl = window.location.origin + window.location.pathname;
        
        // Zufälligen Token generieren
        const token = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        
        // URL mit Token und ID erstellen
        return `${baseUrl}?view=shared&id=${resultId}&token=${token}`;
    }
    
    /**
     * Erstellt einen Batch-Export für mehrere Ergebnisse
     * @param {Array<Object>} results - Liste der zu exportierenden Ergebnisse
     * @param {Object} options - Exportoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Batch-Exports
     */
    function createBatchExport(results, options = {}) {
        return new Promise((resolve, reject) => {
            if (!results || !Array.isArray(results) || results.length === 0) {
                reject(new Error('Keine Ergebnisse zum Exportieren angegeben'));
                return;
            }
            
            // Standardoptionen mit benutzerdefinierten Optionen zusammenführen
            const exportOptions = Object.assign({}, _defaultExportSettings, options);
            
            // Batch-Export-Dialog anzeigen
            const dialogHtml = `
                <div class="is24-batch-export-dialog">
                    <div class="is24-batch-export-header">
                        <h3>Mehrere Ergebnisse exportieren</h3>
                        <p>Sie exportieren ${results.length} Ergebnisse</p>
                    </div>
                    
                    <div class="is24-batch-export-body">
                        <div class="is24-export-formats">
                            <h4>Format auswählen</h4>
                            <div class="is24-format-buttons">
                                <button class="is24-format-button" data-format="pdf">
                                    <i class="is24-icon-pdf"></i>
                                    <span>PDF (ein Dokument)</span>
                                </button>
                                <button class="is24-format-button" data-format="pdf-separate">
                                    <i class="is24-icon-pdf"></i>
                                    <span>PDF (separate Dokumente)</span>
                                </button>
                                <button class="is24-format-button" data-format="xlsx">
                                    <i class="is24-icon-excel"></i>
                                    <span>Excel</span>
                                </button>
                                <button class="is24-format-button" data-format="csv">
                                    <i class="is24-icon-table"></i>
                                    <span>CSV</span>
                                </button>
                                <button class="is24-format-button" data-format="zip">
                                    <i class="is24-icon-archive"></i>
                                    <span>ZIP-Archiv</span>
                                </button>
                            </div>
                        </div>
                        
                        <div class="is24-batch-export-options">
                            <h4>Exportoptionen</h4>
                            
                            <div class="is24-checkbox">
                                <input type="checkbox" id="includeVisualizations" 
                                    ${exportOptions.includeVisualizations ? 'checked' : ''}>
                                <label for="includeVisualizations">Visualisierungen einbeziehen</label>
                            </div>
                            
                            <div class="is24-checkbox">
                                <input type="checkbox" id="includeRawData" 
                                    ${exportOptions.includeRawData ? 'checked' : ''}>
                                <label for="includeRawData">Rohdaten einbeziehen</label>
                            </div>
                            
                            <div class="is24-checkbox">
                                <input type="checkbox" id="includeComments" 
                                    ${exportOptions.includeComments ? 'checked' : ''}>
                                <label for="includeComments">Kommentare einbeziehen</label>
                            </div>
                            
                            <div class="is24-form-group">
                                <label for="batchExportGroupBy">Gruppieren nach</label>
                                <select class="is24-form-control" id="batchExportGroupBy">
                                    <option value="none">Keine Gruppierung</option>
                                    <option value="user">Teilnehmer</option>
                                    <option value="test">Test</option>
                                    <option value="date">Datum</option>
                                    <option value="score">Punktzahl</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="is24-batch-export-summary">
                            <h4>Zusammenfassung</h4>
                            
                            <div class="is24-summary-items">
                                <div class="is24-summary-item">
                                    <div class="is24-summary-label">Anzahl der Ergebnisse:</div>
                                    <div class="is24-summary-value">${results.length}</div>
                                </div>
                                
                                <div class="is24-summary-item">
                                    <div class="is24-summary-label">Teilnehmer:</div>
                                    <div class="is24-summary-value">${_countUniqueValues(results, 'userName')} unique</div>
                                </div>
                                
                                <div class="is24-summary-item">
                                    <div class="is24-summary-label">Tests:</div>
                                    <div class="is24-summary-value">${_countUniqueValues(results, 'testName')} unique</div>
                                </div>
                                
                                <div class="is24-summary-item">
                                    <div class="is24-summary-label">Zeitraum:</div>
                                    <div class="is24-summary-value">${_getDateRange(results)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="is24-batch-export-footer">
                        <button id="batchExportCancel" class="is24-btn is24-btn-secondary">Abbrechen</button>
                        <button id="batchExportDownload" class="is24-btn is24-btn-primary" disabled>
                            <i class="is24-icon-download"></i> Exportieren
                        </button>
                    </div>
                </div>
            `;
            
            // Dialog anzeigen
            App.Modules.UI.Dialog.show({
                content: dialogHtml,
                width: '700px',
                height: 'auto',
                showClose: true,
                onOpen: () => {
                    // Format-Buttons mit Event-Listenern ausstatten
                    const formatButtons = document.querySelectorAll('.is24-format-button');
                    formatButtons.forEach(button => {
                        button.addEventListener('click', (e) => {
                            // Vorherige Auswahl deaktivieren
                            document.querySelectorAll('.is24-format-button').forEach(btn => {
                                btn.classList.remove('is24-active');
                            });
                            
                            // Neue Auswahl aktivieren
                            e.currentTarget.classList.add('is24-active');
                            
                            // Format speichern
                            exportOptions.format = e.currentTarget.getAttribute('data-format');
                            
                            // Export-Button aktivieren
                            document.getElementById('batchExportDownload').removeAttribute('disabled');
                        });
                    });
                    
                    // Abbrechen-Button
                    const cancelButton = document.getElementById('batchExportCancel');
                    if (cancelButton) {
                        cancelButton.addEventListener('click', () => {
                            App.Modules.UI.Dialog.close();
                            reject(new Error('Batch-Export abgebrochen'));
                        });
                    }
                    
                    // Export-Button
                    const exportButton = document.getElementById('batchExportDownload');
                    if (exportButton) {
                        exportButton.addEventListener('click', () => {
                            // Optionen aktualisieren
                            exportOptions.includeVisualizations = document.getElementById('includeVisualizations').checked;
                            exportOptions.includeRawData = document.getElementById('includeRawData').checked;
                            exportOptions.includeComments = document.getElementById('includeComments').checked;
                            exportOptions.groupBy = document.getElementById('batchExportGroupBy').value;
                            
                            // Export durchführen
                            _performBatchExport(results, exportOptions)
                                .then(result => {
                                    resolve(result);
                                    App.Modules.UI.Dialog.close();
                                })
                                .catch(error => {
                                    App.Modules.UI.Notification.show({
                                        type: 'error',
                                        message: 'Export fehlgeschlagen: ' + error.message,
                                        duration: 5000
                                    });
                                    reject(error);
                                });
                        });
                    }
                }
            });
        });
    }
    
    /**
     * Zählt eindeutige Werte in einem Array von Objekten
     * @private
     * @param {Array<Object>} items - Array von Objekten
     * @param {string} property - Eigenschaft, für die eindeutige Werte gezählt werden sollen
     * @returns {number} - Anzahl eindeutiger Werte
     */
    function _countUniqueValues(items, property) {
        const uniqueValues = new Set();
        
        items.forEach(item => {
            if (item[property]) {
                uniqueValues.add(item[property]);
            }
        });
        
        return uniqueValues.size;
    }
    
    /**
     * Bestimmt den Datumsbereich für ein Array von Ergebnissen
     * @private
     * @param {Array<Object>} results - Array von Ergebnissen
     * @returns {string} - Formatierter Datumsbereich
     */
    function _getDateRange(results) {
        let minDate = null;
        let maxDate = null;
        
        results.forEach(result => {
            if (result.date) {
                const date = new Date(result.date);
                if (!minDate || date < minDate) {
                    minDate = date;
                }
                if (!maxDate || date > maxDate) {
                    maxDate = date;
                }
            }
        });
        
        if (!minDate || !maxDate) {
            return 'Unbekannt';
        }
        
        // Formatieren
        const formatDate = (date) => {
            return date.toLocaleDateString();
        };
        
        return `${formatDate(minDate)} - ${formatDate(maxDate)}`;
    }
    
    /**
     * Führt einen Batch-Export durch
     * @private
     * @param {Array<Object>} results - Liste der zu exportierenden Ergebnisse
     * @param {Object} options - Exportoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Batch-Exports
     */
    function _performBatchExport(results, options) {
        return new Promise((resolve, reject) => {
            // Neue Job-ID generieren
            const jobId = `batch-export-${Date.now()}-${++_jobCounter}`;
            
            // Job in aktive Jobs aufnehmen
            _activeJobs.push({
                id: jobId,
                type: 'batch-export',
                status: 'running',
                progress: 0,
                options: options,
                data: results,
                startTime: new Date()
            });
            
            // Benachrichtigung anzeigen
            App.Modules.UI.Notification.show({
                type: 'info',
                message: `Batch-Export wird vorbereitet...`,
                duration: 3000
            });
            
            // Exportvorgang simulieren
            let progress = 0;
            const updateInterval = setInterval(() => {
                progress += 5;
                _updateJobProgress(jobId, progress);
                
                if (progress >= 100) {
                    clearInterval(updateInterval);
                    
                    // Export abschließen
                    setTimeout(() => {
                        _completeBatchExport(jobId, options)
                            .then(result => {
                                resolve(result);
                            })
                            .catch(error => {
                                reject(error);
                            });
                    }, 500);
                }
            }, 200);
        });
    }
    
    /**
     * Schließt einen Batch-Export-Job ab
     * @private
     * @param {string} jobId - ID des Jobs
     * @param {Object} options - Exportoptionen
     * @returns {Promise<Object>} - Promise mit dem Ergebnis des Batch-Exports
     */
    function _completeBatchExport(jobId, options) {
        return new Promise((resolve, reject) => {
            const job = _activeJobs.find(job => job.id === jobId);
            if (!job) {
                reject(new Error('Job nicht gefunden'));
                return;
            }
            
            // Format bestimmen
            const format = options.format;
            
            // Dateiname generieren
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            let fileName;
            let fileExtension;
            
            switch (format) {
                case 'pdf':
                    fileName = `Testergebnisse_${timestamp}.pdf`;
                    fileExtension = '.pdf';
                    break;
                case 'pdf-separate':
                    fileName = `Testergebnisse_${timestamp}.zip`;
                    fileExtension = '.zip';
                    break;
                case 'xlsx':
                    fileName = `Testergebnisse_${timestamp}.xlsx`;
                    fileExtension = '.xlsx';
                    break;
                case 'csv':
                    fileName = `Testergebnisse_${timestamp}.csv`;
                    fileExtension = '.csv';
                    break;
                case 'zip':
                    fileName = `Testergebnisse_${timestamp}.zip`;
                    fileExtension = '.zip';
                    break;
                default:
                    reject(new Error(`Unbekanntes Format: ${format}`));
                    return;
            }
            
            // Job als abgeschlossen markieren
            job.status = 'completed';
            job.endTime = new Date();
            job.result = {
                fileName: fileName,
                fileSize: Math.floor(Math.random() * 5000) + 1000, // Simulierte Dateigröße in KB
                format: format,
                itemCount: job.data.length,
                url: `data:application/octet-stream;base64,SIMULATED_FILE_CONTENT` // Simulierter Download-Link
            };
            
            // Erfolgsbenachrichtigung anzeigen
            let formatName;
            switch (format) {
                case 'pdf':
                    formatName = 'PDF (ein Dokument)';
                    break;
                case 'pdf-separate':
                    formatName = 'PDF (separate Dokumente)';
                    break;
                case 'xlsx':
                    formatName = 'Excel';
                    break;
                case 'csv':
                    formatName = 'CSV';
                    break;
                case 'zip':
                    formatName = 'ZIP-Archiv';
                    break;
                default:
                    formatName = format;
            }
            
            App.Modules.UI.Notification.show({
                type: 'success',
                message: `${formatName} mit ${job.data.length} Ergebnissen erfolgreich erstellt`,
                duration: 5000
            });
            
            // Simulierten Download initiieren
            _triggerDownload(fileName, job.result.url);
            
            // Job-Ergebnis zurückgeben
            resolve(job.result);
        });
    }
    
    /**
     * Listet alle aktiven oder abgeschlossenen Export- und Freigabe-Jobs auf
     * @param {Object} options - Filteroptionen
     * @returns {Array<Object>} - Liste der Jobs
     */
    function getJobs(options = {}) {
        // Standardoptionen
        const filterOptions = Object.assign({
            status: null, // 'running', 'completed', 'failed', oder null für alle
            type: null, // 'export', 'share', 'batch-export', oder null für alle
            sort: 'startTime', // 'startTime', 'endTime', 'type', 'status'
            order: 'desc', // 'asc', 'desc'
            limit: 50 // Anzahl der zurückzugebenden Jobs
        }, options);
        
        // Jobs filtern
        let filteredJobs = _activeJobs.filter(job => {
            if (filterOptions.status && job.status !== filterOptions.status) {
                return false;
            }
            if (filterOptions.type && job.type !== filterOptions.type) {
                return false;
            }
            return true;
        });
        
        // Jobs sortieren
        filteredJobs.sort((a, b) => {
            let valueA, valueB;
            
            switch (filterOptions.sort) {
                case 'startTime':
                    valueA = a.startTime;
                    valueB = b.startTime;
                    break;
                case 'endTime':
                    valueA = a.endTime || new Date(0);
                    valueB = b.endTime || new Date(0);
                    break;
                case 'type':
                    valueA = a.type;
                    valueB = b.type;
                    break;
                case 'status':
                    valueA = a.status;
                    valueB = b.status;
                    break;
                default:
                    valueA = a.startTime;
                    valueB = b.startTime;
            }
            
            if (filterOptions.order === 'asc') {
                return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
            } else {
                return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
            }
        });
        
        // Anzahl begrenzen
        if (filterOptions.limit > 0) {
            filteredJobs = filteredJobs.slice(0, filterOptions.limit);
        }
        
        return filteredJobs;
    }
    
    /**
     * Erstellt eine druckbare Version eines Ergebnisses oder mehrerer Ergebnisse
     * @param {Object|Array<Object>} data - Zu druckende Daten
     * @param {Object} options - Druckoptionen
     * @returns {Promise<void>} - Promise, der nach dem Drucken aufgelöst wird
     */
    function createPrintableVersion(data, options = {}) {
        return new Promise((resolve, reject) => {
            try {
                // Standardoptionen
                const printOptions = Object.assign({
                    title: 'Testergebnisse',
                    includeVisualizations: true,
                    includeRawData: false,
                    includeComments: true,
                    orientation: 'portrait',
                    paperSize: 'a4'
                }, options);
                
                // Druckbares Dokument im Hintergrund erstellen
                const printContainer = document.createElement('div');
                printContainer.className = 'is24-print-container';
                printContainer.style.display = 'none';
                document.body.appendChild(printContainer);
                
                // Kopfzeilen- und Fußzeileninformationen
                const headerHtml = `
                    <div class="is24-print-header">
                        <div class="is24-print-logo">ImmoScout24 E-Learning</div>
                        <div class="is24-print-title">${printOptions.title}</div>
                        <div class="is24-print-date">${new Date().toLocaleDateString()}</div>
                    </div>
                `;
                
                const footerHtml = `
                    <div class="is24-print-footer">
                        <div class="is24-print-page-info">Seite <span class="is24-page-num"></span> von <span class="is24-page-count"></span></div>
                        <div class="is24-print-timestamp">Erstellt am ${new Date().toLocaleString()}</div>
                    </div>
                `;
                
                // Inhalt basierend auf Datentyp erstellen
                let contentHtml = '';
                
                if (Array.isArray(data)) {
                    // Mehrere Ergebnisse drucken
                    contentHtml = _createBatchPrintContent(data, printOptions);
                } else {
                    // Einzelnes Ergebnis drucken
                    contentHtml = _createSinglePrintContent(data, printOptions);
                }
                
                // Vollständiges Dokument zusammensetzen
                printContainer.innerHTML = `
                    <div class="is24-print-document" style="width: ${printOptions.paperSize === 'a4' ? '210mm' : printOptions.paperSize === 'a3' ? '297mm' : '215.9mm'}">
                        ${headerHtml}
                        <div class="is24-print-content">
                            ${contentHtml}
                        </div>
                        ${footerHtml}
                    </div>
                `;
                
                // Druckstil hinzufügen
                const printStyle = document.createElement('style');
                printStyle.textContent = `
                    @media print {
                        body * {
                            visibility: hidden;
                        }
                        .is24-print-container, .is24-print-container * {
                            visibility: visible;
                        }
                        .is24-print-container {
                            position: absolute;
                            left: 0;
                            top: 0;
                            width: 100%;
                        }
                        .is24-print-document {
                            margin: 0;
                            padding: 0;
                        }
                        .is24-print-header {
                            position: fixed;
                            top: 0;
                            width: 100%;
                            padding: 10mm 0;
                            text-align: center;
                        }
                        .is24-print-footer {
                            position: fixed;
                            bottom: 0;
                            width: 100%;
                            padding: 5mm 0;
                            text-align: center;
                        }
                        .is24-print-content {
                            margin-top: 25mm;
                            margin-bottom: 20mm;
                        }
                        @page {
                            size: ${printOptions.paperSize} ${printOptions.orientation};
                            margin: 10mm;
                        }
                    }
                `;
                printContainer.appendChild(printStyle);
                
                // Druckausgabe initiieren
                setTimeout(() => {
                    window.print();
                    
                    // Nach dem Drucken aufräumen
                    setTimeout(() => {
                        document.body.removeChild(printContainer);
                        resolve();
                    }, 1000);
                }, 500);
                
            } catch (error) {
                reject(error);
            }
        });
    }
    
    /**
     * Erstellt Druckinhalt für ein einzelnes Ergebnis
     * @private
     * @param {Object} data - Zu druckendes Ergebnis
     * @param {Object} options - Druckoptionen
     * @returns {string} - HTML für den Druckinhalt
     */
    function _createSinglePrintContent(data, options) {
        // Einfacher Inhalt für ein einzelnes Ergebnis
        return `
            <div class="is24-print-result">
                <div class="is24-print-result-header">
                    <h1>${data.testName || 'Testergebnis'}</h1>
                    <div class="is24-print-result-meta">
                        <p><strong>Teilnehmer:</strong> ${data.userName || 'Unbekannt'}</p>
                        <p><strong>Datum:</strong> ${data.date ? new Date(data.date).toLocaleDateString() : 'Unbekannt'}</p>
                        <p><strong>Dauer:</strong> ${data.duration || 'Unbekannt'}</p>
                    </div>
                </div>
                
                <div class="is24-print-result-score">
                    <div class="is24-score-display">
                        <div class="is24-score-circle">${data.score ? data.score + '%' : 'N/A'}</div>
                        <div class="is24-score-label">Gesamtergebnis</div>
                    </div>
                </div>
                
                ${options.includeVisualizations && data.categoryScores ? `
                    <div class="is24-print-result-categories">
                        <h2>Ergebnisse nach Kategorien</h2>
                        <table class="is24-print-table">
                            <thead>
                                <tr>
                                    <th>Kategorie</th>
                                    <th>Punktzahl</th>
                                    <th>Bewertung</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(data.categoryScores).map(([category, score]) => {
                                    let rating;
                                    if (score >= 80) rating = 'Sehr gut';
                                    else if (score >= 70) rating = 'Gut';
                                    else if (score >= 60) rating = 'Befriedigend';
                                    else if (score >= 50) rating = 'Ausreichend';
                                    else rating = 'Mangelhaft';
                                    
                                    return `
                                        <tr>
                                            <td>${category}</td>
                                            <td>${score.toFixed(1)}%</td>
                                            <td>${rating}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                ` : ''}
                
                ${options.includeComments && data.comments ? `
                    <div class="is24-print-result-comments">
                        <h2>Kommentare & Feedback</h2>
                        <div class="is24-comments-list">
                            ${data.comments.map(comment => `
                                <div class="is24-comment-item">
                                    <div class="is24-comment-author">${comment.author || 'System'}</div>
                                    <div class="is24-comment-date">${comment.date ? new Date(comment.date).toLocaleString() : ''}</div>
                                    <div class="is24-comment-text">${comment.text}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
    }
    
    /**
     * Erstellt Druckinhalt für mehrere Ergebnisse
     * @private
     * @param {Array<Object>} data - Zu druckende Ergebnisse
     * @param {Object} options - Druckoptionen
     * @returns {string} - HTML für den Druckinhalt
     */
    function _createBatchPrintContent(data, options) {
        // Zusammenfassung der Ergebnisse erstellen
        return `
            <div class="is24-print-batch-results">
                <div class="is24-print-summary">
                    <h1>Zusammenfassung der Ergebnisse</h1>
                    <p>Anzahl der Ergebnisse: ${data.length}</p>
                    <p>Zeitraum: ${_getDateRange(data)}</p>
                    <p>Durchschnittliche Punktzahl: ${_calculateAverageScore(data).toFixed(1)}%</p>
                </div>
                
                <div class="is24-print-results-table">
                    <h2>Ergebnisübersicht</h2>
                    <table class="is24-print-table">
                        <thead>
                            <tr>
                                <th>Teilnehmer</th>
                                <th>Test</th>
                                <th>Datum</th>
                                <th>Punktzahl</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(result => {
                                let status = 'Nicht bestanden';
                                if (result.score >= 80) status = 'Bestanden';
                                else if (result.score >= 50) status = 'Teilweise bestanden';
                                
                                return `
                                    <tr>
                                        <td>${result.userName || 'Unbekannt'}</td>
                                        <td>${result.testName || 'Unbekannt'}</td>
                                        <td>${result.date ? new Date(result.date).toLocaleDateString() : 'Unbekannt'}</td>
                                        <td>${result.score ? result.score.toFixed(1) + '%' : 'N/A'}</td>
                                        <td>${status}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    
    /**
     * Berechnet die durchschnittliche Punktzahl für eine Liste von Ergebnissen
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {number} - Durchschnittliche Punktzahl
     */
    function _calculateAverageScore(results) {
        const validScores = results.filter(result => typeof result.score === 'number').map(result => result.score);
        if (validScores.length === 0) return 0;
        return validScores.reduce((sum, score) => sum + score, 0) / validScores.length;
    }
    
    // Öffentliche API
    return {
        showExportDialog,
        showShareDialog,
        createBatchExport,
        createPrintableVersion,
        getJobs,
        
        // Konstanten
        get supportedFormats() {
            return Object.keys(_exportFormats);
        },
        
        get shareTargets() {
            return Object.keys(_shareOptions);
        },
        
        get accessLevels() {
            return Object.keys(_accessLevels);
        }
    };
})();
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.5-1 - Integration mit anderen Systemkomponenten
 * @module js/modules/results/visualization/integration
 * @requires js/modules/results/data-manager
 * @requires js/modules/results/visualization/base
 * @requires js/modules/user/user-manager
 * @requires js/modules/test/test-manager
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für die Integration der Ergebnisvisualisierung in das Gesamtsystem
App.Modules.Results = App.Modules.Results || {};
App.Modules.Results.Visualization = App.Modules.Results.Visualization || {};

/**
 * Modul für die Integration der Ergebnisvisualisierung mit anderen Systemkomponenten
 * @namespace
 */
App.Modules.Results.Integration = (function() {
    // Private Variablen
    let _initialized = false;
    let _eventHandlers = {};
    let _dataSubscriptions = [];
    let _activeIntegrations = {};
    let _pendingOperations = [];
    
    /**
     * Initialisiert das Integrationsmodul
     * @param {Object} options - Konfigurationsoptionen
     * @returns {Promise<boolean>} - Promise, der nach erfolgreicher Initialisierung aufgelöst wird
     */
    function initialize(options = {}) {
        return new Promise((resolve, reject) => {
            if (_initialized) {
                console.warn('Integrationsmodul bereits initialisiert');
                resolve(true);
                return;
            }
            
            // Grundeinstellungen
            const config = Object.assign({
                userIntegration: true,
                testIntegration: true,
                dashboardIntegration: true,
                apiIntegration: true,
                eventIntegration: true,
                autoRefresh: true,
                refreshInterval: 60000 // 1 Minute
            }, options);
            
            console.log('Initialisiere Integrationsmodul mit Konfiguration:', config);
            
            // Integrationen basierend auf Konfiguration durchführen
            const integrationPromises = [];
            
            // Benutzermodul-Integration
            if (config.userIntegration) {
                integrationPromises.push(_integrateWithUserModule()
                    .then(() => {
                        _activeIntegrations.user = true;
                        console.log('Benutzermodul-Integration erfolgreich');
                    })
                    .catch(error => {
                        console.error('Benutzermodul-Integration fehlgeschlagen:', error);
                        throw error;
                    })
                );
            }
            
            // Testmodul-Integration
            if (config.testIntegration) {
                integrationPromises.push(_integrateWithTestModule()
                    .then(() => {
                        _activeIntegrations.test = true;
                        console.log('Testmodul-Integration erfolgreich');
                    })
                    .catch(error => {
                        console.error('Testmodul-Integration fehlgeschlagen:', error);
                        throw error;
                    })
                );
            }
            
            // API-Integration
            if (config.apiIntegration) {
                integrationPromises.push(_integrateWithAPI()
                    .then(() => {
                        _activeIntegrations.api = true;
                        console.log('API-Integration erfolgreich');
                    })
                    .catch(error => {
                        console.error('API-Integration fehlgeschlagen:', error);
                        throw error;
                    })
                );
            }
            
            // Event-Integration
            if (config.eventIntegration) {
                integrationPromises.push(_setupEventHandling()
                    .then(() => {
                        _activeIntegrations.event = true;
                        console.log('Event-Integration erfolgreich');
                    })
                    .catch(error => {
                        console.error('Event-Integration fehlgeschlagen:', error);
                        throw error;
                    })
                );
            }
            
            // Dashboard-Integration wird in Teil 2 implementiert
            
            // Alle Integrationen abwarten
            Promise.all(integrationPromises)
                .then(() => {
                    _initialized = true;
                    
                    // Periodische Aktualisierung einrichten, falls aktiviert
                    if (config.autoRefresh) {
                        _setupAutoRefresh(config.refreshInterval);
                    }
                    
                    // Ausstehende Operationen ausführen
                    _processPendingOperations();
                    
                    console.log('Integrationsmodul erfolgreich initialisiert');
                    resolve(true);
                })
                .catch(error => {
                    console.error('Fehler bei der Initialisierung des Integrationsmoduls:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Integriert das Visualisierungsmodul mit dem Benutzermodul
     * @private
     * @returns {Promise<void>} - Promise, der nach erfolgreicher Integration aufgelöst wird
     */
    function _integrateWithUserModule() {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob das Benutzermodul existiert
                if (!App.Modules.User || !App.Modules.User.Manager) {
                    throw new Error('Benutzermodul nicht verfügbar');
                }
                
                const UserManager = App.Modules.User.Manager;
                
                // Berechtigungen für Ergebnisvisualisierung registrieren
                UserManager.registerPermissions([
                    {
                        name: 'results.view',
                        description: 'Ergebnisse anzeigen',
                        defaultRoles: ['user', 'trainer', 'admin', 'teamleader']
                    },
                    {
                        name: 'results.view.own',
                        description: 'Eigene Ergebnisse anzeigen',
                        defaultRoles: ['user', 'trainer', 'admin', 'teamleader']
                    },
                    {
                        name: 'results.view.team',
                        description: 'Teamergebnisse anzeigen',
                        defaultRoles: ['trainer', 'admin', 'teamleader']
                    },
                    {
                        name: 'results.view.all',
                        description: 'Alle Ergebnisse anzeigen',
                        defaultRoles: ['trainer', 'admin']
                    },
                    {
                        name: 'results.export',
                        description: 'Ergebnisse exportieren',
                        defaultRoles: ['trainer', 'admin', 'teamleader']
                    },
                    {
                        name: 'results.share',
                        description: 'Ergebnisse teilen',
                        defaultRoles: ['trainer', 'admin', 'teamleader']
                    }
                ]);
                
                // Event-Handler registrieren
                UserManager.addEventListener('user.login', _handleUserLogin);
                UserManager.addEventListener('user.logout', _handleUserLogout);
                UserManager.addEventListener('user.role.change', _handleUserRoleChange);
                UserManager.addEventListener('user.team.change', _handleUserTeamChange);
                
                // Aktuellen Benutzer abfragen und Rechte überprüfen
                const currentUser = UserManager.getCurrentUser();
                if (currentUser) {
                    // Integration für aktuellen Benutzer durchführen
                    _setupUserSpecificIntegration(currentUser);
                }
                
                resolve();
                
            } catch (error) {
                console.error('Fehler bei der Benutzermodul-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Richtet benutzerspezifische Integrationen ein
     * @private
     * @param {Object} user - Benutzerinformationen
     * @returns {void}
     */
    function _setupUserSpecificIntegration(user) {
        if (!user) return;
        
        // Benutzerrechte für Ergebnisvisualisierung prüfen
        const UserManager = App.Modules.User.Manager;
        
        // Sichtbarkeit und Funktionalität basierend auf Berechtigungen festlegen
        const canViewOwn = UserManager.hasPermission('results.view.own');
        const canViewTeam = UserManager.hasPermission('results.view.team');
        const canViewAll = UserManager.hasPermission('results.view.all');
        const canExport = UserManager.hasPermission('results.export');
        const canShare = UserManager.hasPermission('results.share');
        
        // Datenfilter basierend auf Berechtigungen einstellen
        const dataFilters = {
            userId: canViewOwn ? user.id : null,
            teamId: canViewTeam ? user.teamId : null,
            showAll: canViewAll
        };
        
        // Datenfilter im Daten-Manager setzen
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.setUserFilters(dataFilters);
        }
        
        // Export- und Freigabeoptionen anpassen
        if (App.Modules.Results.Export) {
            // Export-Schaltflächen ein-/ausblenden
            const exportButtons = document.querySelectorAll('.is24-export-button');
            exportButtons.forEach(button => {
                button.style.display = canExport ? 'inline-flex' : 'none';
            });
            
            // Freigabe-Schaltflächen ein-/ausblenden
            const shareButtons = document.querySelectorAll('.is24-share-button');
            shareButtons.forEach(button => {
                button.style.display = canShare ? 'inline-flex' : 'none';
            });
        }
        
        // Benutzer-bezogene Event-Handler hinzufügen
        _eventHandlers.userDataUpdate = function(event) {
            if (event.userId === user.id || canViewTeam || canViewAll) {
                _refreshAllVisualizations();
            }
        };
        
        // Event-Listener registrieren
        if (App.Events) {
            App.Events.subscribe('results.data.update', _eventHandlers.userDataUpdate);
        }
    }
    
    /**
     * Handler für Benutzeranmeldung
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleUserLogin(event) {
        console.log('Benutzer angemeldet:', event.user);
        
        // Benutzerspezifische Integration einrichten
        _setupUserSpecificIntegration(event.user);
        
        // Visualisierungen aktualisieren
        _refreshAllVisualizations();
    }
    
    /**
     * Handler für Benutzerabmeldung
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleUserLogout(event) {
        console.log('Benutzer abgemeldet:', event.userId);
        
        // Datenfilter zurücksetzen
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.resetUserFilters();
        }
        
        // Event-Handler entfernen
        if (App.Events && _eventHandlers.userDataUpdate) {
            App.Events.unsubscribe('results.data.update', _eventHandlers.userDataUpdate);
        }
    }
    
    /**
     * Handler für Rollenänderung des Benutzers
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleUserRoleChange(event) {
        console.log('Benutzerrolle geändert:', event.userId, event.newRoles);
        
        // Benutzer neu laden
        const UserManager = App.Modules.User.Manager;
        const user = UserManager.getUserById(event.userId);
        
        // Benutzerspezifische Integration aktualisieren
        if (user) {
            _setupUserSpecificIntegration(user);
        }
    }
    
    /**
     * Handler für Teamänderung des Benutzers
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleUserTeamChange(event) {
        console.log('Benutzerteam geändert:', event.userId, event.newTeamId);
        
        // Datenfilter aktualisieren, falls aktueller Benutzer
        const UserManager = App.Modules.User.Manager;
        const currentUser = UserManager.getCurrentUser();
        
        if (currentUser && currentUser.id === event.userId) {
            const canViewTeam = UserManager.hasPermission('results.view.team');
            
            if (canViewTeam && App.Modules.Results.DataManager) {
                App.Modules.Results.DataManager.setTeamFilter(event.newTeamId);
            }
            
            // Visualisierungen aktualisieren
            _refreshAllVisualizations();
        }
    }
    
    /**
     * Integriert das Visualisierungsmodul mit dem Testmodul
     * @private
     * @returns {Promise<void>} - Promise, der nach erfolgreicher Integration aufgelöst wird
     */
    function _integrateWithTestModule() {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob das Testmodul existiert
                if (!App.Modules.Test || !App.Modules.Test.Manager) {
                    throw new Error('Testmodul nicht verfügbar');
                }
                
                const TestManager = App.Modules.Test.Manager;
                
                // Event-Handler registrieren
                TestManager.addEventListener('test.completed', _handleTestCompletion);
                TestManager.addEventListener('test.evaluated', _handleTestEvaluation);
                TestManager.addEventListener('test.updated', _handleTestUpdate);
                
                // Testdaten für Visualisierungen bereitstellen
                _setupTestDataProviders();
                
                // Alle aktiven Testdaten laden
                TestManager.getActiveTests()
                    .then(tests => {
                        // Test-Metadaten im Daten-Manager registrieren
                        if (App.Modules.Results.DataManager) {
                            App.Modules.Results.DataManager.registerTestMetadata(tests);
                        }
                        resolve();
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Testdaten:', error);
                        // Integration trotz Fehler bei Daten fortsetzen
                        resolve();
                    });
                
            } catch (error) {
                console.error('Fehler bei der Testmodul-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Richtet Test-Datenprovider ein
     * @private
     * @returns {void}
     */
    function _setupTestDataProviders() {
        // Prüfen, ob das Datenmanager-Modul existiert
        if (!App.Modules.Results.DataManager) {
            console.warn('Datenmanager-Modul nicht verfügbar, Testdaten-Provider können nicht eingerichtet werden');
            return;
        }
        
        const DataManager = App.Modules.Results.DataManager;
        const TestManager = App.Modules.Test.Manager;
        
        // Provider für Testmetadaten registrieren
        DataManager.registerDataProvider('testMetadata', async () => {
            try {
                const tests = await TestManager.getActiveTests();
                return tests;
            } catch (error) {
                console.error('Fehler beim Laden der Testmetadaten:', error);
                return [];
            }
        });
        
        // Provider für Testkategorien registrieren
        DataManager.registerDataProvider('testCategories', async () => {
            try {
                const categories = await TestManager.getCategories();
                return categories;
            } catch (error) {
                console.error('Fehler beim Laden der Testkategorien:', error);
                return [];
            }
        });
        
        // Provider für Testfragentypen registrieren
        DataManager.registerDataProvider('questionTypes', async () => {
            try {
                const questionTypes = await TestManager.getQuestionTypes();
                return questionTypes;
            } catch (error) {
                console.error('Fehler beim Laden der Fragentypen:', error);
                return [];
            }
        });
    }
    
    /**
     * Handler für abgeschlossene Tests
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleTestCompletion(event) {
        console.log('Test abgeschlossen:', event.testId, event.userId);
        
        // Neue Testergebnisse laden und Visualisierungen aktualisieren
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.refreshResultData(event.testId, event.userId)
                .then(() => {
                    _refreshAllVisualizations();
                    
                    // Benachrichtigung anzeigen
                    App.Modules.UI.Notification.show({
                        type: 'success',
                        message: 'Neues Testergebnis verfügbar',
                        duration: 5000
                    });
                })
                .catch(error => {
                    console.error('Fehler beim Laden des neuen Testergebnisses:', error);
                });
        }
        
        // Systemweites Ereignis auslösen
        if (App.Events) {
            App.Events.publish('results.new', {
                testId: event.testId,
                userId: event.userId,
                timestamp: new Date().toISOString()
            });
        }
    }
    
    /**
     * Handler für bewertete Tests
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleTestEvaluation(event) {
        console.log('Test bewertet:', event.testId, event.userId);
        
        // Testergebnisse aktualisieren und Visualisierungen aktualisieren
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.refreshResultData(event.testId, event.userId)
                .then(() => {
                    _refreshAllVisualizations();
                    
                    // Benachrichtigung anzeigen
                    App.Modules.UI.Notification.show({
                        type: 'info',
                        message: 'Testergebnis wurde aktualisiert',
                        duration: 5000
                    });
                })
                .catch(error => {
                    console.error('Fehler beim Aktualisieren des Testergebnisses:', error);
                });
        }
        
        // Systemweites Ereignis auslösen
        if (App.Events) {
            App.Events.publish('results.updated', {
                testId: event.testId,
                userId: event.userId,
                timestamp: new Date().toISOString()
            });
        }
    }
    
    /**
     * Handler für Test-Updates
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleTestUpdate(event) {
        console.log('Test aktualisiert:', event.testId);
        
        // Testmetadaten aktualisieren
        if (App.Modules.Results.DataManager && App.Modules.Test.Manager) {
            App.Modules.Test.Manager.getTestById(event.testId)
                .then(test => {
                    App.Modules.Results.DataManager.updateTestMetadata(test);
                    
                    // Visualisierungen aktualisieren, falls betroffen
                    _refreshVisualizationsForTest(event.testId);
                })
                .catch(error => {
                    console.error('Fehler beim Aktualisieren der Testmetadaten:', error);
                });
        }
    }
    
    /**
     * Integriert das Visualisierungsmodul mit der API
     * @private
     * @returns {Promise<void>} - Promise, der nach erfolgreicher Integration aufgelöst wird
     */
    function _integrateWithAPI() {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob das API-Modul existiert
                if (!App.API) {
                    console.warn('API-Modul nicht verfügbar, Integration wird übersprungen');
                    resolve();
                    return;
                }
                
                // API-Endpunkte für Ergebnisvisualisierung registrieren
                App.API.registerEndpoints([
                    {
                        path: '/api/results',
                        method: 'GET',
                        handler: _handleAPIGetResults,
                        description: 'Ruft Testergebnisse ab'
                    },
                    {
                        path: '/api/results/:id',
                        method: 'GET',
                        handler: _handleAPIGetResultById,
                        description: 'Ruft ein bestimmtes Testergebnis ab'
                    },
                    {
                        path: '/api/results/user/:userId',
                        method: 'GET',
                        handler: _handleAPIGetResultsByUser,
                        description: 'Ruft Testergebnisse für einen bestimmten Benutzer ab'
                    },
                    {
                        path: '/api/results/test/:testId',
                        method: 'GET',
                        handler: _handleAPIGetResultsByTest,
                        description: 'Ruft Testergebnisse für einen bestimmten Test ab'
                    },
                    {
                        path: '/api/results/export/:id',
                        method: 'GET',
                        handler: _handleAPIExportResult,
                        description: 'Exportiert ein Testergebnis'
                    },
                    {
                        path: '/api/results/visualizations',
                        method: 'GET',
                        handler: _handleAPIGetVisualizations,
                        description: 'Ruft verfügbare Visualisierungen ab'
                    }
                ]);
                
                // API-Daten-Transformation einrichten
                _setupAPIDataTransformers();
                
                resolve();
                
            } catch (error) {
                console.error('Fehler bei der API-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Richtet API-Datentransformatoren ein
     * @private
     * @returns {void}
     */
    function _setupAPIDataTransformers() {
        if (!App.API || !App.API.registerTransformer) {
            return;
        }
        
        // Transformator für Ergebnisdaten (Anonymisierung, Filterung)
        App.API.registerTransformer('results', (data, context) => {
            // Daten basierend auf Benutzerrolle filtern
            const user = context.user;
            const isAdmin = user && user.roles && user.roles.includes('admin');
            const isTrainer = user && user.roles && user.roles.includes('trainer');
            const isTeamLeader = user && user.roles && user.roles.includes('teamleader');
            
            // Wenn normaler Benutzer, nur eigene Ergebnisse zurückgeben
            if (user && !isAdmin && !isTrainer && !isTeamLeader) {
                return data.filter(item => item.userId === user.id);
            }
            
            // Wenn Teamleiter, nur Ergebnisse aus eigenem Team zurückgeben
            if (isTeamLeader && !isAdmin && !isTrainer) {
                return data.filter(item => {
                    const itemUser = App.Modules.User.Manager.getUserById(item.userId);
                    return itemUser && itemUser.teamId === user.teamId;
                });
            }
            
            // Für Administratoren und Trainer alle Daten zurückgeben
            return data;
        });
        
        // Transformator für einzelnes Ergebnis
        App.API.registerTransformer('result', (data, context) => {
            const user = context.user;
            
            // Prüfen, ob Benutzer berechtigt ist, dieses Ergebnis zu sehen
            if (!_canUserAccessResult(user, data)) {
                // Sensible Daten entfernen
                delete data.rawAnswers;
                delete data.individualFeedback;
                
                // Nur grundlegende Informationen beibehalten
                return {
                    id: data.id,
                    testId: data.testId,
                    testName: data.testName,
                    date: data.date,
                    score: data.score,
                    error: 'Zugriff auf detaillierte Daten verweigert'
                };
            }
            
            return data;
        });
    }
    
    /**
     * Prüft, ob ein Benutzer auf ein bestimmtes Ergebnis zugreifen darf
     * @private
     * @param {Object} user - Benutzerinformationen
     * @param {Object} result - Ergebnisdaten
     * @returns {boolean} - True, wenn Zugriff erlaubt ist
     */
    function _canUserAccessResult(user, result) {
        if (!user || !result) return false;
        
        // Administratoren und Trainer haben Zugriff auf alle Ergebnisse
        if (user.roles && (user.roles.includes('admin') || user.roles.includes('trainer'))) {
            return true;
        }
        
        // Benutzer haben Zugriff auf ihre eigenen Ergebnisse
        if (result.userId === user.id) {
            return true;
        }
        
        // Teamleiter haben Zugriff auf Ergebnisse aus ihrem Team
        if (user.roles && user.roles.includes('teamleader')) {
            const resultUser = App.Modules.User.Manager.getUserById(result.userId);
            return resultUser && resultUser.teamId === user.teamId;
        }
        
        return false;
    }
    
    /**
     * API-Handler für das Abrufen von Testergebnissen
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIGetResults(req, res) {
        // Filteroption aus Query-Parametern extrahieren
        const options = {
            limit: parseInt(req.query.limit) || 50,
            offset: parseInt(req.query.offset) || 0,
            sort: req.query.sort || 'date',
            order: req.query.order || 'desc',
            from: req.query.from ? new Date(req.query.from) : null,
            to: req.query.to ? new Date(req.query.to) : null
        };
        
        // Daten aus dem Datenmanager abrufen
        App.Modules.Results.DataManager.getResults(options)
            .then(results => {
                // Transformieren der Daten für die API
                const transformedResults = App.API.transformData('results', results, { user: req.user });
                
                res.status(200).json({
                    success: true,
                    data: transformedResults,
                    meta: {
                        total: transformedResults.length,
                        limit: options.limit,
                        offset: options.offset
                    }
                });
            })
            .catch(error => {
                console.error('API-Fehler beim Abrufen von Ergebnissen:', error);
                res.status(500).json({
                    success: false,
                    error: 'Fehler beim Abrufen der Ergebnisse',
                    message: error.message
                });
            });
    }
    
    /**
     * API-Handler für das Abrufen eines Testergebnisses nach ID
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIGetResultById(req, res) {
        const resultId = req.params.id;
        
        if (!resultId) {
            res.status(400).json({
                success: false,
                error: 'Fehlende Ergebnis-ID'
            });
            return;
        }
        
        // Ergebnis aus dem Datenmanager abrufen
        App.Modules.Results.DataManager.getResultById(resultId)
            .then(result => {
                if (!result) {
                    res.status(404).json({
                        success: false,
                        error: 'Ergebnis nicht gefunden'
                    });
                    return;
                }
                
                // Transformieren des Ergebnisses für die API
                const transformedResult = App.API.transformData('result', result, { user: req.user });
                
                res.status(200).json({
                    success: true,
                    data: transformedResult
                });
            })
            .catch(error => {
                console.error('API-Fehler beim Abrufen eines Ergebnisses:', error);
                res.status(500).json({
                    success: false,
                    error: 'Fehler beim Abrufen des Ergebnisses',
                    message: error.message
                });
            });
    }
    
    /**
     * API-Handler für das Abrufen von Testergebnissen eines bestimmten Benutzers
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIGetResultsByUser(req, res) {
        const userId = req.params.userId;
        
        if (!userId) {
            res.status(400).json({
                success: false,
                error: 'Fehlende Benutzer-ID'
            });
            return;
        }
        
        // Nur eigene Ergebnisse oder bei entsprechenden Rechten
        if (req.user.id !== userId && !_canUserAccessUserResults(req.user, userId)) {
            res.status(403).json({
                success: false,
                error: 'Keine Berechtigung zum Abrufen dieser Ergebnisse'
            });
            return;
        }
        
        // Ergebnisse aus dem Datenmanager abrufen
        App.Modules.Results.DataManager.getResultsByUser(userId)
            .then(results => {
                // Transformieren der Daten für die API
                const transformedResults = App.API.transformData('results', results, { user: req.user });
                
                res.status(200).json({
                    success: true,
                    data: transformedResults,
                    meta: {
                        total: transformedResults.length,
                        userId: userId
                    }
                });
            })
            .catch(error => {
                console.error('API-Fehler beim Abrufen von Benutzerergebnissen:', error);
                res.status(500).json({
                    success: false,
                    error: 'Fehler beim Abrufen der Benutzerergebnisse',
                    message: error.message
                });
            });
    }
    
    /**
     * Prüft, ob ein Benutzer auf Ergebnisse eines anderen Benutzers zugreifen darf
     * @private
     * @param {Object} user - Aktueller Benutzer
     * @param {string} targetUserId - ID des Zielbenutzers
     * @returns {boolean} - True, wenn Zugriff erlaubt ist
     */
    function _canUserAccessUserResults(user, targetUserId) {
        if (!user) return false;
        
        // Administratoren und Trainer haben Zugriff auf alle Benutzerergebnisse
        if (user.roles && (user.roles.includes('admin') || user.roles.includes('trainer'))) {
            return true;
        }
        
        // Teamleiter haben Zugriff auf Ergebnisse von Benutzern in ihrem Team
        if (user.roles && user.roles.includes('teamleader')) {
            const targetUser = App.Modules.User.Manager.getUserById(targetUserId);
            return targetUser && targetUser.teamId === user.teamId;
        }
        
        return false;
    }
    
    /**
     * API-Handler für das Abrufen von Testergebnissen für einen bestimmten Test
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIGetResultsByTest(req, res) {
        const testId = req.params.testId;
        
        if (!testId) {
            res.status(400).json({
                success: false,
                error: 'Fehlende Test-ID'
            });
            return;
        }
        
        // Nur mit entsprechenden Rechten
        if (!_canUserAccessTestResults(req.user, testId)) {
            res.status(403).json({
                success: false,
                error: 'Keine Berechtigung zum Abrufen dieser Testergebnisse'
            });
            return;
        }
        
        // Ergebnisse aus dem Datenmanager abrufen
        App.Modules.Results.DataManager.getResultsByTest(testId)
            .then(results => {
                // Transformieren der Daten für die API
                const transformedResults = App.API.transformData('results', results, { user: req.user });
                
                res.status(200).json({
                    success: true,
                    data: transformedResults,
                    meta: {
                        total: transformedResults.length,
                        testId: testId
                    }
                });
            })
            .catch(error => {
                console.error('API-Fehler beim Abrufen von Testergebnissen:', error);
                res.status(500).json({
                    success: false,
                    error: 'Fehler beim Abrufen der Testergebnisse',
                    message: error.message
                });
            });
    }
    
    /**
     * Prüft, ob ein Benutzer auf Ergebnisse eines bestimmten Tests zugreifen darf
     * @private
     * @param {Object} user - Aktueller Benutzer
     * @param {string} testId - ID des Tests
     * @returns {boolean} - True, wenn Zugriff erlaubt ist
     */
    function _canUserAccessTestResults(user, testId) {
        if (!user) return false;
        
        // Administratoren und Trainer haben Zugriff auf alle Testergebnisse
        if (user.roles && (user.roles.includes('admin') || user.roles.includes('trainer'))) {
            return true;
        }
        
        // Teamleiter haben Zugriff auf Ergebnisse von Tests in ihrem Bereich
        if (user.roles && user.roles.includes('teamleader')) {
            const test = App.Modules.Test.Manager.getTestById(testId);
            // Prüfen, ob der Test für das Team des Teamleiters relevant ist
            return test && test.targetTeams && test.targetTeams.includes(user.teamId);
        }
        
        return false;
    }
    
    /**
     * API-Handler für den Export von Testergebnissen
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIExportResult(req, res) {
        const resultId = req.params.id;
        const format = req.query.format || 'json';
        
        if (!resultId) {
            res.status(400).json({
                success: false,
                error: 'Fehlende Ergebnis-ID'
            });
            return;
        }
        
        // Prüfen, ob der Benutzer über Exportberechtigungen verfügt
        if (!_canUserExportResults(req.user)) {
            res.status(403).json({
                success: false,
                error: 'Keine Berechtigung zum Exportieren von Ergebnissen'
            });
            return;
        }
        
        // Ergebnis aus dem Datenmanager abrufen
        App.Modules.Results.DataManager.getResultById(resultId)
            .then(result => {
                if (!result) {
                    res.status(404).json({
                        success: false,
                        error: 'Ergebnis nicht gefunden'
                    });
                    return;
                }
                
                // Prüfen, ob der Benutzer auf dieses Ergebnis zugreifen darf
                if (!_canUserAccessResult(req.user, result)) {
                    res.status(403).json({
                        success: false,
                        error: 'Keine Berechtigung zum Exportieren dieses Ergebnisses'
                    });
                    return;
                }
                
                // Export basierend auf Format durchführen
                switch (format.toLowerCase()) {
                    case 'json':
                        _exportResultAsJSON(result, res);
                        break;
                    case 'csv':
                        _exportResultAsCSV(result, res);
                        break;
                    case 'pdf':
                        _exportResultAsPDF(result, res);
                        break;
                    default:
                        res.status(400).json({
                            success: false,
                            error: `Nicht unterstütztes Format: ${format}`
                        });
                }
            })
            .catch(error => {
                console.error('API-Fehler beim Exportieren eines Ergebnisses:', error);
                res.status(500).json({
                    success: false,
                    error: 'Fehler beim Exportieren des Ergebnisses',
                    message: error.message
                });
            });
    }
    
    /**
     * Prüft, ob ein Benutzer Ergebnisse exportieren darf
     * @private
     * @param {Object} user - Benutzerinformationen
     * @returns {boolean} - True, wenn Export erlaubt ist
     */
    function _canUserExportResults(user) {
        if (!user) return false;
        
        // Prüfen, ob der Benutzer die Export-Berechtigung hat
        return App.Modules.User.Manager.hasPermission('results.export', user.id);
    }
    
    /**
     * Exportiert ein Ergebnis als JSON
     * @private
     * @param {Object} result - Ergebnisdaten
     * @param {Object} res - API-Antwortobjekt
     * @returns {void}
     */
    function _exportResultAsJSON(result, res) {
        // Transformieren für Export
        const exportData = {
            id: result.id,
            testId: result.testId,
            testName: result.testName,
            userId: result.userId,
            userName: result.userName,
            date: result.date,
            score: result.score,
            duration: result.duration,
            categoryScores: result.categoryScores || {},
            status: result.status || 'completed',
            exportedAt: new Date().toISOString()
        };
        
        // Content-Disposition-Header für Download setzen
        res.setHeader('Content-Disposition', `attachment; filename=Ergebnis_${result.id}.json`);
        res.setHeader('Content-Type', 'application/json');
        
        // JSON-Daten zurückgeben
        res.json(exportData);
    }
    
    /**
     * Exportiert ein Ergebnis als CSV
     * @private
     * @param {Object} result - Ergebnisdaten
     * @param {Object} res - API-Antwortobjekt
     * @returns {void}
     */
    function _exportResultAsCSV(result, res) {
        // CSV-Header
        let csvContent = 'Kategorie,Punktzahl\n';
        
        // Daten hinzufügen
        if (result.categoryScores) {
            Object.entries(result.categoryScores).forEach(([category, score]) => {
                csvContent += `"${category}",${score}\n`;
            });
        }
        
        // Content-Disposition-Header für Download setzen
        res.setHeader('Content-Disposition', `attachment; filename=Ergebnis_${result.id}.csv`);
        res.setHeader('Content-Type', 'text/csv');
        
        // CSV-Daten zurückgeben
        res.send(csvContent);
    }
    
    /**
     * Exportiert ein Ergebnis als PDF
     * @private
     * @param {Object} result - Ergebnisdaten
     * @param {Object} res - API-Antwortobjekt
     * @returns {void}
     */
    function _exportResultAsPDF(result, res) {
        // In einer realen Implementierung würde hier ein PDF generiert
        // Da dies im Client-seitigen JavaScript nur begrenzt möglich ist,
        // wird hier ein Fehler zurückgegeben
        res.status(501).json({
            success: false,
            error: 'PDF-Export über API noch nicht implementiert',
            message: 'Bitte verwenden Sie die Web-Oberfläche für PDF-Exporte'
        });
    }
    
    /**
     * API-Handler für das Abrufen verfügbarer Visualisierungen
     * @private
     * @param {Object} req - Anfrageobjekt
     * @param {Object} res - Antwortobjekt
     * @returns {void}
     */
    function _handleAPIGetVisualizations(req, res) {
        // Verfügbare Visualisierungstypen sammeln
        const visualizationModules = [
            'base', 'advanced', 'explorer', 'dashboard'
        ];
        
        const visualizations = [];
        
        // Für jedes Modul die verfügbaren Visualisierungen ermitteln
        visualizationModules.forEach(moduleName => {
            if (App.Modules.Results.Visualization[moduleName]) {
                const moduleVisualizations = App.Modules.Results.Visualization[moduleName].getVisualizationTypes
                    ? App.Modules.Results.Visualization[moduleName].getVisualizationTypes()
                    : [];
                
                visualizations.push(...moduleVisualizations);
            }
        });
        
        // Ergebnisse zurückgeben
        res.status(200).json({
            success: true,
            data: visualizations
        });
    }
    
    /**
     * Richtet die Event-Behandlung für das Integrationsmodul ein
     * @private
     * @returns {Promise<void>} - Promise, der nach erfolgreicher Einrichtung aufgelöst wird
     */
    function _setupEventHandling() {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob das Event-System existiert
                if (!App.Events) {
                    console.warn('Event-System nicht verfügbar, Event-Integration wird übersprungen');
                    resolve();
                    return;
                }
                
                // Ereignisse registrieren
                const events = [
                    'results.data.update',
                    'results.visualization.update',
                    'results.new',
                    'results.updated',
                    'results.deleted'
                ];
                
                App.Events.registerEvents(events);
                
                // Ereignisbehandlung einrichten
                App.Events.subscribe('results.data.update', _handleResultDataUpdate);
                App.Events.subscribe('results.visualization.update', _handleVisualizationUpdate);
                App.Events.subscribe('results.new', _handleNewResult);
                App.Events.subscribe('results.updated', _handleUpdatedResult);
                App.Events.subscribe('results.deleted', _handleDeletedResult);
                
                // Event-Zustellung an andere Module einrichten
                _setupEventDistribution();
                
                resolve();
                
            } catch (error) {
                console.error('Fehler bei der Event-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Richtet die Event-Verteilung an andere Module ein
     * @private
     * @returns {void}
     */
    function _setupEventDistribution() {
        // Event-Weiterleitung an Dashboard-Modul
        if (App.Modules.Dashboard) {
            App.Events.subscribe('results.new', (event) => {
                App.Modules.Dashboard.handleResultUpdate(event);
            });
            
            App.Events.subscribe('results.updated', (event) => {
                App.Modules.Dashboard.handleResultUpdate(event);
            });
        }
        
        // Event-Weiterleitung an Notification-Modul
        if (App.Modules.Notification) {
            App.Events.subscribe('results.new', (event) => {
                // Benachrichtigung für Trainer und Teamleiter
                const userManager = App.Modules.User.Manager;
                const result = App.Modules.Results.DataManager.getResultById(event.resultId);
                
                if (result) {
                    // Trainer benachrichtigen
                    userManager.getUsersByRole('trainer').forEach(trainer => {
                        App.Modules.Notification.sendNotification(trainer.id, {
                            type: 'result_new',
                            title: 'Neues Testergebnis',
                            message: `${result.userName} hat den Test "${result.testName}" abgeschlossen.`,
                            data: {
                                resultId: result.id,
                                testId: result.testId,
                                userId: result.userId
                            }
                        });
                    });
                    
                    // Teamleiter benachrichtigen (falls Benutzer im Team)
                    const user = userManager.getUserById(result.userId);
                    if (user && user.teamId) {
                        const teamLeaders = userManager.getUsersByTeamAndRole(user.teamId, 'teamleader');
                        teamLeaders.forEach(leader => {
                            App.Modules.Notification.sendNotification(leader.id, {
                                type: 'result_new',
                                title: 'Neues Testergebnis im Team',
                                message: `${result.userName} aus Ihrem Team hat den Test "${result.testName}" abgeschlossen.`,
                                data: {
                                    resultId: result.id,
                                    testId: result.testId,
                                    userId: result.userId,
                                    teamId: user.teamId
                                }
                            });
                        });
                    }
                }
            });
        }
    }
    
    /**
     * Handler für Aktualisierungen der Ergebnisdaten
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleResultDataUpdate(event) {
        console.log('Ergebnisdaten aktualisiert:', event);
        
        // Visualisierungen aktualisieren
        _refreshAllVisualizations();
    }
    
    /**
     * Handler für Aktualisierungen der Visualisierungen
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleVisualizationUpdate(event) {
        console.log('Visualisierungsaktualisierung:', event);
        
        // Spezifische Visualisierung aktualisieren, falls ID angegeben
        if (event.visualizationId) {
            _refreshVisualization(event.visualizationId);
        } else {
            // Sonst alle aktualisieren
            _refreshAllVisualizations();
        }
    }
    
    /**
     * Handler für neue Testergebnisse
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleNewResult(event) {
        console.log('Neues Testergebnis:', event);
        
        // Daten aktualisieren
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.refreshResultData(event.testId, event.userId)
                .then(() => {
                    // Visualisierungen aktualisieren
                    _refreshVisualizationsForTest(event.testId);
                })
                .catch(error => {
                    console.error('Fehler beim Aktualisieren des neuen Testergebnisses:', error);
                });
        }
    }
    
    /**
     * Handler für aktualisierte Testergebnisse
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleUpdatedResult(event) {
        console.log('Testergebnis aktualisiert:', event);
        
        // Daten aktualisieren
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.refreshResultData(event.testId, event.userId)
                .then(() => {
                    // Visualisierungen aktualisieren
                    _refreshVisualizationsForTest(event.testId);
                })
                .catch(error => {
                    console.error('Fehler beim Aktualisieren des geänderten Testergebnisses:', error);
                });
        }
    }
    
    /**
     * Handler für gelöschte Testergebnisse
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleDeletedResult(event) {
        console.log('Testergebnis gelöscht:', event);
        
        // Daten aktualisieren
        if (App.Modules.Results.DataManager) {
            App.Modules.Results.DataManager.removeResult(event.resultId)
                .then(() => {
                    // Visualisierungen aktualisieren
                    _refreshVisualizationsForTest(event.testId);
                })
                .catch(error => {
                    console.error('Fehler beim Aktualisieren nach Löschung eines Testergebnisses:', error);
                });
        }
    }
    
    /**
     * Richtet eine periodische Aktualisierung ein
     * @private
     * @param {number} interval - Aktualisierungsintervall in Millisekunden
     * @returns {void}
     */
    function _setupAutoRefresh(interval) {
        // Bestehenden Timer löschen
        if (_eventHandlers.refreshTimer) {
            clearInterval(_eventHandlers.refreshTimer);
        }
        
        // Neuen Timer einrichten
        _eventHandlers.refreshTimer = setInterval(() => {
            // Daten aktualisieren
            if (App.Modules.Results.DataManager) {
                App.Modules.Results.DataManager.refreshAllData()
                    .then(() => {
                        // Alle Visualisierungen aktualisieren
                        _refreshAllVisualizations();
                    })
                    .catch(error => {
                        console.error('Fehler bei der automatischen Aktualisierung:', error);
                    });
            }
        }, interval);
    }
    
    /**
     * Aktualisiert alle Visualisierungen
     * @private
     * @returns {void}
     */
    function _refreshAllVisualizations() {
        // Alle registrierten Visualisierungen aktualisieren
        if (App.Modules.Results.Visualization.Manager) {
            App.Modules.Results.Visualization.Manager.refreshAll();
        }
        
        // Einzelne Visualisierungsmodule direkt aktualisieren
        if (App.Modules.Results.Visualization.Explorer) {
            App.Modules.Results.Visualization.Explorer.refreshData && App.Modules.Results.Visualization.Explorer.refreshData();
        }
        
        if (App.Modules.Results.Visualization.Dashboard) {
            App.Modules.Results.Visualization.Dashboard.update && App.Modules.Results.Visualization.Dashboard.update();
        }
    }
    
    /**
     * Aktualisiert eine bestimmte Visualisierung
     * @private
     * @param {string} visualizationId - ID der zu aktualisierenden Visualisierung
     * @returns {void}
     */
    function _refreshVisualization(visualizationId) {
        if (App.Modules.Results.Visualization.Manager) {
            App.Modules.Results.Visualization.Manager.refresh(visualizationId);
        }
    }
    
    /**
     * Aktualisiert alle Visualisierungen für einen bestimmten Test
     * @private
     * @param {string} testId - ID des Tests
     * @returns {void}
     */
    function _refreshVisualizationsForTest(testId) {
        if (App.Modules.Results.Visualization.Manager) {
            App.Modules.Results.Visualization.Manager.refreshForTest(testId);
        } else {
            // Fallback: Alle aktualisieren
            _refreshAllVisualizations();
        }
    }
    
    /**
     * Verarbeitet ausstehende Operationen nach der Initialisierung
     * @private
     * @returns {void}
     */
    function _processPendingOperations() {
        if (_pendingOperations.length === 0) {
            return;
        }
        
        console.log(`Verarbeite ${_pendingOperations.length} ausstehende Operationen`);
        
        // Jede ausstehende Operation verarbeiten
        _pendingOperations.forEach(operation => {
            try {
                if (operation.type === 'refresh') {
                    _refreshAllVisualizations();
                } else if (operation.type === 'refreshTest') {
                    _refreshVisualizationsForTest(operation.testId);
                } else if (operation.type === 'refreshVisualization') {
                    _refreshVisualization(operation.visualizationId);
                }
            } catch (error) {
                console.error('Fehler beim Verarbeiten einer ausstehenden Operation:', error);
            }
        });
        
        // Ausstehende Operationen löschen
        _pendingOperations = [];
    }
    
    /**
     * Fügt eine Operation zur ausstehenden Liste hinzu, falls das Modul noch nicht initialisiert ist
     * @private
     * @param {Object} operation - Auszuführende Operation
     * @returns {boolean} - True, wenn Operation in die Warteschlange gestellt wurde
     */
    function _addPendingOperation(operation) {
        if (_initialized) {
            return false;
        }
        
        _pendingOperations.push(operation);
        return true;
    }
    
    // Öffentliche API
    return {
        initialize,
        
        // Aktualisierungsfunktionen
        refreshAllVisualizations: function() {
            if (!_initialized) {
                return _addPendingOperation({ type: 'refresh' });
            }
            _refreshAllVisualizations();
            return true;
        },
        
        refreshVisualizationsForTest: function(testId) {
            if (!_initialized) {
                return _addPendingOperation({ type: 'refreshTest', testId });
            }
            _refreshVisualizationsForTest(testId);
            return true;
        },
        
        refreshVisualization: function(visualizationId) {
            if (!_initialized) {
                return _addPendingOperation({ type: 'refreshVisualization', visualizationId });
            }
            _refreshVisualization(visualizationId);
            return true;
        },
        
        // Modul-Status
        isInitialized: function() {
            return _initialized;
        },
        
        getActiveIntegrations: function() {
            return { ..._activeIntegrations };
        }
    };
})();
/**
 * @fileOverview Ergebnisvisualisierung Teil 2.5-2 - Erweiterte Integration mit Dashboard, Berichtswesen und Event-System
 * @module js/modules/results/visualization/integration-extended
 * @requires js/modules/results/data-manager
 * @requires js/modules/results/visualization/base
 * @requires js/modules/dashboard/dashboard-manager
 * @requires js/modules/reports/report-manager
 * @version 1.0.0
 */

// Namespace für die Ergebnisvisualisierung
if (!window.ImmoScout24 || !window.ImmoScout24.TestApp) {
    throw new Error('Die Hauptanwendung wurde nicht initialisiert');
}

// Zugriff auf Namespace sicherstellen
const App = window.ImmoScout24.TestApp;

// Modul für erweiterte Integration erstellen (erweitert das bestehende Integrationsmodul)
(function() {
    // Zugriff auf Basismodul sicherstellen
    if (!App.Modules.Results || !App.Modules.Results.Integration) {
        console.error('Basis-Integrationsmodul nicht gefunden, erweiterte Integration kann nicht initialisiert werden');
        return;
    }
    
    // Zugriff auf privaten Bereich des Modules via Closures
    const BaseIntegration = App.Modules.Results.Integration;
    
    // Private Variablen für das erweiterte Modul
    let _dashboardIntegration = {
        initialized: false,
        widgets: {},
        dashboards: {}
    };
    
    let _reportIntegration = {
        initialized: false,
        templates: {},
        scheduledReports: []
    };
    
    let _eventHandlers = {};
    
    /**
     * Initialisiert die erweiterte Dashboard-Integration
     * @param {Object} options - Konfigurationsoptionen
     * @returns {Promise<boolean>} - Promise, der nach erfolgreicher Initialisierung aufgelöst wird
     */
    function initializeDashboardIntegration(options = {}) {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob Dashboard-Modul existiert
                if (!App.Modules.Dashboard || !App.Modules.Dashboard.Manager) {
                    console.warn('Dashboard-Modul nicht verfügbar, Integration wird übersprungen');
                    resolve(false);
                    return;
                }
                
                console.log('Initialisiere erweiterte Dashboard-Integration');
                
                const DashboardManager = App.Modules.Dashboard.Manager;
                
                // Standard-Widgets für Ergebnisvisualisierung registrieren
                _registerResultWidgets(options);
                
                // Rollen-spezifische Dashboards einrichten
                _setupRoleSpecificDashboards(options);
                
                // Event-Listener für Dashboard-Ereignisse
                DashboardManager.addEventListener('dashboard.widget.added', _handleWidgetAdded);
                DashboardManager.addEventListener('dashboard.widget.removed', _handleWidgetRemoved);
                DashboardManager.addEventListener('dashboard.widget.updated', _handleWidgetUpdated);
                DashboardManager.addEventListener('dashboard.layout.changed', _handleDashboardLayoutChanged);
                
                // Vorhandene Dashboards abrufen und konfigurieren
                DashboardManager.getActiveDashboards()
                    .then(dashboards => {
                        // Für jedes Dashboard prüfen, ob es Ergebnis-Widgets enthält
                        dashboards.forEach(dashboard => {
                            const resultWidgets = dashboard.widgets.filter(widget => 
                                widget.type.startsWith('result') || widget.type.startsWith('test')
                            );
                            
                            if (resultWidgets.length > 0) {
                                // Daten-Callbacks für jedes Widget einrichten
                                _setupWidgetDataCallbacks(dashboard.id, resultWidgets);
                            }
                        });
                        
                        _dashboardIntegration.initialized = true;
                        console.log('Dashboard-Integration erfolgreich abgeschlossen');
                        resolve(true);
                    })
                    .catch(error => {
                        console.error('Fehler beim Abrufen aktiver Dashboards:', error);
                        // Integration trotz Fehler fortsetzen
                        _dashboardIntegration.initialized = true;
                        resolve(true);
                    });
                
            } catch (error) {
                console.error('Fehler bei der Dashboard-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Registriert Standard-Widgets für die Ergebnisvisualisierung
     * @private
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function _registerResultWidgets(options) {
        const DashboardManager = App.Modules.Dashboard.Manager;
        
        // Liste der zu registrierenden Widgets
        const widgets = [
            {
                type: 'result-score-overview',
                name: 'Ergebnis-Übersicht',
                description: 'Zeigt eine Übersicht der Testergebnisse',
                icon: 'is24-icon-chart-bar',
                allowedRoles: ['user', 'trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideScoreOverviewData,
                config: {
                    defaultSize: { width: 6, height: 4 },
                    minSize: { width: 3, height: 2 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'period', type: 'select', label: 'Zeitraum', 
                          options: [
                              { value: 'week', label: 'Letzte Woche' },
                              { value: 'month', label: 'Letzter Monat' },
                              { value: 'quarter', label: 'Letztes Quartal' },
                              { value: 'year', label: 'Letztes Jahr' },
                              { value: 'all', label: 'Alle' }
                          ],
                          default: 'month'
                        },
                        { name: 'chartType', type: 'select', label: 'Diagrammtyp',
                          options: [
                              { value: 'bar', label: 'Balkendiagramm' },
                              { value: 'line', label: 'Liniendiagramm' },
                              { value: 'radar', label: 'Netzdiagramm' },
                              { value: 'pie', label: 'Kreisdiagramm' }
                          ],
                          default: 'bar'
                        },
                        { name: 'showLabels', type: 'checkbox', label: 'Beschriftungen anzeigen', default: true },
                        { name: 'showLegend', type: 'checkbox', label: 'Legende anzeigen', default: true }
                    ]
                }
            },
            {
                type: 'result-latest',
                name: 'Neueste Ergebnisse',
                description: 'Zeigt die neuesten Testergebnisse',
                icon: 'is24-icon-list',
                allowedRoles: ['trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideLatestResultsData,
                config: {
                    defaultSize: { width: 6, height: 3 },
                    minSize: { width: 3, height: 2 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'limit', type: 'number', label: 'Anzahl', min: 1, max: 20, default: 5 },
                        { name: 'showScore', type: 'checkbox', label: 'Punktzahl anzeigen', default: true },
                        { name: 'showDate', type: 'checkbox', label: 'Datum anzeigen', default: true },
                        { name: 'showUser', type: 'checkbox', label: 'Benutzer anzeigen', default: true }
                    ]
                }
            },
            {
                type: 'result-category-analysis',
                name: 'Kategorieanalyse',
                description: 'Analysiert Ergebnisse nach Kategorien',
                icon: 'is24-icon-chart-pie',
                allowedRoles: ['user', 'trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideCategoryAnalysisData,
                config: {
                    defaultSize: { width: 8, height: 5 },
                    minSize: { width: 4, height: 3 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'categoryLimit', type: 'number', label: 'Max. Kategorien', min: 3, max: 15, default: 8 },
                        { name: 'sortBy', type: 'select', label: 'Sortierung',
                          options: [
                              { value: 'score', label: 'Nach Punktzahl' },
                              { value: 'alphabetical', label: 'Alphabetisch' },
                              { value: 'importance', label: 'Nach Wichtigkeit' }
                          ],
                          default: 'score'
                        },
                        { name: 'showAverage', type: 'checkbox', label: 'Durchschnitt anzeigen', default: true },
                        { name: 'showTarget', type: 'checkbox', label: 'Zielwerte anzeigen', default: false }
                    ]
                }
            },
            {
                type: 'result-improvement',
                name: 'Verbesserungspotenzial',
                description: 'Zeigt Bereiche mit Verbesserungspotenzial',
                icon: 'is24-icon-trending-up',
                allowedRoles: ['user', 'trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideImprovementData,
                config: {
                    defaultSize: { width: 6, height: 4 },
                    minSize: { width: 3, height: 3 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'limit', type: 'number', label: 'Anzahl', min: 1, max: 10, default: 5 },
                        { name: 'threshold', type: 'number', label: 'Schwellenwert (%)', min: 0, max: 100, default: 70 },
                        { name: 'includeRecommendations', type: 'checkbox', label: 'Empfehlungen anzeigen', default: true },
                        { name: 'showProgress', type: 'checkbox', label: 'Fortschritt anzeigen', default: true }
                    ]
                }
            },
            {
                type: 'result-team-comparison',
                name: 'Team-Vergleich',
                description: 'Vergleicht Ergebnisse zwischen Teams',
                icon: 'is24-icon-users',
                allowedRoles: ['trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideTeamComparisonData,
                config: {
                    defaultSize: { width: 8, height: 6 },
                    minSize: { width: 4, height: 4 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'period', type: 'select', label: 'Zeitraum', 
                          options: [
                              { value: 'month', label: 'Letzter Monat' },
                              { value: 'quarter', label: 'Letztes Quartal' },
                              { value: 'year', label: 'Letztes Jahr' },
                              { value: 'all', label: 'Alle' }
                          ],
                          default: 'quarter'
                        },
                        { name: 'chartType', type: 'select', label: 'Diagrammtyp',
                          options: [
                              { value: 'bar', label: 'Balkendiagramm' },
                              { value: 'radar', label: 'Netzdiagramm' },
                              { value: 'heatmap', label: 'Heatmap' }
                          ],
                          default: 'bar'
                        },
                        { name: 'includeCategories', type: 'checkbox', label: 'Nach Kategorien aufschlüsseln', default: false },
                        { name: 'normalizeData', type: 'checkbox', label: 'Daten normalisieren', default: true }
                    ]
                }
            },
            {
                type: 'result-trend-analysis',
                name: 'Trend-Analyse',
                description: 'Analysiert Trends und Entwicklungen bei Testergebnissen',
                icon: 'is24-icon-trending-up',
                allowedRoles: ['trainer', 'admin', 'teamleader'],
                category: 'Ergebnisse',
                dataProvider: _provideTrendAnalysisData,
                config: {
                    defaultSize: { width: 8, height: 5 },
                    minSize: { width: 4, height: 3 },
                    maxSize: { width: 12, height: 8 },
                    settings: [
                        { name: 'period', type: 'select', label: 'Zeitraum', 
                          options: [
                              { value: 'quarter', label: 'Letztes Quartal' },
                              { value: 'halfyear', label: 'Letztes Halbjahr' },
                              { value: 'year', label: 'Letztes Jahr' },
                              { value: 'all', label: 'Alle' }
                          ],
                          default: 'quarter'
                        },
                        { name: 'interval', type: 'select', label: 'Interval',
                          options: [
                              { value: 'day', label: 'Täglich' },
                              { value: 'week', label: 'Wöchentlich' },
                              { value: 'month', label: 'Monatlich' }
                          ],
                          default: 'week'
                        },
                        { name: 'showTrendline', type: 'checkbox', label: 'Trendlinie anzeigen', default: true },
                        { name: 'showPrediction', type: 'checkbox', label: 'Prognose anzeigen', default: false }
                    ]
                }
            }
        ];
        
        // Widgets registrieren
        widgets.forEach(widget => {
            DashboardManager.registerWidgetType(widget);
            _dashboardIntegration.widgets[widget.type] = widget;
        });
        
        console.log(`${widgets.length} Ergebnis-Widgets registriert`);
    }
    
    /**
     * Richtet rollenspezifische Dashboards ein
     * @private
     * @param {Object} options - Konfigurationsoptionen
     * @returns {void}
     */
    function _setupRoleSpecificDashboards(options) {
        const DashboardManager = App.Modules.Dashboard.Manager;
        
        // Dashboard-Vorlage für normale Benutzer
        const userDashboard = {
            name: 'Meine Testergebnisse',
            description: 'Übersicht Ihrer persönlichen Testergebnisse',
            role: 'user',
            isDefault: true,
            layout: {
                type: 'grid',
                rows: 12,
                columns: 12
            },
            widgets: [
                {
                    type: 'result-score-overview',
                    title: 'Meine Ergebnisse',
                    position: { x: 0, y: 0, width: 6, height: 4 },
                    settings: {
                        period: 'quarter',
                        chartType: 'line',
                        showLabels: true,
                        showLegend: true
                    }
                },
                {
                    type: 'result-category-analysis',
                    title: 'Meine Kategorien',
                    position: { x: 6, y: 0, width: 6, height: 4 },
                    settings: {
                        categoryLimit: 8,
                        sortBy: 'score',
                        showAverage: true,
                        showTarget: true
                    }
                },
                {
                    type: 'result-improvement',
                    title: 'Verbesserungspotenzial',
                    position: { x: 0, y: 4, width: 6, height: 4 },
                    settings: {
                        limit: 5,
                        threshold: 70,
                        includeRecommendations: true,
                        showProgress: true
                    }
                }
            ]
        };
        
        // Dashboard-Vorlage für Trainer
        const trainerDashboard = {
            name: 'Trainer-Dashboard',
            description: 'Übersicht und Analyse aller Testergebnisse',
            role: 'trainer',
            isDefault: true,
            layout: {
                type: 'grid',
                rows: 12,
                columns: 12
            },
            widgets: [
                {
                    type: 'result-latest',
                    title: 'Neueste Ergebnisse',
                    position: { x: 0, y: 0, width: 6, height: 3 },
                    settings: {
                        limit: 8,
                        showScore: true,
                        showDate: true,
                        showUser: true
                    }
                },
                {
                    type: 'result-team-comparison',
                    title: 'Team-Vergleich',
                    position: { x: 6, y: 0, width: 6, height: 6 },
                    settings: {
                        period: 'quarter',
                        chartType: 'bar',
                        includeCategories: true,
                        normalizeData: true
                    }
                },
                {
                    type: 'result-trend-analysis',
                    title: 'Trend-Analyse',
                    position: { x: 0, y: 3, width: 6, height: 5 },
                    settings: {
                        period: 'halfyear',
                        interval: 'week',
                        showTrendline: true,
                        showPrediction: true
                    }
                }
            ]
        };
        
        // Dashboard-Vorlage für Teamleiter
        const teamleaderDashboard = {
            name: 'Team-Leistung',
            description: 'Übersicht der Leistung Ihres Teams',
            role: 'teamleader',
            isDefault: true,
            layout: {
                type: 'grid',
                rows: 12,
                columns: 12
            },
            widgets: [
                {
                    type: 'result-latest',
                    title: 'Neueste Team-Ergebnisse',
                    position: { x: 0, y: 0, width: 6, height: 3 },
                    settings: {
                        limit: 5,
                        showScore: true,
                        showDate: true,
                        showUser: true
                    }
                },
                {
                    type: 'result-category-analysis',
                    title: 'Team-Kategorien',
                    position: { x: 6, y: 0, width: 6, height: 4 },
                    settings: {
                        categoryLimit: 8,
                        sortBy: 'score',
                        showAverage: true,
                        showTarget: true
                    }
                },
                {
                    type: 'result-trend-analysis',
                    title: 'Team-Entwicklung',
                    position: { x: 0, y: 3, width: 6, height: 5 },
                    settings: {
                        period: 'quarter',
                        interval: 'week',
                        showTrendline: true,
                        showPrediction: false
                    }
                }
            ]
        };
        
        // Dashboards registrieren
        DashboardManager.registerDashboardTemplate('user-results', userDashboard);
        DashboardManager.registerDashboardTemplate('trainer-results', trainerDashboard);
        DashboardManager.registerDashboardTemplate('teamleader-results', teamleaderDashboard);
        
        // Dashboards für spätere Referenz speichern
        _dashboardIntegration.dashboards['user'] = userDashboard;
        _dashboardIntegration.dashboards['trainer'] = trainerDashboard;
        _dashboardIntegration.dashboards['teamleader'] = teamleaderDashboard;
        
        console.log('Rollenspezifische Dashboards registriert');
    }
    
    /**
     * Richtet Daten-Callbacks für Widgets ein
     * @private
     * @param {string} dashboardId - ID des Dashboards
     * @param {Array<Object>} widgets - Liste der Widgets
     * @returns {void}
     */
    function _setupWidgetDataCallbacks(dashboardId, widgets) {
        widgets.forEach(widget => {
            if (_dashboardIntegration.widgets[widget.type]) {
                const dataProvider = _dashboardIntegration.widgets[widget.type].dataProvider;
                
                if (typeof dataProvider === 'function') {
                    // Daten-Callback bei Dashboard-Manager registrieren
                    App.Modules.Dashboard.Manager.registerWidgetDataCallback(
                        dashboardId,
                        widget.id,
                        (dashboard, widgetInstance) => dataProvider(dashboard, widgetInstance)
                    );
                }
            }
        });
    }
    
    /**
     * Handler für hinzugefügtes Widget
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleWidgetAdded(event) {
        if (!event.widget || !event.dashboardId) return;
        
        // Prüfen, ob es sich um ein Ergebnis-Widget handelt
        if (event.widget.type.startsWith('result') || event.widget.type.startsWith('test')) {
            // Daten-Callback einrichten
            _setupWidgetDataCallbacks(event.dashboardId, [event.widget]);
            
            // Initialen Daten-Refresh auslösen
            App.Modules.Dashboard.Manager.refreshWidget(event.dashboardId, event.widget.id);
        }
    }
    
    /**
     * Handler für entferntes Widget
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleWidgetRemoved(event) {
        // Keine spezielle Behandlung erforderlich, Dashboard-Manager bereinigt Callbacks automatisch
        console.log('Widget entfernt:', event.widgetId);
    }
    
    /**
     * Handler für aktualisiertes Widget
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleWidgetUpdated(event) {
        if (!event.widget || !event.dashboardId) return;
        
        // Wenn es sich um ein Ergebnis-Widget handelt, Daten aktualisieren
        if (event.widget.type.startsWith('result') || event.widget.type.startsWith('test')) {
            // Daten aktualisieren
            App.Modules.Dashboard.Manager.refreshWidget(event.dashboardId, event.widget.id);
        }
    }
    
    /**
     * Handler für geänderte Dashboard-Layouts
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleDashboardLayoutChanged(event) {
        // Keine spezielle Behandlung erforderlich
        console.log('Dashboard-Layout geändert:', event.dashboardId);
    }
    
    // Daten-Provider-Funktionen für Widgets
    
    /**
     * Daten-Provider für Ergebnis-Übersicht-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideScoreOverviewData(dashboard, widget) {
        return new Promise((resolve, reject) => {
            const settings = widget.settings || {};
            const userId = App.Modules.User.Manager.getCurrentUser().id;
            const period = settings.period || 'month';
            
            // Zeitraum bestimmen
            const endDate = new Date();
            let startDate;
            
            switch (period) {
                case 'week':
                    startDate = new Date();
                    startDate.setDate(startDate.getDate() - 7);
                    break;
                case 'month':
                    startDate = new Date();
                    startDate.setMonth(startDate.getMonth() - 1);
                    break;
                case 'quarter':
                    startDate = new Date();
                    startDate.setMonth(startDate.getMonth() - 3);
                    break;
                case 'year':
                    startDate = new Date();
                    startDate.setFullYear(startDate.getFullYear() - 1);
                    break;
                case 'all':
                    startDate = null;
                    break;
                default:
                    startDate = new Date();
                    startDate.setMonth(startDate.getMonth() - 1);
            }
            
            // Optionen für Datenabfrage
            const options = {
                userId: userId,
                startDate: startDate,
                endDate: endDate,
                sort: 'date',
                order: 'asc'
            };
            
            // Ergebnisse basierend auf Benutzerrolle abrufen
            const userRoles = App.Modules.User.Manager.getUserRoles(userId);
            
            // Für normale Benutzer nur eigene Ergebnisse
            if (!userRoles.includes('admin') && !userRoles.includes('trainer') && !userRoles.includes('teamleader')) {
                options.userId = userId;
            } 
            // Für Teamleiter nur Ergebnisse des Teams
            else if (userRoles.includes('teamleader') && !userRoles.includes('admin') && !userRoles.includes('trainer')) {
                const user = App.Modules.User.Manager.getUserById(userId);
                if (user && user.teamId) {
                    options.teamId = user.teamId;
                    delete options.userId;
                }
            }
            // Für Administratoren und Trainer alle Ergebnisse (userId entfernen)
            else if (userRoles.includes('admin') || userRoles.includes('trainer')) {
                delete options.userId;
            }
            
            // Daten abrufen
            App.Modules.Results.DataManager.getResults(options)
                .then(results => {
                    // Gruppierung nach Datum
                    const groupedData = _groupResultsByDate(results, period);
                    
                    // Daten transformieren basierend auf Charttyp
                    const chartData = _transformDataForChart(groupedData, settings.chartType || 'bar');
                    
                    // Zusätzliche Metadaten hinzufügen
                    const data = {
                        chartData: chartData,
                        summary: {
                            count: results.length,
                            averageScore: _calculateAverageScore(results),
                            highestScore: _findHighestScore(results),
                            lowestScore: _findLowestScore(results),
                            trend: _calculateTrend(results)
                        },
                        settings: settings
                    };
                    
                    resolve(data);
                })
                .catch(error => {
                    console.error('Fehler beim Abrufen der Übersichtsdaten:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Gruppiert Ergebnisse nach Datum
     * @private
     * @param {Array<Object>} results - Ergebnisse
     * @param {string} period - Zeitraum ('week', 'month', 'quarter', 'year', 'all')
     * @returns {Object} - Nach Datum gruppierte Daten
     */
    function _groupResultsByDate(results, period) {
        const groupedData = {};
        
        results.forEach(result => {
            const date = new Date(result.date);
            let key = '';
            
            // Gruppierungsschlüssel basierend auf Zeitraum erstellen
            switch (period) {
                case 'week':
                    // Gruppiere nach Tag
                    key = date.toISOString().split('T')[0];
                    break;
                case 'month':
                    // Gruppiere nach Tag
                    key = date.toISOString().split('T')[0];
                    break;
                case 'quarter':
                    // Gruppiere nach Woche
                    const weekNum = _getWeekNumber(date);
                    key = `${date.getFullYear()}-W${weekNum}`;
                    break;
                case 'year':
                    // Gruppiere nach Monat
                    key = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    break;
                case 'all':
                    // Gruppiere nach Monat
                    key = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    break;
                default:
                    key = date.toISOString().split('T')[0];
            }
            
            // Gruppe erstellen, falls nicht vorhanden
            if (!groupedData[key]) {
                groupedData[key] = {
                    date: key,
                    results: [],
                    averageScore: 0,
                    count: 0
                };
            }
            
            // Ergebnis zur Gruppe hinzufügen
            groupedData[key].results.push(result);
            groupedData[key].count++;
        });
        
        // Durchschnittliche Punktzahl für jede Gruppe berechnen
        Object.values(groupedData).forEach(group => {
            group.averageScore = _calculateAverageScore(group.results);
        });
        
        return groupedData;
    }
    
    /**
     * Berechnet die Kalenderwoche eines Datums
     * @private
     * @param {Date} date - Datum
     * @returns {number} - Kalenderwoche
     */
    function _getWeekNumber(date) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }
    
    /**
     * Transformiert Daten für verschiedene Diagrammtypen
     * @private
     * @param {Object} groupedData - Nach Datum gruppierte Daten
     * @param {string} chartType - Diagrammtyp ('bar', 'line', 'radar', 'pie')
     * @returns {Object} - Für das Diagramm formatierte Daten
     */
    function _transformDataForChart(groupedData, chartType) {
        const sortedKeys = Object.keys(groupedData).sort();
        const labels = sortedKeys.map(key => {
            // Benutzfreundliche Datumsformatierung
            if (key.includes('-W')) {
                // Wochenformat
                const [year, week] = key.split('-W');
                return `KW ${week}/${year}`;
            } else if (key.length === 7) {
                // Monatsformat (YYYY-MM)
                const [year, month] = key.split('-');
                const monthNames = [
                    'Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
                ];
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            } else {
                // Tagesdatum (YYYY-MM-DD)
                const date = new Date(key);
                return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' });
            }
        });
        
        const data = sortedKeys.map(key => groupedData[key].averageScore);
        
        // Basierend auf Diagrammtyp formatieren
        switch (chartType) {
            case 'bar':
                return {
                    type: 'bar',
                    labels: labels,
                    datasets: [{
                        label: 'Durchschnittspunktzahl',
                        data: data,
                        backgroundColor: 'rgba(0, 255, 208, 0.6)',
                        borderColor: 'rgba(0, 255, 208, 1)',
                        borderWidth: 1
                    }]
                };
            case 'line':
                return {
                    type: 'line',
                    labels: labels,
                    datasets: [{
                        label: 'Durchschnittspunktzahl',
                        data: data,
                        fill: false,
                        borderColor: 'rgba(0, 255, 208, 1)',
                        tension: 0.1,
                        pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                        pointBorderColor: '#fff',
                        pointRadius: 4
                    }]
                };
            case 'radar':
                return {
                    type: 'radar',
                    labels: labels,
                    datasets: [{
                        label: 'Durchschnittspunktzahl',
                        data: data,
                        backgroundColor: 'rgba(0, 255, 208, 0.2)',
                        borderColor: 'rgba(0, 255, 208, 1)',
                        pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                        pointBorderColor: '#fff',
                        pointRadius: 3
                    }]
                };
            case 'pie':
                // Für Kreisdiagramm aggregieren wir nach Leistungsstufen
                const performanceLevels = {
                    'Sehr gut (>=90%)': 0,
                    'Gut (80-89%)': 0,
                    'Befriedigend (70-79%)': 0,
                    'Ausreichend (60-69%)': 0,
                    'Mangelhaft (<60%)': 0
                };
                
                // Ergebnisse zählen
                Object.values(groupedData).forEach(group => {
                    group.results.forEach(result => {
                        const score = result.score || 0;
                        if (score >= 90) performanceLevels['Sehr gut (>=90%)']++;
                        else if (score >= 80) performanceLevels['Gut (80-89%)']++;
                        else if (score >= 70) performanceLevels['Befriedigend (70-79%)']++;
                        else if (score >= 60) performanceLevels['Ausreichend (60-69%)']++;
                        else performanceLevels['Mangelhaft (<60%)']++;
                    });
                });
                
                return {
                    type: 'pie',
                    labels: Object.keys(performanceLevels),
                    datasets: [{
                        data: Object.values(performanceLevels),
                        backgroundColor: [
                            'rgba(0, 255, 208, 0.8)',
                            'rgba(0, 200, 163, 0.8)',
                            'rgba(255, 193, 7, 0.8)',
                            'rgba(255, 152, 0, 0.8)',
                            'rgba(255, 87, 34, 0.8)'
                        ],
                        borderColor: [
                            'rgba(0, 255, 208, 1)',
                            'rgba(0, 200, 163, 1)',
                            'rgba(255, 193, 7, 1)',
                            'rgba(255, 152, 0, 1)',
                            'rgba(255, 87, 34, 1)'
                        ],
                        borderWidth: 1
                    }]
                };
            default:
                return {
                    type: 'bar',
                    labels: labels,
                    datasets: [{
                        label: 'Durchschnittspunktzahl',
                        data: data,
                        backgroundColor: 'rgba(0, 255, 208, 0.6)',
                        borderColor: 'rgba(0, 255, 208, 1)',
                        borderWidth: 1
                    }]
                };
        }
    }
    
    /**
     * Berechnet die durchschnittliche Punktzahl aus einer Liste von Ergebnissen
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {number} - Durchschnittliche Punktzahl
     */
    function _calculateAverageScore(results) {
        if (!results || results.length === 0) return 0;
        
        const validScores = results.filter(result => typeof result.score === 'number').map(result => result.score);
        if (validScores.length === 0) return 0;
        
        const sum = validScores.reduce((acc, score) => acc + score, 0);
        return Math.round((sum / validScores.length) * 10) / 10; // Auf eine Dezimalstelle runden
    }
    
    /**
     * Findet die höchste Punktzahl in einer Liste von Ergebnissen
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {number} - Höchste Punktzahl
     */
    function _findHighestScore(results) {
        if (!results || results.length === 0) return 0;
        
        const validScores = results.filter(result => typeof result.score === 'number').map(result => result.score);
        if (validScores.length === 0) return 0;
        
        return Math.max(...validScores);
    }
    
    /**
     * Findet die niedrigste Punktzahl in einer Liste von Ergebnissen
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {number} - Niedrigste Punktzahl
     */
    function _findLowestScore(results) {
        if (!results || results.length === 0) return 0;
        
        const validScores = results.filter(result => typeof result.score === 'number').map(result => result.score);
        if (validScores.length === 0) return 0;
        
        return Math.min(...validScores);
    }
    
    /**
     * Berechnet den Trend aus einer Liste von Ergebnissen
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {Object} - Trend-Informationen
     */
    function _calculateTrend(results) {
        if (!results || results.length < 2) {
            return { direction: 'neutral', value: 0 };
        }
        
        // Nach Datum sortieren
        const sortedResults = [...results].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // In gleichgroße Gruppen aufteilen
        const half = Math.floor(sortedResults.length / 2);
        const firstHalf = sortedResults.slice(0, half);
        const secondHalf = sortedResults.slice(half);
        
        // Durchschnitt für beide Hälften berechnen
        const firstAvg = _calculateAverageScore(firstHalf);
        const secondAvg = _calculateAverageScore(secondHalf);
        
        // Differenz berechnen
        const difference = secondAvg - firstAvg;
        
        // Trendrichtung bestimmen
        let direction = 'neutral';
        if (difference > 2) direction = 'up';
        else if (difference < -2) direction = 'down';
        
        return {
            direction: direction,
            value: Math.round(difference * 10) / 10
        };
    }
    
    /**
     * Daten-Provider für Neueste-Ergebnisse-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideLatestResultsData(dashboard, widget) {
        return new Promise((resolve, reject) => {
            const settings = widget.settings || {};
            const limit = settings.limit || 5;
            const userId = App.Modules.User.Manager.getCurrentUser().id;
            
            // Optionen für Datenabfrage
            const options = {
                sort: 'date',
                order: 'desc',
                limit: limit
            };
            
            // Zugriffsrechte basierend auf Benutzerrolle
            const userRoles = App.Modules.User.Manager.getUserRoles(userId);
            
            // Für normale Benutzer nur eigene Ergebnisse
            if (!userRoles.includes('admin') && !userRoles.includes('trainer') && !userRoles.includes('teamleader')) {
                options.userId = userId;
            } 
            // Für Teamleiter nur Ergebnisse des Teams
            else if (userRoles.includes('teamleader') && !userRoles.includes('admin') && !userRoles.includes('trainer')) {
                const user = App.Modules.User.Manager.getUserById(userId);
                if (user && user.teamId) {
                    options.teamId = user.teamId;
                }
            }
            
            // Daten abrufen
            App.Modules.Results.DataManager.getResults(options)
                .then(results => {
                    // Zusätzliche Informationen abrufen
                    const enhancedResults = results.map(result => {
                        // Benutzername abrufen, falls nicht vorhanden
                        if (!result.userName && result.userId) {
                            const user = App.Modules.User.Manager.getUserById(result.userId);
                            if (user) {
                                result.userName = user.fullName || user.username;
                            }
                        }
                        
                        // Testname abrufen, falls nicht vorhanden
                        if (!result.testName && result.testId) {
                            const test = App.Modules.Test.Manager.getTestById(result.testId);
                            if (test) {
                                result.testName = test.name;
                            }
                        }
                        
                        // Datum formatieren
                        if (result.date) {
                            const date = new Date(result.date);
                            result.formattedDate = date.toLocaleDateString('de-DE', { 
                                day: '2-digit', 
                                month: '2-digit', 
                                year: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        
                        // Status bestimmen
                        result.status = 'Nicht bestanden';
                        if (result.score >= 80) result.status = 'Bestanden';
                        else if (result.score >= 50) result.status = 'Teilweise bestanden';
                        
                        return result;
                    });
                    
                    resolve({
                        results: enhancedResults,
                        settings: settings
                    });
                })
                .catch(error => {
                    console.error('Fehler beim Abrufen der neuesten Ergebnisse:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Daten-Provider für Kategorieanalyse-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideCategoryAnalysisData(dashboard, widget) {
        return new Promise((resolve, reject) => {
            const settings = widget.settings || {};
            const categoryLimit = settings.categoryLimit || 8;
            const sortBy = settings.sortBy || 'score';
            const userId = App.Modules.User.Manager.getCurrentUser().id;
            
            // Optionen für Datenabfrage
            const options = {
                sort: 'date',
                order: 'desc'
            };
            
            // Zugriffsrechte basierend auf Benutzerrolle
            const userRoles = App.Modules.User.Manager.getUserRoles(userId);
            
            // Für normale Benutzer nur eigene Ergebnisse
            if (!userRoles.includes('admin') && !userRoles.includes('trainer') && !userRoles.includes('teamleader')) {
                options.userId = userId;
            } 
            // Für Teamleiter nur Ergebnisse des Teams
            else if (userRoles.includes('teamleader') && !userRoles.includes('admin') && !userRoles.includes('trainer')) {
                const user = App.Modules.User.Manager.getUserById(userId);
                if (user && user.teamId) {
                    options.teamId = user.teamId;
                }
            }
            
            // Daten abrufen
            App.Modules.Results.DataManager.getResults(options)
                .then(results => {
                    // Ergebnisse nach Kategorien aggregieren
                    const categoryScores = _aggregateResultsByCategory(results);
                    
                    // Kategorien sortieren
                    let sortedCategories = [];
                    
                    switch (sortBy) {
                        case 'score':
                            // Nach Punktzahl absteigend sortieren
                            sortedCategories = Object.entries(categoryScores).sort((a, b) => b[1].averageScore - a[1].averageScore);
                            break;
                        case 'alphabetical':
                            // Alphabetisch sortieren
                            sortedCategories = Object.entries(categoryScores).sort((a, b) => a[0].localeCompare(b[0]));
                            break;
                        case 'importance':
                            // Nach Wichtigkeit (Anzahl der Tests) sortieren
                            sortedCategories = Object.entries(categoryScores).sort((a, b) => b[1].count - a[1].count);
                            break;
                        default:
                            sortedCategories = Object.entries(categoryScores).sort((a, b) => b[1].averageScore - a[1].averageScore);
                    }
                    
                    // Auf die angegebene Anzahl begrenzen
                    sortedCategories = sortedCategories.slice(0, categoryLimit);
                    
                    // Zielwerte abrufen, falls gewünscht
                    let targetScores = {};
                    if (settings.showTarget) {
                        targetScores = _getCategoryTargetScores();
                    }
                    
                    // Durchschnittswerte abrufen, falls gewünscht
                    let averageScores = {};
                    if (settings.showAverage) {
                        averageScores = _getCategoryAverageScores();
                    }
                    
                    // Daten für Chart vorbereiten
                    const categories = sortedCategories.map(([category]) => category);
                    const scores = sortedCategories.map(([, data]) => data.averageScore);
                    
                    const chartData = {
                        type: 'radar',
                        labels: categories,
                        datasets: [
                            {
                                label: 'Deine Ergebnisse',
                                data: scores,
                                backgroundColor: 'rgba(0, 255, 208, 0.2)',
                                borderColor: 'rgba(0, 255, 208, 1)',
                                borderWidth: 2,
                                pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                                pointBorderColor: '#fff',
                                pointRadius: 4
                            }
                        ]
                    };
                    
                    // Zielwerte hinzufügen, falls gewünscht
                    if (settings.showTarget) {
                        const targetData = categories.map(category => targetScores[category] || 80);
                        
                        chartData.datasets.push({
                            label: 'Zielwerte',
                            data: targetData,
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            borderColor: 'rgba(255, 193, 7, 1)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            pointBackgroundColor: 'rgba(255, 193, 7, 1)',
                            pointBorderColor: '#fff',
                            pointRadius: 3
                        });
                    }
                    
                    // Durchschnittswerte hinzufügen, falls gewünscht
                    if (settings.showAverage) {
                        const averageData = categories.map(category => averageScores[category] || 0);
                        
                        chartData.datasets.push({
                            label: 'Durchschnitt',
                            data: averageData,
                            backgroundColor: 'rgba(153, 102, 255, 0.1)',
                            borderColor: 'rgba(153, 102, 255, 1)',
                            borderWidth: 1,
                            pointBackgroundColor: 'rgba(153, 102, 255, 1)',
                            pointBorderColor: '#fff',
                            pointRadius: 3
                        });
                    }
                    
                    resolve({
                        chartData: chartData,
                        categories: sortedCategories.map(([category, data]) => ({
                            name: category,
                            averageScore: data.averageScore,
                            count: data.count,
                            trend: data.trend,
                            targetScore: targetScores[category] || 80,
                            averageScore: averageScores[category] || 0
                        })),
                        settings: settings
                    });
                })
                .catch(error => {
                    console.error('Fehler beim Abrufen der Kategorieanalyse-Daten:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Aggregiert Ergebnisse nach Kategorien
     * @private
     * @param {Array<Object>} results - Liste von Ergebnissen
     * @returns {Object} - Nach Kategorien aggregierte Daten
     */
    function _aggregateResultsByCategory(results) {
        const categoryScores = {};
        
        results.forEach(result => {
            // Kategorienscores aus Ergebnis verarbeiten
            if (result.categoryScores) {
                Object.entries(result.categoryScores).forEach(([category, score]) => {
                    if (!categoryScores[category]) {
                        categoryScores[category] = {
                            scores: [],
                            count: 0,
                            averageScore: 0,
                            trend: { direction: 'neutral', value: 0 }
                        };
                    }
                    
                    // Score zur Liste hinzufügen
                    categoryScores[category].scores.push({
                        score: score,
                        date: result.date
                    });
                    categoryScores[category].count++;
                });
            }
        });
        
        // Durchschnitt und Trend für jede Kategorie berechnen
        Object.values(categoryScores).forEach(category => {
            if (category.scores.length > 0) {
                // Durchschnitt berechnen
                const sum = category.scores.reduce((acc, item) => acc + item.score, 0);
                category.averageScore = Math.round((sum / category.scores.length) * 10) / 10;
                
                // Trend berechnen
                if (category.scores.length >= 2) {
                    // Nach Datum sortieren
                    const sortedScores = [...category.scores].sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // In gleichgroße Gruppen aufteilen
                    const half = Math.floor(sortedScores.length / 2);
                    const firstHalf = sortedScores.slice(0, half);
                    const secondHalf = sortedScores.slice(half);
                    
                    // Durchschnitt für beide Hälften berechnen
                    const firstAvg = firstHalf.reduce((acc, item) => acc + item.score, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((acc, item) => acc + item.score, 0) / secondHalf.length;
                    
                    // Differenz berechnen
                    const difference = secondAvg - firstAvg;
                    
                    // Trendrichtung bestimmen
                    let direction = 'neutral';
                    if (difference > 2) direction = 'up';
                    else if (difference < -2) direction = 'down';
                    
                    category.trend = {
                        direction: direction,
                        value: Math.round(difference * 10) / 10
                    };
                }
            }
        });
        
        return categoryScores;
    }
    
    /**
     * Ruft Zielwerte für Kategorien ab
     * @private
     * @returns {Object} - Zielwerte für Kategorien
     */
    function _getCategoryTargetScores() {
        // In einer realen Implementierung würden diese Daten aus der Datenbank kommen
        // Hier werden Beispielwerte zurückgegeben
        return {
            'Grundlagen': 90,
            'Immobilienbewertung': 85,
            'Marktanalyse': 80,
            'Rechtliches': 85,
            'Finanzierung': 85,
            'Verkaufsprozesse': 90,
            'Kundenberatung': 95,
            'Verhandlung': 90,
            'Digitale Tools': 85
        };
    }
    
    /**
     * Ruft durchschnittliche Werte für Kategorien ab
     * @private
     * @returns {Object} - Durchschnittswerte für Kategorien
     */
    function _getCategoryAverageScores() {
        // In einer realen Implementierung würden diese Daten aus der Datenbank kommen
        // Hier werden Beispielwerte zurückgegeben
        return {
            'Grundlagen': 78,
            'Immobilienbewertung': 72,
            'Marktanalyse': 68,
            'Rechtliches': 70,
            'Finanzierung': 75,
            'Verkaufsprozesse': 80,
            'Kundenberatung': 85,
            'Verhandlung': 76,
            'Digitale Tools': 65
        };
    }
    
    /**
     * Daten-Provider für Verbesserungspotenzial-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideImprovementData(dashboard, widget) {
        return new Promise((resolve, reject) => {
            const settings = widget.settings || {};
            const limit = settings.limit || 5;
            const threshold = settings.threshold || 70;
            const userId = App.Modules.User.Manager.getCurrentUser().id;
            
            // Optionen für Datenabfrage
            const options = {
                sort: 'date',
                order: 'desc'
            };
            
            // Zugriffsrechte basierend auf Benutzerrolle
            const userRoles = App.Modules.User.Manager.getUserRoles(userId);
            
            // Für normale Benutzer nur eigene Ergebnisse
            if (!userRoles.includes('admin') && !userRoles.includes('trainer') && !userRoles.includes('teamleader')) {
                options.userId = userId;
            } 
            // Für Teamleiter nur Ergebnisse des Teams
            else if (userRoles.includes('teamleader') && !userRoles.includes('admin') && !userRoles.includes('trainer')) {
                const user = App.Modules.User.Manager.getUserById(userId);
                if (user && user.teamId) {
                    options.teamId = user.teamId;
                }
            }
            
            // Daten abrufen
            App.Modules.Results.DataManager.getResults(options)
                .then(results => {
                    // Ergebnisse nach Kategorien aggregieren
                    const categoryScores = _aggregateResultsByCategory(results);
                    
                    // Kategorien nach Verbesserungspotenzial sortieren (niedrigste Punktzahl zuerst)
                    const sortedCategories = Object.entries(categoryScores)
                        .filter(([, data]) => data.averageScore < threshold) // Nur Kategorien unter dem Schwellenwert
                        .sort((a, b) => a[1].averageScore - b[1].averageScore);
                    
                    // Auf die angegebene Anzahl begrenzen
                    const improvementCategories = sortedCategories.slice(0, limit).map(([category, data]) => ({
                        name: category,
                        score: data.averageScore,
                        gap: threshold - data.averageScore,
                        trend: data.trend,
                        recommendation: _generateRecommendation(category, data.averageScore, threshold)
                    }));
                    
                    // Für Balkendiagramm vorbereiten
                    const chartData = {
                        type: 'horizontalBar',
                        labels: improvementCategories.map(cat => cat.name),
                        datasets: [
                            {
                                label: 'Aktuelle Punktzahl',
                                data: improvementCategories.map(cat => cat.score),
                                backgroundColor: improvementCategories.map(cat => {
                                    // Farbe basierend auf Abstand zum Schwellenwert
                                    const gap = threshold - cat.score;
                                    if (gap > 20) return 'rgba(255, 87, 34, 0.8)';
                                    if (gap > 10) return 'rgba(255, 152, 0, 0.8)';
                                    return 'rgba(255, 193, 7, 0.8)';
                                }),
                                borderColor: 'rgba(0, 0, 0, 0.1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Ziel',
                                data: improvementCategories.map(() => threshold),
                                backgroundColor: 'rgba(0, 0, 0, 0)',
                                borderColor: 'rgba(0, 255, 208, 0.8)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line'
                            }
                        ]
                    };
                    
                    resolve({
                        chartData: chartData,
                        improvementCategories: improvementCategories,
                        settings: settings
                    });
                })
                .catch(error => {
                    console.error('Fehler beim Abrufen der Verbesserungspotenzial-Daten:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Generiert eine Empfehlung für eine Kategorie
     * @private
     * @param {string} category - Kategorienname
     * @param {number} score - Aktuelle Punktzahl
     * @param {number} threshold - Schwellenwert
     * @returns {string} - Empfehlung
     */
    function _generateRecommendation(category, score, threshold) {
        const gap = threshold - score;
        
        // Empfehlungsvorlagen basierend auf Kategorie und Lücke
        const recommendations = {
            'Grundlagen': [
                'Wiederholen Sie die grundlegenden Konzepte und Definitionen.',
                'Nutzen Sie die Online-Lernmodule für Grundlagenwissen.',
                'Nehmen Sie an den Grundlagen-Workshops teil.'
            ],
            'Immobilienbewertung': [
                'Üben Sie die Anwendung verschiedener Bewertungsmethoden.',
                'Machen Sie sich mit den aktuellen Marktpreisen vertraut.',
                'Vertiefen Sie Ihr Wissen über Bewertungsfaktoren.'
            ],
            'Marktanalyse': [
                'Verbessern Sie Ihre Fähigkeiten zur Datenanalyse und -interpretation.',
                'Bleiben Sie über aktuelle Markttrends informiert.',
                'Nutzen Sie die verfügbaren Marktforschungstools.'
            ],
            'Rechtliches': [
                'Aktualisieren Sie Ihr Wissen über relevante Gesetze und Vorschriften.',
                'Nehmen Sie an Rechtsschulungen teil.',
                'Konsultieren Sie die Rechtsdatenbank für spezifische Fragen.'
            ],
            'Finanzierung': [
                'Verbessern Sie Ihr Verständnis von Finanzierungskonzepten.',
                'Machen Sie sich mit den aktuellen Zinssätzen und Konditionen vertraut.',
                'Üben Sie Finanzierungsberechnungen und -beratung.'
            ],
            'Verkaufsprozesse': [
                'Optimieren Sie Ihre Verkaufstechniken und -strategien.',
                'Nutzen Sie die Best-Practice-Beispiele für erfolgreiche Verkäufe.',
                'Nehmen Sie an Verkaufstrainings teil.'
            ],
            'Kundenberatung': [
                'Verbessern Sie Ihre Kommunikations- und Beratungsfähigkeiten.',
                'Üben Sie Kundengespräche und Bedarfsanalysen.',
                'Nutzen Sie Feedback zur Verbesserung Ihrer Beratungsqualität.'
            ],
            'Verhandlung': [
                'Entwickeln Sie effektivere Verhandlungsstrategien.',
                'Üben Sie schwierige Verhandlungssituationen.',
                'Lernen Sie von erfolgreichen Verhandlern im Team.'
            ],
            'Digitale Tools': [
                'Machen Sie sich mit den neuesten digitalen Werkzeugen vertraut.',
                'Nutzen Sie die verfügbaren Online-Schulungen für digitale Tools.',
                'Üben Sie die effiziente Nutzung der Unternehmenssoftware.'
            ]
        };
        
        // Standardempfehlungen für unbekannte Kategorien
        const defaultRecommendations = [
            'Wiederholen Sie die Inhalte dieser Kategorie regelmäßig.',
            'Wenden Sie sich an Ihren Trainer für spezifische Unterstützung.',
            'Nutzen Sie zusätzliche Lernmaterialien zu diesem Thema.'
        ];
        
        // Empfehlung basierend auf Lücke auswählen
        const categoryRecommendations = recommendations[category] || defaultRecommendations;
        let index = 0;
        
        if (gap > 20) index = 0; // Große Lücke: grundlegende Empfehlung
        else if (gap > 10) index = 1; // Mittlere Lücke: mittlere Empfehlung
        else index = 2; // Kleine Lücke: fortgeschrittene Empfehlung
        
        return categoryRecommendations[index];
    }
    
    /**
     * Daten-Provider für Team-Vergleich-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideTeamComparisonData(dashboard, widget) {
        // Die Implementierung dieser Funktion würde ähnlich aussehen wie die anderen Daten-Provider
        // Hier wird nur ein Platzhalter zurückgegeben
        return Promise.resolve({
            chartData: {
                type: 'bar',
                labels: ['Team A', 'Team B', 'Team C', 'Team D'],
                datasets: [{
                    label: 'Durchschnittliche Punktzahl',
                    data: [78.5, 82.3, 65.8, 73.2],
                    backgroundColor: [
                        'rgba(0, 255, 208, 0.6)',
                        'rgba(0, 255, 208, 0.6)',
                        'rgba(0, 255, 208, 0.6)',
                        'rgba(0, 255, 208, 0.6)'
                    ],
                    borderColor: [
                        'rgba(0, 255, 208, 1)',
                        'rgba(0, 255, 208, 1)',
                        'rgba(0, 255, 208, 1)',
                        'rgba(0, 255, 208, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            teams: [
                { name: 'Team A', score: 78.5, memberCount: 12, testsCompleted: 48 },
                { name: 'Team B', score: 82.3, memberCount: 8, testsCompleted: 32 },
                { name: 'Team C', score: 65.8, memberCount: 10, testsCompleted: 35 },
                { name: 'Team D', score: 73.2, memberCount: 15, testsCompleted: 53 }
            ],
            settings: widget.settings || {}
        });
    }
    
    /**
     * Daten-Provider für Trend-Analyse-Widget
     * @private
     * @param {Object} dashboard - Dashboard-Objekt
     * @param {Object} widget - Widget-Objekt
     * @returns {Promise<Object>} - Daten für das Widget
     */
    function _provideTrendAnalysisData(dashboard, widget) {
        // Die Implementierung dieser Funktion würde ähnlich aussehen wie die anderen Daten-Provider
        // Hier wird nur ein Platzhalter zurückgegeben
        return Promise.resolve({
            chartData: {
                type: 'line',
                labels: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul'],
                datasets: [{
                    label: 'Durchschnittliche Punktzahl',
                    data: [65, 68, 72, 78, 74, 80, 82],
                    fill: false,
                    borderColor: 'rgba(0, 255, 208, 1)',
                    tension: 0.1,
                    pointBackgroundColor: 'rgba(0, 255, 208, 1)',
                    pointBorderColor: '#fff',
                    pointRadius: 4
                }]
            },
            trend: {
                direction: 'up',
                value: 17.0,
                prediction: 85.4
            },
            settings: widget.settings || {}
        });
    }
    
    /**
     * Initialisiert die Berichtswesen-Integration
     * @param {Object} options - Konfigurationsoptionen
     * @returns {Promise<boolean>} - Promise, der nach erfolgreicher Initialisierung aufgelöst wird
     */
    function initializeReportIntegration(options = {}) {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob das Berichtsmodul existiert
                if (!App.Modules.Reports || !App.Modules.Reports.Manager) {
                    console.warn('Berichtsmodul nicht verfügbar, Integration wird übersprungen');
                    resolve(false);
                    return;
                }
                
                console.log('Initialisiere Berichtswesen-Integration');
                
                const ReportManager = App.Modules.Reports.Manager;
                
                // Berichtsvorlagen registrieren
                _registerReportTemplates();
                
                // Datenquellen für Berichte registrieren
                _registerReportDataSources();
                
                // Event-Listener für Berichtsereignisse
                ReportManager.addEventListener('report.generated', _handleReportGenerated);
                ReportManager.addEventListener('report.scheduled', _handleReportScheduled);
                
                // Geplante Berichte laden
                ReportManager.getScheduledReports()
                    .then(scheduledReports => {
                        _reportIntegration.scheduledReports = scheduledReports;
                        _reportIntegration.initialized = true;
                        console.log('Berichtswesen-Integration erfolgreich abgeschlossen');
                        resolve(true);
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden geplanter Berichte:', error);
                        // Integration trotz Fehler fortsetzen
                        _reportIntegration.initialized = true;
                        resolve(true);
                    });
                
            } catch (error) {
                console.error('Fehler bei der Berichtswesen-Integration:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Registriert Berichtsvorlagen
     * @private
     * @returns {void}
     */
    function _registerReportTemplates() {
        const ReportManager = App.Modules.Reports.Manager;
        
        // Berichtsvorlagen definieren
        const templates = [
            {
                id: 'user-performance',
                name: 'Benutzerleistungsbericht',
                description: 'Detaillierte Analyse der Leistung eines Benutzers',
                type: 'user',
                formats: ['pdf', 'html', 'docx'],
                sections: [
                    { id: 'summary', name: 'Zusammenfassung', required: true },
                    { id: 'test-results', name: 'Testergebnisse', required: true },
                    { id: 'category-analysis', name: 'Kategorieanalyse', required: true },
                    { id: 'trend-analysis', name: 'Trendanalyse', required: false },
                    { id: 'recommendations', name: 'Empfehlungen', required: false }
                ],
                dataProvider: _provideUserPerformanceReportData,
                renderer: 'default'
            },
            {
                id: 'team-performance',
                name: 'Teamleistungsbericht',
                description: 'Analyse der Leistung eines Teams',
                type: 'team',
                formats: ['pdf', 'html', 'xlsx'],
                sections: [
                    { id: 'summary', name: 'Zusammenfassung', required: true },
                    { id: 'team-overview', name: 'Teamübersicht', required: true },
                    { id: 'member-performance', name: 'Mitgliederleistung', required: true },
                    { id: 'category-analysis', name: 'Kategorieanalyse', required: true },
                    { id: 'trend-analysis', name: 'Trendanalyse', required: false },
                    { id: 'recommendations', name: 'Empfehlungen', required: false }
                ],
                dataProvider: _provideTeamPerformanceReportData,
                renderer: 'default'
            },
            {
                id: 'test-analysis',
                name: 'Testanalysebericht',
                description: 'Detaillierte Analyse eines Tests',
                type: 'test',
                formats: ['pdf', 'html', 'xlsx'],
                sections: [
                    { id: 'summary', name: 'Zusammenfassung', required: true },
                    { id: 'test-overview', name: 'Testübersicht', required: true },
                    { id: 'question-analysis', name: 'Fragenanalyse', required: true },
                    { id: 'participant-performance', name: 'Teilnehmerleistung', required: true },
                    { id: 'category-analysis', name: 'Kategorieanalyse', required: false },
                    { id: 'recommendations', name: 'Empfehlungen', required: false }
                ],
                dataProvider: _provideTestAnalysisReportData,
                renderer: 'default'
            }
        ];
        
        // Vorlagen registrieren
        templates.forEach(template => {
            ReportManager.registerReportTemplate(template);
            _reportIntegration.templates[template.id] = template;
        });
        
        console.log(`${templates.length} Berichtsvorlagen registriert`);
    }
    
    /**
     * Registriert Datenquellen für Berichte
     * @private
     * @returns {void}
     */
    function _registerReportDataSources() {
        const ReportManager = App.Modules.Reports.Manager;
        
        // Datenquellen registrieren
        ReportManager.registerDataSource('user-results', {
            description: 'Testergebnisse eines Benutzers',
            provider: async (params) => {
                if (!params.userId) throw new Error('Benutzer-ID erforderlich');
                
                try {
                    const results = await App.Modules.Results.DataManager.getResultsByUser(params.userId);
                    return results;
                } catch (error) {
                    console.error('Fehler beim Abrufen der Benutzerergebnisse:', error);
                    throw error;
                }
            }
        });
        
        ReportManager.registerDataSource('team-results', {
            description: 'Testergebnisse eines Teams',
            provider: async (params) => {
                if (!params.teamId) throw new Error('Team-ID erforderlich');
                
                try {
                    const results = await App.Modules.Results.DataManager.getResultsByTeam(params.teamId);
                    return results;
                } catch (error) {
                    console.error('Fehler beim Abrufen der Teamergebnisse:', error);
                    throw error;
                }
            }
        });
        
        ReportManager.registerDataSource('test-results', {
            description: 'Ergebnisse eines Tests',
            provider: async (params) => {
                if (!params.testId) throw new Error('Test-ID erforderlich');
                
                try {
                    const results = await App.Modules.Results.DataManager.getResultsByTest(params.testId);
                    return results;
                } catch (error) {
                    console.error('Fehler beim Abrufen der Testergebnisse:', error);
                    throw error;
                }
            }
        });
        
        console.log('Berichtsdatenquellen registriert');
    }
    
    /**
     * Daten-Provider für Benutzerleistungsbericht
     * @private
     * @param {Object} params - Parameter für den Bericht
     * @param {Object} template - Berichtsvorlage
     * @returns {Promise<Object>} - Daten für den Bericht
     */
    function _provideUserPerformanceReportData(params, template) {
        // Die Implementierung dieser Funktion würde ähnlich aussehen wie die anderen Daten-Provider
        // Hier wird nur ein Platzhalter zurückgegeben
        return Promise.resolve({
            title: 'Benutzerleistungsbericht',
            user: {
                id: params.userId,
                name: 'Max Mustermann',
                team: 'Verkaufsteam Nord'
            },
            summary: {
                testCount: 12,
                averageScore: 78.5,
                trend: { direction: 'up', value: 5.2 }
            },
            sections: {
                'test-results': {
                    tests: [
                        { name: 'Grundlagentest', date: '2023-06-15', score: 82 },
                        { name: 'Verkaufstraining', date: '2023-07-10', score: 75 },
                        { name: 'Kundenkommunikation', date: '2023-08-05', score: 90 }
                    ]
                },
                'category-analysis': {
                    categories: [
                        { name: 'Grundlagen', score: 85 },
                        { name: 'Verkaufstechniken', score: 78 },
                        { name: 'Kundenkommunikation', score: 90 }
                    ]
                },
                'trend-analysis': {
                    data: [
                        { date: '2023-01', score: 70 },
                        { date: '2023-02', score: 72 },
                        { date: '2023-03', score: 75 },
                        { date: '2023-04', score: 78 },
                        { date: '2023-05', score: 76 },
                        { date: '2023-06', score: 82 },
                        { date: '2023-07', score: 80 },
                        { date: '2023-08', score: 85 }
                    ]
                },
                'recommendations': {
                    items: [
                        'Weitere Vertiefung im Bereich Verkaufstechniken',
                        'Regelmäßige Übungen zu Immobilienbewertung',
                        'Teilnahme am Workshop "Fortgeschrittene Verhandlungsstrategien"'
                    ]
                }
            }
        });
    }
    
    /**
     * Daten-Provider für Teamleistungsbericht
     * @private
     * @param {Object} params - Parameter für den Bericht
     * @param {Object} template - Berichtsvorlage
     * @returns {Promise<Object>} - Daten für den Bericht
     */
    function _provideTeamPerformanceReportData(params, template) {
        // Ähnlich wie _provideUserPerformanceReportData, aber für Teams
        return Promise.resolve({});
    }
    
    /**
     * Daten-Provider für Testanalysebericht
     * @private
     * @param {Object} params - Parameter für den Bericht
     * @param {Object} template - Berichtsvorlage
     * @returns {Promise<Object>} - Daten für den Bericht
     */
    function _provideTestAnalysisReportData(params, template) {
        // Ähnlich wie _provideUserPerformanceReportData, aber für Tests
        return Promise.resolve({});
    }
    
    /**
     * Handler für generierte Berichte
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleReportGenerated(event) {
        console.log('Bericht generiert:', event.reportId);
        
        // Benachrichtigung an Benutzer senden
        if (event.userId && App.Modules.Notification) {
            App.Modules.Notification.sendNotification(event.userId, {
                type: 'report_generated',
                title: 'Bericht erstellt',
                message: `Ihr Bericht "${event.reportName}" wurde erfolgreich erstellt.`,
                data: {
                    reportId: event.reportId,
                    reportType: event.reportType
                }
            });
        }
    }
    
    /**
     * Handler für geplante Berichte
     * @private
     * @param {Object} event - Ereignisdaten
     * @returns {void}
     */
    function _handleReportScheduled(event) {
        console.log('Bericht geplant:', event.reportTemplateId);
        
        // Geplanten Bericht zur Liste hinzufügen
        if (event.schedule) {
            _reportIntegration.scheduledReports.push({
                id: event.scheduleId,
                templateId: event.reportTemplateId,
                params: event.params,
                schedule: event.schedule,
                userId: event.userId
            });
        }
    }
    
    /**
     * Ruft erweiterte Dashboard-Integration ab
     * @returns {Object} - Status der Dashboard-Integration
     */
    function getDashboardIntegrationStatus() {
        return {
            initialized: _dashboardIntegration.initialized,
            widgetCount: Object.keys(_dashboardIntegration.widgets).length,
            dashboardCount: Object.keys(_dashboardIntegration.dashboards).length
        };
    }
    
    /**
     * Ruft erweiterte Berichtswesen-Integration ab
     * @returns {Object} - Status der Berichtswesen-Integration
     */
    function getReportIntegrationStatus() {
        return {
            initialized: _reportIntegration.initialized,
            templateCount: Object.keys(_reportIntegration.templates).length,
            scheduledReportCount: _reportIntegration.scheduledReports.length
        };
    }
    
    /**
     * Generiert einen Bericht basierend auf den Ergebnisdaten
     * @param {string} templateId - ID der Berichtsvorlage
     * @param {Object} params - Parameter für den Bericht
     * @param {string} format - Ausgabeformat (pdf, html, xlsx)
     * @returns {Promise<Object>} - Generierter Bericht
     */
    function generateReport(templateId, params, format = 'pdf') {
        return new Promise((resolve, reject) => {
            // Sicherstellen, dass die Integration initialisiert wurde
            if (!_reportIntegration.initialized) {
                reject(new Error('Berichtswesen-Integration nicht initialisiert'));
                return;
            }
            
            // Prüfen, ob die Vorlage existiert
            if (!_reportIntegration.templates[templateId]) {
                reject(new Error(`Berichtsvorlage ${templateId} nicht gefunden`));
                return;
            }
            
            // Prüfen, ob das Format unterstützt wird
            if (!_reportIntegration.templates[templateId].formats.includes(format)) {
                reject(new Error(`Format ${format} wird für diese Vorlage nicht unterstützt`));
                return;
            }
            
            // Bericht generieren
            App.Modules.Reports.Manager.generateReport(templateId, params, format)
                .then(report => {
                    resolve(report);
                })
                .catch(error => {
                    console.error('Fehler bei der Berichtsgenerierung:', error);
                    reject(error);
                });
        });
    }
    
    /**
     * Plant einen regelmäßigen Bericht
     * @param {string} templateId - ID der Berichtsvorlage
     * @param {Object} params - Parameter für den Bericht
     * @param {Object} schedule - Zeitplan für den Bericht
     * @param {string} format - Ausgabeformat (pdf, html, xlsx)
     * @returns {Promise<Object>} - Geplanter Bericht
     */
    function scheduleReport(templateId, params, schedule, format = 'pdf') {
        return new Promise((resolve, reject) => {
            // Sicherstellen, dass die Integration initialisiert wurde
            if (!_reportIntegration.initialized) {
                reject(new Error('Berichtswesen-Integration nicht initialisiert'));
                return;
            }
            
            // Bericht planen
            App.Modules.Reports.Manager.scheduleReport(templateId, params, schedule, format)
                .then(scheduledReport => {
                    // Zur Liste hinzufügen
                    _reportIntegration.scheduledReports.push(scheduledReport);
                    resolve(scheduledReport);
                })
                .catch(error => {
                    console.error('Fehler beim Planen des Berichts:', error);
                    reject(error);
                });
        });
    }
    
    // Funktionen zum Basismodul hinzufügen
    
    // Dashboard-Integration
    BaseIntegration.initializeDashboardIntegration = initializeDashboardIntegration;
    BaseIntegration.getDashboardIntegrationStatus = getDashboardIntegrationStatus;
    
    // Berichtswesen-Integration
    BaseIntegration.initializeReportIntegration = initializeReportIntegration;
    BaseIntegration.getReportIntegrationStatus = getReportIntegrationStatus;
    BaseIntegration.generateReport = generateReport;
    BaseIntegration.scheduleReport = scheduleReport;
    
    // Erweitertes Initialisierungs-Callback
    const originalInitialize = BaseIntegration.initialize;
    
    // Überschreiben der Initialisierungsfunktion, um erweiterte Integrationen einzubeziehen
    BaseIntegration.initialize = function(options = {}) {
        return new Promise((resolve, reject) => {
            // Basis-Initialisierung ausführen
            originalInitialize(options)
                .then(() => {
                    // Erweiterte Integrationen initialisieren
                    const promises = [];
                    
                    // Dashboard-Integration, falls konfiguriert
                    if (options.dashboardIntegration) {
                        promises.push(initializeDashboardIntegration(options));
                    }
                    
                    // Berichtswesen-Integration, falls konfiguriert
                    if (options.reportIntegration) {
                        promises.push(initializeReportIntegration(options));
                    }
                    
                    // Wenn keine erweiterten Integrationen konfiguriert sind, sofort fertig
                    if (promises.length === 0) {
                        resolve(true);
                        return;
                    }
                    
                    // Auf alle erweiterten Integrationen warten
                    Promise.all(promises)
                        .then(() => {
                            console.log('Erweiterte Integration erfolgreich abgeschlossen');
                            resolve(true);
                        })
                        .catch(error => {
                            console.error('Fehler bei der erweiterten Integration:', error);
                            
                            // Integration trotz Fehler fortsetzen
                            console.warn('Fortsetzung trotz Fehler in der erweiterten Integration');
                            resolve(true);
                        });
                })
                .catch(error => {
                    reject(error);
                });
        });
    };
    
    console.log('Erweiterte Integrationsmodule erfolgreich geladen');
    
})();

/**
 * JS-Block 7.1.1-part1: Trainer-Dashboard-Struktur (Teil 1)
 * ImmoScout24 E-Learning Projekt
 * 
 * Dieses Modul implementiert die Grundstruktur des Trainer-Dashboards,
 * das als zentrale Anlaufstelle für alle Trainer-Funktionen dient.
 */

// Namespace für Trainer-Funktionalitäten
if (!window.ImmoLMS) window.ImmoLMS = {};
if (!window.ImmoLMS.Trainer) window.ImmoLMS.Trainer = {};

window.ImmoLMS.Trainer.Dashboard = (function() {
    'use strict';
    
    // Private Variablen
    let _initialized = false;
    let _currentUser = null;
    let _assignedLearners = [];
    let _pendingAssessments = [];
    let _recentTestResults = [];
    let _dashboardStats = {
        totalLearners: 0,
        activeTests: 0,
        pendingReviews: 0,
        completedAssessments: 0,
        averageScore: 0,
        passRate: 0
    };
    
    // Cache für DOM-Elemente
    const _elements = {
        dashboardContainer: null,
        statCards: null,
        pendingReviewsList: null,
        recentActivityList: null,
        learnerOverviewTable: null,
        quickActionsPanel: null,
        notificationsPanel: null,
        searchBar: null
    };
    
    /**
     * Initialisiert das Trainer-Dashboard und lädt die notwendigen Daten
     * @param {Object} user - Das Benutzerobjekt des aktuellen Trainers
     * @returns {Promise<boolean>} - Promise, das nach Abschluss der Initialisierung erfüllt wird
     */
    async function initialize(user) {
        if (_initialized) return true;
        
        try {
            _currentUser = user;
            
            // Prüfe Benutzerrechte
            if (!_checkTrainerPermissions(user)) {
                console.error('Benutzer hat keine Trainer-Berechtigungen');
                window.ImmoLMS.Notifications.showError('Sie haben keine Berechtigung, auf das Trainer-Dashboard zuzugreifen.');
                return false;
            }
            
            // Dashboard-Container erstellen und DOM-Elemente cachen
            _createDashboardStructure();
            _cacheDOMElements();
            
            // Daten laden
            await _loadDashboardData();
            
            // UI-Komponenten rendern
            _renderDashboardComponents();
            
            // Event-Listener registrieren
            _registerEventListeners();
            
            _initialized = true;
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung des Trainer-Dashboards:', error);
            window.ImmoLMS.Notifications.showError('Das Trainer-Dashboard konnte nicht initialisiert werden.');
            return false;
        }
    }
    
    /**
     * Prüft, ob der Benutzer Trainer-Berechtigungen hat
     * @param {Object} user - Das Benutzerobjekt
     * @returns {boolean} - True, wenn der Benutzer Trainer-Berechtigungen hat
     */
    function _checkTrainerPermissions(user) {
        return user && 
               (user.role === 'trainer' || 
                user.role === 'admin' || 
                (user.permissions && user.permissions.includes('trainer_access')));
    }
    
    /**
     * Erstellt die grundlegende DOM-Struktur des Dashboards
     */
    function _createDashboardStructure() {
        const mainContent = document.getElementById('main-content');
        if (!mainContent) return;
        
        // Bestehenden Inhalt leeren
        mainContent.innerHTML = '';
        
        // Dashboard-Container erstellen
        const dashboardHTML = `
            <div id="trainer-dashboard" class="dashboard-container">
                <header class="dashboard-header">
                    <h1>Trainer-Dashboard</h1>
                    <div class="dashboard-actions">
                        <div id="trainer-search-container" class="search-container">
                            <input type="text" id="trainer-search" placeholder="Lernende oder Tests suchen...">
                            <button id="trainer-search-btn"><i class="fas fa-search"></i></button>
                        </div>
                        <div class="action-buttons">
                            <button id="create-new-test-btn" class="btn primary-btn">
                                <i class="fas fa-plus"></i> Neuen Test erstellen
                            </button>
                            <button id="dashboard-settings-btn" class="btn icon-btn">
                                <i class="fas fa-cog"></i>
                            </button>
                            <div id="notification-icon" class="notification-icon">
                                <i class="fas fa-bell"></i>
                                <span class="notification-badge">0</span>
                            </div>
                        </div>
                    </div>
                </header>
                
                <div class="dashboard-grid">
                    <!-- Statistik-Karten -->
                    <section id="trainer-stats" class="dashboard-section stats-cards">
                        <div class="stat-card" id="total-learners-card">
                            <div class="stat-icon"><i class="fas fa-users"></i></div>
                            <div class="stat-content">
                                <h3>Zugewiesene Lernende</h3>
                                <p class="stat-value">0</p>
                            </div>
                        </div>
                        <div class="stat-card" id="active-tests-card">
                            <div class="stat-icon"><i class="fas fa-tasks"></i></div>
                            <div class="stat-content">
                                <h3>Aktive Tests</h3>
                                <p class="stat-value">0</p>
                            </div>
                        </div>
                        <div class="stat-card" id="pending-reviews-card">
                            <div class="stat-icon"><i class="fas fa-clipboard-check"></i></div>
                            <div class="stat-content">
                                <h3>Offene Bewertungen</h3>
                                <p class="stat-value">0</p>
                            </div>
                        </div>
                        <div class="stat-card" id="pass-rate-card">
                            <div class="stat-icon"><i class="fas fa-chart-line"></i></div>
                            <div class="stat-content">
                                <h3>Erfolgsquote</h3>
                                <p class="stat-value">0%</p>
                            </div>
                        </div>
                    </section>
                    
                    <!-- Offene Bewertungen -->
                    <section id="pending-reviews" class="dashboard-section">
                        <div class="section-header">
                            <h2>Offene Bewertungen</h2>
                            <button class="btn text-btn" id="view-all-reviews-btn">Alle anzeigen</button>
                        </div>
                        <div class="section-content">
                            <ul id="pending-reviews-list" class="reviews-list">
                                <li class="empty-state">
                                    <i class="fas fa-check-circle"></i>
                                    <p>Keine offenen Bewertungen vorhanden</p>
                                </li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- Aktuelle Aktivitäten -->
                    <section id="recent-activities" class="dashboard-section">
                        <div class="section-header">
                            <h2>Aktuelle Aktivitäten</h2>
                            <div class="filter-dropdown">
                                <select id="activity-filter">
                                    <option value="all">Alle Aktivitäten</option>
                                    <option value="tests-started">Tests begonnen</option>
                                    <option value="tests-completed">Tests abgeschlossen</option>
                                    <option value="reviews-needed">Bewertung erforderlich</option>
                                </select>
                            </div>
                        </div>
                        <div class="section-content">
                            <ul id="recent-activity-list" class="activity-list">
                                <li class="empty-state">
                                    <i class="fas fa-history"></i>
                                    <p>Keine aktuellen Aktivitäten</p>
                                </li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- Schnellzugriff -->
                    <section id="quick-actions" class="dashboard-section">
                        <div class="section-header">
                            <h2>Schnellzugriff</h2>
                        </div>
                        <div class="section-content">
                            <div class="quick-actions-grid">
                                <button class="quick-action-btn" id="create-test-btn">
                                    <i class="fas fa-file-alt"></i>
                                    <span>Test erstellen</span>
                                </button>
                                <button class="quick-action-btn" id="review-submissions-btn">
                                    <i class="fas fa-check-square"></i>
                                    <span>Einreichungen bewerten</span>
                                </button>
                                <button class="quick-action-btn" id="assign-test-btn">
                                    <i class="fas fa-user-plus"></i>
                                    <span>Test zuweisen</span>
                                </button>
                                <button class="quick-action-btn" id="create-report-btn">
                                    <i class="fas fa-chart-bar"></i>
                                    <span>Bericht erstellen</span>
                                </button>
                                <button class="quick-action-btn" id="view-learners-btn">
                                    <i class="fas fa-users"></i>
                                    <span>Lernende anzeigen</span>
                                </button>
                                <button class="quick-action-btn" id="view-test-library-btn">
                                    <i class="fas fa-book"></i>
                                    <span>Testbibliothek</span>
                                </button>
                            </div>
                        </div>
                    </section>
                    
                    <!-- Lernende Übersicht -->
                    <section id="learners-overview" class="dashboard-section full-width">
                        <div class="section-header">
                            <h2>Lernende Übersicht</h2>
                            <div class="section-actions">
                                <button class="btn icon-btn" id="export-learners-btn" title="Daten exportieren">
                                    <i class="fas fa-download"></i>
                                </button>
                                <div class="search-mini">
                                    <input type="text" id="learner-search" placeholder="Lernende suchen...">
                                </div>
                            </div>
                        </div>
                        <div class="section-content">
                            <table id="learners-table" class="data-table">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Team</th>
                                        <th>Zugewiesene Tests</th>
                                        <th>Abgeschlossene Tests</th>
                                        <th>Ø Bewertung</th>
                                        <th>Letzter Test</th>
                                        <th>Aktionen</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="empty-state-row">
                                        <td colspan="7">
                                            <div class="empty-state">
                                                <i class="fas fa-user-graduate"></i>
                                                <p>Keine Lernenden zugewiesen</p>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>
                </div>
                
                <!-- Benachrichtigungen Panel (versteckt) -->
                <div id="notifications-panel" class="side-panel">
                    <div class="panel-header">
                        <h2>Benachrichtigungen</h2>
                        <button id="close-notifications-btn" class="btn icon-btn">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="panel-content">
                        <ul id="notifications-list" class="notifications-list">
                            <li class="empty-state">
                                <i class="fas fa-bell-slash"></i>
                                <p>Keine neuen Benachrichtigungen</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        `;
        
        mainContent.innerHTML = dashboardHTML;
    }
    
    /**
     * Speichert Referenzen zu wichtigen DOM-Elementen
     */
    function _cacheDOMElements() {
        _elements.dashboardContainer = document.getElementById('trainer-dashboard');
        _elements.statCards = {
            totalLearners: document.getElementById('total-learners-card'),
            activeTests: document.getElementById('active-tests-card'),
            pendingReviews: document.getElementById('pending-reviews-card'),
            passRate: document.getElementById('pass-rate-card')
        };
        _elements.pendingReviewsList = document.getElementById('pending-reviews-list');
        _elements.recentActivityList = document.getElementById('recent-activity-list');
        _elements.learnerOverviewTable = document.getElementById('learners-table');
        _elements.quickActionsPanel = document.getElementById('quick-actions');
        _elements.notificationsPanel = document.getElementById('notifications-panel');
        _elements.searchBar = document.getElementById('trainer-search');
    }
    
    /**
     * Lädt alle erforderlichen Daten für das Dashboard
     * @returns {Promise<void>}
     */
    async function _loadDashboardData() {
        try {
            // Lade zugewiesene Lernende
            _assignedLearners = await window.ImmoLMS.DataService.getAssignedLearners(_currentUser.id);
            
            // Lade offene Bewertungen
            _pendingAssessments = await window.ImmoLMS.DataService.getPendingAssessments(_currentUser.id);
            
            // Lade kürzlich abgeschlossene Tests
            _recentTestResults = await window.ImmoLMS.DataService.getRecentTestResults({
                trainerId: _currentUser.id,
                limit: 10
            });
            
            // Berechne Dashboard-Statistiken
            _calculateDashboardStats();
        } catch (error) {
            console.error('Fehler beim Laden der Dashboard-Daten:', error);
            window.ImmoLMS.Notifications.showError('Die Dashboard-Daten konnten nicht geladen werden.');
        }
    }
    
    /**
     * Berechnet Statistiken für das Dashboard
     */
    function _calculateDashboardStats() {
        // Anzahl der zugewiesenen Lernenden
        _dashboardStats.totalLearners = _assignedLearners.length;
        
        // Anzahl der aktiven Tests
        const activeTests = window.ImmoLMS.DataService.getActiveTests(_currentUser.id);
        _dashboardStats.activeTests = activeTests.length;
        
        // Anzahl der offenen Bewertungen
        _dashboardStats.pendingReviews = _pendingAssessments.length;
        
        // Anzahl der abgeschlossenen Bewertungen
        const completedAssessments = window.ImmoLMS.DataService.getCompletedAssessments(_currentUser.id);
        _dashboardStats.completedAssessments = completedAssessments.length;
        
        // Durchschnittliche Bewertung
        if (completedAssessments.length > 0) {
            const totalScore = completedAssessments.reduce((sum, assessment) => sum + assessment.score, 0);
            _dashboardStats.averageScore = totalScore / completedAssessments.length;
        }
        
        // Erfolgsquote
        if (completedAssessments.length > 0) {
            const passedTests = completedAssessments.filter(assessment => assessment.passed).length;
            _dashboardStats.passRate = (passedTests / completedAssessments.length) * 100;
        }
    }
    
    /**
     * Rendert alle Dashboard-Komponenten mit den geladenen Daten
     */
    function _renderDashboardComponents() {
        // Aktualisiere Statistik-Karten
        _updateStatCards();
        
        // Rendere offene Bewertungen
        _renderPendingReviews();
        
        // Rendere aktuelle Aktivitäten
        _renderRecentActivities();
        
        // Rendere Lernenden-Übersicht
        _renderLearnersOverview();
    }
    
    /**
     * Aktualisiert die Statistik-Karten mit den aktuellen Werten
     */
    function _updateStatCards() {
        // Aktualisiere Lernenden-Anzahl
        const totalLearnersValue = _elements.statCards.totalLearners.querySelector('.stat-value');
        totalLearnersValue.textContent = _dashboardStats.totalLearners;
        
        // Aktualisiere aktive Tests
        const activeTestsValue = _elements.statCards.activeTests.querySelector('.stat-value');
        activeTestsValue.textContent = _dashboardStats.activeTests;
        
        // Aktualisiere offene Bewertungen
        const pendingReviewsValue = _elements.statCards.pendingReviews.querySelector('.stat-value');
        pendingReviewsValue.textContent = _dashboardStats.pendingReviews;
        
        // Aktualisiere Erfolgsquote
        const passRateValue = _elements.statCards.passRate.querySelector('.stat-value');
        passRateValue.textContent = `${_dashboardStats.passRate.toFixed(1)}%`;
    }
    
    /**
     * Rendert die Liste der offenen Bewertungen
     */
    function _renderPendingReviews() {
        if (!_elements.pendingReviewsList) return;
        
        // Liste leeren
        _elements.pendingReviewsList.innerHTML = '';
        
        // Prüfen, ob es offene Bewertungen gibt
        if (_pendingAssessments.length === 0) {
            _elements.pendingReviewsList.innerHTML = `
                <li class="empty-state">
                    <i class="fas fa-check-circle"></i>
                    <p>Keine offenen Bewertungen vorhanden</p>
                </li>
            `;
            return;
        }
        
        // Maximal 5 offene Bewertungen anzeigen
        const pendingToShow = _pendingAssessments.slice(0, 5);
        
        // Bewertungen in der Liste anzeigen
        pendingToShow.forEach(assessment => {
            const submissionDate = new Date(assessment.submissionDate);
            const formattedDate = submissionDate.toLocaleDateString('de-DE');
            
            const listItem = document.createElement('li');
            listItem.className = 'review-item';
            listItem.dataset.id = assessment.id;
            
            listItem.innerHTML = `
                <div class="review-info">
                    <h4>${assessment.testName}</h4>
                    <p class="user-info">
                        <span class="user-name">${assessment.userName}</span>
                        <span class="submission-date">Eingereicht am ${formattedDate}</span>
                    </p>
                    <p class="test-type">${assessment.testType}</p>
                </div>
                <div class="review-actions">
                    <button class="btn primary-btn review-btn" data-id="${assessment.id}">
                        Bewerten
                    </button>
                </div>
            `;
            
            _elements.pendingReviewsList.appendChild(listItem);
        });
    }
    
    // Weitere private Funktionen werden in JS-Block 7.1.1-part2 implementiert
    
    // Öffentliche API
    return {
        initialize: initialize,
        // Weitere öffentliche Methoden werden in JS-Block 7.1.1-part2 implementiert
    };
})();
/**
 * JS-Block 7.1.1-part2: Trainer-Dashboard-Struktur (Teil 2)
 * ImmoScout24 E-Learning Projekt
 * 
 * Dieser Block erweitert die Grundstruktur des Trainer-Dashboards mit weiteren
 * Funktionen wie Event-Handling, Aktivitätsanzeige und Lernenden-Übersicht.
 */

// Fortsetzung des Trainer-Dashboard-Moduls
(function() {
    'use strict';
    
    // Auf vorhandenes Modul zugreifen
    const Dashboard = window.ImmoLMS.Trainer.Dashboard;
    
    // Private Funktionen erweitern
    
    /**
     * Registriert alle Event-Listener für das Dashboard
     */
    function _registerEventListeners() {
        // Dashboard-Aktionen
        const createNewTestBtn = document.getElementById('create-new-test-btn');
        if (createNewTestBtn) {
            createNewTestBtn.addEventListener('click', _handleCreateNewTest);
        }
        
        const dashboardSettingsBtn = document.getElementById('dashboard-settings-btn');
        if (dashboardSettingsBtn) {
            dashboardSettingsBtn.addEventListener('click', _handleDashboardSettings);
        }
        
        // Benachrichtigungssymbol
        const notificationIcon = document.getElementById('notification-icon');
        if (notificationIcon) {
            notificationIcon.addEventListener('click', _toggleNotificationsPanel);
        }
        
        // Schließen-Button für Benachrichtigungen
        const closeNotificationsBtn = document.getElementById('close-notifications-btn');
        if (closeNotificationsBtn) {
            closeNotificationsBtn.addEventListener('click', _hideNotificationsPanel);
        }
        
        // Aktivitätsfilter
        const activityFilter = document.getElementById('activity-filter');
        if (activityFilter) {
            activityFilter.addEventListener('change', _filterActivities);
        }
        
        // Schnellzugriff-Buttons
        const quickActionBtns = document.querySelectorAll('.quick-action-btn');
        quickActionBtns.forEach(btn => {
            btn.addEventListener('click', _handleQuickAction);
        });
        
        // "Alle anzeigen"-Button für Bewertungen
        const viewAllReviewsBtn = document.getElementById('view-all-reviews-btn');
        if (viewAllReviewsBtn) {
            viewAllReviewsBtn.addEventListener('click', _handleViewAllReviews);
        }
        
        // Bewertungsbuttons in der Liste
        const reviewButtons = document.querySelectorAll('.review-btn');
        reviewButtons.forEach(btn => {
            btn.addEventListener('click', _handleReviewAssessment);
        });
        
        // Export-Button für Lernenden-Daten
        const exportLearnersBtn = document.getElementById('export-learners-btn');
        if (exportLearnersBtn) {
            exportLearnersBtn.addEventListener('click', _handleExportLearners);
        }
        
        // Suchfunktionen
        const trainerSearch = document.getElementById('trainer-search');
        if (trainerSearch) {
            trainerSearch.addEventListener('input', _handleGlobalSearch);
        }
        
        const learnerSearch = document.getElementById('learner-search');
        if (learnerSearch) {
            learnerSearch.addEventListener('input', _handleLearnerSearch);
        }
    }
    
    /**
     * Rendert die Liste der aktuellen Aktivitäten
     * @param {string} filter - Optionaler Filter für den Aktivitätstyp
     */
    function _renderRecentActivities(filter = 'all') {
        if (!_elements.recentActivityList) return;
        
        // Liste leeren
        _elements.recentActivityList.innerHTML = '';
        
        // Aktivitäten nach Typ filtern (wenn erforderlich)
        let filteredActivities = _recentTestResults;
        if (filter !== 'all') {
            filteredActivities = _recentTestResults.filter(activity => {
                switch (filter) {
                    case 'tests-started':
                        return activity.status === 'started';
                    case 'tests-completed':
                        return activity.status === 'completed';
                    case 'reviews-needed':
                        return activity.status === 'completed' && activity.needsReview;
                    default:
                        return true;
                }
            });
        }
        
        // Prüfen, ob es gefilterte Aktivitäten gibt
        if (filteredActivities.length === 0) {
            _elements.recentActivityList.innerHTML = `
                <li class="empty-state">
                    <i class="fas fa-history"></i>
                    <p>Keine Aktivitäten für diesen Filter</p>
                </li>
            `;
            return;
        }
        
        // Aktivitäten sortieren (neueste zuerst)
        filteredActivities.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Aktivitäten in der Liste anzeigen
        filteredActivities.forEach(activity => {
            const activityDate = new Date(activity.date);
            const formattedDate = activityDate.toLocaleDateString('de-DE');
            const formattedTime = activityDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            
            // Icon und Statusklasse basierend auf dem Aktivitätstyp bestimmen
            let iconClass = 'fas fa-file-alt';
            let statusClass = '';
            let statusText = '';
            
            switch (activity.status) {
                case 'started':
                    iconClass = 'fas fa-play-circle';
                    statusClass = 'status-started';
                    statusText = 'Test begonnen';
                    break;
                case 'completed':
                    iconClass = 'fas fa-check-circle';
                    statusClass = 'status-completed';
                    statusText = activity.passed ? 'Test bestanden' : 'Test nicht bestanden';
                    break;
                case 'expired':
                    iconClass = 'fas fa-clock';
                    statusClass = 'status-expired';
                    statusText = 'Zeitlimit überschritten';
                    break;
                default:
                    statusText = 'Unbekannter Status';
            }
            
            // Wenn eine Bewertung erforderlich ist, Icon und Statusklasse ändern
            if (activity.needsReview) {
                iconClass = 'fas fa-clipboard-check';
                statusClass = 'status-review-needed';
                statusText = 'Bewertung erforderlich';
            }
            
            const listItem = document.createElement('li');
            listItem.className = `activity-item ${statusClass}`;
            listItem.dataset.id = activity.id;
            
            listItem.innerHTML = `
                <div class="activity-icon">
                    <i class="${iconClass}"></i>
                </div>
                <div class="activity-content">
                    <div class="activity-header">
                        <h4>${activity.testName}</h4>
                        <span class="activity-timestamp">${formattedDate}, ${formattedTime}</span>
                    </div>
                    <p class="user-info">${activity.userName}</p>
                    <p class="activity-status">${statusText}</p>
                    ${activity.score !== undefined ? `<p class="activity-score">Ergebnis: ${activity.score}%</p>` : ''}
                </div>
                <div class="activity-actions">
                    ${activity.needsReview ? 
                      `<button class="btn primary-btn review-btn" data-id="${activity.id}">Bewerten</button>` :
                      `<button class="btn secondary-btn details-btn" data-id="${activity.id}">Details</button>`
                    }
                </div>
            `;
            
            _elements.recentActivityList.appendChild(listItem);
        });
        
        // Event-Listener für die neu erstellten Buttons hinzufügen
        const reviewButtons = _elements.recentActivityList.querySelectorAll('.review-btn');
        reviewButtons.forEach(btn => {
            btn.addEventListener('click', _handleReviewAssessment);
        });
        
        const detailButtons = _elements.recentActivityList.querySelectorAll('.details-btn');
        detailButtons.forEach(btn => {
            btn.addEventListener('click', _handleViewActivityDetails);
        });
    }
    
    /**
     * Rendert die Übersicht der zugewiesenen Lernenden
     */
    function _renderLearnersOverview() {
        if (!_elements.learnerOverviewTable) return;
        
        const tableBody = _elements.learnerOverviewTable.querySelector('tbody');
        if (!tableBody) return;
        
        // Tabelle leeren
        tableBody.innerHTML = '';
        
        // Prüfen, ob es zugewiesene Lernende gibt
        if (_assignedLearners.length === 0) {
            tableBody.innerHTML = `
                <tr class="empty-state-row">
                    <td colspan="7">
                        <div class="empty-state">
                            <i class="fas fa-user-graduate"></i>
                            <p>Keine Lernenden zugewiesen</p>
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Lernende in der Tabelle anzeigen
        _assignedLearners.forEach(learner => {
            // Testdaten für den Lernenden abrufen
            const learnerTests = window.ImmoLMS.DataService.getLearnerTests(learner.id);
            const assignedTestsCount = learnerTests.length;
            const completedTestsCount = learnerTests.filter(test => test.status === 'completed').length;
            
            // Durchschnittliche Bewertung berechnen
            let averageScore = 0;
            const completedTests = learnerTests.filter(test => test.status === 'completed' && test.score !== undefined);
            if (completedTests.length > 0) {
                const totalScore = completedTests.reduce((sum, test) => sum + test.score, 0);
                averageScore = (totalScore / completedTests.length).toFixed(1);
            }
            
            // Datum des letzten Tests
            let lastTestDate = '-';
            if (learnerTests.length > 0) {
                // Sortiere Tests nach Datum (neueste zuerst)
                const sortedTests = [...learnerTests].sort((a, b) => new Date(b.date) - new Date(a.date));
                if (sortedTests[0].date) {
                    const date = new Date(sortedTests[0].date);
                    lastTestDate = date.toLocaleDateString('de-DE');
                }
            }
            
            const row = document.createElement('tr');
            row.dataset.id = learner.id;
            
            row.innerHTML = `
                <td class="learner-name">
                    <div class="user-info-cell">
                        <div class="user-avatar">
                            ${learner.avatar ? 
                              `<img src="${learner.avatar}" alt="${learner.name}">` : 
                              `<div class="avatar-placeholder">${learner.name.charAt(0)}</div>`
                            }
                        </div>
                        <div class="user-details">
                            <span class="user-name">${learner.name}</span>
                            <span class="user-email">${learner.email}</span>
                        </div>
                    </div>
                </td>
                <td>${learner.team || '-'}</td>
                <td>${assignedTestsCount}</td>
                <td>${completedTestsCount}</td>
                <td>${averageScore > 0 ? `${averageScore}%` : '-'}</td>
                <td>${lastTestDate}</td>
                <td class="actions-cell">
                    <button class="btn icon-btn" title="Tests anzeigen" data-action="view-tests" data-id="${learner.id}">
                        <i class="fas fa-clipboard-list"></i>
                    </button>
                    <button class="btn icon-btn" title="Test zuweisen" data-action="assign-test" data-id="${learner.id}">
                        <i class="fas fa-tasks"></i>
                    </button>
                    <button class="btn icon-btn" title="Bericht erstellen" data-action="create-report" data-id="${learner.id}">
                        <i class="fas fa-chart-bar"></i>
                    </button>
                    <div class="dropdown">
                        <button class="btn icon-btn dropdown-toggle" title="Weitere Aktionen">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                        <div class="dropdown-menu">
                            <a href="#" data-action="view-profile" data-id="${learner.id}">Profil anzeigen</a>
                            <a href="#" data-action="message" data-id="${learner.id}">Nachricht senden</a>
                            <a href="#" data-action="remove" data-id="${learner.id}">Von Gruppe entfernen</a>
                        </div>
                    </div>
                </td>
            `;
            
            tableBody.appendChild(row);
        });
        
        // Event-Listener für die Aktionsbuttons hinzufügen
        _addLearnerActionListeners();
    }
    
    /**
     * Fügt Event-Listener für die Aktionsbuttons in der Lernenden-Tabelle hinzu
     */
    function _addLearnerActionListeners() {
        // Buttons für "Tests anzeigen"
        const viewTestsButtons = document.querySelectorAll('button[data-action="view-tests"]');
        viewTestsButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const learnerId = e.currentTarget.dataset.id;
                _handleViewLearnerTests(learnerId);
            });
        });
        
        // Buttons für "Test zuweisen"
        const assignTestButtons = document.querySelectorAll('button[data-action="assign-test"]');
        assignTestButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const learnerId = e.currentTarget.dataset.id;
                _handleAssignTest(learnerId);
            });
        });
        
        // Buttons für "Bericht erstellen"
        const createReportButtons = document.querySelectorAll('button[data-action="create-report"]');
        createReportButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const learnerId = e.currentTarget.dataset.id;
                _handleCreateLearnerReport(learnerId);
            });
        });
        
        // Dropdown-Toggle-Buttons
        const dropdownToggles = document.querySelectorAll('.dropdown-toggle');
        dropdownToggles.forEach(toggle => {
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                // Alle anderen Dropdown-Menüs schließen
                document.querySelectorAll('.dropdown-menu.active').forEach(menu => {
                    if (menu !== e.currentTarget.nextElementSibling) {
                        menu.classList.remove('active');
                    }
                });
                // Aktuelles Dropdown-Menü umschalten
                e.currentTarget.nextElementSibling.classList.toggle('active');
            });
        });
        
        // Dropdown-Menü-Einträge
        const dropdownActions = document.querySelectorAll('.dropdown-menu a');
        dropdownActions.forEach(action => {
            action.addEventListener('click', (e) => {
                e.preventDefault();
                const actionType = e.currentTarget.dataset.action;
                const learnerId = e.currentTarget.dataset.id;
                
                switch (actionType) {
                    case 'view-profile':
                        _handleViewLearnerProfile(learnerId);
                        break;
                    case 'message':
                        _handleSendMessage(learnerId);
                        break;
                    case 'remove':
                        _handleRemoveLearner(learnerId);
                        break;
                }
                
                // Dropdown-Menü schließen
                e.currentTarget.parentElement.classList.remove('active');
            });
        });
        
        // Klick außerhalb schließt alle Dropdown-Menüs
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu.active').forEach(menu => {
                    menu.classList.remove('active');
                });
            }
        });
    }
    
    /**
     * Filtert die Aktivitätsliste nach dem ausgewählten Typ
     * @param {Event} e - Das Event-Objekt
     */
    function _filterActivities(e) {
        const filterValue = e.target.value;
        _renderRecentActivities(filterValue);
    }
    
    /**
     * Zeigt oder versteckt das Benachrichtigungspanel
     */
    function _toggleNotificationsPanel() {
        const panel = document.getElementById('notifications-panel');
        if (panel) {
            panel.classList.toggle('active');
            
            // Wenn das Panel aktiv ist, Benachrichtigungen laden und anzeigen
            if (panel.classList.contains('active')) {
                _loadAndRenderNotifications();
            }
        }
    }
    
    /**
     * Versteckt das Benachrichtigungspanel
     */
    function _hideNotificationsPanel() {
        const panel = document.getElementById('notifications-panel');
        if (panel) {
            panel.classList.remove('active');
        }
    }
    
    /**
     * Lädt Benachrichtigungen und rendert sie im Panel
     */
    function _loadAndRenderNotifications() {
        const notificationsList = document.getElementById('notifications-list');
        if (!notificationsList) return;
        
        // Liste leeren
        notificationsList.innerHTML = '';
        
        // Benachrichtigungen laden
        const notifications = window.ImmoLMS.NotificationService.getNotifications(_currentUser.id);
        
        // Prüfen, ob es Benachrichtigungen gibt
        if (notifications.length === 0) {
            notificationsList.innerHTML = `
                <li class="empty-state">
                    <i class="fas fa-bell-slash"></i>
                    <p>Keine neuen Benachrichtigungen</p>
                </li>
            `;
            return;
        }
        
        // Benachrichtigungen sortieren (neueste zuerst)
        notifications.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Anzahl der ungelesenen Benachrichtigungen aktualisieren
        const unreadCount = notifications.filter(notification => !notification.read).length;
        const notificationBadge = document.querySelector('.notification-badge');
        if (notificationBadge) {
            notificationBadge.textContent = unreadCount;
            notificationBadge.style.display = unreadCount > 0 ? 'block' : 'none';
        }
        
        // Benachrichtigungen in der Liste anzeigen
        notifications.forEach(notification => {
            const notificationDate = new Date(notification.date);
            const formattedDate = notificationDate.toLocaleDateString('de-DE');
            const formattedTime = notificationDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            
            const listItem = document.createElement('li');
            listItem.className = `notification-item ${notification.read ? 'read' : 'unread'}`;
            listItem.dataset.id = notification.id;
            
            // Icon basierend auf der Benachrichtigungsart festlegen
            let iconClass = 'fas fa-bell';
            switch (notification.type) {
                case 'test_completed':
                    iconClass = 'fas fa-check-circle';
                    break;
                case 'review_needed':
                    iconClass = 'fas fa-clipboard-check';
                    break;
                case 'message':
                    iconClass = 'fas fa-envelope';
                    break;
                case 'system':
                    iconClass = 'fas fa-cog';
                    break;
            }
            
            listItem.innerHTML = `
                <div class="notification-icon">
                    <i class="${iconClass}"></i>
                </div>
                <div class="notification-content">
                    <div class="notification-header">
                        <h4>${notification.title}</h4>
                        <span class="notification-timestamp">${formattedDate}, ${formattedTime}</span>
                    </div>
                    <p class="notification-message">${notification.message}</p>
                </div>
                <div class="notification-actions">
                    ${notification.read ? 
                      `<button class="btn icon-btn mark-unread-btn" title="Als ungelesen markieren" data-id="${notification.id}">
                          <i class="fas fa-envelope"></i>
                      </button>` : 
                      `<button class="btn icon-btn mark-read-btn" title="Als gelesen markieren" data-id="${notification.id}">
                          <i class="fas fa-envelope-open"></i>
                      </button>`
                    }
                    <button class="btn icon-btn delete-btn" title="Löschen" data-id="${notification.id}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            notificationsList.appendChild(listItem);
        });
        
        // Event-Listener für die neu erstellten Buttons hinzufügen
        const markReadButtons = notificationsList.querySelectorAll('.mark-read-btn');
        markReadButtons.forEach(btn => {
            btn.addEventListener('click', _handleMarkNotificationRead);
        });
        
        const markUnreadButtons = notificationsList.querySelectorAll('.mark-unread-btn');
        markUnreadButtons.forEach(btn => {
            btn.addEventListener('click', _handleMarkNotificationUnread);
        });
        
        const deleteButtons = notificationsList.querySelectorAll('.delete-btn');
        deleteButtons.forEach(btn => {
            btn.addEventListener('click', _handleDeleteNotification);
        });
        
        // Klick auf Benachrichtigung markiert sie als gelesen
        const notificationItems = notificationsList.querySelectorAll('.notification-item');
        notificationItems.forEach(item => {
            item.addEventListener('click', (e) => {
                // Nicht auslösen, wenn auf einen Button geklickt wurde
                if (e.target.closest('button')) return;
                
                const notificationId = item.dataset.id;
                const notification = notifications.find(n => n.id === notificationId);
                
                if (notification && !notification.read) {
                    window.ImmoLMS.NotificationService.markAsRead(notificationId);
                    item.classList.remove('unread');
                    item.classList.add('read');
                    
                    // Button aktualisieren
                    const markReadBtn = item.querySelector('.mark-read-btn');
                    if (markReadBtn) {
                        const markUnreadBtn = document.createElement('button');
                        markUnreadBtn.className = 'btn icon-btn mark-unread-btn';
                        markUnreadBtn.title = 'Als ungelesen markieren';
                        markUnreadBtn.dataset.id = notificationId;
                        markUnreadBtn.innerHTML = '<i class="fas fa-envelope"></i>';
                        markUnreadBtn.addEventListener('click', _handleMarkNotificationUnread);
                        
                        markReadBtn.replaceWith(markUnreadBtn);
                    }
                    
                    // Anzahl der ungelesenen Benachrichtigungen aktualisieren
                    const unreadCount = notifications.filter(n => !n.read && n.id !== notificationId).length;
                    const notificationBadge = document.querySelector('.notification-badge');
                    if (notificationBadge) {
                        notificationBadge.textContent = unreadCount;
                        notificationBadge.style.display = unreadCount > 0 ? 'block' : 'none';
                    }
                }
                
                // Benachrichtigung öffnen (falls vorhanden)
                if (notification && notification.link) {
                    window.location.href = notification.link;
                }
            });
        });
    }
    
    /**
     * Sucht global nach Lernenden, Tests oder anderen Elementen
     * @param {Event} e - Das Event-Objekt
     */
    function _handleGlobalSearch(e) {
        const searchValue = e.target.value.trim().toLowerCase();
        
        // Nichts tun, wenn weniger als 2 Zeichen eingegeben wurden
        if (searchValue.length < 2) return;
        
        // Hier würde eine umfassendere Suchfunktion implementiert werden
        console.log('Globale Suche nach:', searchValue);
        
        // In der vollständigen Implementierung:
        // 1. Suche nach Lernenden
        // 2. Suche nach Tests
        // 3. Suche nach Bewertungen
        // 4. Anzeige der Ergebnisse in einem Dropdown oder Modal
    }
    
    /**
     * Filtert die Lernenden-Tabelle basierend auf dem Suchbegriff
     * @param {Event} e - Das Event-Objekt
     */
    function _handleLearnerSearch(e) {
        const searchValue = e.target.value.trim().toLowerCase();
        const tableRows = _elements.learnerOverviewTable.querySelectorAll('tbody tr:not(.empty-state-row)');
        
        // Alle Zeilen durchgehen und ggf. ausblenden
        tableRows.forEach(row => {
            const learnerName = row.querySelector('.user-name').textContent.toLowerCase();
            const learnerEmail = row.querySelector('.user-email').textContent.toLowerCase();
            const teamName = row.querySelector('td:nth-child(2)').textContent.toLowerCase();
            
            // Zeile anzeigen, wenn einer der Werte den Suchbegriff enthält
            if (searchValue === '' || 
                learnerName.includes(searchValue) || 
                learnerEmail.includes(searchValue) || 
                teamName.includes(searchValue)) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
        
        // Leerer-Zustand anzeigen, wenn keine Ergebnisse gefunden wurden
        const visibleRows = Array.from(tableRows).filter(row => row.style.display !== 'none');
        const emptyStateRow = _elements.learnerOverviewTable.querySelector('.empty-state-row');
        
        if (visibleRows.length === 0 && searchValue !== '') {
            // Wenn keine Zeilen sichtbar sind, Leerer-Zustand anzeigen
            if (!emptyStateRow) {
                const tbody = _elements.learnerOverviewTable.querySelector('tbody');
                const newEmptyRow = document.createElement('tr');
                newEmptyRow.className = 'empty-state-row';
                newEmptyRow.innerHTML = `
                    <td colspan="7">
                        <div class="empty-state">
                            <i class="fas fa-search"></i>
                            <p>Keine Ergebnisse für "${searchValue}" gefunden</p>
                        </div>
                    </td>
                `;
                tbody.appendChild(newEmptyRow);
            } else {
                emptyStateRow.style.display = '';
                emptyStateRow.querySelector('.empty-state p').textContent = `Keine Ergebnisse für "${searchValue}" gefunden`;
            }
        } else if (emptyStateRow) {
            // Leerer-Zustand ausblenden, wenn Ergebnisse vorhanden sind
            emptyStateRow.style.display = 'none';
        }
    }
    
    /**
     * Exportiert die Lernenden-Daten als CSV- oder JSON-Datei
     */
    function _handleExportLearners() {
        // Modal mit Export-Optionen anzeigen
        window.ImmoLMS.Modal.show({
            title: 'Lernende exportieren',
            content: `
                <div class="export-options">
                    <div class="option-group">
                        <h3>Format auswählen</h3>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="export-format" value="csv" checked>
                                CSV-Datei
                            </label>
                            <label>
                                <input type="radio" name="export-format" value="json">
                                JSON-Datei
                            </label>
                        </div>
                    </div>
                    
                    <div class="option-group">
                        <h3>Zu exportierende Daten</h3>
                        <div class="checkbox-group">
                            <label>
                                <input type="checkbox" name="export-field" value="name" checked>
                                Name
                            </label>
                            <label>
                                <input type="checkbox" name="export-field" value="email" checked>
                                E-Mail
                            </label>
                            <label>
                                <input type="checkbox" name="export-field" value="team" checked>
                                Team
                            </label>
                            <label>
                                <input type="checkbox" name="export-field" value="tests" checked>
                                Testzuweisungen
                            </label>
                            <label>
                                <input type="checkbox" name="export-field" value="results" checked>
                                Testergebnisse
                            </label>
                        </div>
                    </div>
                </div>
            `,
            buttons: [
                {
                    label: 'Abbrechen',
                    class: 'btn secondary-btn',
                    action: 'close'
                },
                {
                    label: 'Exportieren',
                    class: 'btn primary-btn',
                    action: function() {
                        // Format ermitteln
                        const format = document.querySelector('input[name="export-format"]:checked').value;
                        
                        // Felder ermitteln
                        const fields = Array.from(document.querySelectorAll('input[name="export-field"]:checked'))
                            .map(checkbox => checkbox.value);
                        
                        // Export durchführen
                        _exportLearnerData(format, fields);
                        
                        window.ImmoLMS.Modal.close();
                    }
                }
            ]
        });
    }
    
    /**
     * Exportiert die Lernenden-Daten im gewünschten Format
     * @param {string} format - Das Exportformat ('csv' oder 'json')
     * @param {Array<string>} fields - Die zu exportierenden Felder
     */
    function _exportLearnerData(format, fields) {
        // Daten aufbereiten
        const exportData = _assignedLearners.map(learner => {
            const learnerData = {};
            
            // Nur die ausgewählten Felder hinzufügen
            if (fields.includes('name')) learnerData.name = learner.name;
            if (fields.includes('email')) learnerData.email = learner.email;
            if (fields.includes('team')) learnerData.team = learner.team || '';
            
            // Testzuweisungen und -ergebnisse hinzufügen
            if (fields.includes('tests') || fields.includes('results')) {
                const learnerTests = window.ImmoLMS.DataService.getLearnerTests(learner.id);
                
                if (fields.includes('tests')) {
                    learnerData.assignedTests = learnerTests.length;
                    learnerData.completedTests = learnerTests.filter(test => test.status === 'completed').length;
                }
                
                if (fields.includes('results')) {
                    const completedTests = learnerTests.filter(test => test.status === 'completed' && test.score !== undefined);
                    if (completedTests.length > 0) {
                        const totalScore = completedTests.reduce((sum, test) => sum + test.score, 0);
                        learnerData.averageScore = (totalScore / completedTests.length).toFixed(1);
                    } else {
                        learnerData.averageScore = 0;
                    }
                }
            }
            
            return learnerData;
        });
        
        // Exportieren
        if (format === 'csv') {
            _downloadCSV(exportData);
        } else {
            _downloadJSON(exportData);
        }
    }
    
    /**
     * Lädt die Daten als CSV-Datei herunter
     * @param {Array<Object>} data - Die zu exportierenden Daten
     */
    function _downloadCSV(data) {
        if (data.length === 0) {
            window.ImmoLMS.Notifications.showWarning('Keine Daten zum Exportieren vorhanden.');
            return;
        }
        
        // Header bestimmen (aus den Schlüsseln des ersten Objekts)
        const headers = Object.keys(data[0]);
        
        // CSV-Zeilen erstellen
        const csvRows = [];
        
        // Header-Zeile hinzufügen
        csvRows.push(headers.join(','));
        
        // Datenzeilen hinzufügen
        for (const item of data) {
            const values = headers.map(header => {
                const value = item[header];
                // Werte mit Kommas in Anführungszeichen setzen
                return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
            });
            csvRows.push(values.join(','));
        }
        
        // CSV-String erstellen
        const csvString = csvRows.join('\n');
        
        // Datei erstellen und herunterladen
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `learners_export_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        window.ImmoLMS.Notifications.showSuccess('Daten wurden als CSV exportiert.');
    }
    
    /**
     * Lädt die Daten als JSON-Datei herunter
     * @param {Array<Object>} data - Die zu exportierenden Daten
     */
    function _downloadJSON(data) {
        if (data.length === 0) {
            window.ImmoLMS.Notifications.showWarning('Keine Daten zum Exportieren vorhanden.');
            return;
        }
        
        // JSON-String erstellen
        const jsonString = JSON.stringify(data, null, 2);
        
        // Datei erstellen und herunterladen
        const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `learners_export_${new Date().toISOString().split('T')[0]}.json`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        window.ImmoLMS.Notifications.showSuccess('Daten wurden als JSON exportiert.');
    }
    
    // Event-Handler für Aktionen (Stubs für zukünftige Implementierung)
    function _handleCreateNewTest() {
        window.location.href = '#/tests/create';
    }
    
    function _handleDashboardSettings() {
        // Hier würde ein Modal mit Dashboard-Einstellungen angezeigt werden
        console.log('Dashboard-Einstellungen öffnen');
    }
    
    function _handleQuickAction(e) {
        const actionId = e.currentTarget.id;
        
        switch (actionId) {
            case 'create-test-btn':
                window.location.href = '#/tests/create';
                break;
            case 'review-submissions-btn':
                window.location.href = '#/reviews';
                break;
            case 'assign-test-btn':
                window.location.href = '#/tests/assign';
                break;
            case 'create-report-btn':
                window.location.href = '#/reports/create';
                break;
            case 'view-learners-btn':
                window.location.href = '#/learners';
                break;
            case 'view-test-library-btn':
                window.location.href = '#/tests/library';
                break;
            default:
                console.log('Unbekannte Schnellzugriffsaktion:', actionId);
        }
    }
    
    function _handleViewAllReviews() {
        window.location.href = '#/reviews';
    }
    
    function _handleReviewAssessment(e) {
        const assessmentId = e.currentTarget.dataset.id;
        window.location.href = `#/reviews/${assessmentId}`;
    }
    
    function _handleViewActivityDetails(e) {
        const activityId = e.currentTarget.dataset.id;
        window.location.href = `#/activities/${activityId}`;
    }
    
    function _handleViewLearnerTests(learnerId) {
        window.location.href = `#/learners/${learnerId}/tests`;
    }
    
    function _handleAssignTest(learnerId) {
        window.location.href = `#/tests/assign?learner=${learnerId}`;
    }
    
    function _handleCreateLearnerReport(learnerId) {
        window.location.href = `#/reports/create?learner=${learnerId}`;
    }
    
    function _handleViewLearnerProfile(learnerId) {
        window.location.href = `#/learners/${learnerId}`;
    }
    
    function _handleSendMessage(learnerId) {
        // Hier würde ein Modal zum Senden einer Nachricht angezeigt werden
        console.log('Nachricht an Lernenden senden:', learnerId);
    }
    
    function _handleRemoveLearner(learnerId) {
        // Bestätigungsdialog anzeigen
        window.ImmoLMS.Modal.confirm({
            title: 'Lernenden entfernen',
            message: 'Möchten Sie diesen Lernenden wirklich aus Ihrer Gruppe entfernen?',
            confirmButton: 'Entfernen',
            cancelButton: 'Abbrechen',
            onConfirm: function() {
                // Lernenden entfernen
                window.ImmoLMS.DataService.removeLearnerFromTrainer(learnerId, _currentUser.id)
                    .then(success => {
                        if (success) {
                            // Lernenden aus der Liste entfernen
                            _assignedLearners = _assignedLearners.filter(learner => learner.id !== learnerId);
                            
                            // UI aktualisieren
                            _renderLearnersOverview();
                            _calculateDashboardStats();
                            _updateStatCards();
                            
                            window.ImmoLMS.Notifications.showSuccess('Lernender wurde erfolgreich entfernt.');
                        } else {
                            window.ImmoLMS.Notifications.showError('Beim Entfernen des Lernenden ist ein Fehler aufgetreten.');
                        }
                    });
            }
        });
    }
    
    function _handleMarkNotificationRead(e) {
        const notificationId = e.currentTarget.dataset.id;
        window.ImmoLMS.NotificationService.markAsRead(notificationId);
        
        // UI aktualisieren
        const notificationItem = e.currentTarget.closest('.notification-item');
        notificationItem.classList.remove('unread');
        notificationItem.classList.add('read');
        
        // Button aktualisieren
        const markUnreadBtn = document.createElement('button');
        markUnreadBtn.className = 'btn icon-btn mark-unread-btn';
        markUnreadBtn.title = 'Als ungelesen markieren';
        markUnreadBtn.dataset.id = notificationId;
        markUnreadBtn.innerHTML = '<i class="fas fa-envelope"></i>';
        markUnreadBtn.addEventListener('click', _handleMarkNotificationUnread);
        
        e.currentTarget.replaceWith(markUnreadBtn);
        
        // Anzahl der ungelesenen Benachrichtigungen aktualisieren
        const notifications = window.ImmoLMS.NotificationService.getNotifications(_currentUser.id);
        const unreadCount = notifications.filter(notification => !notification.read).length;
        const notificationBadge = document.querySelector('.notification-badge');
        if (notificationBadge) {
            notificationBadge.textContent = unreadCount;
            notificationBadge.style.display = unreadCount > 0 ? 'block' : 'none';
        }
    }
    
    function _handleMarkNotificationUnread(e) {
        const notificationId = e.currentTarget.dataset.id;
        window.ImmoLMS.NotificationService.markAsUnread(notificationId);
        
        // UI aktualisieren
        const notificationItem = e.currentTarget.closest('.notification-item');
        notificationItem.classList.remove('read');
        notificationItem.classList.add('unread');
        
        // Button aktualisieren
        const markReadBtn = document.createElement('button');
        markReadBtn.className = 'btn icon-btn mark-read-btn';
        markReadBtn.title = 'Als gelesen markieren';
        markReadBtn.dataset.id = notificationId;
        markReadBtn.innerHTML = '<i class="fas fa-envelope-open"></i>';
        markReadBtn.addEventListener('click', _handleMarkNotificationRead);
        
        e.currentTarget.replaceWith(markReadBtn);
        
        // Anzahl der ungelesenen Benachrichtigungen aktualisieren
        const notifications = window.ImmoLMS.NotificationService.getNotifications(_currentUser.id);
        const unreadCount = notifications.filter(notification => !notification.read).length;
        const notificationBadge = document.querySelector('.notification-badge');
        if (notificationBadge) {
            notificationBadge.textContent = unreadCount;
            notificationBadge.style.display = unreadCount > 0 ? 'block' : 'none';
        }
    }
    
    function _handleDeleteNotification(e) {
        const notificationId = e.currentTarget.dataset.id;
        
        // Bestätigungsdialog anzeigen
        window.ImmoLMS.Modal.confirm({
            title: 'Benachrichtigung löschen',
            message: 'Möchten Sie diese Benachrichtigung wirklich löschen?',
            confirmButton: 'Löschen',
            cancelButton: 'Abbrechen',
            onConfirm: function() {
                window.ImmoLMS.NotificationService.deleteNotification(notificationId);
                
                // Element aus dem DOM entfernen
                const notificationItem = e.currentTarget.closest('.notification-item');
                notificationItem.remove();
                
                // Anzahl der ungelesenen Benachrichtigungen aktualisieren
                const notifications = window.ImmoLMS.NotificationService.getNotifications(_currentUser.id);
                const unreadCount = notifications.filter(notification => !notification.read).length;
                const notificationBadge = document.querySelector('.notification-badge');
                if (notificationBadge) {
                    notificationBadge.textContent = unreadCount;
                    notificationBadge.style.display = unreadCount > 0 ? 'block' : 'none';
                }
                
                // Leerer-Zustand anzeigen, wenn keine Benachrichtigungen mehr vorhanden sind
                if (notifications.length === 0) {
                    const notificationsList = document.getElementById('notifications-list');
                    if (notificationsList) {
                        notificationsList.innerHTML = `
                            <li class="empty-state">
                                <i class="fas fa-bell-slash"></i>
                                <p>Keine neuen Benachrichtigungen</p>
                            </li>
                        `;
                    }
                }
            }
        });
    }
    
    /**
     * Aktualisiert das Dashboard mit den neuesten Daten
     * @returns {Promise<void>}
     */
    async function refresh() {
        // Daten neu laden
        await _loadDashboardData();
        
        // UI-Komponenten aktualisieren
        _renderDashboardComponents();
        
        window.ImmoLMS.Notifications.showInfo('Dashboard wurde aktualisiert.');
    }
    
    // Vorhandenes Modul erweitern
    Object.assign(Dashboard, {
        _registerEventListeners: _registerEventListeners,
        _renderRecentActivities: _renderRecentActivities,
        _renderLearnersOverview: _renderLearnersOverview,
        refresh: refresh
    });
})();
/**
 * JS-Block 7.1.2-part1: Trainer-Dashboard Datenvisualisierung (Teil 1)
 * ImmoScout24 E-Learning Projekt
 * 
 * Dieses Modul implementiert visuelle Datenrepräsentationen für das Trainer-Dashboard,
 * einschließlich Diagrammen und interaktiven Grafiken zur Analyse von Lern- und Testdaten.
 */

// Namespace für Dashboard-Visualisierungen
if (!window.ImmoLMS) window.ImmoLMS = {};
if (!window.ImmoLMS.Trainer) window.ImmoLMS.Trainer = {};
if (!window.ImmoLMS.Trainer.Visualization) window.ImmoLMS.Trainer.Visualization = {};

window.ImmoLMS.Trainer.Visualization = (function() {
    'use strict';
    
    // Private Variablen
    let _initialized = false;
    let _currentUser = null;
    let _chartInstances = {
        performanceChart: null,
        testCompletionChart: null,
        passRateChart: null,
        categoryPerformanceChart: null,
        weeklyActivityChart: null,
        monthlyProgressChart: null
    };
    let _colorPalette = {
        primary: '#00FFD0',        // ImmoScout24 Hauptfarbe
        secondary: '#087885',      // Sekundärfarbe
        accent: '#FF5A5F',         // Akzentfarbe
        neutral: '#333333',        // Neutral
        success: '#4CAF50',        // Erfolg
        warning: '#FFC107',        // Warnung
        danger: '#FF5252',         // Gefahr
        lightGrey: '#E0E0E0',      // Heller Hintergrund
        dataColors: [              // Farben für Datenserien
            '#00FFD0', '#087885', '#36A2EB', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#7BDCB5', '#8ED1FC'
        ]
    };
    
    // DOM-Element-Cache
    const _elements = {
        dashboardContainer: null,
        performanceChartContainer: null,
        testCompletionChartContainer: null,
        passRateChartContainer: null,
        categoryChartContainer: null,
        weeklyActivityChartContainer: null,
        monthlyProgressChartContainer: null,
        datePickers: null,
        filterControls: null
    };
    
    // Konfigurations-Standardwerte
    const _defaultConfig = {
        timeRange: 'last30days',       // 'last7days', 'last30days', 'last90days', 'thisYear'
        groupBy: 'day',                // 'day', 'week', 'month'
        dataDetail: 'summary',         // 'summary', 'detailed'
        includePending: true,          // Pendente Bewertungen einbeziehen
        filterByCategory: 'all',       // 'all' oder spezifische Kategorie-ID
        filterByTeam: 'all',           // 'all' oder spezifische Team-ID
        animationDuration: 800,        // Animationsdauer in ms
        responsiveCharts: true         // Responsive Charts 
    };
    
    // Aktuelle Konfiguration
    let _config = { ..._defaultConfig };
    
    /**
     * Initialisiert das Visualisierungsmodul
     * @param {Object} user - Das Benutzerobjekt des aktuellen Trainers
     * @param {Object} config - Optionale Konfigurationseinstellungen
     * @returns {Promise<boolean>} - Promise, das nach Abschluss der Initialisierung erfüllt wird
     */
    async function initialize(user, config = {}) {
        if (_initialized) return true;
        
        try {
            _currentUser = user;
            
            // Konfiguration mit übergebenen Werten überschreiben
            _config = { ..._defaultConfig, ...config };
            
            // DOM-Elemente cachen
            _cacheDOMElements();
            
            // Dashboard-Struktur um Visualisierungsbereich erweitern
            _createVisualizationSection();
            
            // Event-Listener registrieren
            _registerEventListeners();
            
            // Diagramme initialisieren und rendern
            await _initializeCharts();
            
            _initialized = true;
            return true;
        } catch (error) {
            console.error('Fehler bei der Initialisierung des Visualisierungsmoduls:', error);
            window.ImmoLMS.Notifications.showError('Die Dashboard-Visualisierungen konnten nicht initialisiert werden.');
            return false;
        }
    }
    
    /**
     * Speichert Referenzen zu DOM-Elementen
     */
    function _cacheDOMElements() {
        _elements.dashboardContainer = document.getElementById('trainer-dashboard');
        
        // Weitere Elemente werden nach dem Erstellen der Visualisierungssektion zwischengespeichert
    }
    
    /**
     * Erstellt die DOM-Struktur für die Visualisierungssektion
     */
    function _createVisualizationSection() {
        // Nur fortfahren, wenn der Dashboard-Container existiert
        if (!_elements.dashboardContainer) return;
        
        // Prüfen, ob bereits eine Visualisierungssektion existiert
        let visualizationSection = document.getElementById('visualization-section');
        if (visualizationSection) {
            // Vorhandene Sektion leeren
            visualizationSection.innerHTML = '';
        } else {
            // Neue Sektion erstellen und einfügen
            visualizationSection = document.createElement('section');
            visualizationSection.id = 'visualization-section';
            visualizationSection.className = 'dashboard-section full-width';
            
            // Nach der Lernenden-Übersicht einfügen
            const learnersSection = document.getElementById('learners-overview');
            if (learnersSection && learnersSection.nextElementSibling) {
                _elements.dashboardContainer.insertBefore(visualizationSection, learnersSection.nextElementSibling);
            } else {
                _elements.dashboardContainer.appendChild(visualizationSection);
            }
        }
        
        // HTML-Struktur für die Visualisierungssektion erstellen
        visualizationSection.innerHTML = `
            <div class="section-header with-controls">
                <h2>Dashboard Visualisierungen</h2>
                <div class="visualization-controls">
                    <div class="control-group">
                        <label for="time-range">Zeitraum:</label>
                        <select id="time-range" class="control-select">
                            <option value="last7days">Letzte 7 Tage</option>
                            <option value="last30days" selected>Letzte 30 Tage</option>
                            <option value="last90days">Letzte 90 Tage</option>
                            <option value="thisYear">Dieses Jahr</option>
                            <option value="custom">Benutzerdefiniert</option>
                        </select>
                    </div>
                    
                    <div class="control-group date-range" style="display: none;">
                        <label for="date-from">Von:</label>
                        <input type="date" id="date-from" class="date-input">
                        <label for="date-to">Bis:</label>
                        <input type="date" id="date-to" class="date-input">
                        <button id="apply-date-range" class="btn secondary-btn">Anwenden</button>
                    </div>
                    
                    <div class="control-group">
                        <label for="grouping">Gruppieren nach:</label>
                        <select id="grouping" class="control-select">
                            <option value="day">Tag</option>
                            <option value="week">Woche</option>
                            <option value="month">Monat</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="chart-filter">Filter:</label>
                        <select id="chart-filter" class="control-select">
                            <option value="all">Alle Kategorien</option>
                            <!-- Dynamisch gefüllt -->
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="include-pending" checked>
                            Offene Bewertungen einbeziehen
                        </label>
                    </div>
                    
                    <button id="refresh-charts" class="btn icon-btn" title="Aktualisieren">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
            </div>
            
            <div class="visualization-grid">
                <!-- Leistungsübersicht -->
                <div class="visualization-card">
                    <div class="card-header">
                        <h3>Gesamtleistung</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="performance" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="performance">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-details" data-chart="performance">Details umschalten</a>
                                    <a href="#" data-action="reset-zoom" data-chart="performance">Zoom zurücksetzen</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="performance-chart-container" class="chart-container">
                            <canvas id="performance-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Test-Abschlussrate -->
                <div class="visualization-card">
                    <div class="card-header">
                        <h3>Test-Abschlussrate</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="completion" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="completion">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-view" data-chart="completion">Diagrammtyp ändern</a>
                                    <a href="#" data-action="reset-zoom" data-chart="completion">Zoom zurücksetzen</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="test-completion-chart-container" class="chart-container">
                            <canvas id="test-completion-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Bestehensquote -->
                <div class="visualization-card">
                    <div class="card-header">
                        <h3>Bestehensquote</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="passrate" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="passrate">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-view" data-chart="passrate">Diagrammtyp ändern</a>
                                    <a href="#" data-action="export-data" data-chart="passrate">Daten exportieren</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="pass-rate-chart-container" class="chart-container">
                            <canvas id="pass-rate-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Kategorie-Leistung -->
                <div class="visualization-card">
                    <div class="card-header">
                        <h3>Leistung nach Kategorie</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="category" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="category">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-view" data-chart="category">Diagrammtyp ändern</a>
                                    <a href="#" data-action="export-data" data-chart="category">Daten exportieren</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="category-performance-chart-container" class="chart-container">
                            <canvas id="category-performance-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Wöchentliche Aktivität -->
                <div class="visualization-card wide-card">
                    <div class="card-header">
                        <h3>Wöchentliche Testaktivität</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="weekly" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="weekly">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-details" data-chart="weekly">Details umschalten</a>
                                    <a href="#" data-action="export-data" data-chart="weekly">Daten exportieren</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="weekly-activity-chart-container" class="chart-container">
                            <canvas id="weekly-activity-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Monatlicher Fortschritt -->
                <div class="visualization-card wide-card">
                    <div class="card-header">
                        <h3>Monatlicher Lernfortschritt</h3>
                        <div class="card-actions">
                            <button class="btn icon-btn chart-info-btn" data-chart="monthly" title="Info">
                                <i class="fas fa-info-circle"></i>
                            </button>
                            <div class="dropdown">
                                <button class="btn icon-btn dropdown-toggle" title="Optionen">
                                    <i class="fas fa-ellipsis-v"></i>
                                </button>
                                <div class="dropdown-menu">
                                    <a href="#" data-action="download-chart" data-chart="monthly">Als Bild herunterladen</a>
                                    <a href="#" data-action="toggle-view" data-chart="monthly">Diagrammtyp ändern</a>
                                    <a href="#" data-action="export-data" data-chart="monthly">Daten exportieren</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="monthly-progress-chart-container" class="chart-container">
                            <canvas id="monthly-progress-chart"></canvas>
                            <div class="chart-loading">
                                <div class="spinner"></div>
                                <p>Daten werden geladen...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // DOM-Elemente nach dem Erstellen zwischenspeichern
        _cacheDOMElementsAfterCreation();
    }
    
    /**
     * Speichert Referenzen zu DOM-Elementen nach der Erstellung der Visualisierungssektion
     */
    function _cacheDOMElementsAfterCreation() {
        _elements.performanceChartContainer = document.getElementById('performance-chart-container');
        _elements.testCompletionChartContainer = document.getElementById('test-completion-chart-container');
        _elements.passRateChartContainer = document.getElementById('pass-rate-chart-container');
        _elements.categoryChartContainer = document.getElementById('category-performance-chart-container');
        _elements.weeklyActivityChartContainer = document.getElementById('weekly-activity-chart-container');
        _elements.monthlyProgressChartContainer = document.getElementById('monthly-progress-chart-container');
        
        _elements.datePickers = {
            from: document.getElementById('date-from'),
            to: document.getElementById('date-to'),
            applyBtn: document.getElementById('apply-date-range')
        };
        
        _elements.filterControls = {
            timeRange: document.getElementById('time-range'),
            grouping: document.getElementById('grouping'),
            chartFilter: document.getElementById('chart-filter'),
            includePending: document.getElementById('include-pending'),
            refreshBtn: document.getElementById('refresh-charts')
        };
    }
    
    /**
     * Registriert Event-Listener für die Visualisierungselemente
     */
    function _registerEventListeners() {
        // Prüfen, ob die Filter-Elemente existieren
        if (!_elements.filterControls) return;
        
        // Event-Listener für den Zeitraum
        _elements.filterControls.timeRange.addEventListener('change', (e) => {
            const value = e.target.value;
            _config.timeRange = value;
            
            // Datumspicker anzeigen/ausblenden für benutzerdefinierte Zeiträume
            const dateRangeControls = document.querySelector('.date-range');
            if (dateRangeControls) {
                dateRangeControls.style.display = value === 'custom' ? 'flex' : 'none';
            }
            
            // Diagramme aktualisieren, wenn kein benutzerdefinierter Zeitraum ausgewählt ist
            if (value !== 'custom') {
                _refreshAllCharts();
            }
        });
        
        // Event-Listener für die Datumspicker
        if (_elements.datePickers.applyBtn) {
            _elements.datePickers.applyBtn.addEventListener('click', () => {
                const fromDate = _elements.datePickers.from.value;
                const toDate = _elements.datePickers.to.value;
                
                if (fromDate && toDate) {
                    _config.customDateRange = {
                        from: fromDate,
                        to: toDate
                    };
                    _refreshAllCharts();
                } else {
                    window.ImmoLMS.Notifications.showWarning('Bitte wählen Sie ein gültiges Datum aus.');
                }
            });
            
            // Heutige und vorherige Daten setzen
            const today = new Date();
            const lastMonth = new Date();
            lastMonth.setMonth(today.getMonth() - 1);
            
            _elements.datePickers.to.value = today.toISOString().split('T')[0];
            _elements.datePickers.from.value = lastMonth.toISOString().split('T')[0];
        }
        
        // Event-Listener für die Gruppierung
        _elements.filterControls.grouping.addEventListener('change', (e) => {
            _config.groupBy = e.target.value;
            _refreshAllCharts();
        });
        
        // Event-Listener für den Filter
        _elements.filterControls.chartFilter.addEventListener('change', (e) => {
            _config.filterByCategory = e.target.value;
            _refreshAllCharts();
        });
        
        // Event-Listener für die Einbeziehung offener Bewertungen
        _elements.filterControls.includePending.addEventListener('change', (e) => {
            _config.includePending = e.target.checked;
            _refreshAllCharts();
        });
        
        // Event-Listener für die Aktualisierung
        _elements.filterControls.refreshBtn.addEventListener('click', () => {
            _refreshAllCharts(true); // true = Daten neu laden
        });
        
        // Event-Listener für Diagramm-Info-Buttons
        const chartInfoButtons = document.querySelectorAll('.chart-info-btn');
        chartInfoButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const chartType = e.currentTarget.dataset.chart;
                _showChartInfo(chartType);
            });
        });
        
        // Event-Listener für Dropdown-Toggles
        const dropdownToggles = document.querySelectorAll('.visualization-grid .dropdown-toggle');
        dropdownToggles.forEach(toggle => {
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Alle anderen Dropdown-Menüs schließen
                document.querySelectorAll('.visualization-grid .dropdown-menu.active').forEach(menu => {
                    if (menu !== e.currentTarget.nextElementSibling) {
                        menu.classList.remove('active');
                    }
                });
                
                // Aktuelles Dropdown-Menü umschalten
                e.currentTarget.nextElementSibling.classList.toggle('active');
            });
        });
        
        // Event-Listener für Dropdown-Aktionen
        const dropdownActions = document.querySelectorAll('.visualization-grid .dropdown-menu a');
        dropdownActions.forEach(action => {
            action.addEventListener('click', (e) => {
                e.preventDefault();
                
                const actionType = e.currentTarget.dataset.action;
                const chartType = e.currentTarget.dataset.chart;
                
                switch (actionType) {
                    case 'download-chart':
                        _downloadChart(chartType);
                        break;
                    case 'toggle-view':
                        _toggleChartView(chartType);
                        break;
                    case 'toggle-details':
                        _toggleChartDetails(chartType);
                        break;
                    case 'reset-zoom':
                        _resetChartZoom(chartType);
                        break;
                    case 'export-data':
                        _exportChartData(chartType);
                        break;
                }
                
                // Dropdown-Menü schließen
                e.currentTarget.parentElement.classList.remove('active');
            });
        });
        
        // Klick außerhalb schließt alle Dropdown-Menüs
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.visualization-grid .dropdown')) {
                document.querySelectorAll('.visualization-grid .dropdown-menu.active').forEach(menu => {
                    menu.classList.remove('active');
                });
            }
        });
        
        // Kategorien für den Filter laden
        _loadCategories();
    }
    
    /**
     * Lädt verfügbare Testkategorien für den Filter
     */
    function _loadCategories() {
        const filterDropdown = _elements.filterControls.chartFilter;
        if (!filterDropdown) return;
        
        // Kategorien abrufen
        const categories = window.ImmoLMS.DataService.getTestCategories();
        
        // Dropdown leeren (außer "Alle Kategorien" Option)
        while (filterDropdown.options.length > 1) {
            filterDropdown.remove(1);
        }
        
        // Kategorien hinzufügen
        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            filterDropdown.appendChild(option);
        });
    }
    
    /**
     * Initialisiert und rendert alle Diagramme
     * @returns {Promise<void>}
     */
    async function _initializeCharts() {
        // Chart.js konfigurieren
        Chart.defaults.font.family = "'Roboto', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif";
        Chart.defaults.color = '#333333';
        Chart.defaults.responsive = _config.responsiveCharts;
        Chart.defaults.maintainAspectRatio = false;
        
        // Daten für die Diagramme laden
        const data = await _loadChartData();
        
        // Lade-Indikatoren ausblenden
        document.querySelectorAll('.chart-loading').forEach(loader => {
            loader.style.display = 'none';
        });
        
        // Diagramme erstellen und rendern
        _createPerformanceChart(data);
        _createTestCompletionChart(data);
        _createPassRateChart(data);
        _createCategoryPerformanceChart(data);
        _createWeeklyActivityChart(data);
        _createMonthlyProgressChart(data);
    }
    
    /**
     * Lädt die Daten für alle Diagramme
     * @param {boolean} forceReload - Wenn true, werden die Daten neu geladen
     * @returns {Promise<Object>} - Objekt mit allen Daten für die Diagramme
     */
    async function _loadChartData(forceReload = false) {
        try {
            // Zeitraum basierend auf der Konfiguration bestimmen
            const timeRange = _getTimeRangeForQuery();
            
            // Basisparameter für alle Abfragen
            const baseParams = {
                trainerId: _currentUser.id,
                startDate: timeRange.startDate,
                endDate: timeRange.endDate,
                includePending: _config.includePending,
                filterByCategory: _config.filterByCategory !== 'all' ? _config.filterByCategory : null,
                filterByTeam: _config.filterByTeam !== 'all' ? _config.filterByTeam : null,
                groupBy: _config.groupBy,
                forceReload: forceReload
            };
            
            // Parallele Datenabfragen ausführen für bessere Performance
            const [
                performanceData,
                completionData,
                passRateData,
                categoryData,
                weeklyActivityData,
                monthlyProgressData
            ] = await Promise.all([
                window.ImmoLMS.DataService.getTrainerPerformanceData(baseParams),
                window.ImmoLMS.DataService.getTestCompletionData(baseParams),
                window.ImmoLMS.DataService.getPassRateData(baseParams),
                window.ImmoLMS.DataService.getCategoryPerformanceData(baseParams),
                window.ImmoLMS.DataService.getWeeklyActivityData(baseParams),
                window.ImmoLMS.DataService.getMonthlyProgressData(baseParams)
            ]);
            
            return {
                performance: performanceData,
                completion: completionData,
                passRate: passRateData,
                category: categoryData,
                weeklyActivity: weeklyActivityData,
                monthlyProgress: monthlyProgressData
            };
        } catch (error) {
            console.error('Fehler beim Laden der Diagrammdaten:', error);
            window.ImmoLMS.Notifications.showError('Die Diagrammdaten konnten nicht geladen werden.');
            
            // Leere Datenstruktur zurückgeben, damit die Diagramme nicht abstürzen
            return {
                performance: { labels: [], datasets: [] },
                completion: { labels: [], datasets: [] },
                passRate: { labels: [], datasets: [] },
                category: { labels: [], datasets: [] },
                weeklyActivity: { labels: [], datasets: [] },
                monthlyProgress: { labels: [], datasets: [] }
            };
        }
    }
    
    /**
     * Bestimmt den Zeitraum für die Datenanfragen basierend auf der Konfiguration
     * @returns {Object} - Objekt mit Start- und Enddatum
     */
    function _getTimeRangeForQuery() {
        const endDate = new Date();
        let startDate = new Date();
        
        // Zeitraum basierend auf der Konfiguration festlegen
        switch (_config.timeRange) {
            case 'last7days':
                startDate.setDate(endDate.getDate() - 7);
                break;
            case 'last30days':
                startDate.setDate(endDate.getDate() - 30);
                break;
            case 'last90days':
                startDate.setDate(endDate.getDate() - 90);
                break;
            case 'thisYear':
                startDate = new Date(endDate.getFullYear(), 0, 1); // 1. Januar des aktuellen Jahres
                break;
            case 'custom':
                if (_config.customDateRange) {
                    startDate = new Date(_config.customDateRange.from);
                    endDate = new Date(_config.customDateRange.to);
                } else {
                    // Fallback auf letzte 30 Tage
                    startDate.setDate(endDate.getDate() - 30);
                }
                break;
        }
        
        // Formatiere Datum als ISO-String (YYYY-MM-DD)
        return {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0]
        };
    }
    
    /**
     * Erstellt das Gesamtleistungs-Diagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createPerformanceChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.performanceChart) {
            _chartInstances.performanceChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'line',
            data: data.performance,
            options: {
                plugins: {
                    title: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += context.parsed.y.toFixed(1) + '%';
                                return label;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                animations: {
                    tension: {
                        duration: _config.animationDuration,
                        easing: 'easeOutQuad',
                        from: 0.8,
                        to: 0.2,
                        loop: false
                    }
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.performanceChart = new Chart(ctx, config);
    }
    
    /**
     * Erstellt das Test-Abschlussraten-Diagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createTestCompletionChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.testCompletionChart) {
            _chartInstances.testCompletionChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('test-completion-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'doughnut',
            data: data.completion,
            options: {
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.parsed || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${percentage}% (${value})`;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                cutout: '70%',
                animations: {
                    animateRotate: true,
                    animateScale: true
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.testCompletionChart = new Chart(ctx, config);
    }
    
    /**
     * Erstellt das Bestehensquoten-Diagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createPassRateChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.passRateChart) {
            _chartInstances.passRateChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('pass-rate-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'bar',
            data: data.passRate,
            options: {
                indexAxis: 'y',
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += context.parsed.x.toFixed(1) + '%';
                                return label;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    },
                    y: {
                        grid: {
                            display: false
                        }
                    }
                },
                animations: {
                    y: {
                        easing: 'easeInOutQuad',
                        duration: _config.animationDuration
                    }
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.passRateChart = new Chart(ctx, config);
    }
    
    /**
     * Erstellt das Kategorie-Leistungs-Diagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createCategoryPerformanceChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.categoryPerformanceChart) {
            _chartInstances.categoryPerformanceChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('category-performance-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'radar',
            data: data.category,
            options: {
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += context.parsed.r.toFixed(1) + '%';
                                return label;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            stepSize: 20,
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        pointLabels: {
                            font: {
                                size: 12
                            }
                        }
                    }
                },
                elements: {
                    line: {
                        tension: 0.2
                    }
                },
                animation: {
                    duration: _config.animationDuration
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.categoryPerformanceChart = new Chart(ctx, config);
    }
    
    /**
     * Erstellt das wöchentliche Aktivitätsdiagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createWeeklyActivityChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.weeklyActivityChart) {
            _chartInstances.weeklyActivityChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('weekly-activity-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'bar',
            data: data.weeklyActivity,
            options: {
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: {
                            precision: 0
                        }
                    }
                },
                responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                animation: {
                    duration: _config.animationDuration
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.weeklyActivityChart = new Chart(ctx, config);
    }
    
    /**
     * Erstellt das monatliche Fortschrittsdiagramm
     * @param {Object} data - Die für das Diagramm zu verwendenden Daten
     */
    function _createMonthlyProgressChart(data) {
        // Bestehende Instanz zerstören, falls vorhanden
        if (_chartInstances.monthlyProgressChart) {
            _chartInstances.monthlyProgressChart.destroy();
        }
        
        // Canvas-Element abrufen
        const ctx = document.getElementById('monthly-progress-chart').getContext('2d');
        
        // Diagrammkonfiguration
        const config = {
            type: 'line',
            data: data.monthlyProgress,
            options: {
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.dataset.yAxisID === 'y-axis-1') {
                                    label += context.parsed.y.toFixed(1) + '%';
                                } else {
                                    label += context.parsed.y;
                                }
                                return label;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        id: 'y-axis-1',
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    },
                    y1: {
                        id: 'y-axis-2',
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            precision: 0
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                animations: {
                    tension: {
                        duration: _config.animationDuration,
                        easing: 'easeOutQuad',
                        from: 0.8,
                        to: 0.2,
                        loop: false
                    }
                }
            }
        };
        
        // Diagramm erstellen
        _chartInstances.monthlyProgressChart = new Chart(ctx, config);
    }
    
    /**
     * Aktualisiert alle Diagramme mit neuen Daten
     * @param {boolean} forceReload - Wenn true, werden die Daten neu geladen
     */
    async function _refreshAllCharts(forceReload = false) {
        try {
            // Lade-Indikatoren anzeigen
            document.querySelectorAll('.chart-loading').forEach(loader => {
                loader.style.display = 'flex';
            });
            
            // Daten neu laden
            const data = await _loadChartData(forceReload);
            
            // Diagramme aktualisieren
            _updateChartData('performanceChart', data.performance);
            _updateChartData('testCompletionChart', data.completion);
            _updateChartData('passRateChart', data.passRate);
            _updateChartData('categoryPerformanceChart', data.category);
            _updateChartData('weeklyActivityChart', data.weeklyActivity);
            _updateChartData('monthlyProgressChart', data.monthlyProgress);
            
            // Lade-Indikatoren ausblenden
            document.querySelectorAll('.chart-loading').forEach(loader => {
                loader.style.display = 'none';
            });
            
            window.ImmoLMS.Notifications.showSuccess('Diagramme wurden aktualisiert.');
        } catch (error) {
            console.error('Fehler beim Aktualisieren der Diagramme:', error);
            window.ImmoLMS.Notifications.showError('Die Diagramme konnten nicht aktualisiert werden.');
            
            // Lade-Indikatoren ausblenden
            document.querySelectorAll('.chart-loading').forEach(loader => {
                loader.style.display = 'none';
            });
        }
    }
    
    /**
     * Aktualisiert ein Diagramm mit neuen Daten
     * @param {string} chartKey - Der Schlüssel des zu aktualisierenden Diagramms
     * @param {Object} newData - Die neuen Daten für das Diagramm
     */
    function _updateChartData(chartKey, newData) {
        const chart = _chartInstances[chartKey];
        if (!chart) return;
        
        // Daten aktualisieren
        chart.data.labels = newData.labels;
        
        // Datasets aktualisieren oder hinzufügen
        for (let i = 0; i < newData.datasets.length; i++) {
            if (i < chart.data.datasets.length) {
                // Vorhandenes Dataset aktualisieren
                chart.data.datasets[i].data = newData.datasets[i].data;
                
                // Optional: Weitere Eigenschaften aktualisieren
                if (newData.datasets[i].label) {
                    chart.data.datasets[i].label = newData.datasets[i].label;
                }
                if (newData.datasets[i].backgroundColor) {
                    chart.data.datasets[i].backgroundColor = newData.datasets[i].backgroundColor;
                }
                if (newData.datasets[i].borderColor) {
                    chart.data.datasets[i].borderColor = newData.datasets[i].borderColor;
                }
            } else {
                // Neues Dataset hinzufügen
                chart.data.datasets.push(newData.datasets[i]);
            }
        }
        
        // Überflüssige Datasets entfernen
        if (chart.data.datasets.length > newData.datasets.length) {
            chart.data.datasets = chart.data.datasets.slice(0, newData.datasets.length);
        }
        
        // Diagramm aktualisieren
        chart.update();
    }
    
    /**
     * Zeigt Informationen zu einem Diagramm an
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _showChartInfo(chartType) {
        let title = '';
        let content = '';
        
        switch (chartType) {
            case 'performance':
                title = 'Gesamtleistung - Information';
                content = `
                    <p>Dieses Diagramm zeigt die durchschnittliche Leistung Ihrer Lernenden über den gewählten Zeitraum.</p>
                    <ul>
                        <li><strong>Durchschnittliche Punktzahl:</strong> Durchschnittliche Punktzahl aller abgeschlossenen Tests.</li>
                        <li><strong>Bestanden:</strong> Prozentsatz der bestandenen Tests.</li>
                        <li><strong>Nicht bestanden:</strong> Prozentsatz der nicht bestandenen Tests.</li>
                    </ul>
                    <p>Mit diesem Diagramm können Sie Trends in der Gesamtleistung Ihrer Lernenden identifizieren.</p>
                `;
                break;
            case 'completion':
                title = 'Test-Abschlussrate - Information';
                content = `
                    <p>Dieses Diagramm zeigt die Verteilung der Teststatus für alle zugewiesenen Tests.</p>
                    <ul>
                        <li><strong>Abgeschlossen:</strong> Tests, die vollständig abgeschlossen wurden.</li>
                        <li><strong>In Bearbeitung:</strong> Tests, die begonnen, aber noch nicht abgeschlossen wurden.</li>
                        <li><strong>Nicht begonnen:</strong> Tests, die zugewiesen, aber noch nicht begonnen wurden.</li>
                        <li><strong>Abgelaufen:</strong> Tests, deren Frist abgelaufen ist, ohne dass sie abgeschlossen wurden.</li>
                    </ul>
                    <p>Dieses Diagramm hilft Ihnen, die Gesamtbeteiligung und Abschlussrate zu überwachen.</p>
                `;
                break;
            case 'passrate':
                title = 'Bestehensquote - Information';
                content = `
                    <p>Dieses Diagramm zeigt die Bestehensquote nach Test oder Testkategorie.</p>
                    <p>Sie können hier sehen, welche Tests oder Kategorien die höchsten und niedrigsten Erfolgsraten haben, um zu identifizieren, wo Ihre Lernenden möglicherweise zusätzliche Unterstützung benötigen.</p>
                `;
                break;
            case 'category':
                title = 'Leistung nach Kategorie - Information';
                content = `
                    <p>Dieses Radar-Diagramm zeigt die durchschnittliche Leistung Ihrer Lernenden in verschiedenen Testkategorien.</p>
                    <p>Es ermöglicht Ihnen, auf einen Blick zu erkennen, in welchen Bereichen Ihre Lernenden stark sind und in welchen Bereichen sie möglicherweise Unterstützung benötigen.</p>
                `;
                break;
            case 'weekly':
                title = 'Wöchentliche Testaktivität - Information';
                content = `
                    <p>Dieses Diagramm zeigt die wöchentliche Testaktivität über den gewählten Zeitraum.</p>
                    <ul>
                        <li><strong>Begonnene Tests:</strong> Anzahl der Tests, die in der jeweiligen Woche begonnen wurden.</li>
                        <li><strong>Abgeschlossene Tests:</strong> Anzahl der Tests, die in der jeweiligen Woche abgeschlossen wurden.</li>
                        <li><strong>Bestandene Tests:</strong> Anzahl der Tests, die in der jeweiligen Woche bestanden wurden.</li>
                    </ul>
                    <p>Mit diesem Diagramm können Sie Wochen mit hoher und niedriger Aktivität identifizieren.</p>
                `;
                break;
            case 'monthly':
                title = 'Monatlicher Lernfortschritt - Information';
                content = `
                    <p>Dieses Diagramm zeigt den monatlichen Fortschritt und die Aktivität Ihrer Lernenden.</p>
                    <p>Es kombiniert mehrere Metriken:</p>
                    <ul>
                        <li><strong>Durchschnittliche Punktzahl (%):</strong> Die durchschnittliche Punktzahl aller abgeschlossenen Tests pro Monat.</li>
                        <li><strong>Bestehensquote (%):</strong> Der Prozentsatz der bestandenen Tests pro Monat.</li>
                        <li><strong>Anzahl der Tests:</strong> Die Gesamtzahl der abgeschlossenen Tests pro Monat.</li>
                    </ul>
                    <p>Dieses Diagramm hilft Ihnen, langfristige Trends zu erkennen und den Fortschritt im Verlauf der Zeit zu verfolgen.</p>
                `;
                break;
            default:
                title = 'Diagramm-Information';
                content = 'Keine spezifischen Informationen für dieses Diagramm verfügbar.';
        }
        
        // Modal mit Informationen anzeigen
        window.ImmoLMS.Modal.show({
            title: title,
            content: content,
            width: 'medium',
            buttons: [
                {
                    label: 'Schließen',
                    class: 'btn primary-btn',
                    action: 'close'
                }
            ]
        });
    }
    
    /**
     * Lädt ein Diagramm als Bild herunter
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _downloadChart(chartType) {
        let chartInstance;
        let fileName;
        
        switch (chartType) {
            case 'performance':
                chartInstance = _chartInstances.performanceChart;
                fileName = 'gesamtleistung';
                break;
            case 'completion':
                chartInstance = _chartInstances.testCompletionChart;
                fileName = 'test-abschlussrate';
                break;
            case 'passrate':
                chartInstance = _chartInstances.passRateChart;
                fileName = 'bestehensquote';
                break;
            case 'category':
                chartInstance = _chartInstances.categoryPerformanceChart;
                fileName = 'kategorie-leistung';
                break;
            case 'weekly':
                chartInstance = _chartInstances.weeklyActivityChart;
                fileName = 'wöchentliche-aktivität';
                break;
            case 'monthly':
                chartInstance = _chartInstances.monthlyProgressChart;
                fileName = 'monatlicher-fortschritt';
                break;
            default:
                window.ImmoLMS.Notifications.showError('Unbekannter Diagrammtyp.');
                return;
        }
        
        if (!chartInstance) {
            window.ImmoLMS.Notifications.showError('Diagramm nicht gefunden.');
            return;
        }
        
        // Canvas in Bild umwandeln
        const link = document.createElement('a');
        link.href = chartInstance.toBase64Image('image/png', 1.0);
        link.download = `${fileName}_${new Date().toISOString().split('T')[0]}.png`;
        link.click();
        
        window.ImmoLMS.Notifications.showSuccess('Diagramm wurde als Bild heruntergeladen.');
    }
    
    /**
     * Wechselt den Diagrammtyp einer Chart-Instanz
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _toggleChartView(chartType) {
        let chartInstance;
        let newType;
        
        switch (chartType) {
            case 'completion':
                chartInstance = _chartInstances.testCompletionChart;
                newType = chartInstance.config.type === 'doughnut' ? 'pie' : 'doughnut';
                break;
            case 'passrate':
                chartInstance = _chartInstances.passRateChart;
                newType = chartInstance.config.type === 'bar' ? 'horizontalBar' : 'bar';
                break;
            case 'category':
                chartInstance = _chartInstances.categoryPerformanceChart;
                newType = chartInstance.config.type === 'radar' ? 'polarArea' : 'radar';
                break;
            case 'monthly':
                chartInstance = _chartInstances.monthlyProgressChart;
                newType = chartInstance.config.type === 'line' ? 'bar' : 'line';
                break;
            default:
                window.ImmoLMS.Notifications.showError('Diagrammtyp kann nicht geändert werden.');
                return;
        }
        
        if (!chartInstance) {
            window.ImmoLMS.Notifications.showError('Diagramm nicht gefunden.');
            return;
        }
        
        // Diagrammtyp ändern
        chartInstance.config.type = newType;
        chartInstance.update();
        
        window.ImmoLMS.Notifications.showSuccess('Diagrammtyp wurde geändert.');
    }
    
    /**
     * Schaltet die Details eines Diagramms ein oder aus
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _toggleChartDetails(chartType) {
        let chartInstance;
        
        switch (chartType) {
            case 'performance':
                chartInstance = _chartInstances.performanceChart;
                // Details umschalten: Zusätzliche Datensätze anzeigen/ausblenden
                if (chartInstance.data.datasets.length > 1) {
                    // Auf einen Datensatz reduzieren (zusammenfassen)
                    const mainDataset = { ...chartInstance.data.datasets[0] };
                    chartInstance.data.datasets = [mainDataset];
                } else {
                    // Details anzeigen (muss Daten neu laden)
                    _loadDetailedPerformanceData(chartInstance);
                }
                break;
            case 'weekly':
                chartInstance = _chartInstances.weeklyActivityChart;
                // Detailanzeige umschalten (z.B. Aufschlüsselung nach Kategorien)
                if (chartInstance.data.datasets.length > 3) {
                    // Auf Basisdatensätze reduzieren
                    chartInstance.data.datasets = chartInstance.data.datasets.slice(0, 3);
                } else {
                    // Details anzeigen (muss Daten neu laden)
                    _loadDetailedWeeklyActivityData(chartInstance);
                }
                break;
            default:
                window.ImmoLMS.Notifications.showError('Details können für dieses Diagramm nicht umgeschaltet werden.');
                return;
        }
        
        if (!chartInstance) {
            window.ImmoLMS.Notifications.showError('Diagramm nicht gefunden.');
            return;
        }
        
        // Diagramm aktualisieren
        chartInstance.update();
        
        window.ImmoLMS.Notifications.showSuccess('Diagrammdetails wurden umgeschaltet.');
    }
    
    /**
     * Lädt detaillierte Daten für das Leistungsdiagramm
     * @param {Object} chartInstance - Die Chart.js-Instanz
     */
    async function _loadDetailedPerformanceData(chartInstance) {
        try {
            // Lade-Indikator anzeigen
            const container = document.getElementById('performance-chart-container');
            if (container) {
                container.querySelector('.chart-loading').style.display = 'flex';
            }
            
            // Zeitraum basierend auf der Konfiguration bestimmen
            const timeRange = _getTimeRangeForQuery();
            
            // Detaillierte Daten laden
            const detailedData = await window.ImmoLMS.DataService.getDetailedPerformanceData({
                trainerId: _currentUser.id,
                startDate: timeRange.startDate,
                endDate: timeRange.endDate,
                includePending: _config.includePending,
                filterByCategory: _config.filterByCategory !== 'all' ? _config.filterByCategory : null,
                filterByTeam: _config.filterByTeam !== 'all' ? _config.filterByTeam : null,
                groupBy: _config.groupBy
            });
            
            // Daten dem Diagramm hinzufügen
            chartInstance.data.datasets = detailedData.datasets;
            
            // Diagramm aktualisieren
            chartInstance.update();
            
            // Lade-Indikator ausblenden
            if (container) {
                container.querySelector('.chart-loading').style.display = 'none';
            }
        } catch (error) {
            console.error('Fehler beim Laden detaillierter Leistungsdaten:', error);
            window.ImmoLMS.Notifications.showError('Detaillierte Daten konnten nicht geladen werden.');
            
            // Lade-Indikator ausblenden
            const container = document.getElementById('performance-chart-container');
            if (container) {
                container.querySelector('.chart-loading').style.display = 'none';
            }
        }
    }
    
    /**
     * Lädt detaillierte Daten für das wöchentliche Aktivitätsdiagramm
     * @param {Object} chartInstance - Die Chart.js-Instanz
     */
    async function _loadDetailedWeeklyActivityData(chartInstance) {
        try {
            // Lade-Indikator anzeigen
            const container = document.getElementById('weekly-activity-chart-container');
            if (container) {
                container.querySelector('.chart-loading').style.display = 'flex';
            }
            
            // Zeitraum basierend auf der Konfiguration bestimmen
            const timeRange = _getTimeRangeForQuery();
            
            // Detaillierte Daten laden
            const detailedData = await window.ImmoLMS.DataService.getDetailedWeeklyActivityData({
                trainerId: _currentUser.id,
                startDate: timeRange.startDate,
                endDate: timeRange.endDate,
                includePending: _config.includePending,
                filterByCategory: _config.filterByCategory !== 'all' ? _config.filterByCategory : null,
                filterByTeam: _config.filterByTeam !== 'all' ? _config.filterByTeam : null
            });
            
            // Daten dem Diagramm hinzufügen (bestehende Datensätze beibehalten)
            chartInstance.data.datasets = [
                ...chartInstance.data.datasets.slice(0, 3),
                ...detailedData.datasets
            ];
            
            // Diagramm aktualisieren
            chartInstance.update();
            
            // Lade-Indikator ausblenden
            if (container) {
                container.querySelector('.chart-loading').style.display = 'none';
            }
        } catch (error) {
            console.error('Fehler beim Laden detaillierter Aktivitätsdaten:', error);
            window.ImmoLMS.Notifications.showError('Detaillierte Daten konnten nicht geladen werden.');
            
            // Lade-Indikator ausblenden
            const container = document.getElementById('weekly-activity-chart-container');
            if (container) {
                container.querySelector('.chart-loading').style.display = 'none';
            }
        }
    }
    
    /**
     * Setzt den Zoom eines Diagramms zurück
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _resetChartZoom(chartType) {
        let chartInstance;
        
        switch (chartType) {
            case 'performance':
                chartInstance = _chartInstances.performanceChart;
                break;
            default:
                window.ImmoLMS.Notifications.showError('Zoom kann für dieses Diagramm nicht zurückgesetzt werden.');
                return;
        }
        
        if (!chartInstance) {
            window.ImmoLMS.Notifications.showError('Diagramm nicht gefunden.');
            return;
        }
        
        // Zoom zurücksetzen (falls vorhanden)
        if (chartInstance.resetZoom) {
            chartInstance.resetZoom();
        } else {
            // Alternativ: Diagramm neu rendern
            chartInstance.update();
        }
        
        window.ImmoLMS.Notifications.showSuccess('Zoom wurde zurückgesetzt.');
    }
    
    /**
     * Exportiert die Daten eines Diagramms
     * @param {string} chartType - Der Typ des Diagramms
     */
    function _exportChartData(chartType) {
        let chartInstance;
        let fileName;
        
        switch (chartType) {
            case 'passrate':
                chartInstance = _chartInstances.passRateChart;
                fileName = 'bestehensquote-daten';
                break;
            case 'category':
                chartInstance = _chartInstances.categoryPerformanceChart;
                fileName = 'kategorie-leistung-daten';
                break;
            case 'weekly':
                chartInstance = _chartInstances.weeklyActivityChart;
                fileName = 'wöchentliche-aktivität-daten';
                break;
            case 'monthly':
                chartInstance = _chartInstances.monthlyProgressChart;
                fileName = 'monatlicher-fortschritt-daten';
                break;
            default:
                window.ImmoLMS.Notifications.showError('Daten können für dieses Diagramm nicht exportiert werden.');
                return;
        }
        
        if (!chartInstance) {
            window.ImmoLMS.Notifications.showError('Diagramm nicht gefunden.');
            return;
        }
        
        // Daten aus dem Diagramm extrahieren
        const data = {
            labels: chartInstance.data.labels,
            datasets: chartInstance.data.datasets.map(dataset => ({
                label: dataset.label,
                data: dataset.data
            }))
        };
        
        // Modal mit Export-Optionen anzeigen
        window.ImmoLMS.Modal.show({
            title: 'Diagrammdaten exportieren',
            content: `
                <div class="export-options">
                    <div class="option-group">
                        <h3>Format auswählen</h3>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="export-format" value="csv" checked>
                                CSV-Datei
                            </label>
                            <label>
                                <input type="radio" name="export-format" value="json">
                                JSON-Datei
                            </label>
                            <label>
                                <input type="radio" name="export-format" value="excel">
                                Excel-Datei
                            </label>
                        </div>
                    </div>
                </div>
            `,
            buttons: [
                {
                    label: 'Abbrechen',
                    class: 'btn secondary-btn',
                    action: 'close'
                },
                {
                    label: 'Exportieren',
                    class: 'btn primary-btn',
                    action: function() {
                        // Format ermitteln
                        const format = document.querySelector('input[name="export-format"]:checked').value;
                        
                        // Daten exportieren
                        switch (format) {
                            case 'csv':
                                _exportDataAsCSV(data, fileName);
                                break;
                            case 'json':
                                _exportDataAsJSON(data, fileName);
                                break;
                            case 'excel':
                                _exportDataAsExcel(data, fileName);
                                break;
                        }
                        
                        window.ImmoLMS.Modal.close();
                    }
                }
            ]
        });
    }
    
    /**
     * Exportiert Diagrammdaten als CSV-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDataAsCSV(data, fileName) {
        try {
            // Header-Zeile erstellen (Label + alle Dataset-Labels)
            const headers = ['Label', ...data.datasets.map(ds => ds.label || 'Wert')];
            
            // CSV-Zeilen erstellen
            const csvRows = [];
            
            // Header-Zeile hinzufügen
            csvRows.push(headers.join(','));
            
            // Datenzeilen hinzufügen
            for (let i = 0; i < data.labels.length; i++) {
                const rowValues = [
                    data.labels[i],
                    ...data.datasets.map(ds => {
                        const value = ds.data[i];
                        return value !== undefined ? value : '';
                    })
                ];
                
                // Werte mit Kommas in Anführungszeichen setzen
                const formattedValues = rowValues.map(value => {
                    return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
                });
                
                csvRows.push(formattedValues.join(','));
            }
            
            // CSV-String erstellen
            const csvString = csvRows.join('\n');
            
            // Datei erstellen und herunterladen
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als CSV exportiert.');
        } catch (error) {
            console.error('Fehler beim CSV-Export:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als CSV exportiert werden.');
        }
    }
    
    /**
     * Exportiert Diagrammdaten als JSON-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDataAsJSON(data, fileName) {
        try {
            // Daten für den Export aufbereiten
            const exportData = {
                labels: data.labels,
                datasets: data.datasets.map(ds => ({
                    label: ds.label,
                    data: ds.data
                })),
                exportDate: new Date().toISOString()
            };
            
            // JSON-String erstellen
            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Datei erstellen und herunterladen
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${new Date().toISOString().split('T')[0]}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als JSON exportiert.');
        } catch (error) {
            console.error('Fehler beim JSON-Export:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als JSON exportiert werden.');
        }
    }
    
    /**
     * Exportiert Diagrammdaten als Excel-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDataAsExcel(data, fileName) {
        try {
            // Excel-Export-Funktionalität hier implementieren
            // In der Basisversion verwenden wir einen CSV-Export als Fallback
            window.ImmoLMS.Notifications.showInfo('Excel-Export ist in dieser Version nicht verfügbar. Daten werden als CSV exportiert.');
            _exportDataAsCSV(data, fileName);
        } catch (error) {
            console.error('Fehler beim Excel-Export:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als Excel exportiert werden.');
        }
    }
    
    // Öffentliche API
    return {
        initialize: initialize,
        refreshAllCharts: _refreshAllCharts,
        updateConfig: function(newConfig) {
            _config = { ..._config, ...newConfig };
        },
        getConfig: function() {
            return { ..._config };
        }
    };
})();
/**
 * JS-Block 7.1.2-part2a: Trainer-Dashboard Datenvisualisierung (Teil 2a)
 * ImmoScout24 E-Learning Projekt
 * 
 * Erweitert die Visualisierungsfunktionen des Trainer-Dashboards mit erweiterten Diagrammoptionen,
 * vergleichenden Ansichten und interaktiven Benutzerkontrollen.
 */

// Erweiterung des Visualisierungsmoduls für das Trainer-Dashboard
(function() {
    'use strict';
    
    // Auf vorhandenes Modul zugreifen
    const Visualization = window.ImmoLMS.Trainer.Visualization;
    
    // Private Variablen hinzufügen
    let _comparisonMode = false;
    let _selectedLearners = [];
    let _comparisonConfig = {
        type: 'team',           // 'team', 'individual', 'category'
        timeRange: 'last30days',
        metric: 'scores',       // 'scores', 'completion', 'activity'
        normalize: true         // Normalisierung der Daten für bessere Vergleichbarkeit
    };
    let _comparisonChartInstance = null;
    
    // Hilfsvariablen für erweiterte Diagrammfunktionen
    const _chartPlugins = {};
    
    /**
     * Fügt eine Vergleichsansicht zum Dashboard hinzu
     * @param {HTMLElement} container - Der Container, in den die Vergleichsansicht eingefügt werden soll
     */
    function _addComparisonView(container) {
        if (!container) return;
        
        // Prüfen, ob bereits eine Vergleichsansicht existiert
        let comparisonSection = document.getElementById('comparison-section');
        if (comparisonSection) {
            // Vorhandene Sektion leeren
            comparisonSection.innerHTML = '';
        } else {
            // Neue Sektion erstellen
            comparisonSection = document.createElement('section');
            comparisonSection.id = 'comparison-section';
            comparisonSection.className = 'dashboard-section full-width comparison-section';
            comparisonSection.style.display = 'none'; // Initial ausgeblendet
            
            // Nach der Visualisierungssektion einfügen
            const visualizationSection = document.getElementById('visualization-section');
            if (visualizationSection && visualizationSection.nextElementSibling) {
                container.insertBefore(comparisonSection, visualizationSection.nextElementSibling);
            } else {
                container.appendChild(comparisonSection);
            }
        }
        
        // HTML-Struktur für die Vergleichsansicht erstellen
        comparisonSection.innerHTML = `
            <div class="section-header with-controls">
                <h2>Leistungsvergleich</h2>
                <div class="comparison-controls">
                    <div class="control-group">
                        <label for="comparison-type">Vergleichstyp:</label>
                        <select id="comparison-type" class="control-select">
                            <option value="team">Teams vergleichen</option>
                            <option value="individual">Lernende vergleichen</option>
                            <option value="category">Kategorien vergleichen</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="comparison-metric">Metrik:</label>
                        <select id="comparison-metric" class="control-select">
                            <option value="scores">Punktzahlen</option>
                            <option value="completion">Abschlussraten</option>
                            <option value="activity">Aktivitätsniveau</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="comparison-time">Zeitraum:</label>
                        <select id="comparison-time" class="control-select">
                            <option value="last30days">Letzte 30 Tage</option>
                            <option value="last90days">Letzte 90 Tage</option>
                            <option value="thisYear">Dieses Jahr</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="normalize-data" checked>
                            Daten normalisieren
                        </label>
                    </div>
                    
                    <button id="update-comparison" class="btn secondary-btn">Aktualisieren</button>
                    <button id="close-comparison" class="btn icon-btn" title="Vergleich schließen">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            
            <div class="comparison-content">
                <div class="selection-panel">
                    <div class="panel-header">
                        <h3 id="selection-panel-title">Teams auswählen</h3>
                        <div class="search-container">
                            <input type="text" id="selection-search" placeholder="Suchen...">
                        </div>
                    </div>
                    <div class="selection-list" id="comparison-selection-list">
                        <!-- Dynamisch gefüllt -->
                    </div>
                </div>
                
                <div class="comparison-chart-container">
                    <div class="chart-wrapper">
                        <canvas id="comparison-chart"></canvas>
                        <div class="chart-loading">
                            <div class="spinner"></div>
                            <p>Daten werden geladen...</p>
                        </div>
                    </div>
                    <div class="chart-actions">
                        <button class="btn icon-btn" id="download-comparison" title="Als Bild herunterladen">
                            <i class="fas fa-download"></i>
                        </button>
                        <button class="btn icon-btn" id="export-comparison-data" title="Daten exportieren">
                            <i class="fas fa-file-export"></i>
                        </button>
                        <button class="btn icon-btn" id="toggle-comparison-type" title="Diagrammtyp ändern">
                            <i class="fas fa-chart-bar"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Event-Listener für die Vergleichsansicht hinzufügen
        _addComparisonEventListeners();
    }
    
    /**
     * Registriert Event-Listener für die Vergleichsansicht
     */
    function _addComparisonEventListeners() {
        // Vergleichstyp
        const comparisonType = document.getElementById('comparison-type');
        if (comparisonType) {
            comparisonType.addEventListener('change', (e) => {
                _comparisonConfig.type = e.target.value;
                _updateSelectionPanel();
            });
        }
        
        // Vergleichsmetrik
        const comparisonMetric = document.getElementById('comparison-metric');
        if (comparisonMetric) {
            comparisonMetric.addEventListener('change', (e) => {
                _comparisonConfig.metric = e.target.value;
            });
        }
        
        // Vergleichszeitraum
        const comparisonTime = document.getElementById('comparison-time');
        if (comparisonTime) {
            comparisonTime.addEventListener('change', (e) => {
                _comparisonConfig.timeRange = e.target.value;
            });
        }
        
        // Datennormalisierung
        const normalizeData = document.getElementById('normalize-data');
        if (normalizeData) {
            normalizeData.addEventListener('change', (e) => {
                _comparisonConfig.normalize = e.target.checked;
            });
        }
        
        // Aktualisierungsbutton
        const updateComparison = document.getElementById('update-comparison');
        if (updateComparison) {
            updateComparison.addEventListener('click', _updateComparisonChart);
        }
        
        // Schließen-Button
        const closeComparison = document.getElementById('close-comparison');
        if (closeComparison) {
            closeComparison.addEventListener('click', _toggleComparisonView);
        }
        
        // Suchfeld
        const selectionSearch = document.getElementById('selection-search');
        if (selectionSearch) {
            selectionSearch.addEventListener('input', _filterSelectionList);
        }
        
        // Download-Button
        const downloadComparison = document.getElementById('download-comparison');
        if (downloadComparison) {
            downloadComparison.addEventListener('click', _downloadComparisonChart);
        }
        
        // Export-Button
        const exportComparisonData = document.getElementById('export-comparison-data');
        if (exportComparisonData) {
            exportComparisonData.addEventListener('click', _exportComparisonData);
        }
        
        // Diagrammtyp-Toggle-Button
        const toggleComparisonType = document.getElementById('toggle-comparison-type');
        if (toggleComparisonType) {
            toggleComparisonType.addEventListener('click', _toggleComparisonChartType);
        }
    }
    
    /**
     * Aktualisiert das Auswahlpanel basierend auf dem gewählten Vergleichstyp
     */
    function _updateSelectionPanel() {
        const selectionList = document.getElementById('comparison-selection-list');
        const panelTitle = document.getElementById('selection-panel-title');
        const searchInput = document.getElementById('selection-search');
        
        if (!selectionList || !panelTitle || !searchInput) return;
        
        // Liste leeren
        selectionList.innerHTML = '';
        
        // Titel und Platzhalter aktualisieren
        switch (_comparisonConfig.type) {
            case 'team':
                panelTitle.textContent = 'Teams auswählen';
                searchInput.placeholder = 'Teams suchen...';
                _loadTeamsForComparison();
                break;
            case 'individual':
                panelTitle.textContent = 'Lernende auswählen';
                searchInput.placeholder = 'Lernende suchen...';
                _loadLearnersForComparison();
                break;
            case 'category':
                panelTitle.textContent = 'Kategorien auswählen';
                searchInput.placeholder = 'Kategorien suchen...';
                _loadCategoriesForComparison();
                break;
        }
    }
    
    /**
     * Lädt Teams für den Vergleich
     */
    function _loadTeamsForComparison() {
        const selectionList = document.getElementById('comparison-selection-list');
        if (!selectionList) return;
        
        // Teams laden
        const teams = window.ImmoLMS.DataService.getTeams();
        
        // Teams zur Auswahlliste hinzufügen
        teams.forEach(team => {
            const itemElement = document.createElement('div');
            itemElement.className = 'selection-item';
            itemElement.dataset.id = team.id;
            
            itemElement.innerHTML = `
                <div class="selection-checkbox">
                    <input type="checkbox" id="team-${team.id}" data-id="${team.id}" data-type="team">
                </div>
                <div class="selection-info">
                    <label for="team-${team.id}" class="selection-name">${team.name}</label>
                    <span class="selection-meta">${team.memberCount} Mitglieder</span>
                </div>
            `;
            
            selectionList.appendChild(itemElement);
        });
        
        // Event-Listener für Checkboxen hinzufügen
        const checkboxes = selectionList.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', _handleSelectionChange);
        });
    }
    
    /**
     * Lädt Lernende für den Vergleich
     */
    function _loadLearnersForComparison() {
        const selectionList = document.getElementById('comparison-selection-list');
        if (!selectionList) return;
        
        // Lernende laden
        const learners = window.ImmoLMS.DataService.getAssignedLearners(_currentUser.id);
        
        // Lernende zur Auswahlliste hinzufügen
        learners.forEach(learner => {
            const itemElement = document.createElement('div');
            itemElement.className = 'selection-item';
            itemElement.dataset.id = learner.id;
            
            itemElement.innerHTML = `
                <div class="selection-checkbox">
                    <input type="checkbox" id="learner-${learner.id}" data-id="${learner.id}" data-type="learner">
                </div>
                <div class="selection-info">
                    <label for="learner-${learner.id}" class="selection-name">${learner.name}</label>
                    <span class="selection-meta">${learner.team || 'Kein Team'}</span>
                </div>
                <div class="selection-avatar">
                    ${learner.avatar ? 
                      `<img src="${learner.avatar}" alt="${learner.name}">` : 
                      `<div class="avatar-placeholder">${learner.name.charAt(0)}</div>`
                    }
                </div>
            `;
            
            selectionList.appendChild(itemElement);
        });
        
        // Event-Listener für Checkboxen hinzufügen
        const checkboxes = selectionList.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', _handleSelectionChange);
        });
    }
    
    /**
     * Lädt Kategorien für den Vergleich
     */
    function _loadCategoriesForComparison() {
        const selectionList = document.getElementById('comparison-selection-list');
        if (!selectionList) return;
        
        // Kategorien laden
        const categories = window.ImmoLMS.DataService.getTestCategories();
        
        // Kategorien zur Auswahlliste hinzufügen
        categories.forEach(category => {
            const itemElement = document.createElement('div');
            itemElement.className = 'selection-item';
            itemElement.dataset.id = category.id;
            
            itemElement.innerHTML = `
                <div class="selection-checkbox">
                    <input type="checkbox" id="category-${category.id}" data-id="${category.id}" data-type="category">
                </div>
                <div class="selection-info">
                    <label for="category-${category.id}" class="selection-name">${category.name}</label>
                    <span class="selection-meta">${category.testCount} Tests</span>
                </div>
            `;
            
            selectionList.appendChild(itemElement);
        });
        
        // Event-Listener für Checkboxen hinzufügen
        const checkboxes = selectionList.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', _handleSelectionChange);
        });
    }
    
    /**
     * Verarbeitet Änderungen in der Auswahl
     * @param {Event} e - Das Event-Objekt
     */
    function _handleSelectionChange(e) {
        const checkbox = e.target;
        const id = checkbox.dataset.id;
        const type = checkbox.dataset.type;
        
        // Element zur Auswahl hinzufügen oder entfernen
        if (checkbox.checked) {
            _selectedLearners.push({ id, type });
        } else {
            _selectedLearners = _selectedLearners.filter(item => !(item.id === id && item.type === type));
        }
        
        // Aktualisierungsbutton aktivieren/deaktivieren
        const updateButton = document.getElementById('update-comparison');
        if (updateButton) {
            updateButton.disabled = _selectedLearners.length === 0;
        }
    }
    
    /**
     * Filtert die Auswahlliste basierend auf dem Suchbegriff
     * @param {Event} e - Das Event-Objekt
     */
    function _filterSelectionList(e) {
        const searchValue = e.target.value.trim().toLowerCase();
        const selectionItems = document.querySelectorAll('.selection-item');
        
        selectionItems.forEach(item => {
            const name = item.querySelector('.selection-name').textContent.toLowerCase();
            const meta = item.querySelector('.selection-meta').textContent.toLowerCase();
            
            // Element ein-/ausblenden basierend auf dem Suchbegriff
            if (name.includes(searchValue) || meta.includes(searchValue)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }
    
    /**
     * Aktualisiert das Vergleichsdiagramm
     */
    async function _updateComparisonChart() {
        // Prüfen, ob Elemente ausgewählt wurden
        if (_selectedLearners.length === 0) {
            window.ImmoLMS.Notifications.showWarning('Bitte wählen Sie mindestens ein Element für den Vergleich aus.');
            return;
        }
        
        // Lade-Indikator anzeigen
        const loadingIndicator = document.querySelector('.comparison-chart-container .chart-loading');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'flex';
        }
        
        try {
            // Vergleichsdaten laden
            const data = await _loadComparisonData();
            
            // Diagramm erstellen oder aktualisieren
            _createOrUpdateComparisonChart(data);
            
            // Lade-Indikator ausblenden
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        } catch (error) {
            console.error('Fehler beim Aktualisieren des Vergleichsdiagramms:', error);
            window.ImmoLMS.Notifications.showError('Das Vergleichsdiagramm konnte nicht aktualisiert werden.');
            
            // Lade-Indikator ausblenden
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        }
    }
    
    /**
     * Lädt Daten für den Vergleich
     * @returns {Promise<Object>} - Die Vergleichsdaten
     */
    async function _loadComparisonData() {
        // Zeitraum basierend auf der Konfiguration bestimmen
        const timeRange = _getComparisonTimeRange();
        
        // Basisparameter für die Abfrage
        const baseParams = {
            trainerId: _currentUser.id,
            startDate: timeRange.startDate,
            endDate: timeRange.endDate,
            normalize: _comparisonConfig.normalize,
            metric: _comparisonConfig.metric
        };
        
        // Je nach Vergleichstyp unterschiedliche Daten laden
        switch (_comparisonConfig.type) {
            case 'team':
                return await window.ImmoLMS.DataService.getTeamComparisonData({
                    ...baseParams,
                    teamIds: _selectedLearners.map(item => item.id)
                });
            case 'individual':
                return await window.ImmoLMS.DataService.getLearnerComparisonData({
                    ...baseParams,
                    learnerIds: _selectedLearners.map(item => item.id)
                });
            case 'category':
                return await window.ImmoLMS.DataService.getCategoryComparisonData({
                    ...baseParams,
                    categoryIds: _selectedLearners.map(item => item.id)
                });
            default:
                throw new Error('Ungültiger Vergleichstyp');
        }
    }
    
    /**
     * Bestimmt den Zeitraum für die Vergleichsabfrage
     * @returns {Object} - Objekt mit Start- und Enddatum
     */
    function _getComparisonTimeRange() {
        const endDate = new Date();
        let startDate = new Date();
        
        // Zeitraum basierend auf der Konfiguration festlegen
        switch (_comparisonConfig.timeRange) {
            case 'last30days':
                startDate.setDate(endDate.getDate() - 30);
                break;
            case 'last90days':
                startDate.setDate(endDate.getDate() - 90);
                break;
            case 'thisYear':
                startDate = new Date(endDate.getFullYear(), 0, 1); // 1. Januar des aktuellen Jahres
                break;
            default:
                // Fallback auf letzte 30 Tage
                startDate.setDate(endDate.getDate() - 30);
        }
        
        // Formatiere Datum als ISO-String (YYYY-MM-DD)
        return {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0]
        };
    }
    
    /**
     * Erstellt oder aktualisiert das Vergleichsdiagramm
     * @param {Object} data - Die Vergleichsdaten
     */
    function _createOrUpdateComparisonChart(data) {
        // Canvas-Element abrufen
        const ctx = document.getElementById('comparison-chart');
        if (!ctx) return;
        
        // Diagrammtyp basierend auf der Metrik und den Daten bestimmen
        let chartType = 'line';
        switch (_comparisonConfig.metric) {
            case 'scores':
                chartType = 'line';
                break;
            case 'completion':
                chartType = data.labels.length > 5 ? 'line' : 'bar';
                break;
            case 'activity':
                chartType = 'bar';
                break;
        }
        
        // Bestehende Instanz zerstören, falls vorhanden
        if (_comparisonChartInstance) {
            _comparisonChartInstance.destroy();
        }
        
        // Y-Achsen-Konfiguration basierend auf der Metrik
        const yAxisConfig = {
            beginAtZero: true,
            grid: {
                color: 'rgba(0, 0, 0, 0.1)'
            }
        };
        
        if (_comparisonConfig.metric === 'scores') {
            yAxisConfig.max = 100;
            yAxisConfig.ticks = {
                callback: function(value) {
                    return value + '%';
                }
            };
        }
        
        // Tooltip-Callback basierend auf der Metrik
        const tooltipCallback = {
            label: function(context) {
                let label = context.dataset.label || '';
                if (label) {
                    label += ': ';
                }
                
                switch (_comparisonConfig.metric) {
                    case 'scores':
                        return label + context.parsed.y.toFixed(1) + '%';
                    case 'completion':
                        return label + context.parsed.y.toFixed(1) + '%';
                    case 'activity':
                        return label + context.parsed.y;
                    default:
                        return label + context.parsed.y;
                }
            }
        };
        
        // Diagrammkonfiguration
        const config = {
            type: chartType,
            data: data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: tooltipCallback
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            boxWidth: 10
                        }
                    },
                    title: {
                        display: true,
                        text: _getComparisonTitle(),
                        font: {
                            size: 16
                        },
                        padding: {
                            top: 10,
                            bottom: 20
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        }
                    },
                    y: yAxisConfig
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                animations: {
                    tension: {
                        duration: 1000,
                        easing: 'easeOutQuad',
                        from: 0.8,
                        to: 0.2,
                        loop: false
                    }
                }
            }
        };
        
        // Diagramm erstellen
        _comparisonChartInstance = new Chart(ctx, config);
    }
    
    /**
     * Generiert einen Titel für das Vergleichsdiagramm
     * @returns {string} - Der Diagrammtitel
     */
    function _getComparisonTitle() {
        let entityType = '';
        let metricType = '';
        
        // Entitätstyp bestimmen
        switch (_comparisonConfig.type) {
            case 'team':
                entityType = 'Team';
                break;
            case 'individual':
                entityType = 'Lernenden';
                break;
            case 'category':
                entityType = 'Kategorie';
                break;
        }
        
        // Metriktyp bestimmen
        switch (_comparisonConfig.metric) {
            case 'scores':
                metricType = 'Punktzahlen';
                break;
            case 'completion':
                metricType = 'Abschlussraten';
                break;
            case 'activity':
                metricType = 'Aktivitätsniveau';
                break;
        }
        
        return `${entityType}-Vergleich: ${metricType}`;
    }
    
    /**
     * Schaltet die Vergleichsansicht ein oder aus
     */
    function _toggleComparisonView() {
        const comparisonSection = document.getElementById('comparison-section');
        if (!comparisonSection) return;
        
        // Vergleichsmodus umschalten
        _comparisonMode = !_comparisonMode;
        
        // Vergleichsansicht ein-/ausblenden
        comparisonSection.style.display = _comparisonMode ? 'block' : 'none';
        
        // Auswahlpanel aktualisieren, wenn die Ansicht eingeblendet wird
        if (_comparisonMode) {
            _updateSelectionPanel();
            
            // Fenster zur Vergleichsansicht scrollen
            comparisonSection.scrollIntoView({ behavior: 'smooth' });
        } else {
            // Auswahl zurücksetzen
            _selectedLearners = [];
            
            // Diagramm zerstören
            if (_comparisonChartInstance) {
                _comparisonChartInstance.destroy();
                _comparisonChartInstance = null;
            }
        }
    }
    
    /**
     * Lädt das Vergleichsdiagramm als Bild herunter
     */
    function _downloadComparisonChart() {
        if (!_comparisonChartInstance) {
            window.ImmoLMS.Notifications.showWarning('Kein Diagramm zum Herunterladen vorhanden.');
            return;
        }
        
        // Canvas in Bild umwandeln
        const link = document.createElement('a');
        link.href = _comparisonChartInstance.toBase64Image('image/png', 1.0);
        link.download = `vergleich_${_comparisonConfig.type}_${_comparisonConfig.metric}_${new Date().toISOString().split('T')[0]}.png`;
        link.click();
        
        window.ImmoLMS.Notifications.showSuccess('Diagramm wurde als Bild heruntergeladen.');
    }
    
    /**
     * Exportiert die Vergleichsdaten
     */
    function _exportComparisonData() {
        if (!_comparisonChartInstance) {
            window.ImmoLMS.Notifications.showWarning('Keine Daten zum Exportieren vorhanden.');
            return;
        }
        
        // Daten aus dem Diagramm extrahieren
        const data = {
            labels: _comparisonChartInstance.data.labels,
            datasets: _comparisonChartInstance.data.datasets.map(dataset => ({
                label: dataset.label,
                data: dataset.data
            })),
            config: { ..._comparisonConfig },
            exportDate: new Date().toISOString()
        };
        
        // Modal mit Export-Optionen anzeigen
        window.ImmoLMS.Modal.show({
            title: 'Vergleichsdaten exportieren',
            content: `
                <div class="export-options">
                    <div class="option-group">
                        <h3>Format auswählen</h3>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="export-format" value="csv" checked>
                                CSV-Datei
                            </label>
                            <label>
                                <input type="radio" name="export-format" value="json">
                                JSON-Datei
                            </label>
                        </div>
                    </div>
                </div>
            `,
            buttons: [
                {
                    label: 'Abbrechen',
                    class: 'btn secondary-btn',
                    action: 'close'
                },
                {
                    label: 'Exportieren',
                    class: 'btn primary-btn',
                    action: function() {
                        // Format ermitteln
                        const format = document.querySelector('input[name="export-format"]:checked').value;
                        
                        // Daten exportieren
                        if (format === 'csv') {
                            _exportDataAsCSV(data, `vergleich_${_comparisonConfig.type}_${_comparisonConfig.metric}`);
                        } else {
                            _exportDataAsJSON(data, `vergleich_${_comparisonConfig.type}_${_comparisonConfig.metric}`);
                        }
                        
                        window.ImmoLMS.Modal.close();
                    }
                }
            ]
        });
    }
    
    /**
     * Wechselt den Diagrammtyp des Vergleichsdiagramms
     */
    function _toggleComparisonChartType() {
        if (!_comparisonChartInstance) {
            window.ImmoLMS.Notifications.showWarning('Kein Diagramm zum Ändern vorhanden.');
            return;
        }
        
        // Aktuellen Typ ermitteln und wechseln
        const currentType = _comparisonChartInstance.config.type;
        let newType;
        
        switch (currentType) {
            case 'line':
                newType = 'bar';
                break;
            case 'bar':
                // Für Aktivitätsdaten ist ein Radar-Diagramm möglicherweise nicht sinnvoll
                newType = _comparisonConfig.metric === 'activity' ? 'line' : 'radar';
                break;
            case 'radar':
                newType = 'polarArea';
                break;
            case 'polarArea':
                newType = 'line';
                break;
            default:
                newType = 'line';
        }
        
        // Diagrammtyp ändern
        _comparisonChartInstance.config.type = newType;
        
        // Optionen anpassen
        if (newType === 'radar' || newType === 'polarArea') {
            _comparisonChartInstance.options.scales.x.display = false;
            _comparisonChartInstance.options.scales.y.display = false;
            
            if (newType === 'radar') {
                _comparisonChartInstance.options.scales.r = {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 20
                    }
                };
                
                if (_comparisonConfig.metric === 'scores' || _comparisonConfig.metric === 'completion') {
                    _comparisonChartInstance.options.scales.r.max = 100;
                    _comparisonChartInstance.options.scales.r.ticks.callback = function(value) {
                        return value + '%';
                    };
                }
            }
        } else {
            _comparisonChartInstance.options.scales.x.display = true;
            _comparisonChartInstance.options.scales.y.display = true;
            
            // r-Skala entfernen, falls vorhanden
            if (_comparisonChartInstance.options.scales.r) {
                delete _comparisonChartInstance.options.scales.r;
            }
        }
        
        // Diagramm aktualisieren
        _comparisonChartInstance.update();
        
        window.ImmoLMS.Notifications.showSuccess(`Diagrammtyp wurde zu ${newType} geändert.`);
    }
    
    /**
     * Exportiert Daten als CSV-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDataAsCSV(data, fileName) {
        try {
            // Header-Zeile erstellen (Label + alle Dataset-Labels)
            const headers = ['Label', ...data.datasets.map(ds => ds.label || 'Wert')];
            
            // CSV-Zeilen erstellen
            const csvRows = [];
            
            // Header-Zeile hinzufügen
            csvRows.push(headers.join(','));
            
            // Datenzeilen hinzufügen
            for (let i = 0; i < data.labels.length; i++) {
                const rowValues = [
                    data.labels[i],
                    ...data.datasets.map(ds => {
                        const value = ds.data[i];
                        return value !== undefined ? value : '';
                    })
                ];
                
                // Werte mit Kommas in Anführungszeichen setzen
                const formattedValues = rowValues.map(value => {
                    return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
                });
                
                csvRows.push(formattedValues.join(','));
            }
            
            // CSV-String erstellen
            const csvString = csvRows.join('\n');
            
            // Datei erstellen und herunterladen
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als CSV exportiert.');
        } catch (error) {
            console.error('Fehler beim CSV-Export:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als CSV exportiert werden.');
        }
    }
    
    /**
     * Exportiert Daten als JSON-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDataAsJSON(data, fileName) {
        try {
            // JSON-String erstellen
            const jsonString = JSON.stringify(data, null, 2);
            
            // Datei erstellen und herunterladen
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${new Date().toISOString().split('T')[0]}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als JSON exportiert.');
        } catch (error) {
            console.error('Fehler beim JSON-Export:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als JSON exportiert werden.');
        }
    }
    
    /**
     * Registriert erweiterte Chart.js-Plugins für die Visualisierung
     */
    function _registerChartPlugins() {
        // Zoom-Plugin
        _chartPlugins.zoom = {
            id: 'zoom',
            beforeEvent: function(chart, event, options) {
                // Zoom-Funktionalität hier implementieren
                // Wird in einem zukünftigen Update vollständig implementiert
            }
        };
        
        // Datenhervorhebungs-Plugin
        _chartPlugins.dataHighlight = {
            id: 'dataHighlight',
            beforeDraw: function(chart, args, options) {
                const activeElements = chart.getActiveElements();
                if (activeElements.length > 0) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(activeElements[0].datasetIndex);
                    const element = meta.data[activeElements[0].index];
                    
                    // Hervorhebungsstyling hier implementieren
                    // Wird in einem zukünftigen Update vollständig implementiert
                }
            }
        };
        
        // Plugins bei Chart.js registrieren
        Chart.register(_chartPlugins.zoom);
        Chart.register(_chartPlugins.dataHighlight);
    }
    
    // Öffentliche Methoden und Eigenschaften
    
    /**
     * Öffnet die Vergleichsansicht und initialisiert sie
     * @param {string} type - Der Vergleichstyp ('team', 'individual', 'category')
     * @param {string} metric - Die zu vergleichende Metrik ('scores', 'completion', 'activity')
     */
    function showComparison(type, metric) {
        // Dashboard-Container abrufen
        const dashboardContainer = document.getElementById('trainer-dashboard');
        if (!dashboardContainer) return;
        
        // Vergleichsansicht hinzufügen, falls noch nicht vorhanden
        _addComparisonView(dashboardContainer);
        
        // Konfiguration aktualisieren
        _comparisonConfig.type = type || 'team';
        _comparisonConfig.metric = metric || 'scores';
        
        // Dropdowns aktualisieren
        const typeSelect = document.getElementById('comparison-type');
        const metricSelect = document.getElementById('comparison-metric');
        
        if (typeSelect) typeSelect.value = _comparisonConfig.type;
        if (metricSelect) metricSelect.value = _comparisonConfig.metric;
        
        // Vergleichsansicht anzeigen
        if (!_comparisonMode) {
            _toggleComparisonView();
        }
        
        // Auswahlpanel aktualisieren
        _updateSelectionPanel();
    }
    
    /**
     * Erstellt einen Screenshot eines Diagramms
     * @param {string} chartId - Die ID des Diagramms
     * @returns {string|null} - Die Bild-URL oder null bei Fehler
     */
    function getChartScreenshot(chartId) {
        let chartInstance;
        
        // Diagramminstanz abrufen
        switch (chartId) {
            case 'performance':
                chartInstance = _chartInstances.performanceChart;
                break;
            case 'completion':
                chartInstance = _chartInstances.testCompletionChart;
                break;
            case 'passRate':
                chartInstance = _chartInstances.passRateChart;
                break;
            case 'category':
                chartInstance = _chartInstances.categoryPerformanceChart;
                break;
            case 'weekly':
                chartInstance = _chartInstances.weeklyActivityChart;
                break;
            case 'monthly':
                chartInstance = _chartInstances.monthlyProgressChart;
                break;
            case 'comparison':
                chartInstance = _comparisonChartInstance;
                break;
            default:
                console.error('Unbekannte Diagramm-ID:', chartId);
                return null;
        }
        
        if (!chartInstance) {
            console.error('Diagramm nicht gefunden:', chartId);
            return null;
        }
        
        // Screenshot erstellen
        return chartInstance.toBase64Image('image/png', 1.0);
    }
    
    // Bestehenden Export um neue Funktionen erweitern
    Object.assign(Visualization, {
        showComparison: showComparison,
        getChartScreenshot: getChartScreenshot,
        toggleComparisonView: _toggleComparisonView,
        registerChartPlugins: _registerChartPlugins
    });
    
    // Plugins beim Laden registrieren
    _registerChartPlugins();
})();
/**
 * JS-Block 7.1.2-part2: Trainer-Dashboard Datenvisualisierung (Teil 2)
 * ImmoScout24 E-Learning Projekt
 * 
 * Erweiterte Datenvisualisierung für das Trainer-Dashboard mit interaktiven
 * Analysewerkzeugen, Detailansichten und erweiterten Funktionen.
 */

// Erweiterung des Visualization-Moduls
window.ImmoLMS = window.ImmoLMS || {};
window.ImmoLMS.TrainerDashboard = window.ImmoLMS.TrainerDashboard || {};
window.ImmoLMS.TrainerDashboard.Visualization = window.ImmoLMS.TrainerDashboard.Visualization || {};

(function() {
    // Lokale Referenz auf das Visualization-Modul
    const Visualization = window.ImmoLMS.TrainerDashboard.Visualization;
    
    // Private Variablen für erweiterte Visualisierung
    let _detailViewActive = false;
    let _detailViewConfig = {
        type: null,
        target: null,
        data: null,
        filters: {}
    };
    
    // Detail-Chart-Instanz
    let _detailChartInstance = null;
    
    // Erweiterte Konfigurations-Speicher
    const _advancedSettings = {
        animationEnabled: true,
        tooltipMode: 'nearest',
        legendPosition: 'top',
        colorScheme: 'default',
        gridLines: true,
        dataLabels: false
    };
    
    // Cache für Drill-Down-Daten
    const _drillDownDataCache = {};
    
    /**
     * Erstellt eine Detail-Ansicht für die tiefergehende Analyse eines bestimmten Datenpunkts oder -bereichs
     * @param {string} containerSelector - CSS-Selector für den Container
     * @returns {HTMLElement} - Der erstellte Detail-Container
     */
    function _createDetailView(containerSelector) {
        // Container abrufen
        const container = document.querySelector(containerSelector);
        if (!container) {
            console.error('Container für Detailansicht nicht gefunden:', containerSelector);
            return null;
        }
        
        // Bestehende Detailansicht entfernen, falls vorhanden
        const existingDetailView = document.getElementById('chart-detail-view');
        if (existingDetailView) {
            existingDetailView.remove();
        }
        
        // Detailansicht-Container erstellen
        const detailContainer = document.createElement('div');
        detailContainer.id = 'chart-detail-view';
        detailContainer.className = 'chart-detail-view';
        
        // Header mit Schließen-Button
        const header = document.createElement('div');
        header.className = 'detail-view-header';
        
        const title = document.createElement('h3');
        title.id = 'detail-view-title';
        title.textContent = 'Detailansicht';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'btn btn-icon';
        closeButton.innerHTML = '<i class="fas fa-times"></i>';
        closeButton.setAttribute('aria-label', 'Detailansicht schließen');
        closeButton.addEventListener('click', closeDetailView);
        
        header.appendChild(title);
        header.appendChild(closeButton);
        
        // Filter-Bereich
        const filterBar = document.createElement('div');
        filterBar.className = 'detail-filter-bar';
        
        const filterSelect = document.createElement('select');
        filterSelect.id = 'detail-filter-select';
        filterSelect.addEventListener('change', function() {
            _updateDetailView({filter: this.value});
        });
        
        // Standardoptionen hinzufügen (werden später dynamisch aktualisiert)
        const defaultOption = document.createElement('option');
        defaultOption.value = 'all';
        defaultOption.textContent = 'Alle Daten';
        filterSelect.appendChild(defaultOption);
        
        filterBar.appendChild(filterSelect);
        
        // Diagramm-Container
        const chartContainer = document.createElement('div');
        chartContainer.className = 'detail-chart-container';
        
        const canvas = document.createElement('canvas');
        canvas.id = 'detail-chart';
        chartContainer.appendChild(canvas);
        
        // Informationsbereich für Statistiken
        const infoPanel = document.createElement('div');
        infoPanel.id = 'detail-info-panel';
        infoPanel.className = 'detail-info-panel';
        
        // Tool-Leiste
        const toolbar = document.createElement('div');
        toolbar.className = 'detail-toolbar';
        
        // Export-Buttons
        const csvButton = document.createElement('button');
        csvButton.className = 'btn btn-sm';
        csvButton.textContent = 'CSV exportieren';
        csvButton.addEventListener('click', function() {
            if (_detailViewConfig.data) {
                _exportDetailDataAsCSV(_detailViewConfig.data, 'detail_export');
            }
        });
        
        const jsonButton = document.createElement('button');
        jsonButton.className = 'btn btn-sm';
        jsonButton.textContent = 'JSON exportieren';
        jsonButton.addEventListener('click', function() {
            if (_detailViewConfig.data) {
                _exportDetailDataAsJSON(_detailViewConfig.data, 'detail_export');
            }
        });
        
        const screenshotButton = document.createElement('button');
        screenshotButton.className = 'btn btn-sm';
        screenshotButton.textContent = 'Screenshot';
        screenshotButton.addEventListener('click', function() {
            _saveDetailChartAsImage();
        });
        
        toolbar.appendChild(csvButton);
        toolbar.appendChild(jsonButton);
        toolbar.appendChild(screenshotButton);
        
        // Elemente zum Container hinzufügen
        detailContainer.appendChild(header);
        detailContainer.appendChild(filterBar);
        detailContainer.appendChild(chartContainer);
        detailContainer.appendChild(infoPanel);
        detailContainer.appendChild(toolbar);
        
        // Zum Hauptcontainer hinzufügen
        container.appendChild(detailContainer);
        
        return detailContainer;
    }
    
    /**
     * Schließt die Detail-Ansicht
     */
    function closeDetailView() {
        const detailView = document.getElementById('chart-detail-view');
        if (detailView) {
            // Animation zum Ausblenden
            detailView.classList.add('closing');
            
            // Nach Abschluss der Animation entfernen
            setTimeout(() => {
                detailView.remove();
                _detailViewActive = false;
                _detailViewConfig = {
                    type: null,
                    target: null,
                    data: null,
                    filters: {}
                };
                _detailChartInstance = null;
            }, 300);
        }
    }
    
    /**
     * Aktualisiert die Detail-Ansicht mit neuen Konfigurationsparametern
     * @param {Object} config - Konfigurationsobjekt für die Aktualisierung
     */
    function _updateDetailView(config) {
        if (!_detailViewActive || !_detailViewConfig.type) return;
        
        // Konfiguration aktualisieren
        if (config.filter) {
            _detailViewConfig.filters.currentFilter = config.filter;
        }
        
        // Daten basierend auf aktualisierten Filtern neu laden
        _loadDetailViewData().then(data => {
            if (!data) return;
            
            // Diagramm aktualisieren
            _updateDetailChart(data);
            
            // Statistikpanel aktualisieren
            _updateDetailInfoPanel(data);
        }).catch(error => {
            console.error('Fehler beim Aktualisieren der Detailansicht:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht geladen werden.');
        });
    }
    
    /**
     * Lädt Daten für die Detail-Ansicht basierend auf der aktuellen Konfiguration
     * @returns {Promise<Object>} - Promise mit den geladenen Daten
     */
    function _loadDetailViewData() {
        return new Promise((resolve, reject) => {
            // Cache-Schlüssel basierend auf Konfiguration erstellen
            const cacheKey = `${_detailViewConfig.type}_${_detailViewConfig.target}_${JSON.stringify(_detailViewConfig.filters)}`;
            
            // Prüfen, ob Daten bereits im Cache sind
            if (_drillDownDataCache[cacheKey]) {
                resolve(_drillDownDataCache[cacheKey]);
                return;
            }
            
            // Verschiedene Datentypen unterschiedlich behandeln
            let dataPromise;
            
            switch (_detailViewConfig.type) {
                case 'user':
                    dataPromise = _fetchUserDetailData(_detailViewConfig.target, _detailViewConfig.filters);
                    break;
                case 'test':
                    dataPromise = _fetchTestDetailData(_detailViewConfig.target, _detailViewConfig.filters);
                    break;
                case 'category':
                    dataPromise = _fetchCategoryDetailData(_detailViewConfig.target, _detailViewConfig.filters);
                    break;
                case 'trend':
                    dataPromise = _fetchTrendDetailData(_detailViewConfig.target, _detailViewConfig.filters);
                    break;
                default:
                    reject(new Error(`Unbekannter Detailtyp: ${_detailViewConfig.type}`));
                    return;
            }
            
            // Daten laden und in Cache speichern
            dataPromise.then(data => {
                _drillDownDataCache[cacheKey] = data;
                resolve(data);
            }).catch(error => {
                reject(error);
            });
        });
    }
    
    /**
     * Holt detaillierte Benutzerdaten für die Analyse
     * @param {string} userId - Benutzer-ID
     * @param {Object} filters - Filteroptionen
     * @returns {Promise<Object>} - Promise mit den geladenen Daten
     */
    function _fetchUserDetailData(userId, filters) {
        return new Promise((resolve, reject) => {
            try {
                // Hier würde normalerweise ein echter API-Aufruf stehen
                // Für jetzt simulieren wir die Daten basierend auf LocalStorage
                
                // Benutzerdaten abrufen
                const users = window.ImmoLMS.DataStore.getUsers();
                const user = users.find(u => u.id === userId);
                
                if (!user) {
                    reject(new Error(`Benutzer mit ID ${userId} nicht gefunden`));
                    return;
                }
                
                // Testergebnisse abrufen
                const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                const userResults = testResults.filter(result => result.userId === userId);
                
                // Tests abrufen
                const tests = window.ImmoLMS.DataStore.getTests() || [];
                
                // Zeitraumbegrenzung hinzufügen, falls vorhanden
                let filteredResults = userResults;
                if (filters.timeRange) {
                    const now = new Date();
                    const cutoffDate = new Date();
                    
                    switch (filters.timeRange) {
                        case '7days':
                            cutoffDate.setDate(now.getDate() - 7);
                            break;
                        case '30days':
                            cutoffDate.setDate(now.getDate() - 30);
                            break;
                        case '90days':
                            cutoffDate.setDate(now.getDate() - 90);
                            break;
                        case '365days':
                            cutoffDate.setDate(now.getDate() - 365);
                            break;
                    }
                    
                    filteredResults = userResults.filter(result => {
                        const resultDate = new Date(result.completedAt);
                        return resultDate >= cutoffDate;
                    });
                }
                
                // Ergebnisse mit Testdaten anreichern
                const enrichedResults = filteredResults.map(result => {
                    const test = tests.find(t => t.id === result.testId);
                    return {
                        ...result,
                        testName: test ? test.title : 'Unbekannter Test',
                        testCategory: test ? test.category : 'Keine Kategorie',
                        completedDate: new Date(result.completedAt).toLocaleDateString()
                    };
                });
                
                // Daten nach Datum sortieren
                enrichedResults.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
                
                // Daten für das Chart vorbereiten
                const labels = enrichedResults.map(r => r.completedDate);
                const scores = enrichedResults.map(r => r.score);
                const passThresholds = enrichedResults.map(r => r.passThreshold);
                const categories = [...new Set(enrichedResults.map(r => r.testCategory))];
                
                // Kategorie-basierte Datensets vorbereiten
                const categoryDatasets = categories.map(category => {
                    const categoryResults = enrichedResults.filter(r => r.testCategory === category);
                    return {
                        label: category,
                        data: labels.map(date => {
                            const result = categoryResults.find(r => r.completedDate === date);
                            return result ? result.score : null;
                        }),
                        borderColor: _getCategoryColor(category),
                        backgroundColor: _getBackgroundColor(_getCategoryColor(category), 0.2)
                    };
                });
                
                // Kategoriefilter anwenden, falls vorhanden
                let filteredDatasets = categoryDatasets;
                if (filters.category && filters.category !== 'all') {
                    filteredDatasets = categoryDatasets.filter(ds => ds.label === filters.category);
                }
                
                // Statistiken berechnen
                const avgScore = scores.length > 0 ? scores.reduce((sum, score) => sum + score, 0) / scores.length : 0;
                const passCount = enrichedResults.filter(r => r.passed).length;
                const passRate = enrichedResults.length > 0 ? (passCount / enrichedResults.length) * 100 : 0;
                
                // Zeitreihen-Aufschlüsselung
                const resultsByMonth = {};
                enrichedResults.forEach(result => {
                    const date = new Date(result.completedAt);
                    const monthYear = `${date.getMonth() + 1}/${date.getFullYear()}`;
                    
                    if (!resultsByMonth[monthYear]) {
                        resultsByMonth[monthYear] = [];
                    }
                    
                    resultsByMonth[monthYear].push(result);
                });
                
                // Monatsstatistiken berechnen
                const monthlyStats = Object.entries(resultsByMonth).map(([month, results]) => {
                    const monthScores = results.map(r => r.score);
                    const monthAvg = monthScores.reduce((sum, score) => sum + score, 0) / monthScores.length;
                    const monthPassCount = results.filter(r => r.passed).length;
                    const monthPassRate = (monthPassCount / results.length) * 100;
                    
                    return {
                        month,
                        avgScore: monthAvg,
                        passRate: monthPassRate,
                        testCount: results.length
                    };
                });
                
                // Daten zusammenstellen
                const detailData = {
                    chartData: {
                        labels,
                        datasets: filteredDatasets
                    },
                    user: {
                        id: user.id,
                        name: `${user.firstName} ${user.lastName}`,
                        role: user.role,
                        team: user.team
                    },
                    stats: {
                        testsTaken: enrichedResults.length,
                        avgScore: avgScore.toFixed(1),
                        passRate: passRate.toFixed(1),
                        highestScore: Math.max(...scores),
                        lowestScore: Math.min(...scores),
                        lastTestDate: enrichedResults.length > 0 ? 
                            new Date(enrichedResults[enrichedResults.length - 1].completedAt).toLocaleDateString() : 'N/A'
                    },
                    timeSeriesData: monthlyStats,
                    categories,
                    rawResults: enrichedResults
                };
                
                resolve(detailData);
            } catch (error) {
                console.error('Fehler beim Laden der Benutzerdetaildaten:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Holt detaillierte Testdaten für die Analyse
     * @param {string} testId - Test-ID
     * @param {Object} filters - Filteroptionen
     * @returns {Promise<Object>} - Promise mit den geladenen Daten
     */
    function _fetchTestDetailData(testId, filters) {
        return new Promise((resolve, reject) => {
            try {
                // Testdaten abrufen
                const tests = window.ImmoLMS.DataStore.getTests();
                const test = tests.find(t => t.id === testId);
                
                if (!test) {
                    reject(new Error(`Test mit ID ${testId} nicht gefunden`));
                    return;
                }
                
                // Testergebnisse abrufen
                const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                const testSpecificResults = testResults.filter(result => result.testId === testId);
                
                // Benutzer abrufen
                const users = window.ImmoLMS.DataStore.getUsers();
                
                // Zeitraumbegrenzung hinzufügen, falls vorhanden
                let filteredResults = testSpecificResults;
                if (filters.timeRange) {
                    const now = new Date();
                    const cutoffDate = new Date();
                    
                    switch (filters.timeRange) {
                        case '7days':
                            cutoffDate.setDate(now.getDate() - 7);
                            break;
                        case '30days':
                            cutoffDate.setDate(now.getDate() - 30);
                            break;
                        case '90days':
                            cutoffDate.setDate(now.getDate() - 90);
                            break;
                        case '365days':
                            cutoffDate.setDate(now.getDate() - 365);
                            break;
                    }
                    
                    filteredResults = testSpecificResults.filter(result => {
                        const resultDate = new Date(result.completedAt);
                        return resultDate >= cutoffDate;
                    });
                }
                
                // Ergebnisse mit Benutzerdaten anreichern
                const enrichedResults = filteredResults.map(result => {
                    const user = users.find(u => u.id === result.userId);
                    return {
                        ...result,
                        userName: user ? `${user.firstName} ${user.lastName}` : 'Unbekannter Benutzer',
                        userTeam: user ? user.team : 'Kein Team',
                        completedDate: new Date(result.completedAt).toLocaleDateString()
                    };
                });
                
                // Nach Datum sortieren
                enrichedResults.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
                
                // Teambasierte Daten gruppieren
                const teamData = {};
                const teams = [...new Set(enrichedResults.map(r => r.userTeam))];
                
                teams.forEach(team => {
                    const teamResults = enrichedResults.filter(r => r.userTeam === team);
                    const teamScores = teamResults.map(r => r.score);
                    const avgScore = teamScores.reduce((sum, score) => sum + score, 0) / teamScores.length;
                    const passCount = teamResults.filter(r => r.passed).length;
                    const passRate = (passCount / teamResults.length) * 100;
                    
                    teamData[team] = {
                        avgScore,
                        passRate,
                        testCount: teamResults.length,
                        results: teamResults
                    };
                });
                
                // Datumsbasierte Gruppierung für Trend-Analyse
                const dateGroups = {};
                enrichedResults.forEach(result => {
                    const date = result.completedDate;
                    if (!dateGroups[date]) {
                        dateGroups[date] = [];
                    }
                    dateGroups[date].push(result);
                });
                
                // Durchschnittsdaten pro Datum berechnen
                const dateAverages = Object.entries(dateGroups).map(([date, results]) => {
                    const scores = results.map(r => r.score);
                    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    const passCount = results.filter(r => r.passed).length;
                    const passRate = (passCount / results.length) * 100;
                    
                    return {
                        date,
                        avgScore,
                        passRate,
                        testCount: results.length
                    };
                });
                
                // Daten für Charts aufbereiten
                const labels = dateAverages.map(item => item.date);
                const avgScores = dateAverages.map(item => item.avgScore);
                const passRates = dateAverages.map(item => item.passRate);
                
                // Teambasierte Datasets für Charts
                const teamDatasets = teams.map(team => {
                    // Für jedes Datum den Durchschnittswert für das jeweilige Team finden
                    const teamScores = labels.map(date => {
                        const dateResults = dateGroups[date].filter(r => r.userTeam === team);
                        if (dateResults.length === 0) return null;
                        
                        const scores = dateResults.map(r => r.score);
                        return scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    });
                    
                    return {
                        label: team,
                        data: teamScores,
                        borderColor: _getTeamColor(team),
                        backgroundColor: _getBackgroundColor(_getTeamColor(team), 0.2)
                    };
                });
                
                // Teamfilter anwenden, falls vorhanden
                let filteredDatasets = teamDatasets;
                if (filters.team && filters.team !== 'all') {
                    filteredDatasets = teamDatasets.filter(ds => ds.label === filters.team);
                }
                
                // Statistiken berechnen
                const allScores = enrichedResults.map(r => r.score);
                const avgScore = allScores.length > 0 ? allScores.reduce((sum, score) => sum + score, 0) / allScores.length : 0;
                const passCount = enrichedResults.filter(r => r.passed).length;
                const passRate = enrichedResults.length > 0 ? (passCount / enrichedResults.length) * 100 : 0;
                
                // Fragenanalyse
                const questionPerformance = {};
                
                // Geht durch alle Ergebnisse und extrahiert Fragenperformance
                enrichedResults.forEach(result => {
                    if (!result.questionResults) return;
                    
                    result.questionResults.forEach(qResult => {
                        if (!questionPerformance[qResult.questionId]) {
                            questionPerformance[qResult.questionId] = {
                                correct: 0,
                                total: 0,
                                correctRate: 0
                            };
                        }
                        
                        questionPerformance[qResult.questionId].total++;
                        if (qResult.isCorrect) {
                            questionPerformance[qResult.questionId].correct++;
                        }
                    });
                });
                
                // Berechnet Erfolgsraten für Fragen
                Object.keys(questionPerformance).forEach(qId => {
                    const qData = questionPerformance[qId];
                    qData.correctRate = (qData.correct / qData.total) * 100;
                });
                
                // Top-Problematische Fragen identifizieren
                const problematicQuestions = Object.entries(questionPerformance)
                    .map(([id, data]) => ({ id, ...data }))
                    .sort((a, b) => a.correctRate - b.correctRate)
                    .slice(0, 5);
                
                // Daten zusammenstellen
                const detailData = {
                    chartData: {
                        labels,
                        datasets: [
                            ...filteredDatasets,
                            {
                                label: 'Bestehensrate',
                                data: passRates,
                                borderColor: '#00FFD0',
                                backgroundColor: 'rgba(0, 255, 208, 0.2)',
                                yAxisID: 'percentageAxis'
                            }
                        ]
                    },
                    test: {
                        id: test.id,
                        title: test.title,
                        category: test.category,
                        passThreshold: test.passThreshold
                    },
                    stats: {
                        timesCompleted: enrichedResults.length,
                        avgScore: avgScore.toFixed(1),
                        passRate: passRate.toFixed(1),
                        highestScore: Math.max(...allScores),
                        lowestScore: Math.min(...allScores),
                        lastCompletionDate: enrichedResults.length > 0 ? 
                            new Date(enrichedResults[enrichedResults.length - 1].completedAt).toLocaleDateString() : 'N/A'
                    },
                    teamData,
                    teams,
                    timeSeriesData: dateAverages,
                    questionPerformance,
                    problematicQuestions,
                    rawResults: enrichedResults
                };
                
                resolve(detailData);
            } catch (error) {
                console.error('Fehler beim Laden der Testdetaildaten:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Holt detaillierte Kategoriedaten für die Analyse
     * @param {string} category - Kategoriename
     * @param {Object} filters - Filteroptionen
     * @returns {Promise<Object>} - Promise mit den geladenen Daten
     */
    function _fetchCategoryDetailData(category, filters) {
        return new Promise((resolve, reject) => {
            try {
                // Tests in dieser Kategorie abrufen
                const tests = window.ImmoLMS.DataStore.getTests();
                const categoryTests = tests.filter(test => test.category === category);
                
                if (categoryTests.length === 0) {
                    reject(new Error(`Keine Tests für Kategorie ${category} gefunden`));
                    return;
                }
                
                // IDs für Kategorietests abrufen
                const categoryTestIds = categoryTests.map(test => test.id);
                
                // Testergebnisse abrufen
                const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                const categoryResults = testResults.filter(result => categoryTestIds.includes(result.testId));
                
                // Benutzer abrufen
                const users = window.ImmoLMS.DataStore.getUsers();
                
                // Zeitraumbegrenzung hinzufügen, falls vorhanden
                let filteredResults = categoryResults;
                if (filters.timeRange) {
                    const now = new Date();
                    const cutoffDate = new Date();
                    
                    switch (filters.timeRange) {
                        case '7days':
                            cutoffDate.setDate(now.getDate() - 7);
                            break;
                        case '30days':
                            cutoffDate.setDate(now.getDate() - 30);
                            break;
                        case '90days':
                            cutoffDate.setDate(now.getDate() - 90);
                            break;
                        case '365days':
                            cutoffDate.setDate(now.getDate() - 365);
                            break;
                    }
                    
                    filteredResults = categoryResults.filter(result => {
                        const resultDate = new Date(result.completedAt);
                        return resultDate >= cutoffDate;
                    });
                }
                
                // Ergebnisse mit Benutzer- und Testdaten anreichern
                const enrichedResults = filteredResults.map(result => {
                    const user = users.find(u => u.id === result.userId);
                    const test = tests.find(t => t.id === result.testId);
                    
                    return {
                        ...result,
                        userName: user ? `${user.firstName} ${user.lastName}` : 'Unbekannter Benutzer',
                        userTeam: user ? user.team : 'Kein Team',
                        testName: test ? test.title : 'Unbekannter Test',
                        completedDate: new Date(result.completedAt).toLocaleDateString()
                    };
                });
                
                // Nach Datum sortieren
                enrichedResults.sort((a, b) => new Date(a.completedAt) - new Date(b.completedAt));
                
                // Daten nach Tests gruppieren
                const testData = {};
                categoryTests.forEach(test => {
                    const testResults = enrichedResults.filter(r => r.testId === test.id);
                    const testScores = testResults.map(r => r.score);
                    const avgScore = testScores.length > 0 ? testScores.reduce((sum, score) => sum + score, 0) / testScores.length : 0;
                    const passCount = testResults.filter(r => r.passed).length;
                    const passRate = testResults.length > 0 ? (passCount / testResults.length) * 100 : 0;
                    
                    testData[test.id] = {
                        title: test.title,
                        avgScore,
                        passRate,
                        testCount: testResults.length,
                        results: testResults
                    };
                });
                
                // Zeitreihenanalyse
                const dateGroups = {};
                enrichedResults.forEach(result => {
                    const date = result.completedDate;
                    if (!dateGroups[date]) {
                        dateGroups[date] = [];
                    }
                    dateGroups[date].push(result);
                });
                
                // Durchschnittsdaten pro Datum berechnen
                const dateAverages = Object.entries(dateGroups).map(([date, results]) => {
                    const scores = results.map(r => r.score);
                    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    const passCount = results.filter(r => r.passed).length;
                    const passRate = (passCount / results.length) * 100;
                    
                    return {
                        date,
                        avgScore,
                        passRate,
                        testCount: results.length
                    };
                });
                
                // Daten für das Chart aufbereiten
                const labels = dateAverages.map(item => item.date);
                const avgScores = dateAverages.map(item => item.avgScore);
                const passRates = dateAverages.map(item => item.passRate);
                
                // Testbasierte Chart-Datensets
                const testDatasets = categoryTests.map(test => {
                    // Für jedes Datum den Durchschnittswert für den jeweiligen Test finden
                    const testScores = labels.map(date => {
                        const dateResults = dateGroups[date].filter(r => r.testId === test.id);
                        if (dateResults.length === 0) return null;
                        
                        const scores = dateResults.map(r => r.score);
                        return scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    });
                    
                    return {
                        label: test.title,
                        data: testScores,
                        borderColor: _getTestColor(test.id),
                        backgroundColor: _getBackgroundColor(_getTestColor(test.id), 0.2)
                    };
                });
                
                // Testfilter anwenden, falls vorhanden
                let filteredDatasets = testDatasets;
                if (filters.test && filters.test !== 'all') {
                    filteredDatasets = testDatasets.filter(ds => {
                        const test = categoryTests.find(t => t.title === ds.label);
                        return test && test.id === filters.test;
                    });
                }
                
                // Statistiken berechnen
                const allScores = enrichedResults.map(r => r.score);
                const avgScore = allScores.length > 0 ? allScores.reduce((sum, score) => sum + score, 0) / allScores.length : 0;
                const passCount = enrichedResults.filter(r => r.passed).length;
                const passRate = enrichedResults.length > 0 ? (passCount / enrichedResults.length) * 100 : 0;
                
                // Daten zusammenstellen
                const detailData = {
                    chartData: {
                        labels,
                        datasets: [
                            ...filteredDatasets,
                            {
                                label: 'Gesamte Bestehensrate',
                                data: passRates,
                                borderColor: '#00FFD0',
                                backgroundColor: 'rgba(0, 255, 208, 0.2)',
                                yAxisID: 'percentageAxis'
                            }
                        ]
                    },
                    category: {
                        name: category,
                        testCount: categoryTests.length
                    },
                    stats: {
                        timesCompleted: enrichedResults.length,
                        avgScore: avgScore.toFixed(1),
                        passRate: passRate.toFixed(1),
                        highestScore: Math.max(...allScores),
                        lowestScore: Math.min(...allScores),
                        lastCompletionDate: enrichedResults.length > 0 ? 
                            new Date(enrichedResults[enrichedResults.length - 1].completedAt).toLocaleDateString() : 'N/A'
                    },
                    testData,
                    tests: categoryTests,
                    timeSeriesData: dateAverages,
                    rawResults: enrichedResults
                };
                
                resolve(detailData);
            } catch (error) {
                console.error('Fehler beim Laden der Kategoriedetaildaten:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Holt detaillierte Trenddaten für die Analyse
     * @param {string} trendType - Trendtyp ('weekly', 'monthly', etc.)
     * @param {Object} filters - Filteroptionen
     * @returns {Promise<Object>} - Promise mit den geladenen Daten
     */
    function _fetchTrendDetailData(trendType, filters) {
        return new Promise((resolve, reject) => {
            try {
                // Testergebnisse abrufen
                const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                
                // Zeitraumbegrenzung hinzufügen, falls vorhanden
                let filteredResults = testResults;
                if (filters.timeRange) {
                    const now = new Date();
                    const cutoffDate = new Date();
                    
                    switch (filters.timeRange) {
                        case '7days':
                            cutoffDate.setDate(now.getDate() - 7);
                            break;
                        case '30days':
                            cutoffDate.setDate(now.getDate() - 30);
                            break;
                        case '90days':
                            cutoffDate.setDate(now.getDate() - 90);
                            break;
                        case '365days':
                            cutoffDate.setDate(now.getDate() - 365);
                            break;
                    }
                    
                    filteredResults = testResults.filter(result => {
                        const resultDate = new Date(result.completedAt);
                        return resultDate >= cutoffDate;
                    });
                }
                
                // Tests und Benutzer abrufen
                const tests = window.ImmoLMS.DataStore.getTests();
                const users = window.ImmoLMS.DataStore.getUsers();
                
                // Ergebnisse mit Test- und Benutzerdaten anreichern
                const enrichedResults = filteredResults.map(result => {
                    const user = users.find(u => u.id === result.userId);
                    const test = tests.find(t => t.id === result.testId);
                    
                    return {
                        ...result,
                        userName: user ? `${user.firstName} ${user.lastName}` : 'Unbekannter Benutzer',
                        userTeam: user ? user.team : 'Kein Team',
                        testName: test ? test.title : 'Unbekannter Test',
                        testCategory: test ? test.category : 'Keine Kategorie',
                        completedDate: new Date(result.completedAt).toLocaleDateString(),
                        completedDateTime: new Date(result.completedAt)
                    };
                });
                
                // Nach Datum sortieren
                enrichedResults.sort((a, b) => a.completedDateTime - b.completedDateTime);
                
                // Zeitreihenformatierung basierend auf Trendtyp
                let groupedResults;
                let labels;
                
                switch (trendType) {
                    case 'daily':
                        // Tägliche Gruppierung
                        groupedResults = _groupByDaily(enrichedResults);
                        break;
                        
                    case 'weekly':
                        // Wöchentliche Gruppierung
                        groupedResults = _groupByWeekly(enrichedResults);
                        break;
                        
                    case 'monthly':
                        // Monatliche Gruppierung
                        groupedResults = _groupByMonthly(enrichedResults);
                        break;
                        
                    case 'quarterly':
                        // Quartalsweise Gruppierung
                        groupedResults = _groupByQuarterly(enrichedResults);
                        break;
                        
                    default:
                        // Standardmäßig tägliche Gruppierung
                        groupedResults = _groupByDaily(enrichedResults);
                }
                
                // Kategoriefilter anwenden, falls vorhanden
                if (filters.category && filters.category !== 'all') {
                    Object.keys(groupedResults).forEach(period => {
                        groupedResults[period] = groupedResults[period].filter(r => r.testCategory === filters.category);
                    });
                }
                
                // Teamfilter anwenden, falls vorhanden
                if (filters.team && filters.team !== 'all') {
                    Object.keys(groupedResults).forEach(period => {
                        groupedResults[period] = groupedResults[period].filter(r => r.userTeam === filters.team);
                    });
                }
                
                // Zeitreihenstatistiken berechnen
                const timeSeriesStats = {};
                labels = Object.keys(groupedResults).sort((a, b) => {
                    // Sortierung basierend auf Trend-Typ
                    if (trendType === 'daily' || trendType === 'weekly') {
                        return new Date(a) - new Date(b);
                    } else {
                        // Für monatliche und quartalsweise Ansichten
                        const [aMonth, aYear] = a.split('/');
                        const [bMonth, bYear] = b.split('/');
                        return new Date(aYear, aMonth - 1) - new Date(bYear, bMonth - 1);
                    }
                });
                
                // Durchschnittsstatistiken für jeden Zeitraum berechnen
                labels.forEach(period => {
                    const periodResults = groupedResults[period];
                    const scores = periodResults.map(r => r.score);
                    const avgScore = scores.length > 0 ? scores.reduce((sum, score) => sum + score, 0) / scores.length : 0;
                    const passCount = periodResults.filter(r => r.passed).length;
                    const passRate = periodResults.length > 0 ? (passCount / periodResults.length) * 100 : 0;
                    
                    timeSeriesStats[period] = {
                        avgScore,
                        passRate,
                        testCount: periodResults.length,
                        uniqueUsers: [...new Set(periodResults.map(r => r.userId))].length
                    };
                });
                
                // Statistikreihen für das Chart erstellen
                const avgScores = labels.map(period => timeSeriesStats[period].avgScore);
                const passRates = labels.map(period => timeSeriesStats[period].passRate);
                const testCounts = labels.map(period => timeSeriesStats[period].testCount);
                const uniqueUsers = labels.map(period => timeSeriesStats[period].uniqueUsers);
                
                // Teams extrahieren
                const teams = [...new Set(enrichedResults.map(r => r.userTeam))];
                
                // Teambasierte Datasets
                const teamDatasets = teams.map(team => {
                    const teamScores = labels.map(period => {
                        const teamResults = groupedResults[period].filter(r => r.userTeam === team);
                        if (teamResults.length === 0) return null;
                        
                        const scores = teamResults.map(r => r.score);
                        return scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    });
                    
                    return {
                        label: `Team ${team}`,
                        data: teamScores,
                        borderColor: _getTeamColor(team),
                        backgroundColor: _getBackgroundColor(_getTeamColor(team), 0.2)
                    };
                });
                
                // Testdaten für alle Ergebnisse berechnen
                const allScores = enrichedResults.map(r => r.score);
                const avgScore = allScores.length > 0 ? allScores.reduce((sum, score) => sum + score, 0) / allScores.length : 0;
                const passCount = enrichedResults.filter(r => r.passed).length;
                const passRate = enrichedResults.length > 0 ? (passCount / enrichedResults.length) * 100 : 0;
                
                // Kategorien identifizieren
                const categories = [...new Set(enrichedResults.map(r => r.testCategory))];
                
                // Daten zusammenstellen
                const detailData = {
                    chartData: {
                        labels,
                        datasets: [
                            {
                                label: 'Durchschnittliche Punktzahl',
                                data: avgScores,
                                borderColor: '#00FFD0',
                                backgroundColor: 'rgba(0, 255, 208, 0.2)',
                                yAxisID: 'scoreAxis'
                            },
                            {
                                label: 'Bestehensrate',
                                data: passRates,
                                borderColor: '#007BFF',
                                backgroundColor: 'rgba(0, 123, 255, 0.2)',
                                yAxisID: 'percentageAxis'
                            },
                            {
                                label: 'Anzahl der Tests',
                                data: testCounts,
                                borderColor: '#FFC107',
                                backgroundColor: 'rgba(255, 193, 7, 0.2)',
                                yAxisID: 'countAxis'
                            }
                        ]
                    },
                    timeSeriesStats,
                    teamDatasets,
                    trend: {
                        type: trendType,
                        periodCount: labels.length
                    },
                    stats: {
                        totalTests: enrichedResults.length,
                        avgScore: avgScore.toFixed(1),
                        passRate: passRate.toFixed(1),
                        uniqueUsers: [...new Set(enrichedResults.map(r => r.userId))].length,
                        activePeriods: labels.length
                    },
                    teams,
                    categories,
                    rawData: {
                        groupedResults,
                        enrichedResults
                    }
                };
                
                resolve(detailData);
            } catch (error) {
                console.error('Fehler beim Laden der Trenddetaildaten:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Gruppiert Ergebnisse nach Tagen
     * @param {Array} results - Ergebnisarray
     * @returns {Object} - Nach Tagen gruppierte Ergebnisse
     */
    function _groupByDaily(results) {
        const grouped = {};
        
        results.forEach(result => {
            const date = result.completedDate;
            
            if (!grouped[date]) {
                grouped[date] = [];
            }
            
            grouped[date].push(result);
        });
        
        return grouped;
    }
    
    /**
     * Gruppiert Ergebnisse nach Wochen
     * @param {Array} results - Ergebnisarray
     * @returns {Object} - Nach Wochen gruppierte Ergebnisse
     */
    function _groupByWeekly(results) {
        const grouped = {};
        
        results.forEach(result => {
            const date = new Date(result.completedDateTime);
            const startOfWeek = new Date(date);
            
            // Auf den Sonntag der Woche zurücksetzen
            startOfWeek.setDate(date.getDate() - date.getDay());
            
            // Format: YYYY-MM-DD
            const weekKey = startOfWeek.toISOString().split('T')[0];
            
            if (!grouped[weekKey]) {
                grouped[weekKey] = [];
            }
            
            grouped[weekKey].push(result);
        });
        
        return grouped;
    }
    
    /**
     * Gruppiert Ergebnisse nach Monaten
     * @param {Array} results - Ergebnisarray
     * @returns {Object} - Nach Monaten gruppierte Ergebnisse
     */
    function _groupByMonthly(results) {
        const grouped = {};
        
        results.forEach(result => {
            const date = new Date(result.completedDateTime);
            // Format: MM/YYYY
            const monthKey = `${date.getMonth() + 1}/${date.getFullYear()}`;
            
            if (!grouped[monthKey]) {
                grouped[monthKey] = [];
            }
            
            grouped[monthKey].push(result);
        });
        
        return grouped;
    }
    
    /**
     * Gruppiert Ergebnisse nach Quartalen
     * @param {Array} results - Ergebnisarray
     * @returns {Object} - Nach Quartalen gruppierte Ergebnisse
     */
    function _groupByQuarterly(results) {
        const grouped = {};
        
        results.forEach(result => {
            const date = new Date(result.completedDateTime);
            const quarter = Math.floor(date.getMonth() / 3) + 1;
            // Format: Q1/YYYY
            const quarterKey = `Q${quarter}/${date.getFullYear()}`;
            
            if (!grouped[quarterKey]) {
                grouped[quarterKey] = [];
            }
            
            grouped[quarterKey].push(result);
        });
        
        return grouped;
    }
    
    /**
     * Generiert eine konsistente Farbe für eine Kategorie
     * @param {string} category - Kategoriename
     * @returns {string} - Farbcode
     */
    function _getCategoryColor(category) {
        // Wir verwenden einen einfachen Hash, um eine konsistente Farbe zu generieren
        let hash = 0;
        for (let i = 0; i < category.length; i++) {
            hash = category.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Basierend auf ImmoScout24-Farbschema (Cyan-Grün-Palette)
        const baseColors = [
            '#00FFD0', // ImmoScout24 Hauptfarbe
            '#00E6BD', 
            '#00CCAA',
            '#00B396', 
            '#009982',
            '#00806F',
            '#00665C',
            '#004D44'
        ];
        
        // Farbe aus Palette auswählen
        return baseColors[Math.abs(hash) % baseColors.length];
    }
    
    /**
     * Generiert eine konsistente Farbe für ein Team
     * @param {string} team - Teamname
     * @returns {string} - Farbcode
     */
    function _getTeamColor(team) {
        // Wir verwenden einen einfachen Hash, um eine konsistente Farbe zu generieren
        let hash = 0;
        for (let i = 0; i < team.length; i++) {
            hash = team.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Basierend auf ImmoScout24-Farbschema (Blau-Palette)
        const baseColors = [
            '#007BFF',
            '#0069D9',
            '#0056B3',
            '#004590',
            '#00326B',
            '#001E44',
            '#000E20'
        ];
        
        // Farbe aus Palette auswählen
        return baseColors[Math.abs(hash) % baseColors.length];
    }
    
    /**
     * Generiert eine konsistente Farbe für einen Test
     * @param {string} testId - Test-ID
     * @returns {string} - Farbcode
     */
    function _getTestColor(testId) {
        // Wir verwenden einen einfachen Hash, um eine konsistente Farbe zu generieren
        let hash = 0;
        for (let i = 0; i < testId.length; i++) {
            hash = testId.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Basierend auf ImmoScout24-Farbschema (Lila-Palette)
        const baseColors = [
            '#6610f2',
            '#5E0DE1',
            '#560AD1',
            '#4E08C0',
            '#4606AF',
            '#3E059F',
            '#36048E',
            '#2E037C',
            '#26026B',
            '#1E015A'
        ];
        
        // Farbe aus Palette auswählen
        return baseColors[Math.abs(hash) % baseColors.length];
    }
    
    /**
     * Generiert eine Hintergrundfarbe mit Transparenz
     * @param {string} color - RGB- oder Hex-Farbcode
     * @param {number} alpha - Transparenzwert (0-1)
     * @returns {string} - RGBA-Farbcode mit Transparenz
     */
    function _getBackgroundColor(color, alpha) {
        // Überprüfen, ob es sich um einen Hex-Farbcode handelt
        if (color.startsWith('#')) {
            // Hex zu RGB konvertieren
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Regulärer Ausdruck für RGB-Farbcode (rgb(r, g, b))
        const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1]);
            const g = parseInt(rgbMatch[2]);
            const b = parseInt(rgbMatch[3]);
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Falls kein gültiger Farbcode, transparentes Schwarz zurückgeben
        return `rgba(0, 0, 0, ${alpha})`;
    }
    
    /**
     * Aktualisiert das Detail-Chart mit neuen Daten
     * @param {Object} data - Chartdaten
     */
    function _updateDetailChart(data) {
        const chartCanvas = document.getElementById('detail-chart');
        if (!chartCanvas) return;
        
        // Bestehende Chart-Instanz zerstören, falls vorhanden
        if (_detailChartInstance) {
            _detailChartInstance.destroy();
        }
        
        // Chart-Typ basierend auf Datentyp wählen
        let chartType = 'line';
        let chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: _advancedSettings.animationEnabled,
            interaction: {
                mode: _advancedSettings.tooltipMode,
                intersect: false
            },
            plugins: {
                legend: {
                    position: _advancedSettings.legendPosition
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            const yAxisID = context.dataset.yAxisID;
                            
                            let suffix = '';
                            if (yAxisID === 'percentageAxis') {
                                suffix = '%';
                            } else if (yAxisID === 'countAxis') {
                                suffix = ' Tests';
                            }
                            
                            return `${label}: ${value.toFixed(1)}${suffix}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        display: _advancedSettings.gridLines
                    }
                },
                y: {
                    beginAtZero: true,
                    grid: {
                        display: _advancedSettings.gridLines
                    }
                }
            }
        };
        
        // Chart-Optionen anpassen, wenn mehrere Y-Achsen benötigt werden
        const hasMultipleYAxes = data.chartData.datasets.some(ds => ds.yAxisID);
        
        if (hasMultipleYAxes) {
            chartOptions.scales = {
                x: {
                    grid: {
                        display: _advancedSettings.gridLines
                    }
                },
                scoreAxis: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                        display: true,
                        text: 'Punktzahl'
                    },
                    beginAtZero: true,
                    grid: {
                        display: _advancedSettings.gridLines
                    }
                },
                percentageAxis: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Prozent'
                    },
                    min: 0,
                    max: 100,
                    grid: {
                        drawOnChartArea: false
                    }
                },
                countAxis: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Anzahl'
                    },
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false
                    }
                }
            };
        }
        
        // Chart erstellen
        _detailChartInstance = new Chart(chartCanvas, {
            type: chartType,
            data: data.chartData,
            options: chartOptions
        });
        
        // Hilfsdaten für das Chart speichern
        _detailChartInstance._metaData = {
            chartData: data.chartData,
            stats: data.stats,
            detailType: _detailViewConfig.type
        };
        
        // Detail-Ansichtstitel aktualisieren
        _updateDetailViewTitle(data);
        
        // Filter-Optionen aktualisieren
        _updateDetailFilterOptions(data);
        
        // Info-Panel aktualisieren
        _updateDetailInfoPanel(data);
    }
    
    /**
     * Aktualisiert den Titel der Detail-Ansicht
     * @param {Object} data - Detaildaten
     */
    function _updateDetailViewTitle(data) {
        const titleElement = document.getElementById('detail-view-title');
        if (!titleElement) return;
        
        let title = 'Detailansicht';
        
        switch (_detailViewConfig.type) {
            case 'user':
                title = `Benutzeranalyse: ${data.user.name}`;
                break;
            case 'test':
                title = `Testanalyse: ${data.test.title}`;
                break;
            case 'category':
                title = `Kategorieanalyse: ${data.category.name}`;
                break;
            case 'trend':
                title = `Trendanalyse: ${_getTrendTypeLabel(data.trend.type)}`;
                break;
        }
        
        titleElement.textContent = title;
    }
    
    /**
     * Aktualisiert die Filteroptionen in der Detail-Ansicht
     * @param {Object} data - Detaildaten
     */
    function _updateDetailFilterOptions(data) {
        const filterSelect = document.getElementById('detail-filter-select');
        if (!filterSelect) return;
        
        // Bestehende Optionen löschen
        while (filterSelect.options.length > 0) {
            filterSelect.remove(0);
        }
        
        // Standardoption hinzufügen
        const defaultOption = document.createElement('option');
        defaultOption.value = 'all';
        defaultOption.textContent = 'Alle Daten';
        filterSelect.appendChild(defaultOption);
        
        // Spezifische Filteroptionen basierend auf Detailtyp hinzufügen
        switch (_detailViewConfig.type) {
            case 'user':
                // Kategoriefilter für Benutzerdaten
                if (data.categories && data.categories.length > 0) {
                    data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = `Kategorie: ${category}`;
                        filterSelect.appendChild(option);
                    });
                }
                break;
                
            case 'test':
                // Teamfilter für Testdaten
                if (data.teams && data.teams.length > 0) {
                    data.teams.forEach(team => {
                        const option = document.createElement('option');
                        option.value = team;
                        option.textContent = `Team: ${team}`;
                        filterSelect.appendChild(option);
                    });
                }
                break;
                
            case 'category':
                // Testfilter für Kategoriedaten
                if (data.tests && data.tests.length > 0) {
                    data.tests.forEach(test => {
                        const option = document.createElement('option');
                        option.value = test.id;
                        option.textContent = `Test: ${test.title}`;
                        filterSelect.appendChild(option);
                    });
                }
                break;
                
            case 'trend':
                // Kategorie- und Teamfilter für Trenddaten
                if (data.categories && data.categories.length > 0) {
                    data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = `category_${category}`;
                        option.textContent = `Kategorie: ${category}`;
                        filterSelect.appendChild(option);
                    });
                }
                
                if (data.teams && data.teams.length > 0) {
                    data.teams.forEach(team => {
                        const option = document.createElement('option');
                        option.value = `team_${team}`;
                        option.textContent = `Team: ${team}`;
                        filterSelect.appendChild(option);
                    });
                }
                break;
        }
        
        // Gruppierungsoptionen für Trenddaten
        if (_detailViewConfig.type === 'trend') {
            const trendTypes = [
                { value: 'daily', label: 'Täglich' },
                { value: 'weekly', label: 'Wöchentlich' },
                { value: 'monthly', label: 'Monatlich' },
                { value: 'quarterly', label: 'Quartalsweise' }
            ];
            
            // Trennlinie hinzufügen
            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '───────────────';
            filterSelect.appendChild(separator);
            
            // Gruppierungsoptionen hinzufügen
            trendTypes.forEach(trend => {
                const option = document.createElement('option');
                option.value = `trend_${trend.value}`;
                option.textContent = `Gruppierung: ${trend.label}`;
                filterSelect.appendChild(option);
            });
        }
    }
    
    /**
     * Aktualisiert das Informationspanel in der Detail-Ansicht
     * @param {Object} data - Detaildaten
     */
    function _updateDetailInfoPanel(data) {
        const infoPanel = document.getElementById('detail-info-panel');
        if (!infoPanel) return;
        
        // Panel leeren
        infoPanel.innerHTML = '';
        
        // Statistik-Karten-Container erstellen
        const statsContainer = document.createElement('div');
        statsContainer.className = 'stats-card-container';
        
        // Statistik-Karten erstellen
        const stats = data.stats || {};
        
        // Formatierte Stats-Box-Generator
        const createStatBox = (label, value, icon) => {
            const statBox = document.createElement('div');
            statBox.className = 'stat-box';
            
            const iconElement = document.createElement('i');
            iconElement.className = `fas ${icon}`;
            
            const valueElement = document.createElement('div');
            valueElement.className = 'stat-value';
            valueElement.textContent = value;
            
            const labelElement = document.createElement('div');
            labelElement.className = 'stat-label';
            labelElement.textContent = label;
            
            statBox.appendChild(iconElement);
            statBox.appendChild(valueElement);
            statBox.appendChild(labelElement);
            
            return statBox;
        };
        
        // Universelle Statistiken für alle Detail-Typen
        statsContainer.appendChild(createStatBox('Durchschnitt', `${stats.avgScore || 0}%`, 'fa-chart-line'));
        statsContainer.appendChild(createStatBox('Bestehensrate', `${stats.passRate || 0}%`, 'fa-check-circle'));
        
        // Spezifische Statistiken basierend auf Detail-Typ
        switch (_detailViewConfig.type) {
            case 'user':
                statsContainer.appendChild(createStatBox('Tests absolviert', stats.testsTaken || 0, 'fa-clipboard-list'));
                statsContainer.appendChild(createStatBox('Höchste Punktzahl', `${stats.highestScore || 0}%`, 'fa-trophy'));
                if (stats.lastTestDate) {
                    statsContainer.appendChild(createStatBox('Letzter Test', stats.lastTestDate, 'fa-calendar'));
                }
                break;
                
            case 'test':
                statsContainer.appendChild(createStatBox('Absolvierungen', stats.timesCompleted || 0, 'fa-users'));
                if (data.test && data.test.passThreshold) {
                    statsContainer.appendChild(createStatBox('Bestehensgrenze', `${data.test.passThreshold}%`, 'fa-tasks'));
                }
                break;
                
            case 'category':
                statsContainer.appendChild(createStatBox('Tests', data.category.testCount || 0, 'fa-folder'));
                statsContainer.appendChild(createStatBox('Absolvierungen', stats.timesCompleted || 0, 'fa-users'));
                break;
                
            case 'trend':
                statsContainer.appendChild(createStatBox('Teilnehmer', stats.uniqueUsers || 0, 'fa-users'));
                statsContainer.appendChild(createStatBox('Absolvierungen', stats.totalTests || 0, 'fa-clipboard-list'));
                statsContainer.appendChild(createStatBox('Aktive Perioden', stats.activePeriods || 0, 'fa-calendar-alt'));
                break;
        }
        
        // Stats-Container hinzufügen
        infoPanel.appendChild(statsContainer);
        
        // Zusätzliche spezifische Informationen hinzufügen
        
        // Problematische Fragen für Tests
        if (_detailViewConfig.type === 'test' && data.problematicQuestions && data.problematicQuestions.length > 0) {
            const problemSection = document.createElement('div');
            problemSection.className = 'detail-section';
            
            const sectionTitle = document.createElement('h4');
            sectionTitle.textContent = 'Herausforderndste Fragen';
            problemSection.appendChild(sectionTitle);
            
            const problemList = document.createElement('ul');
            problemList.className = 'problem-question-list';
            
            data.problematicQuestions.forEach((question, index) => {
                const item = document.createElement('li');
                item.innerHTML = `<span class="question-id">Frage ${index + 1}</span>: <span class="correct-rate">${question.correctRate.toFixed(1)}%</span> korrekt <span class="question-stats">(${question.correct}/${question.total})</span>`;
                problemList.appendChild(item);
            });
            
            problemSection.appendChild(problemList);
            infoPanel.appendChild(problemSection);
        }
        
        // Zeitreiheninformationen für Trends
        if (_detailViewConfig.type === 'trend' && data.timeSeriesStats) {
            const trendSection = document.createElement('div');
            trendSection.className = 'detail-section';
            
            const sectionTitle = document.createElement('h4');
            sectionTitle.textContent = 'Trend-Highlights';
            trendSection.appendChild(sectionTitle);
            
            // Beste und schlechteste Perioden identifizieren
            const periods = Object.keys(data.timeSeriesStats);
            
            if (periods.length > 0) {
                let bestPeriod = periods[0];
                let worstPeriod = periods[0];
                let highestActivity = periods[0];
                
                periods.forEach(period => {
                    if (data.timeSeriesStats[period].avgScore > data.timeSeriesStats[bestPeriod].avgScore) {
                        bestPeriod = period;
                    }
                    
                    if (data.timeSeriesStats[period].avgScore < data.timeSeriesStats[worstPeriod].avgScore) {
                        worstPeriod = period;
                    }
                    
                    if (data.timeSeriesStats[period].testCount > data.timeSeriesStats[highestActivity].testCount) {
                        highestActivity = period;
                    }
                });
                
                const highlightList = document.createElement('ul');
                highlightList.className = 'trend-highlight-list';
                
                const bestItem = document.createElement('li');
                bestItem.innerHTML = `<span class="highlight-label">Beste Leistung:</span> <span class="highlight-period">${bestPeriod}</span> - <span class="highlight-value">${data.timeSeriesStats[bestPeriod].avgScore.toFixed(1)}%</span>`;
                highlightList.appendChild(bestItem);
                
                const worstItem = document.createElement('li');
                worstItem.innerHTML = `<span class="highlight-label">Schwächste Leistung:</span> <span class="highlight-period">${worstPeriod}</span> - <span class="highlight-value">${data.timeSeriesStats[worstPeriod].avgScore.toFixed(1)}%</span>`;
                highlightList.appendChild(worstItem);
                
                const activityItem = document.createElement('li');
                activityItem.innerHTML = `<span class="highlight-label">Höchste Aktivität:</span> <span class="highlight-period">${highestActivity}</span> - <span class="highlight-value">${data.timeSeriesStats[highestActivity].testCount} Tests</span>`;
                highlightList.appendChild(activityItem);
                
                trendSection.appendChild(highlightList);
                infoPanel.appendChild(trendSection);
            }
        }
    }
    
    /**
     * Exportiert Detaildaten als CSV-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDetailDataAsCSV(data, fileName) {
        try {
            let csvContent = '';
            let csvRows = [];
            
            // Je nach Detail-Typ unterschiedliche Daten exportieren
            switch (_detailViewConfig.type) {
                case 'user':
                    // Header-Zeile
                    csvRows.push(['Datum', 'Test', 'Kategorie', 'Punktzahl', 'Bestanden', 'Bestehensgrenze'].join(','));
                    
                    // Datenzeilen
                    if (data.rawResults) {
                        data.rawResults.forEach(result => {
                            const row = [
                                result.completedDate,
                                `"${result.testName}"`,
                                `"${result.testCategory}"`,
                                result.score,
                                result.passed ? 'Ja' : 'Nein',
                                result.passThreshold
                            ];
                            csvRows.push(row.join(','));
                        });
                    }
                    break;
                    
                case 'test':
                    // Header-Zeile
                    csvRows.push(['Datum', 'Benutzer', 'Team', 'Punktzahl', 'Bestanden'].join(','));
                    
                    // Datenzeilen
                    if (data.rawResults) {
                        data.rawResults.forEach(result => {
                            const row = [
                                result.completedDate,
                                `"${result.userName}"`,
                                `"${result.userTeam}"`,
                                result.score,
                                result.passed ? 'Ja' : 'Nein'
                            ];
                            csvRows.push(row.join(','));
                        });
                    }
                    break;
                    
                case 'category':
                    // Header-Zeile
                    csvRows.push(['Datum', 'Test', 'Benutzer', 'Team', 'Punktzahl', 'Bestanden'].join(','));
                    
                    // Datenzeilen
                    if (data.rawResults) {
                        data.rawResults.forEach(result => {
                            const row = [
                                result.completedDate,
                                `"${result.testName}"`,
                                `"${result.userName}"`,
                                `"${result.userTeam}"`,
                                result.score,
                                result.passed ? 'Ja' : 'Nein'
                            ];
                            csvRows.push(row.join(','));
                        });
                    }
                    break;
                    
                case 'trend':
                    // Header-Zeile
                    csvRows.push(['Zeitraum', 'Durchschnittliche Punktzahl', 'Bestehensrate', 'Anzahl Tests', 'Anzahl Benutzer'].join(','));
                    
                    // Datenzeilen
                    if (data.timeSeriesStats) {
                        Object.entries(data.timeSeriesStats).forEach(([period, stats]) => {
                            const row = [
                                period,
                                stats.avgScore.toFixed(1),
                                stats.passRate.toFixed(1),
                                stats.testCount,
                                stats.uniqueUsers
                            ];
                            csvRows.push(row.join(','));
                        });
                    }
                    break;
                    
                default:
                    // Fallback: Chart-Daten exportieren
                    if (data.chartData) {
                        // Header-Zeile
                        const headers = ['Label', ...data.chartData.datasets.map(ds => ds.label || 'Wert')];
                        csvRows.push(headers.join(','));
                        
                        // Datenzeilen
                        for (let i = 0; i < data.chartData.labels.length; i++) {
                            const rowValues = [
                                data.chartData.labels[i],
                                ...data.chartData.datasets.map(ds => {
                                    const value = ds.data[i];
                                    return value !== undefined ? value : '';
                                })
                            ];
                            
                            csvRows.push(rowValues.join(','));
                        }
                    }
            }
            
            // CSV-String erstellen
            csvContent = csvRows.join('\n');
            
            // Datei erstellen und herunterladen
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${_detailViewConfig.type}_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als CSV exportiert.');
        } catch (error) {
            console.error('Fehler beim CSV-Export der Detaildaten:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als CSV exportiert werden.');
        }
    }
    
    /**
     * Exportiert Detaildaten als JSON-Datei
     * @param {Object} data - Die zu exportierenden Daten
     * @param {string} fileName - Der Dateiname (ohne Erweiterung)
     */
    function _exportDetailDataAsJSON(data, fileName) {
        try {
            let exportData;
            
            // Je nach Detail-Typ unterschiedliche Daten exportieren
            switch (_detailViewConfig.type) {
                case 'user':
                    exportData = {
                        user: data.user,
                        stats: data.stats,
                        results: data.rawResults
                    };
                    break;
                    
                case 'test':
                    exportData = {
                        test: data.test,
                        stats: data.stats,
                        results: data.rawResults,
                        questionPerformance: data.questionPerformance
                    };
                    break;
                    
                case 'category':
                    exportData = {
                        category: data.category,
                        stats: data.stats,
                        tests: data.tests,
                        results: data.rawResults
                    };
                    break;
                    
                case 'trend':
                    exportData = {
                        trend: data.trend,
                        stats: data.stats,
                        timeSeriesData: data.timeSeriesStats
                    };
                    break;
                    
                default:
                    // Fallback: Gesamte Daten exportieren
                    exportData = data;
            }
            
            // JSON-String erstellen
            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Datei erstellen und herunterladen
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${fileName}_${_detailViewConfig.type}_${new Date().toISOString().split('T')[0]}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Daten wurden als JSON exportiert.');
        } catch (error) {
            console.error('Fehler beim JSON-Export der Detaildaten:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht als JSON exportiert werden.');
        }
    }
    
    /**
     * Speichert das Detail-Chart als Bild
     */
    function _saveDetailChartAsImage() {
        try {
            if (!_detailChartInstance) {
                window.ImmoLMS.Notifications.showError('Kein aktives Diagramm gefunden.');
                return;
            }
            
            // Bildtyp und -qualität festlegen
            const imageType = 'image/png';
            const imageQuality = 1.0;
            
            // Canvas-Bild als URL abrufen
            const imageUrl = _detailChartInstance.toBase64Image(imageType, imageQuality);
            
            // Dateiname generieren
            let fileName = 'detail_chart';
            
            switch (_detailViewConfig.type) {
                case 'user':
                    fileName = `user_analysis_${_detailViewConfig.target}`;
                    break;
                case 'test':
                    fileName = `test_analysis_${_detailViewConfig.target}`;
                    break;
                case 'category':
                    fileName = `category_analysis_${_detailViewConfig.target}`;
                    break;
                case 'trend':
                    fileName = `trend_analysis_${_detailViewConfig.target}`;
                    break;
            }
            
            // Link zum Herunterladen erstellen
            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = `${fileName}_${new Date().toISOString().split('T')[0]}.png`;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Diagramm wurde als Bild gespeichert.');
        } catch (error) {
            console.error('Fehler beim Speichern des Diagramms als Bild:', error);
            window.ImmoLMS.Notifications.showError('Diagramm konnte nicht als Bild gespeichert werden.');
        }
    }
    
    /**
     * Gibt ein Label für einen Trendtyp zurück
     * @param {string} trendType - Trendtyp-Kennung
     * @returns {string} - Lesbare Bezeichnung
     */
    function _getTrendTypeLabel(trendType) {
        switch (trendType) {
            case 'daily':
                return 'Tägliche Entwicklung';
            case 'weekly':
                return 'Wöchentliche Entwicklung';
            case 'monthly':
                return 'Monatliche Entwicklung';
            case 'quarterly':
                return 'Quartalsweise Entwicklung';
            default:
                return 'Zeitliche Entwicklung';
        }
    }
    
    /**
     * Öffnet die Detail-Ansicht für einen bestimmten Datenpunkt
     * @param {string} type - Detailtyp ('user', 'test', 'category', 'trend')
     * @param {string} target - Ziel-ID oder -Name
     * @param {Object} filters - Filteroptionen
     */
    function showDetailView(type, target, filters = {}) {
        // Dashboard-Container abrufen
        const dashboardContainer = document.getElementById('trainer-dashboard');
        if (!dashboardContainer) {
            console.error('Dashboard-Container nicht gefunden');
            return;
        }
        
        // Detail-Konfiguration setzen
        _detailViewConfig = {
            type: type,
            target: target,
            filters: filters || {}
        };
        
        // Detail-Ansicht erstellen/aktualisieren
        const detailContainer = _createDetailView('#trainer-dashboard');
        if (!detailContainer) return;
        
        // Detail-Ansicht als aktiv markieren
        _detailViewActive = true;
        
        // Daten laden und anzeigen
        _loadDetailViewData().then(data => {
            if (!data) {
                window.ImmoLMS.Notifications.showError('Keine Daten gefunden.');
                closeDetailView();
                return;
            }
            
            // Detail-Chart initialisieren
            _updateDetailChart(data);
            
            // Detail-Ansicht einblenden (mit Animation)
            detailContainer.style.opacity = '0';
            detailContainer.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                detailContainer.style.opacity = '1';
                detailContainer.style.transform = 'translateY(0)';
            }, 50);
            
        }).catch(error => {
            console.error('Fehler beim Laden der Detaildaten:', error);
            window.ImmoLMS.Notifications.showError('Daten konnten nicht geladen werden.');
            closeDetailView();
        });
    }
    
    /**
     * Aktualisiert die erweiterten Visualisierungseinstellungen
     * @param {Object} settings - Neue Einstellungen
     */
    function updateAdvancedSettings(settings) {
        // Einstellungen aktualisieren
        Object.assign(_advancedSettings, settings);
        
        // Alle Charts aktualisieren
        if (_detailViewActive && _detailChartInstance) {
            // Detail-Chart aktualisieren
            _detailChartInstance.options.animation = _advancedSettings.animationEnabled;
            _detailChartInstance.options.interaction.mode = _advancedSettings.tooltipMode;
            _detailChartInstance.options.plugins.legend.position = _advancedSettings.legendPosition;
            
            if (_detailChartInstance.options.scales.x) {
                _detailChartInstance.options.scales.x.grid.display = _advancedSettings.gridLines;
            }
            
            if (_detailChartInstance.options.scales.y) {
                _detailChartInstance.options.scales.y.grid.display = _advancedSettings.gridLines;
            }
            
            // Mehrere Y-Achsen aktualisieren, falls vorhanden
            ['scoreAxis', 'percentageAxis', 'countAxis'].forEach(axisId => {
                if (_detailChartInstance.options.scales[axisId]) {
                    _detailChartInstance.options.scales[axisId].grid.display = _advancedSettings.gridLines;
                }
            });
            
            _detailChartInstance.update();
        }
    }
    
    /**
     * Löscht den Cache für Drill-Down-Daten
     */
    function clearDrillDownCache() {
        Object.keys(_drillDownDataCache).forEach(key => {
            delete _drillDownDataCache[key];
        });
        
        window.ImmoLMS.Notifications.showSuccess('Visualisierungs-Cache wurde geleert.');
    }
    
    // Öffentliche Methoden zum Visualization-Modul hinzufügen
    Object.assign(Visualization, {
        showDetailView: showDetailView,
        closeDetailView: closeDetailView,
        updateAdvancedSettings: updateAdvancedSettings,
        clearDrillDownCache: clearDrillDownCache,
        
        // Debug-Methode (wird in Produktion entfernt)
        getDetailViewConfig: function() {
            return _detailViewConfig;
        }
    });
})();
/**
 * JS-Block 7.2.1-part1: Bewertungsübersicht (Teil 1)
 * ImmoScout24 E-Learning Projekt
 * 
 * Implementierung der Übersichtsansicht für offene Testbewertungen.
 * Ermöglicht Trainern offene Bewertungen zu sehen, zu sortieren und zu filtern.
 */

// Namespace für den Trainer-Dashboard-Bereich
window.ImmoLMS = window.ImmoLMS || {};
window.ImmoLMS.TrainerDashboard = window.ImmoLMS.TrainerDashboard || {};
window.ImmoLMS.TrainerDashboard.OpenAssessments = window.ImmoLMS.TrainerDashboard.OpenAssessments || {};

(function() {
    // Lokale Referenz auf das OpenAssessments-Modul
    const OpenAssessments = window.ImmoLMS.TrainerDashboard.OpenAssessments;
    
    // Private Variablen
    let _currentViewConfig = {
        sortBy: 'dateSubmitted',
        sortOrder: 'desc',
        filter: {
            status: 'all',
            testType: 'all',
            user: null,
            dateRange: null,
            search: ''
        },
        pagination: {
            page: 1,
            itemsPerPage: 10,
            totalItems: 0,
            totalPages: 1
        }
    };
    
    // Referenzen zu DOM-Elementen
    let _domRefs = {
        container: null,
        assessmentList: null,
        filterPanel: null,
        statsPanel: null,
        paginationControls: null
    };
    
    // Cache für geladene Bewertungen
    let _assessmentsCache = {
        lastUpdated: null,
        allAssessments: [],
        filteredAssessments: [],
        displayedAssessments: []
    };
    
    // Timer für automatische Aktualisierung
    let _refreshTimer = null;
    let _refreshInterval = 5 * 60 * 1000; // 5 Minuten
    
    /**
     * Initialisiert die Bewertungsübersicht
     * @param {string} containerId - ID des Container-Elements
     */
    function initialize(containerId) {
        // Container abrufen
        const container = document.getElementById(containerId);
        if (!container) {
            console.error('Container für Bewertungsübersicht nicht gefunden:', containerId);
            return;
        }
        
        _domRefs.container = container;
        
        // UI erstellen
        _createAssessmentUI(container);
        
        // Bewertungen laden
        _loadAssessments().then(() => {
            // Ansicht aktualisieren
            _updateAssessmentList();
            
            // Automatische Aktualisierung starten
            _startAutoRefresh();
        }).catch(error => {
            console.error('Fehler beim Laden der Bewertungen:', error);
            window.ImmoLMS.Notifications.showError('Bewertungen konnten nicht geladen werden.');
        });
        
        // Event-Listener für globale Ereignisse registrieren
        window.addEventListener('assessmentCompleted', _handleAssessmentCompleted);
    }
    
    /**
     * Erstellt die UI-Komponenten für die Bewertungsübersicht
     * @param {HTMLElement} container - Container-Element
     */
    function _createAssessmentUI(container) {
        // Bestehenden Inhalt löschen
        container.innerHTML = '';
        
        // Hauptstruktur
        const assessmentOverview = document.createElement('div');
        assessmentOverview.className = 'assessment-overview';
        
        // Überschrift und Aktionsleiste
        const header = document.createElement('div');
        header.className = 'assessment-header';
        
        const title = document.createElement('h2');
        title.textContent = 'Offene Bewertungen';
        title.className = 'assessment-title';
        
        const actionBar = document.createElement('div');
        actionBar.className = 'assessment-action-bar';
        
        const refreshButton = document.createElement('button');
        refreshButton.className = 'btn btn-primary';
        refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i> Aktualisieren';
        refreshButton.addEventListener('click', () => {
            _loadAssessments(true).then(() => {
                _updateAssessmentList();
                window.ImmoLMS.Notifications.showSuccess('Bewertungsübersicht aktualisiert');
            }).catch(error => {
                console.error('Fehler beim Aktualisieren der Bewertungen:', error);
                window.ImmoLMS.Notifications.showError('Bewertungen konnten nicht aktualisiert werden');
            });
        });
        
        const bulkReviewButton = document.createElement('button');
        bulkReviewButton.className = 'btn btn-secondary';
        bulkReviewButton.innerHTML = '<i class="fas fa-tasks"></i> Stapelverarbeitung';
        bulkReviewButton.setAttribute('disabled', 'disabled'); // Wird in Teil 2 implementiert
        bulkReviewButton.addEventListener('click', () => {
            window.ImmoLMS.Notifications.showInfo('Diese Funktion wird in einem späteren Update freigeschaltet');
        });
        
        actionBar.appendChild(refreshButton);
        actionBar.appendChild(bulkReviewButton);
        
        header.appendChild(title);
        header.appendChild(actionBar);
        
        // Statistik-Panel
        const statsPanel = document.createElement('div');
        statsPanel.className = 'assessment-stats-panel';
        statsPanel.id = 'assessment-stats-panel';
        _domRefs.statsPanel = statsPanel;
        
        // Filter-Panel
        const filterPanel = document.createElement('div');
        filterPanel.className = 'assessment-filter-panel';
        filterPanel.id = 'assessment-filter-panel';
        _domRefs.filterPanel = filterPanel;
        
        // Filter-Komponenten erstellen
        _createFilterComponents(filterPanel);
        
        // Bewertungsliste
        const listContainer = document.createElement('div');
        listContainer.className = 'assessment-list-container';
        
        const listHeader = document.createElement('div');
        listHeader.className = 'assessment-list-header';
        
        // Spaltenköpfe erstellen
        const columns = [
            { id: 'status', label: 'Status', sortable: true },
            { id: 'testTitle', label: 'Test', sortable: true },
            { id: 'userName', label: 'Teilnehmer', sortable: true },
            { id: 'dateSubmitted', label: 'Eingereicht am', sortable: true },
            { id: 'questionsCount', label: 'Offene Fragen', sortable: true },
            { id: 'actions', label: 'Aktionen', sortable: false }
        ];
        
        columns.forEach(column => {
            const headerCell = document.createElement('div');
            headerCell.className = 'assessment-list-header-cell';
            headerCell.dataset.column = column.id;
            
            const labelText = document.createElement('span');
            labelText.textContent = column.label;
            headerCell.appendChild(labelText);
            
            if (column.sortable) {
                const sortIcon = document.createElement('i');
                sortIcon.className = 'fas fa-sort';
                headerCell.appendChild(sortIcon);
                
                headerCell.addEventListener('click', () => {
                    _handleSortChange(column.id);
                });
            }
            
            listHeader.appendChild(headerCell);
        });
        
        const assessmentList = document.createElement('div');
        assessmentList.className = 'assessment-list';
        assessmentList.id = 'assessment-list';
        _domRefs.assessmentList = assessmentList;
        
        // Paginierung
        const paginationControls = document.createElement('div');
        paginationControls.className = 'assessment-pagination';
        paginationControls.id = 'assessment-pagination';
        _domRefs.paginationControls = paginationControls;
        
        // Komponenten zusammenfügen
        listContainer.appendChild(listHeader);
        listContainer.appendChild(assessmentList);
        
        assessmentOverview.appendChild(header);
        assessmentOverview.appendChild(statsPanel);
        assessmentOverview.appendChild(filterPanel);
        assessmentOverview.appendChild(listContainer);
        assessmentOverview.appendChild(paginationControls);
        
        container.appendChild(assessmentOverview);
        
        // Empty State für leere Liste vorbereiten
        _createEmptyState(assessmentList);
    }
    
    /**
     * Erstellt einen "Empty State" für den Fall, dass keine Bewertungen vorhanden sind
     * @param {HTMLElement} container - Container-Element
     */
    function _createEmptyState(container) {
        const emptyState = document.createElement('div');
        emptyState.className = 'assessment-empty-state';
        emptyState.style.display = 'none'; // Standardmäßig versteckt
        
        const emptyIcon = document.createElement('i');
        emptyIcon.className = 'fas fa-clipboard-check empty-icon';
        
        const emptyTitle = document.createElement('h3');
        emptyTitle.textContent = 'Keine offenen Bewertungen';
        
        const emptyText = document.createElement('p');
        emptyText.textContent = 'Es gibt derzeit keine offenen Bewertungen, die Ihre Aufmerksamkeit erfordern.';
        
        emptyState.appendChild(emptyIcon);
        emptyState.appendChild(emptyTitle);
        emptyState.appendChild(emptyText);
        
        container.appendChild(emptyState);
    }
    
    /**
     * Erstellt die Filter-Komponenten für die Bewertungsübersicht
     * @param {HTMLElement} container - Container-Element für Filter
     */
    function _createFilterComponents(container) {
        const filterForm = document.createElement('form');
        filterForm.className = 'assessment-filter-form';
        filterForm.addEventListener('submit', function(e) {
            e.preventDefault();
            _applyFilters();
        });
        
        // Filter-Zeile
        const filterRow = document.createElement('div');
        filterRow.className = 'filter-row';
        
        // Status-Filter
        const statusGroup = document.createElement('div');
        statusGroup.className = 'filter-group';
        
        const statusLabel = document.createElement('label');
        statusLabel.htmlFor = 'filter-status';
        statusLabel.textContent = 'Status:';
        
        const statusSelect = document.createElement('select');
        statusSelect.id = 'filter-status';
        statusSelect.className = 'filter-select';
        
        const statusOptions = [
            { value: 'all', label: 'Alle Status' },
            { value: 'pending', label: 'Ausstehend' },
            { value: 'inProgress', label: 'In Bearbeitung' },
            { value: 'flagged', label: 'Markiert' }
        ];
        
        statusOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            statusSelect.appendChild(optElement);
        });
        
        statusGroup.appendChild(statusLabel);
        statusGroup.appendChild(statusSelect);
        
        // Test-Typ-Filter
        const testTypeGroup = document.createElement('div');
        testTypeGroup.className = 'filter-group';
        
        const testTypeLabel = document.createElement('label');
        testTypeLabel.htmlFor = 'filter-test-type';
        testTypeLabel.textContent = 'Test-Typ:';
        
        const testTypeSelect = document.createElement('select');
        testTypeSelect.id = 'filter-test-type';
        testTypeSelect.className = 'filter-select';
        
        const testTypeOptions = [
            { value: 'all', label: 'Alle Tests' }
            // Weitere Optionen werden dynamisch hinzugefügt
        ];
        
        testTypeOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            testTypeSelect.appendChild(optElement);
        });
        
        testTypeGroup.appendChild(testTypeLabel);
        testTypeGroup.appendChild(testTypeSelect);
        
        // Datums-Filter
        const dateGroup = document.createElement('div');
        dateGroup.className = 'filter-group';
        
        const dateLabel = document.createElement('label');
        dateLabel.htmlFor = 'filter-date-range';
        dateLabel.textContent = 'Zeitraum:';
        
        const dateSelect = document.createElement('select');
        dateSelect.id = 'filter-date-range';
        dateSelect.className = 'filter-select';
        
        const dateOptions = [
            { value: 'all', label: 'Alle Zeiträume' },
            { value: 'today', label: 'Heute' },
            { value: 'yesterday', label: 'Gestern' },
            { value: 'thisWeek', label: 'Diese Woche' },
            { value: 'lastWeek', label: 'Letzte Woche' },
            { value: 'thisMonth', label: 'Dieser Monat' },
            { value: 'custom', label: 'Benutzerdefiniert...' }
        ];
        
        dateOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            dateSelect.appendChild(optElement);
        });
        
        // Container für benutzerdefinierte Datumseingabe (standardmäßig versteckt)
        const customDateContainer = document.createElement('div');
        customDateContainer.className = 'custom-date-container';
        customDateContainer.style.display = 'none';
        
        const fromDateInput = document.createElement('input');
        fromDateInput.type = 'date';
        fromDateInput.id = 'filter-from-date';
        fromDateInput.className = 'date-input';
        
        const toDateInput = document.createElement('input');
        toDateInput.type = 'date';
        toDateInput.id = 'filter-to-date';
        toDateInput.className = 'date-input';
        
        const dateRangeDash = document.createElement('span');
        dateRangeDash.textContent = ' - ';
        dateRangeDash.className = 'date-range-dash';
        
        customDateContainer.appendChild(fromDateInput);
        customDateContainer.appendChild(dateRangeDash);
        customDateContainer.appendChild(toDateInput);
        
        dateSelect.addEventListener('change', function() {
            if (this.value === 'custom') {
                customDateContainer.style.display = 'flex';
            } else {
                customDateContainer.style.display = 'none';
            }
        });
        
        dateGroup.appendChild(dateLabel);
        dateGroup.appendChild(dateSelect);
        dateGroup.appendChild(customDateContainer);
        
        // Suchfeld
        const searchGroup = document.createElement('div');
        searchGroup.className = 'filter-group search-group';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.id = 'filter-search';
        searchInput.className = 'search-input';
        searchInput.placeholder = 'Suchen nach Teilnehmer, Test, ID...';
        
        const searchButton = document.createElement('button');
        searchButton.type = 'submit';
        searchButton.className = 'btn btn-primary search-btn';
        searchButton.innerHTML = '<i class="fas fa-search"></i>';
        
        searchGroup.appendChild(searchInput);
        searchGroup.appendChild(searchButton);
        
        // Filter zurücksetzen
        const resetGroup = document.createElement('div');
        resetGroup.className = 'filter-group reset-group';
        
        const resetButton = document.createElement('button');
        resetButton.type = 'button';
        resetButton.className = 'btn btn-outline-secondary';
        resetButton.textContent = 'Filter zurücksetzen';
        resetButton.addEventListener('click', _resetFilters);
        
        resetGroup.appendChild(resetButton);
        
        // Komponenten zusammenfügen
        filterRow.appendChild(statusGroup);
        filterRow.appendChild(testTypeGroup);
        filterRow.appendChild(dateGroup);
        
        const searchRow = document.createElement('div');
        searchRow.className = 'filter-row search-row';
        searchRow.appendChild(searchGroup);
        searchRow.appendChild(resetGroup);
        
        filterForm.appendChild(filterRow);
        filterForm.appendChild(searchRow);
        
        container.appendChild(filterForm);
    }
    
    /**
     * Wendet die aktuellen Filter auf die Bewertungsliste an
     */
    function _applyFilters() {
        // Filter-Werte aus UI-Elementen extrahieren
        const statusFilter = document.getElementById('filter-status');
        const testTypeFilter = document.getElementById('filter-test-type');
        const dateRangeFilter = document.getElementById('filter-date-range');
        const searchInput = document.getElementById('filter-search');
        
        // Benutzerdefinierte Datumsfilter
        const fromDateInput = document.getElementById('filter-from-date');
        const toDateInput = document.getElementById('filter-to-date');
        
        // Filter-Konfiguration aktualisieren
        _currentViewConfig.filter.status = statusFilter ? statusFilter.value : 'all';
        _currentViewConfig.filter.testType = testTypeFilter ? testTypeFilter.value : 'all';
        _currentViewConfig.filter.search = searchInput ? searchInput.value.trim() : '';
        
        // Datumsbereich festlegen
        if (dateRangeFilter) {
            const dateRangeValue = dateRangeFilter.value;
            
            if (dateRangeValue === 'custom' && fromDateInput && toDateInput) {
                // Benutzerdefinierter Datumsbereich
                const fromDate = fromDateInput.value ? new Date(fromDateInput.value) : null;
                const toDate = toDateInput.value ? new Date(toDateInput.value) : null;
                
                if (fromDate && toDate) {
                    // Ende des Tages für "bis" Datum
                    toDate.setHours(23, 59, 59, 999);
                    
                    _currentViewConfig.filter.dateRange = {
                        type: 'custom',
                        from: fromDate,
                        to: toDate
                    };
                }
            } else {
                // Vordefinierte Datumsbereiche
                _currentViewConfig.filter.dateRange = {
                    type: dateRangeValue
                };
            }
        }
        
        // Zurück zur ersten Seite
        _currentViewConfig.pagination.page = 1;
        
        // Bewertungen filtern und Ansicht aktualisieren
        _filterAssessments();
        _updateAssessmentList();
    }
    
    /**
     * Setzt die Filter auf die Standardwerte zurück
     */
    function _resetFilters() {
        // Filter-Elemente zurücksetzen
        const statusFilter = document.getElementById('filter-status');
        const testTypeFilter = document.getElementById('filter-test-type');
        const dateRangeFilter = document.getElementById('filter-date-range');
        const searchInput = document.getElementById('filter-search');
        const fromDateInput = document.getElementById('filter-from-date');
        const toDateInput = document.getElementById('filter-to-date');
        const customDateContainer = document.querySelector('.custom-date-container');
        
        if (statusFilter) statusFilter.value = 'all';
        if (testTypeFilter) testTypeFilter.value = 'all';
        if (dateRangeFilter) dateRangeFilter.value = 'all';
        if (searchInput) searchInput.value = '';
        if (fromDateInput) fromDateInput.value = '';
        if (toDateInput) toDateInput.value = '';
        if (customDateContainer) customDateContainer.style.display = 'none';
        
        // Filter-Konfiguration zurücksetzen
        _currentViewConfig.filter = {
            status: 'all',
            testType: 'all',
            user: null,
            dateRange: null,
            search: ''
        };
        
        // Zurück zur ersten Seite
        _currentViewConfig.pagination.page = 1;
        
        // Bewertungen neu filtern und Ansicht aktualisieren
        _filterAssessments();
        _updateAssessmentList();
        
        window.ImmoLMS.Notifications.showInfo('Filter wurden zurückgesetzt');
    }
    
    /**
     * Ändert die Sortierreihenfolge der Bewertungsliste
     * @param {string} columnId - ID der Spalte, nach der sortiert werden soll
     */
    function _handleSortChange(columnId) {
        // Aktuelle Sortierung überprüfen
        if (_currentViewConfig.sortBy === columnId) {
            // Sortierreihenfolge umkehren
            _currentViewConfig.sortOrder = _currentViewConfig.sortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Neue Spalte zum Sortieren
            _currentViewConfig.sortBy = columnId;
            _currentViewConfig.sortOrder = 'asc';
        }
        
        // Sortier-Icons aktualisieren
        _updateSortIcons();
        
        // Bewertungen sortieren und Ansicht aktualisieren
        _sortAssessments();
        _updateAssessmentList();
    }
    
    /**
     * Aktualisiert die Sortier-Icons in den Spaltenköpfen basierend auf der aktuellen Sortierung
     */
    function _updateSortIcons() {
        // Alle Spaltenköpfe abrufen
        const headerCells = document.querySelectorAll('.assessment-list-header-cell');
        
        headerCells.forEach(cell => {
            const columnId = cell.dataset.column;
            const iconElement = cell.querySelector('i');
            
            if (iconElement) {
                if (columnId === _currentViewConfig.sortBy) {
                    // Aktive Sortierung
                    iconElement.className = _currentViewConfig.sortOrder === 'asc' ? 
                        'fas fa-sort-up' : 'fas fa-sort-down';
                } else {
                    // Inaktive Sortierung
                    iconElement.className = 'fas fa-sort';
                }
            }
        });
    }
    
    /**
     * Lädt alle offenen Bewertungen aus dem Speicher
     * @param {boolean} [forceRefresh=false] - Erzwingt eine Aktualisierung unabhängig vom Cache
     * @returns {Promise<Array>} - Promise mit den geladenen Bewertungen
     */
    function _loadAssessments(forceRefresh = false) {
        return new Promise((resolve, reject) => {
            try {
                // Prüfen, ob Bewertungen bereits geladen wurden und Cache gültig ist
                const now = new Date();
                const cacheExpired = !_assessmentsCache.lastUpdated || 
                    (now - _assessmentsCache.lastUpdated) > 5 * 60 * 1000; // 5 Minuten Cache-Gültigkeit
                
                if (_assessmentsCache.allAssessments.length > 0 && !cacheExpired && !forceRefresh) {
                    // Cache verwenden
                    resolve(_assessmentsCache.allAssessments);
                    return;
                }
                
                // Bewertungen aus dem Speicher laden
                _fetchAssessmentsData().then(assessments => {
                    // Cache aktualisieren
                    _assessmentsCache.allAssessments = assessments;
                    _assessmentsCache.lastUpdated = now;
                    
                    // Bewertungen filtern
                    _filterAssessments();
                    
                    // Test-Typen für Filter laden
                    _updateTestTypeOptions(assessments);
                    
                    resolve(assessments);
                }).catch(error => {
                    reject(error);
                });
            } catch (error) {
                reject(error);
            }
        });
    }
    
    /**
     * Ruft Bewertungsdaten aus dem Speicher ab und bereitet sie auf
     * @returns {Promise<Array>} - Promise mit den aufbereiteten Bewertungsdaten
     */
    function _fetchAssessmentsData() {
        return new Promise((resolve, reject) => {
            try {
                // Testdaten abrufen
                const tests = window.ImmoLMS.DataStore.getTests() || [];
                
                // Testergebnisse abrufen
                const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                
                // Benutzerdaten abrufen
                const users = window.ImmoLMS.DataStore.getUsers() || [];
                
                // Bewertungsbedürftige Ergebnisse filtern
                const assessableResults = testResults.filter(result => {
                    return result.status === 'completed' && 
                           result.needsManualAssessment === true && 
                           (result.assessmentStatus === 'pending' || 
                            result.assessmentStatus === 'inProgress' || 
                            result.assessmentStatus === 'flagged');
                });
                
                // Bewertungsdaten aufbereiten
                const assessments = assessableResults.map(result => {
                    // Testdaten abrufen
                    const test = tests.find(t => t.id === result.testId) || { title: 'Unbekannter Test' };
                    
                    // Benutzerdaten abrufen
                    const user = users.find(u => u.id === result.userId) || { 
                        firstName: 'Unbekannt', 
                        lastName: 'Unbekannt', 
                        team: 'Kein Team' 
                    };
                    
                    // Anzahl der offenen Fragen ermitteln
                    const totalQuestions = result.questionResults ? result.questionResults.length : 0;
                    const assessedQuestions = result.questionResults ? 
                        result.questionResults.filter(q => q.isAssessed).length : 0;
                    const openQuestionsCount = totalQuestions - assessedQuestions;
                    
                    // Zusätzliche Bewertungsmetadaten
                    const assessmentMeta = result.assessmentMeta || {
                        assignedTo: null,
                        assignedAt: null,
                        assessmentStarted: null,
                        assessmentNotes: null,
                        flagReason: null
                    };
                    
                    return {
                        id: result.id,
                        testId: result.testId,
                        testTitle: test.title,
                        testCategory: test.category,
                        userId: result.userId,
                        userName: `${user.firstName} ${user.lastName}`,
                        userTeam: user.team,
                        dateSubmitted: new Date(result.completedAt),
                        dateSubmittedFormatted: new Date(result.completedAt).toLocaleString(),
                        status: result.assessmentStatus || 'pending',
                        questionsCount: openQuestionsCount,
                        totalQuestionsCount: totalQuestions,
                        assessmentMeta: assessmentMeta,
                        priority: _calculatePriority(result)
                    };
                });
                
                resolve(assessments);
            } catch (error) {
                console.error('Fehler beim Abrufen der Bewertungsdaten:', error);
                reject(error);
            }
        });
    }
    
    /**
     * Berechnet die Priorität einer Bewertung basierend auf verschiedenen Faktoren
     * @param {Object} result - Testergebnis
     * @returns {number} - Prioritätswert (höher = wichtiger)
     */
    function _calculatePriority(result) {
        let priority = 0;
        
        // Faktor 1: Alter der Einreichung
        const now = new Date();
        const completedAt = new Date(result.completedAt);
        const daysDifference = Math.floor((now - completedAt) / (1000 * 60 * 60 * 24));
        
        // Je älter, desto höhere Priorität
        if (daysDifference > 7) {
            priority += 5; // Hohe Priorität für Ergebnisse, die älter als eine Woche sind
        } else if (daysDifference > 3) {
            priority += 3; // Mittlere Priorität für Ergebnisse, die älter als drei Tage sind
        } else if (daysDifference > 1) {
            priority += 1; // Leicht erhöhte Priorität für Ergebnisse, die älter als einen Tag sind
        }
        
        // Faktor 2: Markierte Bewertungen haben höchste Priorität
        if (result.assessmentStatus === 'flagged') {
            priority += 10;
        }
        
        // Faktor 3: In Bearbeitung befindliche Bewertungen haben höhere Priorität als ausstehende
        if (result.assessmentStatus === 'inProgress') {
            priority += 2;
        }
        
        // Faktor 4: Anzahl der offenen Fragen
        if (result.questionResults) {
            const openQuestions = result.questionResults.filter(q => !q.isAssessed).length;
            
            // Weniger offene Fragen = höhere Priorität (schnellere Fertigstellung)
            if (openQuestions <= 2) {
                priority += 2; // Fast fertig
            } else if (openQuestions >= 10) {
                priority -= 1; // Viel Arbeit, etwas niedrigere Priorität
            }
        }
        
        return priority;
    }
    
    /**
     * Filtert die geladenen Bewertungen basierend auf den aktuellen Filtereinstellungen
     */
    function _filterAssessments() {
        if (!_assessmentsCache.allAssessments || _assessmentsCache.allAssessments.length === 0) {
            _assessmentsCache.filteredAssessments = [];
            return;
        }
        
        // Filterkriterien aus Konfiguration extrahieren
        const { status, testType, user, dateRange, search } = _currentViewConfig.filter;
        
        // Filterung durchführen
        let filtered = _assessmentsCache.allAssessments;
        
        // Status-Filter
        if (status && status !== 'all') {
            filtered = filtered.filter(assessment => assessment.status === status);
        }
        
        // Test-Typ-Filter
        if (testType && testType !== 'all') {
            filtered = filtered.filter(assessment => assessment.testId === testType);
        }
        
        // Benutzer-Filter
        if (user) {
            filtered = filtered.filter(assessment => assessment.userId === user);
        }
        
        // Datumsbereich-Filter
        if (dateRange) {
            filtered = filtered.filter(assessment => {
                const submittedDate = assessment.dateSubmitted;
                
                if (dateRange.type === 'custom') {
                    return submittedDate >= dateRange.from && submittedDate <= dateRange.to;
                } else {
                    // Vordefinierte Zeiträume
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const yesterday = new Date(today);
                    yesterday.setDate(today.getDate() - 1);
                    
                    // Wochenanfang (Montag)
                    const thisWeekStart = new Date(today);
                    const dayOfWeek = today.getDay(); // 0 = Sonntag, 1 = Montag, ...
                    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                    thisWeekStart.setDate(today.getDate() - daysFromMonday);
                    
                    // Letzte Woche
                    const lastWeekStart = new Date(thisWeekStart);
                    lastWeekStart.setDate(thisWeekStart.getDate() - 7);
                    const lastWeekEnd = new Date(thisWeekStart);
                    lastWeekEnd.setDate(lastWeekEnd.getDate() - 1);
                    lastWeekEnd.setHours(23, 59, 59, 999);
                    
                    // Monatsanfang
                    const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    
                    switch (dateRange.type) {
                        case 'today':
                            return submittedDate >= today;
                        case 'yesterday':
                            return submittedDate >= yesterday && submittedDate < today;
                        case 'thisWeek':
                            return submittedDate >= thisWeekStart;
                        case 'lastWeek':
                            return submittedDate >= lastWeekStart && submittedDate <= lastWeekEnd;
                        case 'thisMonth':
                            return submittedDate >= thisMonthStart;
                        default:
                            return true;
                    }
                }
            });
        }
        
        // Suchfilter
        if (search && search.trim() !== '') {
            const searchTerm = search.trim().toLowerCase();
            
            filtered = filtered.filter(assessment => {
                return (
                    assessment.testTitle.toLowerCase().includes(searchTerm) ||
                    assessment.userName.toLowerCase().includes(searchTerm) ||
                    assessment.id.toLowerCase().includes(searchTerm) ||
                    assessment.userTeam.toLowerCase().includes(searchTerm) ||
                    assessment.testCategory.toLowerCase().includes(searchTerm)
                );
            });
        }
        
        // Gefilterte Ergebnisse speichern
        _assessmentsCache.filteredAssessments = filtered;
        
        // Paginierung aktualisieren
        const totalItems = filtered.length;
        const itemsPerPage = _currentViewConfig.pagination.itemsPerPage;
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        
        _currentViewConfig.pagination.totalItems = totalItems;
        _currentViewConfig.pagination.totalPages = totalPages > 0 ? totalPages : 1;
        
        // Sicherstellen, dass aktuelle Seite innerhalb des gültigen Bereichs liegt
        if (_currentViewConfig.pagination.page > _currentViewConfig.pagination.totalPages) {
            _currentViewConfig.pagination.page = _currentViewConfig.pagination.totalPages;
        }
        
        // Bewertungen sortieren
        _sortAssessments();
    }
    
    /**
     * Sortiert die gefilterten Bewertungen basierend auf den Sortiereinstellungen
     */
    function _sortAssessments() {
        if (!_assessmentsCache.filteredAssessments || _assessmentsCache.filteredAssessments.length === 0) {
            return;
        }
        
        // Sortierkriterien aus Konfiguration extrahieren
        const { sortBy, sortOrder } = _currentViewConfig;
        
        // Kopie der gefilterten Bewertungen erstellen, um das Original nicht zu verändern
        const sorted = [..._assessmentsCache.filteredAssessments];
        
        // Sortierung durchführen
        sorted.sort((a, b) => {
            let compareResult = 0;
            
            switch (sortBy) {
                case 'status':
                    // Status-basierte Sortierung (pending, inProgress, flagged)
                    const statusOrder = { 'flagged': 0, 'inProgress': 1, 'pending': 2 };
                    compareResult = (statusOrder[a.status] || 3) - (statusOrder[b.status] || 3);
                    break;
                    
                case 'testTitle':
                    // Alphabetische Sortierung nach Testtitel
                    compareResult = a.testTitle.localeCompare(b.testTitle);
                    break;
                    
                case 'userName':
                    // Alphabetische Sortierung nach Benutzername
                    compareResult = a.userName.localeCompare(b.userName);
                    break;
                    
                case 'dateSubmitted':
                    // Chronologische Sortierung nach Einreichungsdatum
                    compareResult = a.dateSubmitted - b.dateSubmitted;
                    break;
                    
                case 'questionsCount':
                    // Numerische Sortierung nach Anzahl der offenen Fragen
                    compareResult = a.questionsCount - b.questionsCount;
                    break;
                    
                case 'priority':
                    // Sortierung nach berechneter Priorität
                    compareResult = b.priority - a.priority;
                    break;
                    
                default:
                    // Standardsortierung nach Einreichungsdatum (neueste zuerst)
                    compareResult = b.dateSubmitted - a.dateSubmitted;
            }
            
            // Sortierreihenfolge anwenden
            return sortOrder === 'asc' ? compareResult : -compareResult;
        });
        
        // Sortierte Bewertungen speichern
        _assessmentsCache.filteredAssessments = sorted;
    }
    
    /**
     * Aktualisiert die Anzeige der Bewertungsliste
     */
    function _updateAssessmentList() {
        const listContainer = _domRefs.assessmentList;
        if (!listContainer) return;
        
        // Daten für aktuelle Seite abrufen
        const { page, itemsPerPage, totalItems } = _currentViewConfig.pagination;
        const startIndex = (page - 1) * itemsPerPage;
        const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
        
        const pageItems = _assessmentsCache.filteredAssessments.slice(startIndex, endIndex);
        _assessmentsCache.displayedAssessments = pageItems;
        
        // Bestehenden Inhalt löschen
        listContainer.innerHTML = '';
        
        // Empty State für leere Liste anzeigen/verstecken
        const emptyState = listContainer.querySelector('.assessment-empty-state') || 
                        listContainer.parentElement.querySelector('.assessment-empty-state');
        
        if (emptyState) {
            if (pageItems.length === 0) {
                emptyState.style.display = 'flex';
                
                // Paginierung verstecken
                if (_domRefs.paginationControls) {
                    _domRefs.paginationControls.style.display = 'none';
                }
            } else {
                emptyState.style.display = 'none';
                
                // Paginierung anzeigen
                if (_domRefs.paginationControls) {
                    _domRefs.paginationControls.style.display = 'flex';
                }
            }
        }
        
        // Bewertungseinträge erstellen
        pageItems.forEach(assessment => {
            const assessmentRow = _createAssessmentRow(assessment);
            listContainer.appendChild(assessmentRow);
        });
        
        // Statistik aktualisieren
        _updateStatistics();
        
        // Paginierung aktualisieren
        _updatePagination();
    }
    
    /**
     * Erstellt eine Zeile für eine Bewertung in der Liste
     * @param {Object} assessment - Bewertungsdaten
     * @returns {HTMLElement} - Die erstellte Zeile
     */
    function _createAssessmentRow(assessment) {
        const row = document.createElement('div');
        row.className = 'assessment-row';
        row.dataset.id = assessment.id;
        
        // Status-Indikator
        const statusCell = document.createElement('div');
        statusCell.className = 'assessment-cell status-cell';
        
        const statusIndicator = document.createElement('span');
        statusIndicator.className = `status-indicator status-${assessment.status}`;
        
        const statusText = document.createElement('span');
        statusText.className = 'status-text';
        
        switch (assessment.status) {
            case 'pending':
                statusText.textContent = 'Ausstehend';
                break;
            case 'inProgress':
                statusText.textContent = 'In Bearbeitung';
                break;
            case 'flagged':
                statusText.textContent = 'Markiert';
                break;
            default:
                statusText.textContent = 'Unbekannt';
        }
        
        statusCell.appendChild(statusIndicator);
        statusCell.appendChild(statusText);
        
        // Test-Titel
        const testCell = document.createElement('div');
        testCell.className = 'assessment-cell test-cell';
        
        const testTitle = document.createElement('span');
        testTitle.className = 'test-title';
        testTitle.textContent = assessment.testTitle;
        
        const testCategory = document.createElement('span');
        testCategory.className = 'test-category';
        testCategory.textContent = assessment.testCategory;
        
        testCell.appendChild(testTitle);
        testCell.appendChild(testCategory);
        
        // Teilnehmer
        const userCell = document.createElement('div');
        userCell.className = 'assessment-cell user-cell';
        
        const userName = document.createElement('span');
        userName.className = 'user-name';
        userName.textContent = assessment.userName;
        
        const userTeam = document.createElement('span');
        userTeam.className = 'user-team';
        userTeam.textContent = assessment.userTeam;
        
        userCell.appendChild(userName);
        userCell.appendChild(userTeam);
        
        // Einreichungsdatum
        const dateCell = document.createElement('div');
        dateCell.className = 'assessment-cell date-cell';
        dateCell.textContent = assessment.dateSubmittedFormatted;
        
        // Offene Fragen
        const questionsCell = document.createElement('div');
        questionsCell.className = 'assessment-cell questions-cell';
        questionsCell.textContent = `${assessment.questionsCount} von ${assessment.totalQuestionsCount}`;
        
        // Aktionen
        const actionsCell = document.createElement('div');
        actionsCell.className = 'assessment-cell actions-cell';
        
        const reviewButton = document.createElement('button');
        reviewButton.className = 'btn btn-primary btn-sm';
        reviewButton.innerHTML = '<i class="fas fa-edit"></i> Bewerten';
        reviewButton.addEventListener('click', () => {
            _startAssessment(assessment.id);
        });
        
        const flagButton = document.createElement('button');
        flagButton.className = 'btn btn-outline-secondary btn-sm';
        flagButton.innerHTML = assessment.status === 'flagged' ?
            '<i class="fas fa-flag-checkered"></i> Entmarkieren' :
            '<i class="fas fa-flag"></i> Markieren';
        flagButton.addEventListener('click', () => {
            _toggleAssessmentFlag(assessment.id, assessment.status !== 'flagged');
        });
        
        actionsCell.appendChild(reviewButton);
        actionsCell.appendChild(flagButton);
        
        // Zeile zusammenfügen
        row.appendChild(statusCell);
        row.appendChild(testCell);
        row.appendChild(userCell);
        row.appendChild(dateCell);
        row.appendChild(questionsCell);
        row.appendChild(actionsCell);
        
        // Prioritäts-Markierung hinzufügen
        if (assessment.priority >= 5) {
            row.classList.add('high-priority');
        } else if (assessment.priority >= 3) {
            row.classList.add('medium-priority');
        }
        
        return row;
    }
    
    /**
     * Aktualisiert die Paginierungssteuerelemente
     */
    function _updatePagination() {
        const paginationContainer = _domRefs.paginationControls;
        if (!paginationContainer) return;
        
        // Bestehenden Inhalt löschen
        paginationContainer.innerHTML = '';
        
        const { page, totalPages, itemsPerPage, totalItems } = _currentViewConfig.pagination;
        
        // Container für Paginierung
        const paginationControls = document.createElement('div');
        paginationControls.className = 'pagination-controls';
        
        // Info-Text zur Paginierung
        const paginationInfo = document.createElement('div');
        paginationInfo.className = 'pagination-info';
        
        const startIndex = Math.min((page - 1) * itemsPerPage + 1, totalItems);
        const endIndex = Math.min(startIndex + itemsPerPage - 1, totalItems);
        
        paginationInfo.textContent = `${startIndex}-${endIndex} von ${totalItems} Bewertungen`;
        
        // Seiten-Buttons
        const pageButtons = document.createElement('div');
        pageButtons.className = 'pagination-buttons';
        
        // Zurück-Button
        const prevButton = document.createElement('button');
        prevButton.className = 'pagination-button prev-button';
        prevButton.innerHTML = '<i class="fas fa-chevron-left"></i>';
        prevButton.disabled = page <= 1;
        prevButton.addEventListener('click', () => {
            if (page > 1) {
                _currentViewConfig.pagination.page--;
                _updateAssessmentList();
            }
        });
        
        // Seitenzahlen
        const maxVisiblePages = 5; // Maximale Anzahl von Seitenzahlen, die angezeigt werden sollen
        let startPage = Math.max(1, page - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
        
        // Anpassen, wenn nicht genügend Seiten am Ende
        if (endPage - startPage + 1 < maxVisiblePages) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // Erste Seite immer anzeigen
        if (startPage > 1) {
            const firstPageButton = document.createElement('button');
            firstPageButton.className = 'pagination-button page-button';
            firstPageButton.textContent = '1';
            firstPageButton.addEventListener('click', () => {
                _currentViewConfig.pagination.page = 1;
                _updateAssessmentList();
            });
            pageButtons.appendChild(firstPageButton);
            
            // Ellipsis hinzufügen, wenn Lücke zwischen erster Seite und startPage
            if (startPage > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.className = 'pagination-ellipsis';
                ellipsis.textContent = '...';
                pageButtons.appendChild(ellipsis);
            }
        }
        
        // Seitenzahlen erstellen
        for (let i = startPage; i <= endPage; i++) {
            const pageButton = document.createElement('button');
            pageButton.className = 'pagination-button page-button';
            if (i === page) {
                pageButton.classList.add('active');
            }
            
            pageButton.textContent = i.toString();
            pageButton.addEventListener('click', () => {
                _currentViewConfig.pagination.page = i;
                _updateAssessmentList();
            });
            
            pageButtons.appendChild(pageButton);
        }
        
        // Letzte Seite immer anzeigen
        if (endPage < totalPages) {
            // Ellipsis hinzufügen, wenn Lücke zwischen endPage und letzter Seite
            if (endPage < totalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.className = 'pagination-ellipsis';
                ellipsis.textContent = '...';
                pageButtons.appendChild(ellipsis);
            }
            
            const lastPageButton = document.createElement('button');
            lastPageButton.className = 'pagination-button page-button';
            lastPageButton.textContent = totalPages.toString();
            lastPageButton.addEventListener('click', () => {
                _currentViewConfig.pagination.page = totalPages;
                _updateAssessmentList();
            });
            pageButtons.appendChild(lastPageButton);
        }
        
        // Weiter-Button
        const nextButton = document.createElement('button');
        nextButton.className = 'pagination-button next-button';
        nextButton.innerHTML = '<i class="fas fa-chevron-right"></i>';
        nextButton.disabled = page >= totalPages;
        nextButton.addEventListener('click', () => {
            if (page < totalPages) {
                _currentViewConfig.pagination.page++;
                _updateAssessmentList();
            }
        });
        
        // Einträge pro Seite Auswahl
        const itemsPerPageSelect = document.createElement('select');
        itemsPerPageSelect.className = 'items-per-page-select';
        
        [10, 25, 50, 100].forEach(value => {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = `${value} pro Seite`;
            if (value === itemsPerPage) {
                option.selected = true;
            }
            itemsPerPageSelect.appendChild(option);
        });
        
        itemsPerPageSelect.addEventListener('change', function() {
            _currentViewConfig.pagination.itemsPerPage = parseInt(this.value);
            _currentViewConfig.pagination.page = 1;
            
            // Gesamtanzahl der Seiten aktualisieren
            _currentViewConfig.pagination.totalPages = Math.ceil(
                _currentViewConfig.pagination.totalItems / _currentViewConfig.pagination.itemsPerPage
            ) || 1;
            
            _updateAssessmentList();
        });
        
        // Komponenten zusammenfügen
        pageButtons.appendChild(prevButton);
        pageButtons.appendChild(nextButton);
        
        paginationControls.appendChild(paginationInfo);
        paginationControls.appendChild(pageButtons);
        paginationControls.appendChild(itemsPerPageSelect);
        
        paginationContainer.appendChild(paginationControls);
    }
    
    /**
     * Aktualisiert die angezeigten Statistiken
     */
    function _updateStatistics() {
        const statsPanel = _domRefs.statsPanel;
        if (!statsPanel) return;
        
        // Bestehenden Inhalt löschen
        statsPanel.innerHTML = '';
        
        // Statistik-Karten erstellen
        const stats = [
            { 
                label: 'Offene Bewertungen', 
                value: _assessmentsCache.allAssessments.length,
                icon: 'fa-clipboard-list',
                color: 'blue'
            },
            { 
                label: 'Markiert', 
                value: _assessmentsCache.allAssessments.filter(a => a.status === 'flagged').length,
                icon: 'fa-flag',
                color: 'red'
            },
            { 
                label: 'In Bearbeitung', 
                value: _assessmentsCache.allAssessments.filter(a => a.status === 'inProgress').length,
                icon: 'fa-spinner',
                color: 'orange'
            },
            { 
                label: 'Hohe Priorität', 
                value: _assessmentsCache.allAssessments.filter(a => a.priority >= 5).length,
                icon: 'fa-exclamation-circle',
                color: 'purple'
            }
        ];
        
        // Statistik-Container erstellen
        const statsContainer = document.createElement('div');
        statsContainer.className = 'stats-container';
        
        stats.forEach(stat => {
            const statCard = document.createElement('div');
            statCard.className = `stat-card ${stat.color}`;
            
            const statIcon = document.createElement('i');
            statIcon.className = `fas ${stat.icon}`;
            
            const statValue = document.createElement('div');
            statValue.className = 'stat-value';
            statValue.textContent = stat.value;
            
            const statLabel = document.createElement('div');
            statLabel.className = 'stat-label';
            statLabel.textContent = stat.label;
            
            statCard.appendChild(statIcon);
            statCard.appendChild(statValue);
            statCard.appendChild(statLabel);
            
            statsContainer.appendChild(statCard);
        });
        
        statsPanel.appendChild(statsContainer);
    }
    
    /**
     * Aktualisiert die Test-Typ-Optionen im Filter
     * @param {Array} assessments - Alle Bewertungen
     */
    function _updateTestTypeOptions(assessments) {
        const testTypeSelect = document.getElementById('filter-test-type');
        if (!testTypeSelect) return;
        
        // Bestehende Optionen speichern (erste Option beibehalten)
        const firstOption = testTypeSelect.options[0];
        
        // Alle Optionen entfernen
        while (testTypeSelect.options.length > 0) {
            testTypeSelect.remove(0);
        }
        
        // Erste Option wieder hinzufügen
        testTypeSelect.appendChild(firstOption);
        
        // Testtypen aus Bewertungen extrahieren und deduplizieren
        const testTypes = {};
        assessments.forEach(assessment => {
            if (!testTypes[assessment.testId]) {
                testTypes[assessment.testId] = assessment.testTitle;
            }
        });
        
        // Testtypen als Optionen hinzufügen
        Object.entries(testTypes).forEach(([id, title]) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = title;
            testTypeSelect.appendChild(option);
        });
    }
    
    /**
     * Startet oder setzt die Bewertung eines Tests fort
     * @param {string} assessmentId - ID der Bewertung
     */
    function _startAssessment(assessmentId) {
        try {
            // Assessment-Daten abrufen
            const assessment = _getAssessmentById(assessmentId);
            
            if (!assessment) {
                console.error('Bewertung nicht gefunden:', assessmentId);
                window.ImmoLMS.Notifications.showError('Bewertung nicht gefunden');
                return;
            }
            
            // Status auf "In Bearbeitung" setzen
            if (assessment.status === 'pending') {
                _updateAssessmentStatus(assessmentId, 'inProgress');
            }
            
            // Weiterleitung zur Bewertungsansicht (wird in JS-Block 7.2.1-part2 implementiert)
            // Dies ist ein Platzhalter für die kommende Implementierung
            window.ImmoLMS.Notifications.showInfo('Weiterleitung zur Bewertungsansicht...');
            
            // Event auslösen
            const event = new CustomEvent('startAssessment', { 
                detail: { assessmentId: assessmentId }
            });
            window.dispatchEvent(event);
            
            // In einem realen System würde hier eine Weiterleitung erfolgen
            console.log('Navigation zur Bewertungsansicht für:', assessmentId);
        } catch (error) {
            console.error('Fehler beim Starten der Bewertung:', error);
            window.ImmoLMS.Notifications.showError('Bewertung konnte nicht gestartet werden');
        }
    }
    
    /**
     * Markiert oder entmarkiert eine Bewertung
     * @param {string} assessmentId - ID der Bewertung
     * @param {boolean} flag - true zum Markieren, false zum Entmarkieren
     */
    function _toggleAssessmentFlag(assessmentId, flag) {
        try {
            // Assessment-Daten abrufen
            const assessment = _getAssessmentById(assessmentId);
            
            if (!assessment) {
                console.error('Bewertung nicht gefunden:', assessmentId);
                window.ImmoLMS.Notifications.showError('Bewertung nicht gefunden');
                return;
            }
            
            // Status entsprechend setzen
            const newStatus = flag ? 'flagged' : (assessment.status === 'flagged' ? 'pending' : assessment.status);
            
            // Grund für Markierung abfragen, falls markiert wird
            if (flag) {
                // In einer realen Implementierung würde hier ein Modal-Dialog angezeigt werden
                const reason = prompt('Grund für die Markierung (optional):', '');
                
                if (reason !== null) { // Nur fortfahren, wenn nicht abgebrochen
                    _updateAssessmentStatus(assessmentId, newStatus, reason);
                    window.ImmoLMS.Notifications.showSuccess('Bewertung wurde markiert');
                }
            } else {
                _updateAssessmentStatus(assessmentId, newStatus);
                window.ImmoLMS.Notifications.showSuccess('Markierung wurde entfernt');
            }
            
            // Ansicht aktualisieren
            _updateAssessmentList();
            
            // Event auslösen
            const event = new CustomEvent('assessmentFlagChanged', { 
                detail: { 
                    assessmentId: assessmentId,
                    flagged: flag
                }
            });
            window.dispatchEvent(event);
        } catch (error) {
            console.error('Fehler beim Ändern der Markierung:', error);
            window.ImmoLMS.Notifications.showError('Markierung konnte nicht geändert werden');
        }
    }
    
    /**
     * Aktualisiert den Status einer Bewertung
     * @param {string} assessmentId - ID der Bewertung
     * @param {string} newStatus - Neuer Status ('pending', 'inProgress', 'flagged')
     * @param {string} [flagReason] - Optional: Grund für die Markierung
     */
    function _updateAssessmentStatus(assessmentId, newStatus, flagReason) {
        // Testergebnisse abrufen
        const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
        
        // Testergebnis finden
        const resultIndex = testResults.findIndex(result => result.id === assessmentId);
        
        if (resultIndex === -1) {
            console.error('Testergebnis nicht gefunden:', assessmentId);
            return;
        }
        
        // Testergebnis aktualisieren
        testResults[resultIndex].assessmentStatus = newStatus;
        
        // Assessment-Metadaten aktualisieren
        if (!testResults[resultIndex].assessmentMeta) {
            testResults[resultIndex].assessmentMeta = {};
        }
        
        // Status-spezifische Metadaten
        if (newStatus === 'inProgress') {
            testResults[resultIndex].assessmentMeta.assessmentStarted = new Date().toISOString();
        } else if (newStatus === 'flagged' && flagReason) {
            testResults[resultIndex].assessmentMeta.flagReason = flagReason;
        }
        
        // Aktualisierte Testergebnisse speichern
        window.ImmoLMS.DataStore.saveTestResults(testResults);
        
        // Bewertungscache aktualisieren
        for (let i = 0; i < _assessmentsCache.allAssessments.length; i++) {
            if (_assessmentsCache.allAssessments[i].id === assessmentId) {
                _assessmentsCache.allAssessments[i].status = newStatus;
                
                // Priorität neu berechnen
                _assessmentsCache.allAssessments[i].priority = _calculatePriority(testResults[resultIndex]);
                break;
            }
        }
        
        // Bewertungen filtern
        _filterAssessments();
    }
    
    /**
     * Ruft eine Bewertung anhand ihrer ID ab
     * @param {string} assessmentId - ID der Bewertung
     * @returns {Object|null} - Bewertungsdaten oder null, wenn nicht gefunden
     */
    function _getAssessmentById(assessmentId) {
        // Erst in den angezeigten Bewertungen suchen
        let assessment = _assessmentsCache.displayedAssessments.find(a => a.id === assessmentId);
        
        if (!assessment) {
            // In allen Bewertungen suchen, falls nicht in den angezeigten
            assessment = _assessmentsCache.allAssessments.find(a => a.id === assessmentId);
        }
        
        return assessment || null;
    }
    
    /**
     * Event-Handler für abgeschlossene Bewertungen
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleAssessmentCompleted(event) {
        const { assessmentId } = event.detail;
        
        // Bewertungen neu laden
        _loadAssessments(true).then(() => {
            // Ansicht aktualisieren
            _updateAssessmentList();
            
            // Benachrichtigung anzeigen
            window.ImmoLMS.Notifications.showSuccess('Bewertung abgeschlossen');
        }).catch(error => {
            console.error('Fehler beim Aktualisieren nach Bewertungsabschluss:', error);
        });
    }
    
    /**
     * Startet die automatische Aktualisierung der Bewertungsdaten
     */
    function _startAutoRefresh() {
        // Bestehenden Timer löschen, falls vorhanden
        if (_refreshTimer) {
            clearInterval(_refreshTimer);
        }
        
        // Neuen Timer erstellen
        _refreshTimer = setInterval(() => {
            // Bewertungen im Hintergrund aktualisieren
            _loadAssessments(true).then(() => {
                // UI nur aktualisieren, wenn sich die Anzahl der Bewertungen geändert hat
                const oldCount = _assessmentsCache.filteredAssessments.length;
                
                // Bewertungen filtern
                _filterAssessments();
                
                if (oldCount !== _assessmentsCache.filteredAssessments.length) {
                    _updateAssessmentList();
                    console.log('Bewertungsübersicht automatisch aktualisiert');
                }
            }).catch(error => {
                console.error('Fehler bei automatischer Aktualisierung:', error);
            });
        }, _refreshInterval);
    }
    
    /**
     * Stoppt die automatische Aktualisierung der Bewertungsdaten
     */
    function stopAutoRefresh() {
        if (_refreshTimer) {
            clearInterval(_refreshTimer);
            _refreshTimer = null;
        }
    }
    
    /**
     * Setzt die Intervallzeit für die automatische Aktualisierung
     * @param {number} intervalMs - Intervallzeit in Millisekunden
     */
    function setRefreshInterval(intervalMs) {
        if (intervalMs < 10000) {
            console.warn('Refresh-Intervall sollte nicht kürzer als 10 Sekunden sein');
            intervalMs = 10000; // Mindestintervall: 10 Sekunden
        }
        
        _refreshInterval = intervalMs;
        
        // Timer neu starten, falls aktiv
        if (_refreshTimer) {
            stopAutoRefresh();
            _startAutoRefresh();
        }
    }
    
    // Öffentliche API
    return Object.assign(OpenAssessments, {
        initialize: initialize,
        refresh: function() {
            return _loadAssessments(true).then(() => {
                _updateAssessmentList();
            });
        },
        stopAutoRefresh: stopAutoRefresh,
        setRefreshInterval: setRefreshInterval,
        // Debug-Funktionen
        getCurrentViewConfig: function() {
            return { ..._currentViewConfig };
        },
        getAssessmentsCount: function() {
            return {
                all: _assessmentsCache.allAssessments.length,
                filtered: _assessmentsCache.filteredAssessments.length,
                displayed: _assessmentsCache.displayedAssessments.length
            };
        }
    });
})();
/**
 * JS-Block 7.2.1-part2: Bewertungsübersicht (Teil 2)
 * ImmoScout24 E-Learning Projekt
 * 
 * Erweiterte Funktionen für die Übersichtsansicht der offenen Testbewertungen.
 * Implementiert Detailansichten, Massenaktionen, Exportfunktionen und erweiterte Filteroptionen.
 */

// Namespace für den Trainer-Dashboard-Bereich
window.ImmoLMS = window.ImmoLMS || {};
window.ImmoLMS.TrainerDashboard = window.ImmoLMS.TrainerDashboard || {};
window.ImmoLMS.TrainerDashboard.OpenAssessments = window.ImmoLMS.TrainerDashboard.OpenAssessments || {};

(function() {
    // Lokale Referenz auf das OpenAssessments-Modul
    const OpenAssessments = window.ImmoLMS.TrainerDashboard.OpenAssessments;
    
    // Private Variablen für Detailansichten
    let _detailViewActive = false;
    let _currentDetailId = null;
    
    // Zwischenspeicher für Massenaktions-Auswahl
    let _selectedAssessments = new Set();
    
    // Referenzen zu DOM-Elementen der Detailansicht
    let _detailDomRefs = {
        container: null,
        header: null,
        content: null,
        questionList: null,
        actionBar: null
    };
    
    // Aktueller Zustand der Massenaktionen
    let _bulkActionState = {
        active: false,
        allSelected: false
    };
    
    /**
     * Initialisiert die erweiterten Funktionen der Bewertungsübersicht
     */
    function initializeExtendedFunctions() {
        // Event-Listener für erweiterte Funktionen
        _registerEventListeners();
        
        // Massenaktionen initialisieren
        _initializeBulkActions();
        
        // Erweiterte Filter initialisieren
        _initializeAdvancedFilters();
        
        // Export-Funktionen initialisieren
        _initializeExportFunctions();
        
        console.log('Erweiterte Bewertungsübersicht initialisiert');
    }
    
    /**
     * Registriert alle Event-Listener für erweiterte Funktionen
     */
    function _registerEventListeners() {
        // Globale Events
        window.addEventListener('startAssessment', _handleStartAssessment);
        window.addEventListener('assessmentDetailView', _handleShowAssessmentDetail);
        window.addEventListener('assessmentDetailClose', _handleCloseAssessmentDetail);
        window.addEventListener('assignAssessment', _handleAssignAssessment);
        window.addEventListener('exportAssessments', _handleExportAssessments);
        
        // Tastatur-Shortcuts
        document.addEventListener('keydown', _handleKeyboardShortcuts);
    }
    
    /**
     * Initialisiert die Massenaktions-Funktionalität
     */
    function _initializeBulkActions() {
        // Bulk-Action-Button aktivieren
        const bulkActionButton = document.querySelector('.assessment-action-bar button:nth-child(2)');
        if (bulkActionButton) {
            bulkActionButton.removeAttribute('disabled');
            bulkActionButton.addEventListener('click', _toggleBulkActionMode);
        }
        
        // Container für Bulk-Action-Leiste vorbereiten
        const container = document.querySelector('.assessment-overview');
        if (container) {
            const bulkActionBar = document.createElement('div');
            bulkActionBar.className = 'bulk-action-bar';
            bulkActionBar.style.display = 'none';
            
            // Auswahl-Informationen
            const selectionInfo = document.createElement('div');
            selectionInfo.className = 'selection-info';
            selectionInfo.innerHTML = '<span class="selected-count">0</span> Bewertungen ausgewählt';
            
            // Aktions-Buttons
            const actionButtons = document.createElement('div');
            actionButtons.className = 'action-buttons';
            
            // Alle auswählen / Keine auswählen
            const toggleAllButton = document.createElement('button');
            toggleAllButton.className = 'btn btn-outline-primary';
            toggleAllButton.textContent = 'Alle auswählen';
            toggleAllButton.addEventListener('click', _toggleSelectAll);
            
            // Zuweisen-Button
            const assignButton = document.createElement('button');
            assignButton.className = 'btn btn-outline-secondary';
            assignButton.innerHTML = '<i class="fas fa-user-check"></i> Zuweisen';
            assignButton.addEventListener('click', () => _bulkAssign());
            
            // Markieren-Button
            const flagButton = document.createElement('button');
            flagButton.className = 'btn btn-outline-warning';
            flagButton.innerHTML = '<i class="fas fa-flag"></i> Markieren';
            flagButton.addEventListener('click', () => _bulkFlag(true));
            
            // Entmarkieren-Button
            const unflagButton = document.createElement('button');
            unflagButton.className = 'btn btn-outline-info';
            unflagButton.innerHTML = '<i class="fas fa-flag-checkered"></i> Entmarkieren';
            unflagButton.addEventListener('click', () => _bulkFlag(false));
            
            // Abbrechen-Button
            const cancelButton = document.createElement('button');
            cancelButton.className = 'btn btn-secondary';
            cancelButton.innerHTML = '<i class="fas fa-times"></i> Abbrechen';
            cancelButton.addEventListener('click', _exitBulkActionMode);
            
            // Komponenten zusammenfügen
            actionButtons.appendChild(toggleAllButton);
            actionButtons.appendChild(assignButton);
            actionButtons.appendChild(flagButton);
            actionButtons.appendChild(unflagButton);
            actionButtons.appendChild(cancelButton);
            
            bulkActionBar.appendChild(selectionInfo);
            bulkActionBar.appendChild(actionButtons);
            
            // Bulk-Action-Leiste vor der Liste einfügen
            const listContainer = container.querySelector('.assessment-list-container');
            if (listContainer) {
                container.insertBefore(bulkActionBar, listContainer);
            } else {
                container.appendChild(bulkActionBar);
            }
        }
    }
    
    /**
     * Initialisiert erweiterte Filterfunktionen
     */
    function _initializeAdvancedFilters() {
        // Überprüfen, ob Filter-Panel existiert
        const filterPanel = document.getElementById('assessment-filter-panel');
        if (!filterPanel) return;
        
        // Container für erweiterte Filter
        const advancedFilterContainer = document.createElement('div');
        advancedFilterContainer.className = 'advanced-filter-container';
        advancedFilterContainer.style.display = 'none';
        
        // Weitere Filter-Optionen hinzufügen
        const additionalFilters = document.createElement('div');
        additionalFilters.className = 'filter-row additional-filters';
        
        // Team-Filter
        const teamGroup = document.createElement('div');
        teamGroup.className = 'filter-group';
        
        const teamLabel = document.createElement('label');
        teamLabel.htmlFor = 'filter-team';
        teamLabel.textContent = 'Team:';
        
        const teamSelect = document.createElement('select');
        teamSelect.id = 'filter-team';
        teamSelect.className = 'filter-select';
        
        // Standardoption
        const defaultTeamOption = document.createElement('option');
        defaultTeamOption.value = 'all';
        defaultTeamOption.textContent = 'Alle Teams';
        teamSelect.appendChild(defaultTeamOption);
        
        // Teams dynamisch laden
        _loadTeamOptions(teamSelect);
        
        teamGroup.appendChild(teamLabel);
        teamGroup.appendChild(teamSelect);
        
        // Prioritäts-Filter
        const priorityGroup = document.createElement('div');
        priorityGroup.className = 'filter-group';
        
        const priorityLabel = document.createElement('label');
        priorityLabel.htmlFor = 'filter-priority';
        priorityLabel.textContent = 'Priorität:';
        
        const prioritySelect = document.createElement('select');
        prioritySelect.id = 'filter-priority';
        prioritySelect.className = 'filter-select';
        
        const priorityOptions = [
            { value: 'all', label: 'Alle Prioritäten' },
            { value: 'high', label: 'Hoch' },
            { value: 'medium', label: 'Mittel' },
            { value: 'low', label: 'Niedrig' }
        ];
        
        priorityOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            prioritySelect.appendChild(optElement);
        });
        
        priorityGroup.appendChild(priorityLabel);
        priorityGroup.appendChild(prioritySelect);
        
        // Fragen-Anzahl-Filter
        const questionsGroup = document.createElement('div');
        questionsGroup.className = 'filter-group';
        
        const questionsLabel = document.createElement('label');
        questionsLabel.htmlFor = 'filter-questions';
        questionsLabel.textContent = 'Offene Fragen:';
        
        const questionsSelect = document.createElement('select');
        questionsSelect.id = 'filter-questions';
        questionsSelect.className = 'filter-select';
        
        const questionsOptions = [
            { value: 'all', label: 'Alle' },
            { value: '1-3', label: '1-3 Fragen' },
            { value: '4-10', label: '4-10 Fragen' },
            { value: 'more', label: 'Mehr als 10' }
        ];
        
        questionsOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            questionsSelect.appendChild(optElement);
        });
        
        questionsGroup.appendChild(questionsLabel);
        questionsGroup.appendChild(questionsSelect);
        
        // Zeiten-Filter (seit wie vielen Tagen ausstehend)
        const timeGroup = document.createElement('div');
        timeGroup.className = 'filter-group';
        
        const timeLabel = document.createElement('label');
        timeLabel.htmlFor = 'filter-waiting-time';
        timeLabel.textContent = 'Wartezeit:';
        
        const timeSelect = document.createElement('select');
        timeSelect.id = 'filter-waiting-time';
        timeSelect.className = 'filter-select';
        
        const timeOptions = [
            { value: 'all', label: 'Alle Zeiten' },
            { value: 'today', label: 'Heute eingereicht' },
            { value: '1-2', label: '1-2 Tage' },
            { value: '3-7', label: '3-7 Tage' },
            { value: 'more', label: 'Über 7 Tage' }
        ];
        
        timeOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label;
            timeSelect.appendChild(optElement);
        });
        
        timeGroup.appendChild(timeLabel);
        timeGroup.appendChild(timeSelect);
        
        // Toggle für erweiterte Filter
        const filterToggle = document.createElement('button');
        filterToggle.className = 'advanced-filter-toggle';
        filterToggle.innerHTML = 'Erweiterte Filter <i class="fas fa-chevron-down"></i>';
        filterToggle.addEventListener('click', function() {
            const isVisible = advancedFilterContainer.style.display !== 'none';
            advancedFilterContainer.style.display = isVisible ? 'none' : 'block';
            this.innerHTML = isVisible ? 
                'Erweiterte Filter <i class="fas fa-chevron-down"></i>' : 
                'Erweiterte Filter <i class="fas fa-chevron-up"></i>';
        });
        
        // Komponenten zusammenfügen
        additionalFilters.appendChild(teamGroup);
        additionalFilters.appendChild(priorityGroup);
        additionalFilters.appendChild(questionsGroup);
        additionalFilters.appendChild(timeGroup);
        
        advancedFilterContainer.appendChild(additionalFilters);
        
        // Zu Filtern hinzufügen
        const filterForm = filterPanel.querySelector('.assessment-filter-form');
        if (filterForm) {
            filterForm.appendChild(filterToggle);
            filterForm.appendChild(advancedFilterContainer);
            
            // Event-Listener für erweiterte Filter-Anwendung
            filterForm.addEventListener('change', function(e) {
                const target = e.target;
                
                // Auf Änderungen in erweiterten Filtern reagieren
                if (target.matches('.advanced-filter-container select')) {
                    _applyAdvancedFilters();
                }
            });
        }
    }
    
    /**
     * Lädt verfügbare Teams für den Filter
     * @param {HTMLSelectElement} selectElement - Das Select-Element für Teams
     */
    function _loadTeamOptions(selectElement) {
        // Benutzerdaten abrufen
        const users = window.ImmoLMS.DataStore.getUsers() || [];
        
        // Teams extrahieren und deduplizieren
        const teams = new Set();
        users.forEach(user => {
            if (user.team) {
                teams.add(user.team);
            }
        });
        
        // Teams als Optionen hinzufügen
        Array.from(teams).sort().forEach(team => {
            const option = document.createElement('option');
            option.value = team;
            option.textContent = team;
            selectElement.appendChild(option);
        });
    }
    
    /**
     * Initialisiert Export-Funktionen
     */
    function _initializeExportFunctions() {
        // Überprüfen, ob Header existiert
        const header = document.querySelector('.assessment-header');
        if (!header) return;
        
        // Export-Button erstellen
        const exportButton = document.createElement('button');
        exportButton.className = 'btn btn-outline-secondary';
        exportButton.innerHTML = '<i class="fas fa-file-export"></i> Exportieren';
        
        // Export-Menü erstellen
        const exportMenu = document.createElement('div');
        exportMenu.className = 'export-menu';
        exportMenu.style.display = 'none';
        
        // Export-Optionen
        const exportOptions = [
            { id: 'csv', label: 'Als CSV exportieren', icon: 'fa-file-csv' },
            { id: 'json', label: 'Als JSON exportieren', icon: 'fa-file-code' },
            { id: 'pdf', label: 'Als PDF exportieren', icon: 'fa-file-pdf' },
            { id: 'print', label: 'Drucken', icon: 'fa-print' }
        ];
        
        exportOptions.forEach(option => {
            const menuItem = document.createElement('div');
            menuItem.className = 'export-menu-item';
            menuItem.innerHTML = `<i class="fas ${option.icon}"></i> ${option.label}`;
            menuItem.addEventListener('click', (e) => {
                e.stopPropagation();
                exportMenu.style.display = 'none';
                _exportAssessments(option.id);
            });
            
            exportMenu.appendChild(menuItem);
        });
        
        // Event-Listener für Export-Button
        exportButton.addEventListener('click', function(e) {
            e.stopPropagation();
            
            if (exportMenu.style.display === 'none') {
                exportMenu.style.display = 'block';
                
                // Positionierung des Menüs relativ zum Button
                const buttonRect = this.getBoundingClientRect();
                exportMenu.style.top = `${buttonRect.bottom}px`;
                exportMenu.style.left = `${buttonRect.left}px`;
                
                // Event-Listener für Klicks außerhalb des Menüs
                setTimeout(() => {
                    window.addEventListener('click', function closeMenu(e) {
                        if (!exportMenu.contains(e.target) && e.target !== exportButton) {
                            exportMenu.style.display = 'none';
                            window.removeEventListener('click', closeMenu);
                        }
                    });
                }, 0);
            } else {
                exportMenu.style.display = 'none';
            }
        });
        
        // Komponenten zur Seite hinzufügen
        const actionBar = header.querySelector('.assessment-action-bar');
        if (actionBar) {
            actionBar.insertBefore(exportButton, actionBar.firstChild);
            document.body.appendChild(exportMenu);
        }
    }
    
    /**
     * Wendet erweiterte Filter auf die Bewertungsliste an
     */
    function _applyAdvancedFilters() {
        // Aktuelle Konfiguration abrufen
        const viewConfig = OpenAssessments.getCurrentViewConfig();
        
        // Erweiterte Filter abrufen
        const teamFilter = document.getElementById('filter-team');
        const priorityFilter = document.getElementById('filter-priority');
        const questionsFilter = document.getElementById('filter-questions');
        const waitingTimeFilter = document.getElementById('filter-waiting-time');
        
        // Filter-Objekt erstellen
        const advancedFilters = {
            team: teamFilter ? teamFilter.value : 'all',
            priority: priorityFilter ? priorityFilter.value : 'all',
            questionsRange: questionsFilter ? questionsFilter.value : 'all',
            waitingTime: waitingTimeFilter ? waitingTimeFilter.value : 'all'
        };
        
        // Filter zur Konfiguration hinzufügen
        viewConfig.filter.advancedFilters = advancedFilters;
        
        // Bewertungen neu filtern
        _filterAssessmentsWithAdvanced();
        
        // Neu geladene und gefilterte Bewertungen anzeigen
        OpenAssessments.refresh();
    }
    
    /**
     * Erweiterte Filterung für Bewertungen
     */
    function _filterAssessmentsWithAdvanced() {
        // Diese Funktion erweitert die Basisfunktionalität aus Teil 1
        // Sie wird aus dem OpenAssessments-Modul aufgerufen und führt die erweiterte Filterung durch
        
        // Hier würde die Implementierung der erweiterten Filterlogik stehen
        // In einer realen Implementierung würde diese Funktion mit dem Basis-Filtermodul integriert werden
        
        console.log('Erweiterte Filterung angewendet');
    }
    
    /**
     * Schaltet den Massenaktions-Modus ein oder aus
     */
    function _toggleBulkActionMode() {
        _bulkActionState.active = !_bulkActionState.active;
        
        // UI-Elemente aktualisieren
        const bulkActionBar = document.querySelector('.bulk-action-bar');
        const assessmentRows = document.querySelectorAll('.assessment-row');
        
        if (_bulkActionState.active) {
            // Massenaktionsmodus aktivieren
            if (bulkActionBar) bulkActionBar.style.display = 'flex';
            
            // Checkboxen zu jeder Zeile hinzufügen
            assessmentRows.forEach(row => {
                if (!row.querySelector('.row-checkbox')) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'row-checkbox';
                    checkbox.addEventListener('change', function() {
                        const assessmentId = row.dataset.id;
                        
                        if (this.checked) {
                            _selectedAssessments.add(assessmentId);
                        } else {
                            _selectedAssessments.delete(assessmentId);
                        }
                        
                        _updateSelectedCount();
                    });
                    
                    row.insertBefore(checkbox, row.firstChild);
                    row.classList.add('bulk-mode');
                }
            });
        } else {
            // Massenaktionsmodus deaktivieren
            _exitBulkActionMode();
        }
    }
    
    /**
     * Beendet den Massenaktions-Modus
     */
    function _exitBulkActionMode() {
        _bulkActionState.active = false;
        _bulkActionState.allSelected = false;
        _selectedAssessments.clear();
        
        // UI-Elemente aktualisieren
        const bulkActionBar = document.querySelector('.bulk-action-bar');
        const assessmentRows = document.querySelectorAll('.assessment-row');
        
        if (bulkActionBar) bulkActionBar.style.display = 'none';
        
        // Checkboxen entfernen
        assessmentRows.forEach(row => {
            const checkbox = row.querySelector('.row-checkbox');
            if (checkbox) {
                row.removeChild(checkbox);
            }
            row.classList.remove('bulk-mode');
        });
    }
    
    /**
     * Schaltet die Auswahl aller sichtbaren Bewertungen ein oder aus
     */
    function _toggleSelectAll() {
        _bulkActionState.allSelected = !_bulkActionState.allSelected;
        
        // UI-Elemente aktualisieren
        const assessmentRows = document.querySelectorAll('.assessment-row');
        const toggleButton = document.querySelector('.action-buttons button:first-child');
        
        if (_bulkActionState.allSelected) {
            // Alle auswählen
            assessmentRows.forEach(row => {
                const checkbox = row.querySelector('.row-checkbox');
                if (checkbox) {
                    checkbox.checked = true;
                }
                
                const assessmentId = row.dataset.id;
                if (assessmentId) {
                    _selectedAssessments.add(assessmentId);
                }
            });
            
            if (toggleButton) toggleButton.textContent = 'Keine auswählen';
        } else {
            // Keine auswählen
            assessmentRows.forEach(row => {
                const checkbox = row.querySelector('.row-checkbox');
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            _selectedAssessments.clear();
            if (toggleButton) toggleButton.textContent = 'Alle auswählen';
        }
        
        _updateSelectedCount();
    }
    
    /**
     * Aktualisiert die Anzeige der ausgewählten Bewertungen
     */
    function _updateSelectedCount() {
        const countElement = document.querySelector('.selected-count');
        if (countElement) {
            countElement.textContent = _selectedAssessments.size;
        }
    }
    
    /**
     * Führt Massenmarkierung für ausgewählte Bewertungen durch
     * @param {boolean} flag - true zum Markieren, false zum Entmarkieren
     */
    function _bulkFlag(flag) {
        if (_selectedAssessments.size === 0) {
            window.ImmoLMS.Notifications.showInfo('Keine Bewertungen ausgewählt');
            return;
        }
        
        // Optional: Grund für Markierung abfragen, wenn markiert wird
        let flagReason = null;
        if (flag) {
            flagReason = prompt('Grund für die Markierung (optional):', '');
            // Abbrechen, wenn der Benutzer Cancel klickt
            if (flagReason === null) return;
        }
        
        // Statusänderungen durchführen
        let updatedCount = 0;
        
        // Testergebnisse abrufen
        const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
        
        // Statusänderungen für ausgewählte Bewertungen durchführen
        _selectedAssessments.forEach(assessmentId => {
            const resultIndex = testResults.findIndex(result => result.id === assessmentId);
            
            if (resultIndex !== -1) {
                // Status aktualisieren
                const newStatus = flag ? 'flagged' : 'pending';
                testResults[resultIndex].assessmentStatus = newStatus;
                
                // Metadaten aktualisieren
                if (!testResults[resultIndex].assessmentMeta) {
                    testResults[resultIndex].assessmentMeta = {};
                }
                
                if (flag && flagReason !== null) {
                    testResults[resultIndex].assessmentMeta.flagReason = flagReason;
                }
                
                updatedCount++;
            }
        });
        
        // Aktualisierte Testergebnisse speichern
        if (updatedCount > 0) {
            window.ImmoLMS.DataStore.saveTestResults(testResults);
            
            // Benachrichtigung anzeigen
            const message = flag ? 
                `${updatedCount} Bewertungen wurden markiert` : 
                `${updatedCount} Bewertungen wurden entmarkiert`;
            
            window.ImmoLMS.Notifications.showSuccess(message);
            
            // Bewertungsübersicht aktualisieren
            OpenAssessments.refresh();
            
            // Massenaktionsmodus beenden
            _exitBulkActionMode();
        }
    }
    
    /**
     * Führt Massenzuweisung für ausgewählte Bewertungen durch
     */
    function _bulkAssign() {
        if (_selectedAssessments.size === 0) {
            window.ImmoLMS.Notifications.showInfo('Keine Bewertungen ausgewählt');
            return;
        }
        
        // In einer realen Implementierung würde hier ein Modal-Dialog angezeigt werden
        // Da dies nur ein Prototyp ist, verwenden wir prompt()
        
        // Verfügbare Trainer abrufen
        const users = window.ImmoLMS.DataStore.getUsers() || [];
        const trainers = users.filter(user => user.role === 'trainer' || user.role === 'admin');
        
        if (trainers.length === 0) {
            window.ImmoLMS.Notifications.showError('Keine Trainer verfügbar');
            return;
        }
        
        // Trainerliste für Auswahl erstellen
        let trainerList = 'Verfügbare Trainer:\n';
        trainers.forEach((trainer, index) => {
            trainerList += `${index + 1}. ${trainer.firstName} ${trainer.lastName}\n`;
        });
        
        // Trainernummer abfragen
        const selectedTrainerIndex = prompt(`${trainerList}\nGeben Sie die Nummer des Trainers ein:`, '1');
        
        if (selectedTrainerIndex === null) return;
        
        const trainerIndex = parseInt(selectedTrainerIndex) - 1;
        
        if (isNaN(trainerIndex) || trainerIndex < 0 || trainerIndex >= trainers.length) {
            window.ImmoLMS.Notifications.showError('Ungültige Auswahl');
            return;
        }
        
        const selectedTrainer = trainers[trainerIndex];
        
        // Zuweisungen durchführen
        let assignedCount = 0;
        
        // Testergebnisse abrufen
        const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
        
        // Zuweisung für ausgewählte Bewertungen durchführen
        _selectedAssessments.forEach(assessmentId => {
            const resultIndex = testResults.findIndex(result => result.id === assessmentId);
            
            if (resultIndex !== -1) {
                // Metadaten aktualisieren
                if (!testResults[resultIndex].assessmentMeta) {
                    testResults[resultIndex].assessmentMeta = {};
                }
                
                testResults[resultIndex].assessmentMeta.assignedTo = selectedTrainer.id;
                testResults[resultIndex].assessmentMeta.assignedAt = new Date().toISOString();
                
                assignedCount++;
            }
        });
        
        // Aktualisierte Testergebnisse speichern
        if (assignedCount > 0) {
            window.ImmoLMS.DataStore.saveTestResults(testResults);
            
            // Benachrichtigung anzeigen
            window.ImmoLMS.Notifications.showSuccess(
                `${assignedCount} Bewertungen wurden ${selectedTrainer.firstName} ${selectedTrainer.lastName} zugewiesen`
            );
            
            // Bewertungsübersicht aktualisieren
            OpenAssessments.refresh();
            
            // Massenaktionsmodus beenden
            _exitBulkActionMode();
        }
    }
    
    /**
     * Exportiert Bewertungsdaten in verschiedenen Formaten
     * @param {string} format - Exportformat ('csv', 'json', 'pdf', 'print')
     */
    function _exportAssessments(format) {
        // Überprüfen, ob Bewertungen geladen wurden
        const assessmentsCount = OpenAssessments.getAssessmentsCount();
        
        if (assessmentsCount.filtered === 0) {
            window.ImmoLMS.Notifications.showInfo('Keine Bewertungen zum Exportieren verfügbar');
            return;
        }
        
        // Festlegen, welche Bewertungen exportiert werden sollen
        let assessmentsToExport;
        
        // Wenn Massenaktionsmodus aktiv ist und Bewertungen ausgewählt sind, verwende diese
        if (_bulkActionState.active && _selectedAssessments.size > 0) {
            // Hier müssten die Bewertungsdaten für die ausgewählten IDs abgerufen werden
            // In einer realen Implementierung würde dies über eine Hilfsfunktion erfolgen
            
            window.ImmoLMS.Notifications.showInfo(
                `Export von ${_selectedAssessments.size} ausgewählten Bewertungen wird vorbereitet...`
            );
            
            // Für diesen Prototyp verwenden wir Platzhaltercode
            assessmentsToExport = _getSelectedAssessmentData();
        } else {
            // Andernfalls alle gefilterten Bewertungen exportieren
            window.ImmoLMS.Notifications.showInfo(
                `Export von ${assessmentsCount.filtered} Bewertungen wird vorbereitet...`
            );
            
            // In einer realen Implementierung würden wir auf das Datenmodell zugreifen
            assessmentsToExport = _getAllFilteredAssessmentData();
        }
        
        // Export basierend auf dem Format durchführen
        switch (format) {
            case 'csv':
                _exportToCSV(assessmentsToExport);
                break;
            case 'json':
                _exportToJSON(assessmentsToExport);
                break;
            case 'pdf':
                _exportToPDF(assessmentsToExport);
                break;
            case 'print':
                _printAssessments(assessmentsToExport);
                break;
            default:
                window.ImmoLMS.Notifications.showError('Unbekanntes Exportformat');
        }
    }
    
    /**
     * Ruft Daten für ausgewählte Bewertungen ab
     * @returns {Array} - Array mit Bewertungsdaten
     */
    function _getSelectedAssessmentData() {
        // In einer realen Implementierung würden hier die vollständigen Daten für die ausgewählten IDs abgerufen werden
        
        // Für diesen Prototyp erstellen wir eine Teilmenge der Daten
        const result = [];
        
        // Alle Assessment-Daten aus dem Cache abrufen
        const assessmentData = _getAllFilteredAssessmentData();
        
        // Daten für ausgewählte IDs filtern
        _selectedAssessments.forEach(id => {
            const assessment = assessmentData.find(a => a.id === id);
            if (assessment) {
                result.push(assessment);
            }
        });
        
        return result;
    }
    
    /**
     * Ruft Daten für alle gefilterten Bewertungen ab
     * @returns {Array} - Array mit Bewertungsdaten
     */
    function _getAllFilteredAssessmentData() {
        // In einer realen Implementierung würden hier die vollständigen Daten für die gefilterten Bewertungen abgerufen werden
        
        // Für diesen Prototyp erstellen wir eine Simulation der Daten
        const assessmentsCount = OpenAssessments.getAssessmentsCount();
        const simulatedData = [];
        
        // Testergebnisse abrufen
        const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
        const tests = window.ImmoLMS.DataStore.getTests() || [];
        const users = window.ImmoLMS.DataStore.getUsers() || [];
        
        // Bewertungsbedürftige Ergebnisse filtern und aufbereiten
        const assessableResults = testResults.filter(result => {
            return result.status === 'completed' && 
                   result.needsManualAssessment === true && 
                   (result.assessmentStatus === 'pending' || 
                    result.assessmentStatus === 'inProgress' || 
                    result.assessmentStatus === 'flagged');
        });
        
        // Bewertungsdaten für Export aufbereiten
        assessableResults.forEach(result => {
            // Testdaten abrufen
            const test = tests.find(t => t.id === result.testId) || { title: 'Unbekannter Test', category: 'Keine Kategorie' };
            
            // Benutzerdaten abrufen
            const user = users.find(u => u.id === result.userId) || { 
                firstName: 'Unbekannt', 
                lastName: 'Unbekannt', 
                team: 'Kein Team',
                email: 'keine@email.com'
            };
            
            // Anzahl der offenen Fragen ermitteln
            const totalQuestions = result.questionResults ? result.questionResults.length : 0;
            const assessedQuestions = result.questionResults ? 
                result.questionResults.filter(q => q.isAssessed).length : 0;
            const openQuestionsCount = totalQuestions - assessedQuestions;
            
            // Zusätzliche Bewertungsmetadaten
            const assessmentMeta = result.assessmentMeta || {};
            
            // Formatierte Daten für den Export
            simulatedData.push({
                id: result.id,
                testId: result.testId,
                testTitle: test.title,
                testCategory: test.category,
                userId: result.userId,
                userName: `${user.firstName} ${user.lastName}`,
                userEmail: user.email,
                userTeam: user.team,
                dateSubmitted: new Date(result.completedAt).toISOString(),
                dateSubmittedFormatted: new Date(result.completedAt).toLocaleString(),
                status: result.assessmentStatus || 'pending',
                statusFormatted: _getFormattedStatus(result.assessmentStatus),
                openQuestions: openQuestionsCount,
                totalQuestions: totalQuestions,
                assignedTo: assessmentMeta.assignedTo ? 
                    (users.find(u => u.id === assessmentMeta.assignedTo)?.firstName + ' ' + 
                     users.find(u => u.id === assessmentMeta.assignedTo)?.lastName) : 
                    'Nicht zugewiesen',
                assignedAt: assessmentMeta.assignedAt ? new Date(assessmentMeta.assignedAt).toLocaleString() : null,
                flagReason: assessmentMeta.flagReason || null
            });
        });
        
        return simulatedData;
    }
    
    /**
     * Gibt eine formatierte Statusbezeichnung zurück
     * @param {string} status - Status-Code
     * @returns {string} - Formatierte Statusbezeichnung
     */
    function _getFormattedStatus(status) {
        switch (status) {
            case 'pending':
                return 'Ausstehend';
            case 'inProgress':
                return 'In Bearbeitung';
            case 'flagged':
                return 'Markiert';
            case 'completed':
                return 'Abgeschlossen';
            default:
                return 'Unbekannt';
        }
    }
    
    /**
     * Exportiert Bewertungsdaten als CSV-Datei
     * @param {Array} data - Zu exportierende Daten
     */
    function _exportToCSV(data) {
        try {
            // CSV-Header definieren
            const headers = [
                'ID', 'Test', 'Kategorie', 'Teilnehmer', 'Team', 'Eingereicht am', 
                'Status', 'Offene Fragen', 'Gesamt Fragen', 'Zugewiesen an'
            ];
            
            // CSV-Zeilen erstellen
            let csvContent = headers.join(',') + '\n';
            
            data.forEach(item => {
                // Werte für die Zeile aufbereiten
                const values = [
                    item.id,
                    _escapeCSVValue(item.testTitle),
                    _escapeCSVValue(item.testCategory),
                    _escapeCSVValue(item.userName),
                    _escapeCSVValue(item.userTeam),
                    _escapeCSVValue(item.dateSubmittedFormatted),
                    _escapeCSVValue(item.statusFormatted),
                    item.openQuestions,
                    item.totalQuestions,
                    _escapeCSVValue(item.assignedTo)
                ];
                
                // Zeile zum CSV-Inhalt hinzufügen
                csvContent += values.join(',') + '\n';
            });
            
            // CSV-Datei erstellen und herunterladen
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `bewertungen_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Bewertungen wurden als CSV exportiert');
        } catch (error) {
            console.error('Fehler beim CSV-Export:', error);
            window.ImmoLMS.Notifications.showError('Bewertungen konnten nicht als CSV exportiert werden');
        }
    }
    
    /**
     * Maskiert Kommas und Anführungszeichen in CSV-Werten
     * @param {string} value - Zu maskierender Wert
     * @returns {string} - Maskierter Wert
     */
    function _escapeCSVValue(value) {
        if (value === null || value === undefined) return '';
        
        const stringValue = String(value);
        
        // Wenn der Wert Kommas, Anführungszeichen oder Zeilenumbrüche enthält,
        // in Anführungszeichen einschließen und enthaltene Anführungszeichen verdoppeln
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
            return '"' + stringValue.replace(/"/g, '""') + '"';
        }
        
        return stringValue;
    }
    
    /**
     * Exportiert Bewertungsdaten als JSON-Datei
     * @param {Array} data - Zu exportierende Daten
     */
    function _exportToJSON(data) {
        try {
            // JSON-String erstellen
            const jsonString = JSON.stringify(data, null, 2);
            
            // JSON-Datei erstellen und herunterladen
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `bewertungen_${new Date().toISOString().slice(0, 10)}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            window.ImmoLMS.Notifications.showSuccess('Bewertungen wurden als JSON exportiert');
        } catch (error) {
            console.error('Fehler beim JSON-Export:', error);
            window.ImmoLMS.Notifications.showError('Bewertungen konnten nicht als JSON exportiert werden');
        }
    }
    
    /**
     * Exportiert Bewertungsdaten als PDF-Dokument
     * @param {Array} data - Zu exportierende Daten
     */
    function _exportToPDF(data) {
        // In einer realen Implementierung würde hier eine PDF-Bibliothek verwendet werden
        // Da dies nur ein Prototyp ist, zeigen wir eine Benachrichtigung an
        
        window.ImmoLMS.Notifications.showInfo(
            'PDF-Export wird in einem späteren Update implementiert'
        );
        
        console.log('PDF-Export:', data);
    }
    
    /**
     * Erstellt eine druckbare Ansicht der Bewertungsdaten
     * @param {Array} data - Zu exportierende Daten
     */
    function _printAssessments(data) {
        try {
            // Druckbaren HTML-Inhalt erstellen
            let printContent = `
                <html>
                <head>
                    <title>Offene Bewertungen</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1 { color: #333; text-align: center; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                        tr:nth-child(even) { background-color: #f9f9f9; }
                        .print-header { display: flex; justify-content: space-between; align-items: center; }
                        .print-date { font-size: 0.8em; color: #666; }
                        .status-pending { color: orange; }
                        .status-inProgress { color: blue; }
                        .status-flagged { color: red; }
                        .print-footer { margin-top: 30px; font-size: 0.8em; text-align: center; color: #666; }
                    </style>
                </head>
                <body>
                    <div class="print-header">
                        <h1>Offene Bewertungen</h1>
                        <div class="print-date">Erstellt am: ${new Date().toLocaleString()}</div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Test</th>
                                <th>Teilnehmer</th>
                                <th>Team</th>
                                <th>Eingereicht am</th>
                                <th>Status</th>
                                <th>Offene Fragen</th>
                                <th>Zugewiesen an</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Datenzeilen hinzufügen
            data.forEach(item => {
                printContent += `
                    <tr>
                        <td>${item.testTitle} (${item.testCategory})</td>
                        <td>${item.userName}</td>
                        <td>${item.userTeam}</td>
                        <td>${item.dateSubmittedFormatted}</td>
                        <td class="status-${item.status}">${item.statusFormatted}</td>
                        <td>${item.openQuestions} / ${item.totalQuestions}</td>
                        <td>${item.assignedTo}</td>
                    </tr>
                `;
            });
            
            // Tabelle und HTML abschließen
            printContent += `
                        </tbody>
                    </table>
                    <div class="print-footer">
                        ImmoScout24 E-Learning System - Insgesamt ${data.length} offene Bewertungen
                    </div>
                </body>
                </html>
            `;
            
            // Druckfenster öffnen
            const printWindow = window.open('', '_blank');
            printWindow.document.write(printContent);
            printWindow.document.close();
            
            // Nach dem Laden drucken
            printWindow.onload = function() {
                printWindow.print();
            };
        } catch (error) {
            console.error('Fehler beim Drucken:', error);
            window.ImmoLMS.Notifications.showError('Bewertungen konnten nicht gedruckt werden');
        }
    }
    
    /**
     * Erstellt die Detailansicht für eine Bewertung
     * @param {string} assessmentId - ID der Bewertung
     */
    function _createDetailView(assessmentId) {
        try {
            // Bewertungsdaten abrufen
            const assessment = _getAssessmentDetailData(assessmentId);
            
            if (!assessment) {
                console.error('Bewertungsdetails nicht gefunden:', assessmentId);
                window.ImmoLMS.Notifications.showError('Bewertungsdetails nicht gefunden');
                return;
            }
            
            // Container für die Detailansicht erstellen
            const detailContainer = document.createElement('div');
            detailContainer.className = 'assessment-detail-view';
            detailContainer.id = 'assessment-detail-view';
            
            // Header-Bereich
            const header = document.createElement('div');
            header.className = 'detail-header';
            
            const closeButton = document.createElement('button');
            closeButton.className = 'btn btn-icon close-detail';
            closeButton.innerHTML = '<i class="fas fa-times"></i>';
            closeButton.setAttribute('aria-label', 'Schließen');
            closeButton.addEventListener('click', _closeDetailView);
            
            const title = document.createElement('h2');
            title.textContent = `Bewertung: ${assessment.testTitle}`;
            
            header.appendChild(title);
            header.appendChild(closeButton);
            
            // Inhaltsbereich
            const content = document.createElement('div');
            content.className = 'detail-content';
            
            // Teilnehmer- und Testinformationen
            const infoSection = document.createElement('div');
            infoSection.className = 'info-section';
            
            const testInfo = document.createElement('div');
            testInfo.className = 'test-info';
            
            const testTitle = document.createElement('h3');
            testTitle.textContent = assessment.testTitle;
            
            const testDetails = document.createElement('div');
            testDetails.className = 'test-details';
            testDetails.innerHTML = `
                <div class="detail-item"><span class="label">Kategorie:</span> <span class="value">${assessment.testCategory}</span></div>
                <div class="detail-item"><span class="label">Test-ID:</span> <span class="value">${assessment.testId}</span></div>
                <div class="detail-item"><span class="label">Fragen:</span> <span class="value">${assessment.totalQuestions}</span></div>
                <div class="detail-item"><span class="label">Offene Fragen:</span> <span class="value">${assessment.openQuestions}</span></div>
            `;
            
            testInfo.appendChild(testTitle);
            testInfo.appendChild(testDetails);
            
            const userInfo = document.createElement('div');
            userInfo.className = 'user-info';
            
            const userName = document.createElement('h3');
            userName.textContent = assessment.userName;
            
            const userDetails = document.createElement('div');
            userDetails.className = 'user-details';
            userDetails.innerHTML = `
                <div class="detail-item"><span class="label">Team:</span> <span class="value">${assessment.userTeam}</span></div>
                <div class="detail-item"><span class="label">E-Mail:</span> <span class="value">${assessment.userEmail}</span></div>
                <div class="detail-item"><span class="label">Eingereicht am:</span> <span class="value">${assessment.dateSubmittedFormatted}</span></div>
                <div class="detail-item"><span class="label">Status:</span> <span class="value status-${assessment.status}">${assessment.statusFormatted}</span></div>
            `;
            
            userInfo.appendChild(userName);
            userInfo.appendChild(userDetails);
            
            infoSection.appendChild(testInfo);
            infoSection.appendChild(userInfo);
            
            // Metadaten-Bereich
            const metaSection = document.createElement('div');
            metaSection.className = 'meta-section';
            
            // Zuweisung und Markierung
            const assignmentInfo = document.createElement('div');
            assignmentInfo.className = 'assignment-info';
            
            if (assessment.assignedTo) {
                assignmentInfo.innerHTML = `
                    <div class="assigned-tag">Zugewiesen an ${assessment.assignedTo}</div>
                    <div class="assigned-date">am ${assessment.assignedAt || 'unbekanntes Datum'}</div>
                `;
            } else {
                assignmentInfo.innerHTML = `
                    <div class="not-assigned-tag">Nicht zugewiesen</div>
                `;
            }
            
            if (assessment.status === 'flagged' && assessment.flagReason) {
                const flagInfo = document.createElement('div');
                flagInfo.className = 'flag-info';
                flagInfo.innerHTML = `
                    <div class="flag-tag">Markiert</div>
                    <div class="flag-reason">${assessment.flagReason}</div>
                `;
                metaSection.appendChild(flagInfo);
            }
            
            metaSection.appendChild(assignmentInfo);
            
            // Aktionsleiste
            const actionBar = document.createElement('div');
            actionBar.className = 'detail-action-bar';
            
            const reviewButton = document.createElement('button');
            reviewButton.className = 'btn btn-primary';
            reviewButton.innerHTML = '<i class="fas fa-edit"></i> Jetzt bewerten';
            reviewButton.addEventListener('click', () => {
                _startAssessment(assessmentId);
                _closeDetailView();
            });
            
            const assignButton = document.createElement('button');
            assignButton.className = 'btn btn-outline-secondary';
            assignButton.innerHTML = '<i class="fas fa-user-check"></i> Zuweisen';
            assignButton.addEventListener('click', () => {
                _showAssignmentDialog(assessmentId);
            });
            
            const flagButton = document.createElement('button');
            if (assessment.status === 'flagged') {
                flagButton.className = 'btn btn-outline-info';
                flagButton.innerHTML = '<i class="fas fa-flag-checkered"></i> Entmarkieren';
                flagButton.addEventListener('click', () => {
                    _toggleAssessmentFlag(assessmentId, false);
                    _closeDetailView();
                });
            } else {
                flagButton.className = 'btn btn-outline-warning';
                flagButton.innerHTML = '<i class="fas fa-flag"></i> Markieren';
                flagButton.addEventListener('click', () => {
                    _toggleAssessmentFlag(assessmentId, true);
                    _closeDetailView();
                });
            }
            
            actionBar.appendChild(reviewButton);
            actionBar.appendChild(assignButton);
            actionBar.appendChild(flagButton);
            
            // Offene Fragen anzeigen
            const questionsSection = document.createElement('div');
            questionsSection.className = 'questions-section';
            
            const questionTitle = document.createElement('h3');
            questionTitle.textContent = 'Offene Fragen';
            
            const questionList = document.createElement('div');
            questionList.className = 'question-list';
            
            // Fragen aus dem Assessment laden
            _loadQuestionPreview(assessment.id, questionList);
            
            questionsSection.appendChild(questionTitle);
            questionsSection.appendChild(questionList);
            
            // Elemente zusammenfügen
            content.appendChild(infoSection);
            content.appendChild(metaSection);
            content.appendChild(actionBar);
            content.appendChild(questionsSection);
            
            // Container zusammenbauen
            detailContainer.appendChild(header);
            detailContainer.appendChild(content);
            
            // DOM-Referenzen speichern
            _detailDomRefs.container = detailContainer;
            _detailDomRefs.header = header;
            _detailDomRefs.content = content;
            _detailDomRefs.questionList = questionList;
            _detailDomRefs.actionBar = actionBar;
            
            // Zur Seite hinzufügen
            document.body.appendChild(detailContainer);
            
            // Animation zum Einblenden
            setTimeout(() => {
                detailContainer.classList.add('active');
            }, 10);
            
            // Aktuellen Zustand aktualisieren
            _detailViewActive = true;
            _currentDetailId = assessmentId;
            
            // Event-Listener für Escape-Taste hinzufügen
            document.addEventListener('keydown', _handleDetailViewKeydown);
            
        } catch (error) {
            console.error('Fehler beim Erstellen der Detailansicht:', error);
            window.ImmoLMS.Notifications.showError('Detailansicht konnte nicht erstellt werden');
        }
    }
    
    /**
     * Schließt die Detailansicht
     */
    function _closeDetailView() {
        if (!_detailViewActive) return;
        
        // Container abrufen
        const detailContainer = document.getElementById('assessment-detail-view');
        if (!detailContainer) return;
        
        // Animation zum Ausblenden
        detailContainer.classList.remove('active');
        
        // Nach der Animation entfernen
        setTimeout(() => {
            detailContainer.remove();
            
            // Zustand zurücksetzen
            _detailViewActive = false;
            _currentDetailId = null;
            
            // Event-Listener entfernen
            document.removeEventListener('keydown', _handleDetailViewKeydown);
        }, 300);
    }
    
    /**
     * Lädt eine Vorschau der Fragen für eine Bewertung
     * @param {string} assessmentId - ID der Bewertung
     * @param {HTMLElement} container - Container für die Fragen
     */
    function _loadQuestionPreview(assessmentId, container) {
        try {
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const result = testResults.find(r => r.id === assessmentId);
            
            if (!result || !result.questionResults) {
                container.innerHTML = '<div class="no-questions">Keine Fragen verfügbar</div>';
                return;
            }
            
            // Offene Fragen filtern
            const openQuestions = result.questionResults.filter(q => !q.isAssessed);
            
            if (openQuestions.length === 0) {
                container.innerHTML = '<div class="no-questions">Alle Fragen wurden bereits bewertet</div>';
                return;
            }
            
            // Fragen anzeigen
            openQuestions.forEach((question, index) => {
                const questionItem = document.createElement('div');
                questionItem.className = 'question-item';
                
                // Überschrift mit Fragennummer
                const questionHeader = document.createElement('div');
                questionHeader.className = 'question-header';
                questionHeader.innerHTML = `<span class="question-number">Frage ${index + 1}</span>`;
                
                // Fragentext (gekürzt für Vorschau)
                const questionText = document.createElement('div');
                questionText.className = 'question-text';
                
                // Maximal 100 Zeichen anzeigen
                const maxLength = 100;
                const text = question.questionText || 'Keine Fragentext verfügbar';
                questionText.textContent = text.length > maxLength ? 
                    text.substring(0, maxLength) + '...' : text;
                
                // Typ der Frage anzeigen
                const questionType = document.createElement('div');
                questionType.className = 'question-type';
                questionType.textContent = _getQuestionTypeLabel(question.type);
                
                // Antwort des Teilnehmers (gekürzt für Vorschau)
                const userAnswer = document.createElement('div');
                userAnswer.className = 'user-answer';
                
                let answerText = 'Keine Antwort';
                
                if (question.userAnswer) {
                    if (typeof question.userAnswer === 'string') {
                        answerText = question.userAnswer;
                    } else if (Array.isArray(question.userAnswer)) {
                        answerText = question.userAnswer.join(', ');
                    } else {
                        answerText = JSON.stringify(question.userAnswer);
                    }
                }
                
                // Maximal 150 Zeichen der Antwort anzeigen
                const maxAnswerLength = 150;
                userAnswer.textContent = answerText.length > maxAnswerLength ? 
                    answerText.substring(0, maxAnswerLength) + '...' : answerText;
                
                // Komponenten zusammenfügen
                questionItem.appendChild(questionHeader);
                questionItem.appendChild(questionType);
                questionItem.appendChild(questionText);
                questionItem.appendChild(userAnswer);
                
                container.appendChild(questionItem);
            });
        } catch (error) {
            console.error('Fehler beim Laden der Fragenvorschau:', error);
            container.innerHTML = '<div class="error-message">Fehler beim Laden der Fragen</div>';
        }
    }
    
    /**
     * Gibt eine lesbare Bezeichnung für einen Fragentyp zurück
     * @param {string} questionType - Fragentyp-Code
     * @returns {string} - Lesbare Bezeichnung
     */
    function _getQuestionTypeLabel(questionType) {
        switch (questionType) {
            case 'multipleChoice':
                return 'Multiple Choice';
            case 'singleChoice':
                return 'Single Choice';
            case 'trueFalse':
                return 'Wahr/Falsch';
            case 'text':
                return 'Freitext';
            default:
                return 'Unbekannter Typ';
        }
    }
    
    /**
     * Ruft detaillierte Daten für eine Bewertung ab
     * @param {string} assessmentId - ID der Bewertung
     * @returns {Object|null} - Detaillierte Bewertungsdaten oder null, wenn nicht gefunden
     */
    function _getAssessmentDetailData(assessmentId) {
        try {
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const result = testResults.find(r => r.id === assessmentId);
            
            if (!result) return null;
            
            // Testdaten abrufen
            const tests = window.ImmoLMS.DataStore.getTests() || [];
            const test = tests.find(t => t.id === result.testId) || { 
                title: 'Unbekannter Test', 
                category: 'Keine Kategorie' 
            };
            
            // Benutzerdaten abrufen
            const users = window.ImmoLMS.DataStore.getUsers() || [];
            const user = users.find(u => u.id === result.userId) || { 
                firstName: 'Unbekannt', 
                lastName: 'Unbekannt', 
                team: 'Kein Team',
                email: 'keine@email.com'
            };
            
            // Anzahl der offenen Fragen ermitteln
            const totalQuestions = result.questionResults ? result.questionResults.length : 0;
            const assessedQuestions = result.questionResults ? 
                result.questionResults.filter(q => q.isAssessed).length : 0;
            const openQuestionsCount = totalQuestions - assessedQuestions;
            
            // Zusätzliche Bewertungsmetadaten
            const assessmentMeta = result.assessmentMeta || {};
            
            // Zuweisungsinformationen
            let assignedToUser = null;
            if (assessmentMeta.assignedTo) {
                const assignee = users.find(u => u.id === assessmentMeta.assignedTo);
                if (assignee) {
                    assignedToUser = `${assignee.firstName} ${assignee.lastName}`;
                }
            }
            
            // Detaillierte Bewertungsdaten zusammenstellen
            return {
                id: result.id,
                testId: result.testId,
                testTitle: test.title,
                testCategory: test.category,
                userId: result.userId,
                userName: `${user.firstName} ${user.lastName}`,
                userEmail: user.email || 'keine@email.com',
                userTeam: user.team,
                dateSubmitted: new Date(result.completedAt),
                dateSubmittedFormatted: new Date(result.completedAt).toLocaleString(),
                status: result.assessmentStatus || 'pending',
                statusFormatted: _getFormattedStatus(result.assessmentStatus),
                openQuestions: openQuestionsCount,
                totalQuestions: totalQuestions,
                assignedTo: assignedToUser,
                assignedAt: assessmentMeta.assignedAt ? new Date(assessmentMeta.assignedAt).toLocaleString() : null,
                flagReason: assessmentMeta.flagReason || null,
                questionResults: result.questionResults || []
            };
        } catch (error) {
            console.error('Fehler beim Abrufen der Bewertungsdetails:', error);
            return null;
        }
    }
    
    /**
     * Zeigt einen Dialog zur Zuweisung einer Bewertung an
     * @param {string} assessmentId - ID der Bewertung
     */
    function _showAssignmentDialog(assessmentId) {
        // In einer realen Implementierung würde hier ein Modal-Dialog angezeigt werden
        // Da dies nur ein Prototyp ist, verwenden wir prompt()
        
        // Verfügbare Trainer abrufen
        const users = window.ImmoLMS.DataStore.getUsers() || [];
        const trainers = users.filter(user => user.role === 'trainer' || user.role === 'admin');
        
        if (trainers.length === 0) {
            window.ImmoLMS.Notifications.showError('Keine Trainer verfügbar');
            return;
        }
        
        // Trainerliste für Auswahl erstellen
        let trainerList = 'Verfügbare Trainer:\n';
        trainers.forEach((trainer, index) => {
            trainerList += `${index + 1}. ${trainer.firstName} ${trainer.lastName}\n`;
        });
        
        // Trainernummer abfragen
        const selectedTrainerIndex = prompt(`${trainerList}\nGeben Sie die Nummer des Trainers ein:`, '1');
        
        if (selectedTrainerIndex === null) return;
        
        const trainerIndex = parseInt(selectedTrainerIndex) - 1;
        
        if (isNaN(trainerIndex) || trainerIndex < 0 || trainerIndex >= trainers.length) {
            window.ImmoLMS.Notifications.showError('Ungültige Auswahl');
            return;
        }
        
        const selectedTrainer = trainers[trainerIndex];
        
        // Zuweisung durchführen
        _assignAssessment(assessmentId, selectedTrainer.id);
        
        // Detailansicht aktualisieren
        if (_detailViewActive && _currentDetailId === assessmentId) {
            _closeDetailView();
            setTimeout(() => {
                _createDetailView(assessmentId);
            }, 500);
        }
    }
    
    /**
     * Weist eine Bewertung einem Trainer zu
     * @param {string} assessmentId - ID der Bewertung
     * @param {string} trainerId - ID des Trainers
     */
    function _assignAssessment(assessmentId, trainerId) {
        try {
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const resultIndex = testResults.findIndex(r => r.id === assessmentId);
            
            if (resultIndex === -1) {
                console.error('Testergebnis nicht gefunden:', assessmentId);
                window.ImmoLMS.Notifications.showError('Bewertung nicht gefunden');
                return;
            }
            
            // Trainerinformationen abrufen
            const users = window.ImmoLMS.DataStore.getUsers() || [];
            const trainer = users.find(u => u.id === trainerId);
            
            if (!trainer) {
                console.error('Trainer nicht gefunden:', trainerId);
                window.ImmoLMS.Notifications.showError('Trainer nicht gefunden');
                return;
            }
            
            // Metadaten aktualisieren
            if (!testResults[resultIndex].assessmentMeta) {
                testResults[resultIndex].assessmentMeta = {};
            }
            
            testResults[resultIndex].assessmentMeta.assignedTo = trainerId;
            testResults[resultIndex].assessmentMeta.assignedAt = new Date().toISOString();
            
            // Aktualisierte Testergebnisse speichern
            window.ImmoLMS.DataStore.saveTestResults(testResults);
            
            // Benachrichtigung anzeigen
            window.ImmoLMS.Notifications.showSuccess(
                `Bewertung wurde ${trainer.firstName} ${trainer.lastName} zugewiesen`
            );
            
            // Bewertungsübersicht aktualisieren
            OpenAssessments.refresh();
            
            // Event auslösen
            const event = new CustomEvent('assessmentAssigned', { 
                detail: { 
                    assessmentId: assessmentId,
                    trainerId: trainerId,
                    trainerName: `${trainer.firstName} ${trainer.lastName}`
                }
            });
            window.dispatchEvent(event);
        } catch (error) {
            console.error('Fehler bei der Zuweisung:', error);
            window.ImmoLMS.Notifications.showError('Zuweisung konnte nicht durchgeführt werden');
        }
    }
    
    /**
     * Behandelt Tastatureingaben im Detail-Ansicht-Modus
     * @param {KeyboardEvent} event - Tastatur-Event
     */
    function _handleDetailViewKeydown(event) {
        // Escape-Taste schließt die Detailansicht
        if (event.key === 'Escape' && _detailViewActive) {
            _closeDetailView();
        }
    }
    
    /**
     * Behandelt Tastaturkürzel für die Bewertungsübersicht
     * @param {KeyboardEvent} event - Tastatur-Event
     */
    function _handleKeyboardShortcuts(event) {
        // Nur reagieren, wenn keine Eingabefelder fokussiert sind
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || 
            event.target.tagName === 'SELECT') {
            return;
        }
        
        // Escape-Taste im Massenaktionsmodus
        if (event.key === 'Escape' && _bulkActionState.active) {
            _exitBulkActionMode();
            event.preventDefault();
        }
        
        // Strg+A im Massenaktionsmodus für "Alle auswählen"
        if (event.key === 'a' && event.ctrlKey && _bulkActionState.active) {
            _toggleSelectAll();
            event.preventDefault();
        }
        
        // Strg+F für Fokus auf Suchfeld
        if (event.key === 'f' && event.ctrlKey) {
            const searchInput = document.getElementById('filter-search');
            if (searchInput) {
                searchInput.focus();
                event.preventDefault();
            }
        }
    }
    
    /**
     * Behandelt den Start einer Bewertung
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleStartAssessment(event) {
        console.log('Start Assessment Event:', event.detail);
        // Diese Funktion wird in JS-Block 7.2.2 implementiert
    }
    
    /**
     * Zeigt die Detailansicht für eine Bewertung an
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleShowAssessmentDetail(event) {
        const { assessmentId } = event.detail;
        _createDetailView(assessmentId);
    }
    
    /**
     * Schließt die Detailansicht
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleCloseAssessmentDetail(event) {
        _closeDetailView();
    }
    
    /**
     * Behandelt Zuweisungen von Bewertungen
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleAssignAssessment(event) {
        const { assessmentId, trainerId } = event.detail;
        _assignAssessment(assessmentId, trainerId);
    }
    
    /**
     * Behandelt den Export von Bewertungen
     * @param {CustomEvent} event - Event-Objekt
     */
    function _handleExportAssessments(event) {
        const { format } = event.detail;
        _exportAssessments(format);
    }
    
    /**
     * Zeigt die Detailansicht für eine Bewertung an (öffentliche Methode)
     * @param {string} assessmentId - ID der Bewertung
     */
    function showAssessmentDetail(assessmentId) {
        // Event auslösen
        const event = new CustomEvent('assessmentDetailView', { 
            detail: { assessmentId: assessmentId }
        });
        window.dispatchEvent(event);
    }
    
    /**
     * Initialisiert Keyboard-Hilfe für Schnellzugriff
     */
    function _initializeKeyboardHelp() {
        // Container für Hilfetext erstellen
        const helpContainer = document.createElement('div');
        helpContainer.className = 'keyboard-help';
        helpContainer.innerHTML = `
            <h3>Tastaturkürzel</h3>
            <ul>
                <li><kbd>Ctrl</kbd> + <kbd>F</kbd> - Suchfeld fokussieren</li>
                <li><kbd>Ctrl</kbd> + <kbd>A</kbd> - Alle auswählen (im Massenaktionsmodus)</li>
                <li><kbd>Esc</kbd> - Massenaktionsmodus oder Detailansicht schließen</li>
            </ul>
            <button class="btn btn-sm btn-secondary close-help">Schließen</button>
        `;
        
        // Style hinzufügen
        helpContainer.style.cssText = `
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        `;
        
        // Schließen-Button
        const closeButton = helpContainer.querySelector('.close-help');
        if (closeButton) {
            closeButton.addEventListener('click', function() {
                helpContainer.style.display = 'none';
            });
        }
        
        // Zum Body hinzufügen
        document.body.appendChild(helpContainer);
        
        // Help-Button zur Übersicht hinzufügen
        const actionBar = document.querySelector('.assessment-action-bar');
        if (actionBar) {
            const helpButton = document.createElement('button');
            helpButton.className = 'btn btn-outline-secondary btn-sm';
            helpButton.innerHTML = '<i class="fas fa-keyboard"></i> Tastaturkürzel';
            helpButton.addEventListener('click', function() {
                helpContainer.style.display = helpContainer.style.display === 'none' ? 'block' : 'none';
            });
            
            actionBar.appendChild(helpButton);
        }
    }
    
    // Öffentliche API
    return Object.assign(OpenAssessments, {
        initializeExtendedFunctions: initializeExtendedFunctions,
        showAssessmentDetail: showAssessmentDetail,
        enableKeyboardShortcuts: _initializeKeyboardHelp,
        closeDetailView: _closeDetailView
    });
})();

// Automatische Initialisierung
document.addEventListener('DOMContentLoaded', function() {
    window.ImmoLMS.TrainerDashboard.OpenAssessments.initializeExtendedFunctions();
    window.ImmoLMS.TrainerDashboard.OpenAssessments.enableKeyboardShortcuts();
});
/**
 * JS-Block 7.2.2-part1: Bewertungsprozess (Teil 1)
 * 
 * Implementiert den Hauptbewertungsprozess für Trainer, um eingereichte Tests
 * zu bewerten, insbesondere Freitextfragen zu beurteilen und Feedback zu geben.
 * 
 * Funktionen:
 * - Bewertungsoberfläche mit Fragen- und Antwortanzeige
 * - Navigation zwischen zu bewertenden Fragen
 * - Bewertungseingabe mit Punktevergabe
 * - Speicherung von Bewertungen und Feedback
 * - Statusverfolgung des Bewertungsprozesses
 */
window.ImmoLMS.TrainerDashboard.AssessmentProcess = (function() {
    // Private Variablen
    let _currentAssessmentId = null;
    let _assessmentData = null;
    let _currentQuestionIndex = 0;
    let _assessmentDomRefs = {};
    let _dirtyState = false;
    let _autoSaveTimer = null;
    let _savedState = {};
    
    // Konstanten
    const AUTO_SAVE_INTERVAL = 30000; // 30 Sekunden
    
    // Öffentliches Objekt
    const AssessmentProcess = {};
    
    /**
     * Initialisiert den Bewertungsprozess
     */
    function initialize() {
        _setupEventListeners();
        return AssessmentProcess;
    }
    
    /**
     * Richtet Event-Listener ein
     */
    function _setupEventListeners() {
        window.addEventListener('startAssessment', _handleStartAssessment);
        window.addEventListener('assessmentSaved', _handleAssessmentSaved);
        window.addEventListener('assessmentCompleted', _handleAssessmentCompleted);
        
        // Event-Listener für "Vor Verlassen warnen"
        window.addEventListener('beforeunload', function(e) {
            if (_dirtyState) {
                // Standard-Meldung für "Vor Verlassen warnen"
                const message = 'Sie haben ungespeicherte Änderungen. Möchten Sie wirklich die Seite verlassen?';
                e.returnValue = message;
                return message;
            }
        });
    }
    
    /**
     * Behandelt das Event zum Starten einer Bewertung
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleStartAssessment(event) {
        const { assessmentId } = event.detail;
        startAssessment(assessmentId);
    }
    
    /**
     * Behandelt das Event nach dem Speichern einer Bewertung
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleAssessmentSaved(event) {
        const { assessmentId, success } = event.detail;
        
        if (success && _currentAssessmentId === assessmentId) {
            _dirtyState = false;
            window.ImmoLMS.Notifications.showSuccess('Bewertung wurde gespeichert');
        }
    }
    
    /**
     * Behandelt das Event nach Abschluss einer Bewertung
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleAssessmentCompleted(event) {
        const { assessmentId, success } = event.detail;
        
        if (success && _currentAssessmentId === assessmentId) {
            _dirtyState = false;
            _closeAssessmentProcess();
            window.ImmoLMS.Notifications.showSuccess('Bewertung wurde abgeschlossen');
            
            // Zurück zur Übersicht mit aktualisierter Liste
            window.ImmoLMS.TrainerDashboard.OpenAssessments.refresh();
        }
    }
    
    /**
     * Startet den Bewertungsprozess für eine bestimmte Einreichung
     * @param {string} assessmentId - ID der zu bewertenden Einreichung
     */
    function startAssessment(assessmentId) {
        try {
            // Bewertungsdaten laden
            _assessmentData = _loadAssessmentData(assessmentId);
            if (!_assessmentData) {
                console.error('Bewertungsdaten konnten nicht geladen werden:', assessmentId);
                window.ImmoLMS.Notifications.showError('Bewertungsdaten konnten nicht geladen werden');
                return false;
            }
            
            // UI für Bewertung erstellen
            _createAssessmentUI();
            
            // Erste Frage anzeigen
            _currentQuestionIndex = 0;
            _showCurrentQuestion();
            
            // Status aktualisieren
            _currentAssessmentId = assessmentId;
            _updateAssessmentStatus('in_progress');
            
            // AutoSave-Timer starten
            _startAutoSaveTimer();
            
            // Event auslösen
            const event = new CustomEvent('assessmentStarted', {
                detail: { assessmentId: assessmentId }
            });
            window.dispatchEvent(event);
            
            return true;
        } catch (error) {
            console.error('Fehler beim Starten des Bewertungsprozesses:', error);
            window.ImmoLMS.Notifications.showError('Bewertungsprozess konnte nicht gestartet werden');
            return false;
        }
    }
    
    /**
     * Lädt die Bewertungsdaten für eine bestimmte Einreichung
     * @param {string} assessmentId - ID der Einreichung
     * @returns {Object|null} - Bewertungsdaten oder null bei Fehler
     */
    function _loadAssessmentData(assessmentId) {
        try {
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const result = testResults.find(r => r.id === assessmentId);
            
            if (!result) {
                console.error('Testergebnis nicht gefunden:', assessmentId);
                return null;
            }
            
            // Testdaten abrufen
            const tests = window.ImmoLMS.DataStore.getTests() || [];
            const test = tests.find(t => t.id === result.testId);
            
            if (!test) {
                console.error('Testdaten nicht gefunden:', result.testId);
                return null;
            }
            
            // Benutzerdaten abrufen
            const users = window.ImmoLMS.DataStore.getUsers() || [];
            const user = users.find(u => u.id === result.userId);
            
            if (!user) {
                console.error('Benutzerdaten nicht gefunden:', result.userId);
                return null;
            }
            
            // Offene Fragen filtern (nicht bewertet oder freitext)
            let questionResults = result.questionResults || [];
            let openQuestions = questionResults.filter(q => !q.isAssessed);
            
            // Wenn keine offenen Fragen gefunden wurden, alle Fragen laden
            // (Dies ermöglicht die Überprüfung bereits bewerteter Fragen)
            if (openQuestions.length === 0) {
                openQuestions = questionResults;
            }
            
            // Tests sortieren: Freitextfragen mit Priorität
            openQuestions.sort((a, b) => {
                // Nicht bewertete vor bewerteten
                if (a.isAssessed !== b.isAssessed) {
                    return a.isAssessed ? 1 : -1;
                }
                
                // Freitext vor anderen Typen
                if (a.type === 'text' && b.type !== 'text') {
                    return -1;
                } else if (a.type !== 'text' && b.type === 'text') {
                    return 1;
                }
                
                // Nach Fragenindex sortieren
                return a.questionIndex - b.questionIndex;
            });
            
            // Bewertungsdaten zusammenstellen
            const assessmentData = {
                id: assessmentId,
                testId: result.testId,
                testTitle: test.title,
                testCategory: test.category,
                testDescription: test.description,
                userId: result.userId,
                userName: `${user.firstName} ${user.lastName}`,
                userEmail: user.email || '',
                userTeam: user.team || '',
                completedAt: new Date(result.completedAt),
                status: result.assessmentStatus || 'pending',
                questions: openQuestions,
                totalQuestions: questionResults.length,
                openQuestions: openQuestions.filter(q => !q.isAssessed).length,
                currentState: {
                    assessedCount: 0,
                    totalScore: 0,
                    maxPossibleScore: 0,
                    feedbackGiven: 0
                }
            };
            
            // Aktueller Bewertungsstand berechnen
            questionResults.forEach(q => {
                if (q.isAssessed) {
                    assessmentData.currentState.assessedCount++;
                    if (q.score !== undefined) {
                        assessmentData.currentState.totalScore += q.score;
                    }
                }
                if (q.maxScore !== undefined) {
                    assessmentData.currentState.maxPossibleScore += q.maxScore;
                }
                if (q.feedback) {
                    assessmentData.currentState.feedbackGiven++;
                }
            });
            
            return assessmentData;
        } catch (error) {
            console.error('Fehler beim Laden der Bewertungsdaten:', error);
            return null;
        }
    }
    
    /**
     * Erstellt die Benutzeroberfläche für den Bewertungsprozess
     */
    function _createAssessmentUI() {
        try {
            // Container für den Bewertungsprozess erstellen
            const assessmentContainer = document.createElement('div');
            assessmentContainer.className = 'assessment-process-container';
            assessmentContainer.id = 'assessment-process-container';
            
            // Header-Bereich
            const header = document.createElement('div');
            header.className = 'assessment-process-header';
            
            const closeButton = document.createElement('button');
            closeButton.className = 'btn btn-icon close-assessment';
            closeButton.innerHTML = '<i class="fas fa-times"></i>';
            closeButton.setAttribute('aria-label', 'Schließen');
            closeButton.addEventListener('click', _handleCloseButtonClick);
            
            const title = document.createElement('h2');
            title.textContent = `Bewertung: ${_assessmentData.testTitle}`;
            
            const subtitle = document.createElement('div');
            subtitle.className = 'assessment-subtitle';
            subtitle.textContent = `Teilnehmer: ${_assessmentData.userName} (${_assessmentData.userTeam})`;
            
            header.appendChild(title);
            header.appendChild(subtitle);
            header.appendChild(closeButton);
            
            // Fortschrittsbereich
            const progressSection = document.createElement('div');
            progressSection.className = 'assessment-progress-section';
            
            const progressBar = document.createElement('div');
            progressBar.className = 'progress';
            progressBar.innerHTML = `
                <div class="progress-bar" role="progressbar" style="width: 0%;" 
                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            `;
            
            const progressStats = document.createElement('div');
            progressStats.className = 'progress-stats';
            progressStats.innerHTML = `
                <span class="questions-progress">Frage 0 von ${_assessmentData.questions.length}</span>
                <span class="score-progress">Punkte: 0 / ${_assessmentData.currentState.maxPossibleScore}</span>
            `;
            
            progressSection.appendChild(progressBar);
            progressSection.appendChild(progressStats);
            
            // Hauptbereich für Fragenanzeige
            const mainSection = document.createElement('div');
            mainSection.className = 'assessment-main-section';
            
            // Container für die aktuelle Frage
            const questionContainer = document.createElement('div');
            questionContainer.className = 'question-container';
            questionContainer.id = 'question-container';
            
            mainSection.appendChild(questionContainer);
            
            // Navigations- und Aktionsbereich
            const actionSection = document.createElement('div');
            actionSection.className = 'assessment-action-section';
            
            const navButtons = document.createElement('div');
            navButtons.className = 'nav-buttons';
            
            const prevButton = document.createElement('button');
            prevButton.className = 'btn btn-outline-primary btn-prev';
            prevButton.innerHTML = '<i class="fas fa-arrow-left"></i> Vorherige';
            prevButton.addEventListener('click', _navigateToPreviousQuestion);
            prevButton.disabled = true;  // Initial deaktiviert
            
            const nextButton = document.createElement('button');
            nextButton.className = 'btn btn-outline-primary btn-next';
            nextButton.innerHTML = 'Nächste <i class="fas fa-arrow-right"></i>';
            nextButton.addEventListener('click', _navigateToNextQuestion);
            
            navButtons.appendChild(prevButton);
            navButtons.appendChild(nextButton);
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'action-buttons';
            
            const saveButton = document.createElement('button');
            saveButton.className = 'btn btn-secondary btn-save';
            saveButton.innerHTML = '<i class="fas fa-save"></i> Speichern';
            saveButton.addEventListener('click', _saveAssessment);
            
            const finishButton = document.createElement('button');
            finishButton.className = 'btn btn-primary btn-finish';
            finishButton.innerHTML = '<i class="fas fa-check-circle"></i> Abschließen';
            finishButton.addEventListener('click', _completeAssessment);
            
            actionButtons.appendChild(saveButton);
            actionButtons.appendChild(finishButton);
            
            actionSection.appendChild(navButtons);
            actionSection.appendChild(actionButtons);
            
            // Hilfspanel für Notizen und Bewertungstipps
            const helpPanel = document.createElement('div');
            helpPanel.className = 'assessment-help-panel';
            helpPanel.innerHTML = `
                <div class="panel-toggle">
                    <button class="btn btn-sm btn-outline-secondary">
                        <i class="fas fa-info-circle"></i> Bewertungshilfe
                    </button>
                </div>
                <div class="panel-content" style="display: none;">
                    <h4>Bewertungstipps</h4>
                    <ul>
                        <li>Bewerten Sie objektiv anhand der Musterlösung</li>
                        <li>Geben Sie konstruktives Feedback</li>
                        <li>Bei Unklarheiten markieren Sie die Bewertung mit dem Flag-Symbol</li>
                    </ul>
                    <h4>Notizen</h4>
                    <textarea class="notes-area" placeholder="Persönliche Notizen zur Bewertung"></textarea>
                </div>
            `;
            
            // Toggle-Funktionalität für Hilfspanel
            const toggleButton = helpPanel.querySelector('.panel-toggle button');
            const panelContent = helpPanel.querySelector('.panel-content');
            toggleButton.addEventListener('click', function() {
                if (panelContent.style.display === 'none') {
                    panelContent.style.display = 'block';
                    toggleButton.innerHTML = '<i class="fas fa-times-circle"></i> Bewertungshilfe ausblenden';
                } else {
                    panelContent.style.display = 'none';
                    toggleButton.innerHTML = '<i class="fas fa-info-circle"></i> Bewertungshilfe';
                }
            });
            
            // Komponenten zusammenfügen
            assessmentContainer.appendChild(header);
            assessmentContainer.appendChild(progressSection);
            assessmentContainer.appendChild(mainSection);
            assessmentContainer.appendChild(actionSection);
            assessmentContainer.appendChild(helpPanel);
            
            // DOM-Referenzen speichern
            _assessmentDomRefs.container = assessmentContainer;
            _assessmentDomRefs.progressBar = progressBar.querySelector('.progress-bar');
            _assessmentDomRefs.progressStats = progressStats;
            _assessmentDomRefs.questionContainer = questionContainer;
            _assessmentDomRefs.prevButton = prevButton;
            _assessmentDomRefs.nextButton = nextButton;
            _assessmentDomRefs.saveButton = saveButton;
            _assessmentDomRefs.finishButton = finishButton;
            _assessmentDomRefs.notesArea = helpPanel.querySelector('.notes-area');
            
            // Zur Seite hinzufügen
            document.body.appendChild(assessmentContainer);
            
            // Animation zum Einblenden
            setTimeout(() => {
                assessmentContainer.classList.add('active');
            }, 10);
            
        } catch (error) {
            console.error('Fehler beim Erstellen der Bewertungs-UI:', error);
            window.ImmoLMS.Notifications.showError('Bewertungsoberfläche konnte nicht erstellt werden');
        }
    }
	/**
     * Zeigt die aktuelle Frage im Bewertungsprozess an
     */
    function _showCurrentQuestion() {
        try {
            if (!_assessmentData || !_assessmentData.questions) {
                console.error('Keine Bewertungsdaten verfügbar');
                return;
            }
            
            // Aktuelle Frage abrufen
            const question = _assessmentData.questions[_currentQuestionIndex];
            if (!question) {
                console.error('Frage nicht gefunden für Index:', _currentQuestionIndex);
                return;
            }
            
            // Container leeren
            const container = _assessmentDomRefs.questionContainer;
            container.innerHTML = '';
            
            // Frage-Container erstellen
            const questionElement = document.createElement('div');
            questionElement.className = `question-element question-type-${question.type}`;
            
            // Fragenheader mit Meta-Informationen
            const questionHeader = document.createElement('div');
            questionHeader.className = 'question-header';
            
            // Fragenummer und Typ
            const questionMeta = document.createElement('div');
            questionMeta.className = 'question-meta';
            questionMeta.innerHTML = `
                <span class="question-number">Frage ${question.questionIndex + 1} von ${_assessmentData.totalQuestions}</span>
                <span class="question-type">${_getQuestionTypeLabel(question.type)}</span>
                ${question.isAssessed ? '<span class="question-assessed">Bereits bewertet</span>' : ''}
            `;
            
            // Status-Anzeige und Aktionen
            const questionActions = document.createElement('div');
            questionActions.className = 'question-actions';
            
            const flagButton = document.createElement('button');
            flagButton.className = 'btn btn-sm btn-outline-warning btn-flag';
            flagButton.innerHTML = question.flagged ? 
                '<i class="fas fa-flag"></i> Markiert' : 
                '<i class="far fa-flag"></i> Markieren';
            flagButton.addEventListener('click', () => _toggleQuestionFlag(question.questionId));
            
            questionActions.appendChild(flagButton);
            
            // Header zusammenfügen
            questionHeader.appendChild(questionMeta);
            questionHeader.appendChild(questionActions);
            
            // Fragentext
            const questionText = document.createElement('div');
            questionText.className = 'question-text';
            questionText.innerHTML = `<h3>${question.questionText}</h3>`;
            
            if (question.questionDescription) {
                const description = document.createElement('div');
                description.className = 'question-description';
                description.innerHTML = question.questionDescription;
                questionText.appendChild(description);
            }
            
            // Antwortbereich
            const answerSection = document.createElement('div');
            answerSection.className = 'answer-section';
            
            // Fragetyp-spezifische Anzeige
            switch (question.type) {
                case 'text':
                    _renderTextQuestionAnswer(answerSection, question);
                    break;
                case 'multipleChoice':
                    _renderMultipleChoiceQuestionAnswer(answerSection, question);
                    break;
                case 'singleChoice':
                    _renderSingleChoiceQuestionAnswer(answerSection, question);
                    break;
                case 'trueFalse':
                    _renderTrueFalseQuestionAnswer(answerSection, question);
                    break;
                default:
                    answerSection.innerHTML = '<div class="error-message">Unbekannter Fragetyp</div>';
            }
            
            // Bewertungsbereich
            const assessmentSection = document.createElement('div');
            assessmentSection.className = 'assessment-section';
            
            // Punktevergabe
            const scoreSection = document.createElement('div');
            scoreSection.className = 'score-section';
            
            const scoreLabel = document.createElement('label');
            scoreLabel.setAttribute('for', 'question-score');
            scoreLabel.textContent = 'Punkte:';
            
            const scoreInput = document.createElement('input');
            scoreInput.type = 'number';
            scoreInput.id = 'question-score';
            scoreInput.className = 'form-control score-input';
            scoreInput.min = 0;
            scoreInput.max = question.maxScore || 10;
            scoreInput.step = 0.5;
            scoreInput.value = question.score !== undefined ? question.score : '';
            scoreInput.addEventListener('change', () => {
                _updateQuestionScore(question.questionId, parseFloat(scoreInput.value));
            });
            
            const scoreMax = document.createElement('span');
            scoreMax.className = 'max-score';
            scoreMax.textContent = `/ ${question.maxScore || 10}`;
            
            scoreSection.appendChild(scoreLabel);
            scoreSection.appendChild(scoreInput);
            scoreSection.appendChild(scoreMax);
            
            // Korrektheit (für automatisch bewertete Fragen)
            if (question.type !== 'text') {
                const correctnessSection = document.createElement('div');
                correctnessSection.className = 'correctness-section';
                
                const correctness = question.isCorrect !== undefined ? question.isCorrect : null;
                let correctnessClass = '';
                let correctnessText = 'Nicht bewertet';
                
                if (correctness === true) {
                    correctnessClass = 'correct';
                    correctnessText = 'Korrekt';
                } else if (correctness === false) {
                    correctnessClass = 'incorrect';
                    correctnessText = 'Inkorrekt';
                }
                
                correctnessSection.innerHTML = `
                    <div class="correctness-indicator ${correctnessClass}">
                        ${correctnessText}
                    </div>
                `;
                
                assessmentSection.appendChild(correctnessSection);
            }
            
            // Feedback-Bereich
            const feedbackSection = document.createElement('div');
            feedbackSection.className = 'feedback-section';
            
            const feedbackLabel = document.createElement('label');
            feedbackLabel.setAttribute('for', 'question-feedback');
            feedbackLabel.textContent = 'Feedback:';
            
            const feedbackInput = document.createElement('textarea');
            feedbackInput.id = 'question-feedback';
            feedbackInput.className = 'form-control feedback-input';
            feedbackInput.rows = 4;
            feedbackInput.value = question.feedback || '';
            feedbackInput.addEventListener('change', () => {
                _updateQuestionFeedback(question.questionId, feedbackInput.value);
            });
            
            feedbackSection.appendChild(feedbackLabel);
            feedbackSection.appendChild(feedbackInput);
            
            // Musterlösung anzeigen (wenn vorhanden)
            if (question.correctAnswer || question.sampleSolution) {
                const solutionSection = document.createElement('div');
                solutionSection.className = 'solution-section';
                
                const solutionHeader = document.createElement('h4');
                solutionHeader.textContent = 'Musterlösung:';
                
                const solutionContent = document.createElement('div');
                solutionContent.className = 'solution-content';
                
                if (question.sampleSolution) {
                    // Wenn eine explizite Musterlösung vorhanden ist
                    solutionContent.innerHTML = question.sampleSolution;
                } else {
                    // Andernfalls die korrekte Antwort anzeigen
                    switch (question.type) {
                        case 'multipleChoice':
                            _renderMultipleChoiceSolution(solutionContent, question);
                            break;
                        case 'singleChoice':
                            _renderSingleChoiceSolution(solutionContent, question);
                            break;
                        case 'trueFalse':
                            solutionContent.textContent = question.correctAnswer ? 'Wahr' : 'Falsch';
                            break;
                        default:
                            solutionContent.textContent = String(question.correctAnswer || 'Keine Musterlösung verfügbar');
                    }
                }
                
                solutionSection.appendChild(solutionHeader);
                solutionSection.appendChild(solutionContent);
                
                assessmentSection.appendChild(solutionSection);
            }
            
            // Abschließender Bewertungsstatus
            const assessmentStatus = document.createElement('div');
            assessmentStatus.className = 'assessment-status';
            
            const statusCheckbox = document.createElement('input');
            statusCheckbox.type = 'checkbox';
            statusCheckbox.id = 'mark-assessed';
            statusCheckbox.className = 'form-check-input';
            statusCheckbox.checked = question.isAssessed || false;
            statusCheckbox.addEventListener('change', () => {
                _updateQuestionAssessedStatus(question.questionId, statusCheckbox.checked);
            });
            
            const statusLabel = document.createElement('label');
            statusLabel.setAttribute('for', 'mark-assessed');
            statusLabel.className = 'form-check-label';
            statusLabel.textContent = 'Als bewertet markieren';
            
            assessmentStatus.appendChild(statusCheckbox);
            assessmentStatus.appendChild(statusLabel);
            
            // Komponenten zusammenfügen
            assessmentSection.appendChild(scoreSection);
            assessmentSection.appendChild(feedbackSection);
            assessmentSection.appendChild(assessmentStatus);
            
            // Alles zum Frage-Element hinzufügen
            questionElement.appendChild(questionHeader);
            questionElement.appendChild(questionText);
            questionElement.appendChild(answerSection);
            questionElement.appendChild(assessmentSection);
            
            // Zum Container hinzufügen
            container.appendChild(questionElement);
            
            // Navigation aktualisieren
            _updateNavigationState();
            
            // Fortschritt aktualisieren
            _updateProgressDisplay();
            
        } catch (error) {
            console.error('Fehler beim Anzeigen der Frage:', error);
            _assessmentDomRefs.questionContainer.innerHTML = `
                <div class="error-display">
                    <h3>Fehler beim Laden der Frage</h3>
                    <p>Die Frage konnte nicht angezeigt werden. Bitte versuchen Sie es erneut.</p>
                </div>
            `;
        }
    }
    
    /**
     * Rendert die Antwort für eine Freitext-Frage
     * @param {HTMLElement} container - Container für die Antwort
     * @param {Object} question - Fragedaten
     */
    function _renderTextQuestionAnswer(container, question) {
        const answerBox = document.createElement('div');
        answerBox.className = 'text-answer-box';
        
        const answerHeader = document.createElement('h4');
        answerHeader.textContent = 'Antwort des Teilnehmers:';
        
        const answerContent = document.createElement('div');
        answerContent.className = 'answer-content';
        
        if (question.userAnswer && question.userAnswer.trim()) {
            answerContent.textContent = question.userAnswer;
        } else {
            answerContent.innerHTML = '<em>Keine Antwort gegeben</em>';
            answerContent.className += ' no-answer';
        }
        
        answerBox.appendChild(answerHeader);
        answerBox.appendChild(answerContent);
        
        container.appendChild(answerBox);
    }
    
    /**
     * Rendert die Antwort für eine Multiple-Choice-Frage
     * @param {HTMLElement} container - Container für die Antwort
     * @param {Object} question - Fragedaten
     */
    function _renderMultipleChoiceQuestionAnswer(container, question) {
        const answerList = document.createElement('div');
        answerList.className = 'mc-answer-list';
        
        const answerHeader = document.createElement('h4');
        answerHeader.textContent = 'Gewählte Antworten:';
        
        // Optionen anzeigen
        if (question.options && question.options.length > 0) {
            const userAnswers = Array.isArray(question.userAnswer) ? question.userAnswer : [];
            const correctAnswers = Array.isArray(question.correctAnswer) ? question.correctAnswer : [];
            
            const optionsList = document.createElement('ul');
            optionsList.className = 'options-list';
            
            question.options.forEach((option, index) => {
                const optionItem = document.createElement('li');
                optionItem.className = 'option-item';
                
                const isSelected = userAnswers.includes(index) || userAnswers.includes(String(index));
                const isCorrect = correctAnswers.includes(index) || correctAnswers.includes(String(index));
                
                if (isSelected) {
                    optionItem.className += ' selected';
                }
                
                // Markierung für korrekt/inkorrekt (für ausgewählte Optionen)
                if (isSelected) {
                    if (isCorrect) {
                        optionItem.className += ' correct';
                    } else {
                        optionItem.className += ' incorrect';
                    }
                }
                
                // Option-Text mit Icon
                optionItem.innerHTML = `
                    <span class="option-indicator">
                        ${isSelected ? '<i class="fas fa-check-square"></i>' : '<i class="far fa-square"></i>'}
                    </span>
                    <span class="option-text">${option}</span>
                    ${isSelected && isCorrect ? '<span class="correctness-icon correct"><i class="fas fa-check"></i></span>' : ''}
                    ${isSelected && !isCorrect ? '<span class="correctness-icon incorrect"><i class="fas fa-times"></i></span>' : ''}
                `;
                
                optionsList.appendChild(optionItem);
            });
            
            answerList.appendChild(answerHeader);
            answerList.appendChild(optionsList);
        } else {
            answerList.innerHTML = '<p>Keine Antwortoptionen verfügbar</p>';
        }
        
        container.appendChild(answerList);
    }
    
    /**
     * Rendert die Antwort für eine Single-Choice-Frage
     * @param {HTMLElement} container - Container für die Antwort
     * @param {Object} question - Fragedaten
     */
    function _renderSingleChoiceQuestionAnswer(container, question) {
        const answerList = document.createElement('div');
        answerList.className = 'sc-answer-list';
        
        const answerHeader = document.createElement('h4');
        answerHeader.textContent = 'Gewählte Antwort:';
        
        // Optionen anzeigen
        if (question.options && question.options.length > 0) {
            const userAnswer = question.userAnswer !== undefined ? 
                (typeof question.userAnswer === 'string' ? parseInt(question.userAnswer) : question.userAnswer) : null;
            const correctAnswer = question.correctAnswer !== undefined ? 
                (typeof question.correctAnswer === 'string' ? parseInt(question.correctAnswer) : question.correctAnswer) : null;
            
            const optionsList = document.createElement('ul');
            optionsList.className = 'options-list';
            
            question.options.forEach((option, index) => {
                const optionItem = document.createElement('li');
                optionItem.className = 'option-item';
                
                const isSelected = userAnswer === index;
                const isCorrect = correctAnswer === index;
                
                if (isSelected) {
                    optionItem.className += ' selected';
                    
                    if (isCorrect) {
                        optionItem.className += ' correct';
                    } else {
                        optionItem.className += ' incorrect';
                    }
                }
                
                // Option-Text mit Icon
                optionItem.innerHTML = `
                    <span class="option-indicator">
                        ${isSelected ? '<i class="fas fa-dot-circle"></i>' : '<i class="far fa-circle"></i>'}
                    </span>
                    <span class="option-text">${option}</span>
                    ${isSelected && isCorrect ? '<span class="correctness-icon correct"><i class="fas fa-check"></i></span>' : ''}
                    ${isSelected && !isCorrect ? '<span class="correctness-icon incorrect"><i class="fas fa-times"></i></span>' : ''}
                `;
                
                optionsList.appendChild(optionItem);
            });
            
            answerList.appendChild(answerHeader);
            answerList.appendChild(optionsList);
        } else {
            answerList.innerHTML = '<p>Keine Antwortoptionen verfügbar</p>';
        }
        
        container.appendChild(answerList);
    }
    
    /**
     * Rendert die Antwort für eine Wahr/Falsch-Frage
     * @param {HTMLElement} container - Container für die Antwort
     * @param {Object} question - Fragedaten
     */
    function _renderTrueFalseQuestionAnswer(container, question) {
        const answerBox = document.createElement('div');
        answerBox.className = 'tf-answer-box';
        
        const answerHeader = document.createElement('h4');
        answerHeader.textContent = 'Antwort des Teilnehmers:';
        
        const userAnswer = question.userAnswer;
        const correctAnswer = question.correctAnswer;
        
        let answerText = 'Keine Antwort';
        let answerClass = 'no-answer';
        
        if (userAnswer === true || userAnswer === 'true') {
            answerText = 'Wahr';
            answerClass = 'true-answer';
        } else if (userAnswer === false || userAnswer === 'false') {
            answerText = 'Falsch';
            answerClass = 'false-answer';
        }
        
        // Korrektheit prüfen
        let correctnessClass = '';
        if (userAnswer !== undefined && userAnswer !== null) {
            if ((userAnswer === true || userAnswer === 'true') === (correctAnswer === true || correctAnswer === 'true')) {
                correctnessClass = 'correct';
            } else {
                correctnessClass = 'incorrect';
            }
        }
        
        const answerDisplay = document.createElement('div');
        answerDisplay.className = `answer-display ${answerClass} ${correctnessClass}`;
        answerDisplay.innerHTML = `
            <span class="answer-text">${answerText}</span>
            ${correctnessClass ? `<span class="correctness-icon ${correctnessClass}">
                <i class="fas fa-${correctnessClass === 'correct' ? 'check' : 'times'}"></i>
            </span>` : ''}
        `;
        
        answerBox.appendChild(answerHeader);
        answerBox.appendChild(answerDisplay);
        
        container.appendChild(answerBox);
    }
    
    /**
     * Rendert die Musterlösung für eine Multiple-Choice-Frage
     * @param {HTMLElement} container - Container für die Lösung
     * @param {Object} question - Fragedaten
     */
    function _renderMultipleChoiceSolution(container, question) {
        if (!question.options || !question.correctAnswer) {
            container.textContent = 'Keine Musterlösung verfügbar';
            return;
        }
        
        const correctAnswers = Array.isArray(question.correctAnswer) ? 
            question.correctAnswer : [question.correctAnswer];
        
        const solutionList = document.createElement('ul');
        solutionList.className = 'solution-list';
        
        correctAnswers.forEach(answerIndex => {
            const index = typeof answerIndex === 'string' ? parseInt(answerIndex) : answerIndex;
            if (question.options[index]) {
                const listItem = document.createElement('li');
                listItem.textContent = question.options[index];
                solutionList.appendChild(listItem);
            }
        });
        
        container.appendChild(solutionList);
    }
	/**
     * Rendert die Musterlösung für eine Single-Choice-Frage
     * @param {HTMLElement} container - Container für die Lösung
     * @param {Object} question - Fragedaten
     */
    function _renderSingleChoiceSolution(container, question) {
        if (!question.options || question.correctAnswer === undefined) {
            container.textContent = 'Keine Musterlösung verfügbar';
            return;
        }
        
        const index = typeof question.correctAnswer === 'string' ? 
            parseInt(question.correctAnswer) : question.correctAnswer;
        
        if (question.options[index]) {
            container.textContent = question.options[index];
        } else {
            container.textContent = 'Ungültige Musterlösung';
        }
    }

    /**
     * Navigiert zur vorherigen Frage
     */
    function _navigateToPreviousQuestion() {
        if (_currentQuestionIndex > 0) {
            _currentQuestionIndex--;
            _showCurrentQuestion();
        }
    }
    
    /**
     * Navigiert zur nächsten Frage
     */
    function _navigateToNextQuestion() {
        if (_currentQuestionIndex < _assessmentData.questions.length - 1) {
            _currentQuestionIndex++;
            _showCurrentQuestion();
        }
    }
    
    /**
     * Aktualisiert den Zustand der Navigationsbuttons
     */
    function _updateNavigationState() {
        // Vorherige-Button deaktivieren, wenn erste Frage
        _assessmentDomRefs.prevButton.disabled = _currentQuestionIndex === 0;
        
        // Nächste-Button deaktivieren, wenn letzte Frage
        _assessmentDomRefs.nextButton.disabled = 
            _currentQuestionIndex === _assessmentData.questions.length - 1;
    }
    
    /**
     * Aktualisiert die Fortschrittsanzeige
     */
    function _updateProgressDisplay() {
        // Aktueller Fortschritt berechnen
        const totalQuestions = _assessmentData.questions.length;
        const currentPosition = _currentQuestionIndex + 1;
        const progressPercentage = Math.round((currentPosition / totalQuestions) * 100);
        
        // Fortschrittsleiste aktualisieren
        const progressBar = _assessmentDomRefs.progressBar;
        progressBar.style.width = `${progressPercentage}%`;
        progressBar.setAttribute('aria-valuenow', progressPercentage);
        progressBar.textContent = `${progressPercentage}%`;
        
        // Fragenzähler aktualisieren
        const progressStats = _assessmentDomRefs.progressStats;
        const questionsProgress = progressStats.querySelector('.questions-progress');
        if (questionsProgress) {
            questionsProgress.textContent = `Frage ${currentPosition} von ${totalQuestions}`;
        }
        
        // Bewerteter Status berechnen
        const assessedCount = _assessmentData.questions.filter(q => q.isAssessed).length;
        const totalScore = _assessmentData.questions.reduce((sum, q) => sum + (q.score || 0), 0);
        const maxPossibleScore = _assessmentData.questions.reduce((sum, q) => sum + (q.maxScore || 0), 0);
        
        // Punktestand aktualisieren
        const scoreProgress = progressStats.querySelector('.score-progress');
        if (scoreProgress) {
            scoreProgress.textContent = `Punkte: ${totalScore} / ${maxPossibleScore}`;
        }
        
        // Bewertungsfortschritt speichern
        _assessmentData.currentState = {
            assessedCount,
            totalScore,
            maxPossibleScore,
            feedbackGiven: _assessmentData.questions.filter(q => q.feedback).length
        };
    }
    
    /**
     * Aktualisiert die Punktzahl für eine Frage
     * @param {string} questionId - ID der Frage
     * @param {number} score - Neue Punktzahl
     */
    function _updateQuestionScore(questionId, score) {
        if (!_assessmentData || !_assessmentData.questions) return;
        
        // Frage finden und Punktzahl aktualisieren
        const question = _assessmentData.questions.find(q => q.questionId === questionId);
        if (question) {
            question.score = score;
            _dirtyState = true;
            _updateProgressDisplay();
        }
    }
    
    /**
     * Aktualisiert das Feedback für eine Frage
     * @param {string} questionId - ID der Frage
     * @param {string} feedback - Neues Feedback
     */
    function _updateQuestionFeedback(questionId, feedback) {
        if (!_assessmentData || !_assessmentData.questions) return;
        
        // Frage finden und Feedback aktualisieren
        const question = _assessmentData.questions.find(q => q.questionId === questionId);
        if (question) {
            question.feedback = feedback;
            _dirtyState = true;
        }
    }
    
    /**
     * Aktualisiert den Bewertungsstatus einer Frage
     * @param {string} questionId - ID der Frage
     * @param {boolean} isAssessed - Neuer Bewertungsstatus
     */
    function _updateQuestionAssessedStatus(questionId, isAssessed) {
        if (!_assessmentData || !_assessmentData.questions) return;
        
        // Frage finden und Status aktualisieren
        const question = _assessmentData.questions.find(q => q.questionId === questionId);
        if (question) {
            question.isAssessed = isAssessed;
            _dirtyState = true;
            _updateProgressDisplay();
        }
    }
    
    /**
     * Schaltet die Markierung einer Frage um
     * @param {string} questionId - ID der Frage
     */
    function _toggleQuestionFlag(questionId) {
        if (!_assessmentData || !_assessmentData.questions) return;
        
        // Frage finden und Markierung umschalten
        const question = _assessmentData.questions.find(q => q.questionId === questionId);
        if (question) {
            question.flagged = !question.flagged;
            _dirtyState = true;
            
            // UI aktualisieren
            const flagButton = document.querySelector('.btn-flag');
            if (flagButton) {
                flagButton.innerHTML = question.flagged ? 
                    '<i class="fas fa-flag"></i> Markiert' : 
                    '<i class="far fa-flag"></i> Markieren';
            }
        }
    }
    
    /**
     * Speichert den aktuellen Bewertungsstand
     */
    function _saveAssessment() {
        try {
            if (!_assessmentData || !_currentAssessmentId) {
                console.error('Keine Bewertungsdaten zum Speichern verfügbar');
                window.ImmoLMS.Notifications.showError('Keine Daten zum Speichern verfügbar');
                return false;
            }
            
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const resultIndex = testResults.findIndex(r => r.id === _currentAssessmentId);
            
            if (resultIndex === -1) {
                console.error('Testergebnis nicht gefunden:', _currentAssessmentId);
                window.ImmoLMS.Notifications.showError('Testergebnis nicht gefunden');
                return false;
            }
            
            // Fragen im Ergebnis aktualisieren
            const originalQuestionResults = testResults[resultIndex].questionResults || [];
            
            _assessmentData.questions.forEach(question => {
                const questionIndex = originalQuestionResults.findIndex(
                    q => q.questionId === question.questionId
                );
                
                if (questionIndex !== -1) {
                    // Bewertungsdaten aktualisieren
                    originalQuestionResults[questionIndex].isAssessed = question.isAssessed || false;
                    originalQuestionResults[questionIndex].score = question.score;
                    originalQuestionResults[questionIndex].feedback = question.feedback;
                    originalQuestionResults[questionIndex].flagged = question.flagged || false;
                }
            });
            
            // Status der Gesamtbewertung aktualisieren
            const allAssessed = originalQuestionResults.every(q => q.isAssessed);
            
            if (allAssessed) {
                testResults[resultIndex].assessmentStatus = 'completed';
            } else {
                testResults[resultIndex].assessmentStatus = 'in_progress';
            }
            
            // Aktualisierte Testergebnisse speichern
            window.ImmoLMS.DataStore.saveTestResults(testResults);
            
            // Zustand aktualisieren
            _dirtyState = false;
            _savedState = JSON.parse(JSON.stringify(_assessmentData));
            
            // Event auslösen
            const event = new CustomEvent('assessmentSaved', {
                detail: { assessmentId: _currentAssessmentId, success: true }
            });
            window.dispatchEvent(event);
            
            return true;
        } catch (error) {
            console.error('Fehler beim Speichern der Bewertung:', error);
            window.ImmoLMS.Notifications.showError('Bewertung konnte nicht gespeichert werden');
            
            // Event auslösen
            const event = new CustomEvent('assessmentSaved', {
                detail: { assessmentId: _currentAssessmentId, success: false, error: error.message }
            });
            window.dispatchEvent(event);
            
            return false;
        }
    }
    
    /**
     * Schließt die Bewertung ab
     */
    function _completeAssessment() {
        try {
            // Prüfen, ob alle Fragen bewertet wurden
            const allAssessed = _assessmentData.questions.every(q => q.isAssessed);
            
            if (!allAssessed) {
                // Bestätigung vom Benutzer einholen
                if (!confirm('Nicht alle Fragen wurden als bewertet markiert. Möchten Sie die Bewertung trotzdem abschließen?')) {
                    return false;
                }
            }
            
            // Bewertung speichern
            const saveResult = _saveAssessment();
            
            if (!saveResult) {
                console.error('Bewertung konnte nicht gespeichert werden');
                return false;
            }
            
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const resultIndex = testResults.findIndex(r => r.id === _currentAssessmentId);
            
            if (resultIndex === -1) {
                console.error('Testergebnis nicht gefunden:', _currentAssessmentId);
                return false;
            }
            
            // Status auf "abgeschlossen" setzen
            testResults[resultIndex].assessmentStatus = 'completed';
            
            // Abschlusszeitstempel hinzufügen
            if (!testResults[resultIndex].assessmentMeta) {
                testResults[resultIndex].assessmentMeta = {};
            }
            
            testResults[resultIndex].assessmentMeta.completedAt = new Date().toISOString();
            testResults[resultIndex].assessmentMeta.completedBy = window.ImmoLMS.Auth.getCurrentUser().id;
            
            // Aktualisierte Testergebnisse speichern
            window.ImmoLMS.DataStore.saveTestResults(testResults);
            
            // Event auslösen
            const event = new CustomEvent('assessmentCompleted', {
                detail: { assessmentId: _currentAssessmentId, success: true }
            });
            window.dispatchEvent(event);
            
            return true;
        } catch (error) {
            console.error('Fehler beim Abschließen der Bewertung:', error);
            window.ImmoLMS.Notifications.showError('Bewertung konnte nicht abgeschlossen werden');
            
            // Event auslösen
            const event = new CustomEvent('assessmentCompleted', {
                detail: { assessmentId: _currentAssessmentId, success: false, error: error.message }
            });
            window.dispatchEvent(event);
            
            return false;
        }
    }
    
    /**
     * Startet den Auto-Save-Timer
     */
    function _startAutoSaveTimer() {
        // Bestehenden Timer löschen, falls vorhanden
        if (_autoSaveTimer) {
            clearInterval(_autoSaveTimer);
        }
        
        // Neuen Timer starten
        _autoSaveTimer = setInterval(() => {
            if (_dirtyState) {
                console.log('Auto-Save ausgelöst');
                _saveAssessment();
            }
        }, AUTO_SAVE_INTERVAL);
    }
    
    /**
     * Stoppt den Auto-Save-Timer
     */
    function _stopAutoSaveTimer() {
        if (_autoSaveTimer) {
            clearInterval(_autoSaveTimer);
            _autoSaveTimer = null;
        }
    }
    
    /**
     * Behandelt den Klick auf den Schließen-Button
     */
    function _handleCloseButtonClick() {
        if (_dirtyState) {
            // Bestätigung vom Benutzer einholen
            if (confirm('Sie haben ungespeicherte Änderungen. Möchten Sie speichern, bevor Sie schließen?')) {
                _saveAssessment();
            }
        }
        
        _closeAssessmentProcess();
    }
    
    /**
     * Schließt den Bewertungsprozess
     */
    function _closeAssessmentProcess() {
        try {
            // Auto-Save-Timer stoppen
            _stopAutoSaveTimer();
            
            // Container abrufen
            const container = document.getElementById('assessment-process-container');
            if (!container) return;
            
            // Animation zum Ausblenden
            container.classList.remove('active');
            
            // Nach der Animation entfernen
            setTimeout(() => {
                container.remove();
                
                // Zustand zurücksetzen
                _currentAssessmentId = null;
                _assessmentData = null;
                _currentQuestionIndex = 0;
                _assessmentDomRefs = {};
                _dirtyState = false;
                _savedState = {};
                
                // Event auslösen
                const event = new CustomEvent('assessmentClosed');
                window.dispatchEvent(event);
            }, 300);
        } catch (error) {
            console.error('Fehler beim Schließen des Bewertungsprozesses:', error);
        }
    }
    
    /**
     * Gibt eine lesbare Bezeichnung für einen Fragentyp zurück
     * @param {string} questionType - Fragentyp-Code
     * @returns {string} - Lesbare Bezeichnung
     */
    function _getQuestionTypeLabel(questionType) {
        switch (questionType) {
            case 'multipleChoice':
                return 'Multiple Choice';
            case 'singleChoice':
                return 'Single Choice';
            case 'trueFalse':
                return 'Wahr/Falsch';
            case 'text':
                return 'Freitext';
            default:
                return 'Unbekannter Typ';
        }
    }
    
    /**
     * Aktualisiert den Status einer Bewertung
     * @param {string} status - Neuer Status
     */
    function _updateAssessmentStatus(status) {
        try {
            if (!_currentAssessmentId) return;
            
            // Testergebnisse abrufen
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const resultIndex = testResults.findIndex(r => r.id === _currentAssessmentId);
            
            if (resultIndex === -1) return;
            
            // Status aktualisieren
            testResults[resultIndex].assessmentStatus = status;
            
            // Aktualisierte Testergebnisse speichern
            window.ImmoLMS.DataStore.saveTestResults(testResults);
        } catch (error) {
            console.error('Fehler beim Aktualisieren des Bewertungsstatus:', error);
        }
    }
    
    // Öffentliche API
    AssessmentProcess.initialize = initialize;
    AssessmentProcess.startAssessment = startAssessment;
    
    return AssessmentProcess;
})();

// Automatische Initialisierung
document.addEventListener('DOMContentLoaded', function() {
    window.ImmoLMS.TrainerDashboard.AssessmentProcess.initialize();
});
/**
 * JS-Block 7.2.2-part2: Bewertungsprozess (Teil 2)
 * 
 * Erweitert den Bewertungsprozess um fortgeschrittene Funktionen
 * wie Vorlagen, Analysetools und Standardisierungsmechanismen.
 * 
 * Funktionen:
 * - Vorlagen für Feedback und Bewertungen
 * - Automatisierte Bewertungsvorschläge
 * - Teamübergreifende Bewertungskonsistenz
 * - Erweiterte Analysewerkzeuge
 * - Integration mit Teststatistiken
 */
window.ImmoLMS.TrainerDashboard.AssessmentEnhancements = (function() {
    // Private Variablen
    let _feedbackTemplates = [];
    let _assessmentAnalytics = {};
    let _currentAssessmentId = null;
    let _statisticsCache = {};
    let _enhancementDomRefs = {};
    let _currentView = 'scoring'; // 'scoring', 'analytics', 'guidelines'
    
    // Konstanten
    const DEFAULT_FEEDBACK_TEMPLATES = [
        {
            id: 'template-excellent',
            title: 'Hervorragend',
            text: 'Ausgezeichnete Antwort! Sie haben alle wichtigen Punkte erfasst und Ihr Verständnis des Themas klar demonstriert.',
            scoreRange: { min: 90, max: 100 }
        },
        {
            id: 'template-good',
            title: 'Gut',
            text: 'Gute Antwort! Sie haben die meisten wichtigen Punkte behandelt. Für eine noch bessere Bewertung könnten Sie auf weitere Details eingehen.',
            scoreRange: { min: 75, max: 89 }
        },
        {
            id: 'template-satisfactory',
            title: 'Befriedigend',
            text: 'Sie haben die Grundlagen erfasst, aber Ihre Antwort könnte detaillierter und präziser sein. Bitte achten Sie auf folgende Aspekte: [Details einfügen].',
            scoreRange: { min: 60, max: 74 }
        },
        {
            id: 'template-needs-improvement',
            title: 'Verbesserungsbedürftig',
            text: 'Ihre Antwort benötigt Verbesserung. Wichtige Aspekte fehlen oder wurden nicht ausreichend behandelt. Bitte wiederholen Sie: [Details einfügen].',
            scoreRange: { min: 0, max: 59 }
        }
    ];
    
    // Öffentliches Objekt
    const AssessmentEnhancements = {};
    
    /**
     * Initialisiert die erweiterten Bewertungsfunktionen
     */
    function initialize() {
        _loadSavedTemplates();
        _setupEventListeners();
        return AssessmentEnhancements;
    }
    
    /**
     * Richtet Event-Listener ein
     */
    function _setupEventListeners() {
        window.addEventListener('assessmentStarted', _handleAssessmentStarted);
        window.addEventListener('assessmentSaved', _handleAssessmentSaved);
        window.addEventListener('assessmentClosed', _handleAssessmentClosed);
        window.addEventListener('assessmentTemplateCreated', _handleTemplateCreated);
        window.addEventListener('assessmentTemplateDeleted', _handleTemplateDeleted);
    }
    
    /**
     * Behandelt das Event für den Start einer Bewertung
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleAssessmentStarted(event) {
        const { assessmentId } = event.detail;
        _currentAssessmentId = assessmentId;
        
        // Warte kurz, bis die UI vollständig geladen ist
        setTimeout(() => {
            _enhanceAssessmentUI();
            _loadAssessmentStatistics(assessmentId);
        }, 500);
    }
    
    /**
     * Behandelt das Event für das Speichern einer Bewertung
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleAssessmentSaved(event) {
        const { assessmentId, success } = event.detail;
        
        if (success && assessmentId === _currentAssessmentId) {
            // Statistiken aktualisieren
            _updateAssessmentStatistics(assessmentId);
        }
    }
    
    /**
     * Behandelt das Event für das Schließen einer Bewertung
     */
    function _handleAssessmentClosed() {
        _currentAssessmentId = null;
    }
    
    /**
     * Behandelt das Event für das Erstellen einer Vorlage
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleTemplateCreated(event) {
        const { template } = event.detail;
        _feedbackTemplates.push(template);
        _saveFeedbackTemplates();
        _updateTemplatePanel();
    }
    
    /**
     * Behandelt das Event für das Löschen einer Vorlage
     * @param {CustomEvent} event - Das Event-Objekt
     */
    function _handleTemplateDeleted(event) {
        const { templateId } = event.detail;
        _feedbackTemplates = _feedbackTemplates.filter(t => t.id !== templateId);
        _saveFeedbackTemplates();
        _updateTemplatePanel();
    }
    
    /**
     * Lädt gespeicherte Feedback-Vorlagen
     */
    function _loadSavedTemplates() {
        try {
            // Aus LocalStorage laden
            const savedTemplates = localStorage.getItem('immoLMS_feedbackTemplates');
            
            if (savedTemplates) {
                _feedbackTemplates = JSON.parse(savedTemplates);
            } else {
                // Standard-Vorlagen verwenden
                _feedbackTemplates = DEFAULT_FEEDBACK_TEMPLATES;
                _saveFeedbackTemplates();
            }
        } catch (error) {
            console.error('Fehler beim Laden der Feedback-Vorlagen:', error);
            _feedbackTemplates = DEFAULT_FEEDBACK_TEMPLATES;
        }
    }
    
    /**
     * Speichert Feedback-Vorlagen im LocalStorage
     */
    function _saveFeedbackTemplates() {
        try {
            localStorage.setItem('immoLMS_feedbackTemplates', JSON.stringify(_feedbackTemplates));
        } catch (error) {
            console.error('Fehler beim Speichern der Feedback-Vorlagen:', error);
        }
    }
    
    /**
     * Erweitert die Bewertungs-UI um zusätzliche Funktionen
     */
    function _enhanceAssessmentUI() {
        try {
            // Container für den Bewertungsprozess finden
            const assessmentContainer = document.getElementById('assessment-process-container');
            if (!assessmentContainer) {
                console.error('Bewertungs-Container nicht gefunden');
                return;
            }
            
            // Haupt-UI-Elemente finden
            const mainSection = assessmentContainer.querySelector('.assessment-main-section');
            if (!mainSection) return;
            
            // Prüfen, ob die Erweiterungen bereits hinzugefügt wurden
            if (document.getElementById('assessment-enhancements-panel')) return;
            
            // Container für die Erweiterungen erstellen
            const enhancementsPanel = document.createElement('div');
            enhancementsPanel.id = 'assessment-enhancements-panel';
            enhancementsPanel.className = 'assessment-enhancements-panel';
            
            // Tabs für verschiedene Funktionen
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'enhancements-tabs';
            
            const tabs = [
                { id: 'scoring', label: 'Bewertungshilfen', icon: 'fas fa-star' },
                { id: 'analytics', label: 'Analyse', icon: 'fas fa-chart-bar' },
                { id: 'guidelines', label: 'Richtlinien', icon: 'fas fa-book' }
            ];
            
            // Tabs erstellen
            tabs.forEach(tab => {
                const tabButton = document.createElement('button');
                tabButton.className = `tab-button ${tab.id === _currentView ? 'active' : ''}`;
                tabButton.setAttribute('data-tab', tab.id);
                tabButton.innerHTML = `<i class="${tab.icon}"></i> ${tab.label}`;
                tabButton.addEventListener('click', () => _switchTab(tab.id));
                
                tabsContainer.appendChild(tabButton);
            });
            
            // Container für den Tab-Inhalt
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-content';
            
            // Inhalte für verschiedene Tabs erstellen
            const scoringContent = _createScoringTabContent();
            const analyticsContent = _createAnalyticsTabContent();
            const guidelinesContent = _createGuidelinesTabContent();
            
            // Inhalte zum Tab-Container hinzufügen
            tabContent.appendChild(scoringContent);
            tabContent.appendChild(analyticsContent);
            tabContent.appendChild(guidelinesContent);
            
            // Nur den aktuellen Tab anzeigen
            scoringContent.style.display = _currentView === 'scoring' ? 'block' : 'none';
            analyticsContent.style.display = _currentView === 'analytics' ? 'block' : 'none';
            guidelinesContent.style.display = _currentView === 'guidelines' ? 'block' : 'none';
            
            // Alles zusammenfügen
            enhancementsPanel.appendChild(tabsContainer);
            enhancementsPanel.appendChild(tabContent);
            
            // DOM-Referenzen speichern
            _enhancementDomRefs.panel = enhancementsPanel;
            _enhancementDomRefs.tabContent = tabContent;
            _enhancementDomRefs.tabs = {};
            _enhancementDomRefs.tabs.scoring = scoringContent;
            _enhancementDomRefs.tabs.analytics = analyticsContent;
            _enhancementDomRefs.tabs.guidelines = guidelinesContent;
            
            // Zur Seite hinzufügen
            mainSection.appendChild(enhancementsPanel);
            
            // Layout-Anpassungen vornehmen
            mainSection.classList.add('with-enhancements');
            
            // Initial anzeigen
            setTimeout(() => {
                enhancementsPanel.classList.add('active');
            }, 100);
            
        } catch (error) {
            console.error('Fehler beim Erweitern der Bewertungs-UI:', error);
        }
    }
    
    /**
     * Erstellt den Inhalt für den Bewertungshilfen-Tab
     * @returns {HTMLElement} - Tab-Inhalt
     */
    function _createScoringTabContent() {
        const container = document.createElement('div');
        container.className = 'scoring-tab-content tab-pane';
        container.id = 'scoring-tab';
        
        // Feedback-Vorlagen
        const templatesSection = document.createElement('div');
        templatesSection.className = 'templates-section';
        
        const templatesHeader = document.createElement('h3');
        templatesHeader.textContent = 'Feedback-Vorlagen';
        
        const templatesDescription = document.createElement('p');
        templatesDescription.className = 'section-description';
        templatesDescription.textContent = 'Klicken Sie auf eine Vorlage, um sie zu verwenden. Der Text wird in das Feedback-Feld eingefügt.';
        
        const templatesList = document.createElement('div');
        templatesList.className = 'templates-list';
        templatesList.id = 'feedback-templates-list';
        
        // Vorlagen hinzufügen
        _feedbackTemplates.forEach(template => {
            const templateItem = document.createElement('div');
            templateItem.className = 'template-item';
            templateItem.setAttribute('data-id', template.id);
            
            const templateHeader = document.createElement('div');
            templateHeader.className = 'template-header';
            
            const templateTitle = document.createElement('span');
            templateTitle.className = 'template-title';
            templateTitle.textContent = template.title;
            
            const scoreRange = document.createElement('span');
            scoreRange.className = 'score-range';
            scoreRange.textContent = `${template.scoreRange.min}-${template.scoreRange.max}%`;
            
            templateHeader.appendChild(templateTitle);
            templateHeader.appendChild(scoreRange);
            
            const templateText = document.createElement('div');
            templateText.className = 'template-text';
            templateText.textContent = template.text.length > 100 ? 
                template.text.substring(0, 100) + '...' : template.text;
            
            const useButton = document.createElement('button');
            useButton.className = 'btn btn-sm btn-outline-primary use-template';
            useButton.textContent = 'Verwenden';
            useButton.addEventListener('click', () => _applyTemplate(template.id));
            
            templateItem.appendChild(templateHeader);
            templateItem.appendChild(templateText);
            templateItem.appendChild(useButton);
            
            templatesList.appendChild(templateItem);
        });
        
        // Neue Vorlage hinzufügen
        const addTemplateButton = document.createElement('button');
        addTemplateButton.className = 'btn btn-sm btn-outline-secondary add-template';
        addTemplateButton.innerHTML = '<i class="fas fa-plus"></i> Neue Vorlage';
        addTemplateButton.addEventListener('click', _showAddTemplateDialog);
        
        templatesSection.appendChild(templatesHeader);
        templatesSection.appendChild(templatesDescription);
        templatesSection.appendChild(templatesList);
        templatesSection.appendChild(addTemplateButton);
        
        // Automatische Bewertungsvorschläge
        const suggestionsSection = document.createElement('div');
        suggestionsSection.className = 'suggestions-section';
        
        const suggestionsHeader = document.createElement('h3');
        suggestionsHeader.textContent = 'Bewertungsvorschläge';
        
        const suggestionsDescription = document.createElement('p');
        suggestionsDescription.className = 'section-description';
        suggestionsDescription.textContent = 'Basierend auf ähnlichen Antworten und Bewertungsmustern.';
        
        const suggestionsContent = document.createElement('div');
        suggestionsContent.className = 'suggestions-content';
        suggestionsContent.innerHTML = `
            <div class="no-suggestions">
                <i class="fas fa-robot"></i>
                <p>Bewertungsvorschläge werden geladen, sobald genügend Daten vorliegen.</p>
            </div>
        `;
        
        // Trigger für Bewertungsvorschläge
        const suggestButton = document.createElement('button');
        suggestButton.className = 'btn btn-sm btn-outline-primary suggest-score';
        suggestButton.innerHTML = '<i class="fas fa-magic"></i> Vorschlag generieren';
        suggestButton.addEventListener('click', _generateScoringProposal);
        
        suggestionsSection.appendChild(suggestionsHeader);
        suggestionsSection.appendChild(suggestionsDescription);
        suggestionsSection.appendChild(suggestionsContent);
        suggestionsSection.appendChild(suggestButton);
        
        // Komponenten zusammenfügen
        container.appendChild(templatesSection);
        container.appendChild(suggestionsSection);
        
        return container;
    }
    
    /**
     * Erstellt den Inhalt für den Analyse-Tab
     * @returns {HTMLElement} - Tab-Inhalt
     */
    function _createAnalyticsTabContent() {
        const container = document.createElement('div');
        container.className = 'analytics-tab-content tab-pane';
        container.id = 'analytics-tab';
        
        // Antwortstatistiken
        const statsSection = document.createElement('div');
        statsSection.className = 'stats-section';
        
        const statsHeader = document.createElement('h3');
        statsHeader.textContent = 'Antwortstatistik';
        
        const statsContent = document.createElement('div');
        statsContent.className = 'stats-content';
        statsContent.id = 'answer-statistics';
        statsContent.innerHTML = `
            <div class="loading-stats">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Statistiken werden geladen...</p>
            </div>
        `;
        
        statsSection.appendChild(statsHeader);
        statsSection.appendChild(statsContent);
        
        // Vergleichende Analyse
        const comparisonSection = document.createElement('div');
        comparisonSection.className = 'comparison-section';
        
        const comparisonHeader = document.createElement('h3');
        comparisonHeader.textContent = 'Vergleichende Analyse';
        
        const comparisonDescription = document.createElement('p');
        comparisonDescription.className = 'section-description';
        comparisonDescription.textContent = 'Vergleich dieser Antwort mit anderen Teilnehmern.';
        
        const comparisonContent = document.createElement('div');
        comparisonContent.className = 'comparison-content';
        comparisonContent.id = 'comparison-analysis';
        comparisonContent.innerHTML = `
            <div class="no-comparison">
                <i class="fas fa-chart-line"></i>
                <p>Vergleichsdaten werden geladen...</p>
            </div>
        `;
        
        comparisonSection.appendChild(comparisonHeader);
        comparisonSection.appendChild(comparisonDescription);
        comparisonSection.appendChild(comparisonContent);
        
        // Schwierigkeitsgrad und Performance
        const difficultySection = document.createElement('div');
        difficultySection.className = 'difficulty-section';
        
        const difficultyHeader = document.createElement('h3');
        difficultyHeader.textContent = 'Fragenanalyse';
        
        const difficultyContent = document.createElement('div');
        difficultyContent.className = 'difficulty-content';
        difficultyContent.id = 'question-analysis';
        difficultyContent.innerHTML = `
            <div class="difficulty-stats">
                <div class="difficulty-indicator">
                    <span class="label">Schwierigkeitsgrad:</span>
                    <div class="indicator-bar">
                        <div class="indicator-value" style="width: 0%"></div>
                    </div>
                    <span class="value">-</span>
                </div>
                <div class="discrimination-indicator">
                    <span class="label">Trennschärfe:</span>
                    <div class="indicator-bar">
                        <div class="indicator-value" style="width: 0%"></div>
                    </div>
                    <span class="value">-</span>
                </div>
            </div>
        `;
        
        difficultySection.appendChild(difficultyHeader);
        difficultySection.appendChild(difficultyContent);
        
        // Komponenten zusammenfügen
        container.appendChild(statsSection);
        container.appendChild(comparisonSection);
        container.appendChild(difficultySection);
        
        return container;
    }
    
    /**
     * Erstellt den Inhalt für den Richtlinien-Tab
     * @returns {HTMLElement} - Tab-Inhalt
     */
    function _createGuidelinesTabContent() {
        const container = document.createElement('div');
        container.className = 'guidelines-tab-content tab-pane';
        container.id = 'guidelines-tab';
        
        // Bewertungsrichtlinien
        const guidelinesSection = document.createElement('div');
        guidelinesSection.className = 'guidelines-section';
        
        const guidelinesHeader = document.createElement('h3');
        guidelinesHeader.textContent = 'Bewertungsrichtlinien';
        
        const guidelinesContent = document.createElement('div');
        guidelinesContent.className = 'guidelines-content';
        guidelinesContent.innerHTML = `
            <div class="guideline-item">
                <h4>Allgemeine Grundsätze</h4>
                <ul>
                    <li>Bewerten Sie objektiv, basierend auf den definierten Kriterien.</li>
                    <li>Bei Freitextantworten geben Sie immer konstruktives Feedback.</li>
                    <li>Achten Sie auf Konsistenz zwischen verschiedenen Bewertungen.</li>
                </ul>
            </div>
            
            <div class="guideline-item">
                <h4>Punktevergabe</h4>
                <ul>
                    <li><strong>90-100%:</strong> Hervorragende Antwort, die über die Erwartungen hinausgeht.</li>
                    <li><strong>75-89%:</strong> Gute Antwort, die alle wichtigen Punkte abdeckt.</li>
                    <li><strong>60-74%:</strong> Befriedigende Antwort mit den wichtigsten Aspekten.</li>
                    <li><strong>0-59%:</strong> Unzureichende Antwort, wesentliche Aspekte fehlen.</li>
                </ul>
            </div>
            
            <div class="guideline-item">
                <h4>Feedback-Richtlinien</h4>
                <ul>
                    <li>Beginnen Sie mit positiven Aspekten der Antwort.</li>
                    <li>Geben Sie konkrete Verbesserungsvorschläge.</li>
                    <li>Beziehen Sie sich auf spezifische Inhalte der Antwort.</li>
                    <li>Ermutigen Sie zur Weiterentwicklung.</li>
                </ul>
            </div>
        `;
        
        guidelinesSection.appendChild(guidelinesHeader);
        guidelinesSection.appendChild(guidelinesContent);
        
        // Häufig gestellte Fragen
        const faqSection = document.createElement('div');
        faqSection.className = 'faq-section';
        
        const faqHeader = document.createElement('h3');
        faqHeader.textContent = 'Häufig gestellte Fragen';
        
        const faqContent = document.createElement('div');
        faqContent.className = 'faq-content';
        
        // FAQ-Einträge mit Collapse-Funktion
        const faqs = [
            {
                question: 'Wie bewerte ich teilweise korrekte Antworten?',
                answer: 'Vergeben Sie Teilpunkte entsprechend der Korrektheit. Berücksichtigen Sie dabei, welche Schlüsselaspekte genannt wurden und wie präzise die Antwort ist. Für wesentliche Elemente sollten mehr Punkte vergeben werden als für nebensächliche Details.'
            },
            {
                question: 'Was tun, wenn eine Antwort über die Musterlösung hinausgeht?',
                answer: 'Zusätzliche relevante Informationen können positiv bewertet werden, solange sie korrekt sind und zum Thema gehören. Bei besonders umfassenden oder tiefgehenden Antworten können Sie auch Bonuspunkte vergeben, sofern die Grundanforderungen erfüllt sind.'
            },
            {
                question: 'Wie gehe ich mit unklaren oder mehrdeutigen Antworten um?',
                answer: 'Bewerten Sie nach dem "Benefit of the Doubt"-Prinzip. Falls die Antwort verschiedene Interpretationen zulässt, wählen Sie die für den Teilnehmer günstigste Auslegung. Bei erheblicher Unklarheit markieren Sie die Bewertung und besprechen Sie den Fall mit Kollegen.'
            }
        ];
        
        faqs.forEach((faq, index) => {
            const faqItem = document.createElement('div');
            faqItem.className = 'faq-item';
            
            const questionButton = document.createElement('button');
            questionButton.className = 'faq-question';
            questionButton.innerHTML = `<i class="fas fa-caret-right"></i> ${faq.question}`;
            questionButton.addEventListener('click', function() {
                this.classList.toggle('active');
                const answerElement = this.nextElementSibling;
                if (answerElement.style.maxHeight) {
                    answerElement.style.maxHeight = null;
                    this.querySelector('i').className = 'fas fa-caret-right';
                } else {
                    answerElement.style.maxHeight = answerElement.scrollHeight + "px";
                    this.querySelector('i').className = 'fas fa-caret-down';
                }
            });
            
            const answerElement = document.createElement('div');
            answerElement.className = 'faq-answer';
            answerElement.textContent = faq.answer;
            
            faqItem.appendChild(questionButton);
            faqItem.appendChild(answerElement);
            
            faqContent.appendChild(faqItem);
        });
        
        faqSection.appendChild(faqHeader);
        faqSection.appendChild(faqContent);
        
        // Teamspezifische Richtlinien
        const teamSection = document.createElement('div');
        teamSection.className = 'team-guidelines-section';
        
        const teamHeader = document.createElement('h3');
        teamHeader.textContent = 'Teamspezifische Bewertungshinweise';
        
        const teamContent = document.createElement('div');
        teamContent.className = 'team-guidelines-content';
        teamContent.id = 'team-specific-guidelines';
        teamContent.innerHTML = `
            <p>Laden von teamspezifischen Richtlinien...</p>
        `;
        
        const refreshButton = document.createElement('button');
        refreshButton.className = 'btn btn-sm btn-outline-secondary refresh-guidelines';
        refreshButton.innerHTML = '<i class="fas fa-sync"></i> Aktualisieren';
        refreshButton.addEventListener('click', _loadTeamGuidelines);
        
        teamSection.appendChild(teamHeader);
        teamSection.appendChild(teamContent);
        teamSection.appendChild(refreshButton);
        
        // Komponenten zusammenfügen
        container.appendChild(guidelinesSection);
        container.appendChild(faqSection);
        container.appendChild(teamSection);
        
        return container;
    }
	/**
     * Wechselt zwischen den Tabs
     * @param {string} tabId - ID des anzuzeigenden Tabs
     */
    function _switchTab(tabId) {
        // Aktiven Tab aktualisieren
        _currentView = tabId;
        
        // Tab-Buttons aktualisieren
        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(button => {
            if (button.getAttribute('data-tab') === tabId) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
        
        // Tab-Inhalte aktualisieren
        if (_enhancementDomRefs.tabs) {
            Object.keys(_enhancementDomRefs.tabs).forEach(key => {
                if (_enhancementDomRefs.tabs[key]) {
                    _enhancementDomRefs.tabs[key].style.display = key === tabId ? 'block' : 'none';
                }
            });
        }
        
        // Bei Wechsel zum Analyse-Tab: Statistiken aktualisieren
        if (tabId === 'analytics' && _currentAssessmentId) {
            _updateAnalyticsDisplay(_currentAssessmentId);
        }
        
        // Bei Wechsel zum Richtlinien-Tab: Team-Richtlinien laden
        if (tabId === 'guidelines') {
            _loadTeamGuidelines();
        }
    }
    
    /**
     * Aktualisiert das Vorlagen-Panel
     */
    function _updateTemplatePanel() {
        const templatesList = document.getElementById('feedback-templates-list');
        if (!templatesList) return;
        
        // Liste leeren
        templatesList.innerHTML = '';
        
        // Vorlagen hinzufügen
        _feedbackTemplates.forEach(template => {
            const templateItem = document.createElement('div');
            templateItem.className = 'template-item';
            templateItem.setAttribute('data-id', template.id);
            
            const templateHeader = document.createElement('div');
            templateHeader.className = 'template-header';
            
            const templateTitle = document.createElement('span');
            templateTitle.className = 'template-title';
            templateTitle.textContent = template.title;
            
            const scoreRange = document.createElement('span');
            scoreRange.className = 'score-range';
            scoreRange.textContent = `${template.scoreRange.min}-${template.scoreRange.max}%`;
            
            templateHeader.appendChild(templateTitle);
            templateHeader.appendChild(scoreRange);
            
            const templateText = document.createElement('div');
            templateText.className = 'template-text';
            templateText.textContent = template.text.length > 100 ? 
                template.text.substring(0, 100) + '...' : template.text;
            
            const useButton = document.createElement('button');
            useButton.className = 'btn btn-sm btn-outline-primary use-template';
            useButton.textContent = 'Verwenden';
            useButton.addEventListener('click', () => _applyTemplate(template.id));
            
            templateItem.appendChild(templateHeader);
            templateItem.appendChild(templateText);
            templateItem.appendChild(useButton);
            
            templatesList.appendChild(templateItem);
        });
    }
    
    /**
     * Wendet eine Feedback-Vorlage auf das aktuelle Feedback-Feld an
     * @param {string} templateId - ID der anzuwendenden Vorlage
     */
    function _applyTemplate(templateId) {
        try {
            // Vorlage finden
            const template = _feedbackTemplates.find(t => t.id === templateId);
            if (!template) return;
            
            // Feedback-Feld finden
            const feedbackInput = document.getElementById('question-feedback');
            if (!feedbackInput) return;
            
            // Feedback-Text einfügen oder anhängen
            if (!feedbackInput.value.trim()) {
                // Wenn das Feld leer ist, Text direkt einfügen
                feedbackInput.value = template.text;
            } else {
                // Sonst fragen, ob ersetzen oder anhängen
                const options = ['Ersetzen', 'Anhängen', 'Abbrechen'];
                const message = 'Das Feedback-Feld enthält bereits Text. Wie möchten Sie fortfahren?';
                
                // In einer echten Implementierung würde hier ein Auswahldialog angezeigt
                // In diesem Beispiel vereinfacht mit confirm/prompt
                const choice = prompt(`${message}\n1: ${options[0]}\n2: ${options[1]}\n3: ${options[2]}`);
                
                if (choice === '1') {
                    // Ersetzen
                    feedbackInput.value = template.text;
                } else if (choice === '2') {
                    // Anhängen
                    feedbackInput.value += '\n\n' + template.text;
                }
                // Bei Abbrechen nichts tun
            }
            
            // Event auslösen, um Änderungen zu registrieren
            const event = new Event('change');
            feedbackInput.dispatchEvent(event);
            
            // Feedback-Eingabefeld fokussieren
            feedbackInput.focus();
            
        } catch (error) {
            console.error('Fehler beim Anwenden der Vorlage:', error);
        }
    }
    
    /**
     * Zeigt den Dialog zum Hinzufügen einer neuen Vorlage
     */
    function _showAddTemplateDialog() {
        try {
            // In einer echten Implementierung würde hier ein modaler Dialog angezeigt
            // In diesem Beispiel vereinfacht mit prompt
            
            const title = prompt('Titel der Vorlage:');
            if (!title) return;
            
            const scoreMin = prompt('Minimale Punktzahl (in Prozent):', '0');
            if (scoreMin === null) return;
            
            const scoreMax = prompt('Maximale Punktzahl (in Prozent):', '100');
            if (scoreMax === null) return;
            
            const text = prompt('Vorlage-Text:');
            if (!text) return;
            
            // Neue Vorlage erstellen
            const newTemplate = {
                id: 'template-' + Date.now(),
                title: title,
                text: text,
                scoreRange: {
                    min: parseInt(scoreMin) || 0,
                    max: parseInt(scoreMax) || 100
                }
            };
            
            // Event auslösen
            const event = new CustomEvent('assessmentTemplateCreated', {
                detail: { template: newTemplate }
            });
            window.dispatchEvent(event);
            
        } catch (error) {
            console.error('Fehler beim Hinzufügen der Vorlage:', error);
        }
    }
    
    /**
     * Lädt Statistiken für eine Bewertung
     * @param {string} assessmentId - ID der Bewertung
     */
    function _loadAssessmentStatistics(assessmentId) {
        try {
            if (!assessmentId) return;
            
            // Falls Statistiken bereits geladen wurden, aus Cache verwenden
            if (_statisticsCache[assessmentId]) {
                _updateAnalyticsDisplay(assessmentId);
                return;
            }
            
            // Testdaten laden
            const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
            const currentResult = testResults.find(r => r.id === assessmentId);
            
            if (!currentResult) return;
            
            // Alle Ergebnisse für denselben Test finden
            const testId = currentResult.testId;
            const allResultsForTest = testResults.filter(r => r.testId === testId);
            
            // Statistiken berechnen
            const statistics = {
                totalSubmissions: allResultsForTest.length,
                averageScore: 0,
                questionDifficulty: {},
                questionDiscrimination: {},
                answerDistribution: {}
            };
            
            // Durchschnittswerte berechnen
            let totalScore = 0;
            let totalMaxScore = 0;
            
            allResultsForTest.forEach(result => {
                if (!result.questionResults) return;
                
                let resultScore = 0;
                let resultMaxScore = 0;
                
                result.questionResults.forEach(question => {
                    const qId = question.questionId;
                    
                    // Schwierigkeitsgrad (Durchschnittliche Punktzahl)
                    if (!statistics.questionDifficulty[qId]) {
                        statistics.questionDifficulty[qId] = {
                            totalScore: 0,
                            totalMaxScore: 0,
                            attempts: 0,
                            correctAnswers: 0
                        };
                    }
                    
                    if (question.score !== undefined && question.maxScore) {
                        statistics.questionDifficulty[qId].totalScore += question.score;
                        statistics.questionDifficulty[qId].totalMaxScore += question.maxScore;
                        statistics.questionDifficulty[qId].attempts++;
                        
                        if (question.isCorrect) {
                            statistics.questionDifficulty[qId].correctAnswers++;
                        }
                        
                        resultScore += question.score;
                        resultMaxScore += question.maxScore;
                    }
                    
                    // Antwortverteilung
                    if (!statistics.answerDistribution[qId]) {
                        statistics.answerDistribution[qId] = {};
                    }
                    
                    const answer = JSON.stringify(question.userAnswer);
                    if (!statistics.answerDistribution[qId][answer]) {
                        statistics.answerDistribution[qId][answer] = 0;
                    }
                    statistics.answerDistribution[qId][answer]++;
                });
                
                totalScore += resultScore;
                totalMaxScore += resultMaxScore;
            });
            
            // Durchschnittliche Punktzahl
            statistics.averageScore = totalMaxScore > 0 ? 
                (totalScore / totalMaxScore) * 100 : 0;
            
            // Schwierigkeitsgrad berechnen
            Object.keys(statistics.questionDifficulty).forEach(qId => {
                const diff = statistics.questionDifficulty[qId];
                if (diff.totalMaxScore > 0) {
                    diff.difficulty = (diff.totalScore / diff.totalMaxScore) * 100;
                    diff.percentCorrect = diff.attempts > 0 ? 
                        (diff.correctAnswers / diff.attempts) * 100 : 0;
                }
            });
            
            // Trennschärfe berechnen (vereinfacht)
            // In einer vollständigen Implementierung würde hier eine komplexere Berechnung erfolgen
            Object.keys(statistics.questionDifficulty).forEach(qId => {
                statistics.questionDiscrimination[qId] = Math.random(); // Dummy-Wert für dieses Beispiel
            });
            
            // Statistiken im Cache speichern
            _statisticsCache[assessmentId] = statistics;
            
            // Anzeige aktualisieren
            _updateAnalyticsDisplay(assessmentId);
            
        } catch (error) {
            console.error('Fehler beim Laden der Bewertungsstatistiken:', error);
        }
    }
    
    /**
     * Aktualisiert die Anzeige der Analyse-Daten
     * @param {string} assessmentId - ID der Bewertung
     */
    function _updateAnalyticsDisplay(assessmentId) {
        try {
            if (!assessmentId || !_statisticsCache[assessmentId]) return;
            
            const stats = _statisticsCache[assessmentId];
            
            // Aktuelle Frage identifizieren
            const container = document.getElementById('assessment-process-container');
            if (!container) return;
            
            // Frage-ID aus der aktuellen Ansicht extrahieren
            const questionElement = container.querySelector('.question-element');
            if (!questionElement) return;
            
            // In einer realen Implementierung würde die Frage-ID aus dem DOM oder dem Zustand extrahiert
            // Hier vereinfacht: Wir verwenden die erste Frage-ID aus den Statistiken
            const currentQuestionId = Object.keys(stats.questionDifficulty)[0];
            if (!currentQuestionId) return;
            
            // Antwortstatistiken aktualisieren
            const statsContent = document.getElementById('answer-statistics');
            if (statsContent) {
                // Leeren
                statsContent.innerHTML = '';
                
                // Allgemeine Statistiken
                const generalStats = document.createElement('div');
                generalStats.className = 'general-stats';
                generalStats.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">Einreichungen:</span>
                        <span class="stat-value">${stats.totalSubmissions}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Durchschnittliche Punktzahl:</span>
                        <span class="stat-value">${stats.averageScore.toFixed(1)}%</span>
                    </div>
                `;
                
                statsContent.appendChild(generalStats);
                
                // Antwortverteilung für aktuelle Frage
                if (stats.answerDistribution[currentQuestionId]) {
                    const distributionStats = document.createElement('div');
                    distributionStats.className = 'distribution-stats';
                    
                    const distributionHeader = document.createElement('h4');
                    distributionHeader.textContent = 'Antwortverteilung:';
                    
                    const distributionList = document.createElement('ul');
                    distributionList.className = 'distribution-list';
                    
                    // Antworten sortieren nach Häufigkeit
                    const answers = Object.keys(stats.answerDistribution[currentQuestionId])
                        .map(answer => ({
                            text: answer,
                            count: stats.answerDistribution[currentQuestionId][answer]
                        }))
                        .sort((a, b) => b.count - a.count);
                    
                    answers.forEach(answer => {
                        const answerItem = document.createElement('li');
                        
                        // Antworttext aufbereiten
                        let answerText = answer.text;
                        try {
                            // Versuchen, JSON zu parsen und zu formatieren
                            const parsed = JSON.parse(answer.text);
                            answerText = typeof parsed === 'object' ? 
                                JSON.stringify(parsed, null, 2) : String(parsed);
                        } catch (e) {
                            // Wenn kein gültiges JSON, Originaltext verwenden
                        }
                        
                        answerItem.innerHTML = `
                            <span class="answer-text">${answerText}</span>
                            <span class="answer-count">${answer.count} (${Math.round(answer.count / stats.totalSubmissions * 100)}%)</span>
                        `;
                        
                        distributionList.appendChild(answerItem);
                    });
                    
                    distributionStats.appendChild(distributionHeader);
                    distributionStats.appendChild(distributionList);
                    
                    statsContent.appendChild(distributionStats);
                }
            }
            
            // Vergleichsanalyse aktualisieren
            const comparisonContent = document.getElementById('comparison-analysis');
            if (comparisonContent) {
                // In einer realen Implementierung würden hier detaillierte Vergleichsdaten angezeigt
                comparisonContent.innerHTML = `
                    <div class="comparison-result">
                        <p>Die aktuelle Antwort liegt im Vergleich zu anderen Teilnehmern:</p>
                        <div class="comparison-indicator">
                            <div class="indicator-bar">
                                <div class="indicator-marker" style="left: 65%"></div>
                            </div>
                            <div class="indicator-labels">
                                <span>Unterdurchschnittlich</span>
                                <span>Durchschnittlich</span>
                                <span>Überdurchschnittlich</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Fragen-Analyse aktualisieren
            const questionAnalysis = document.getElementById('question-analysis');
            if (questionAnalysis && stats.questionDifficulty[currentQuestionId]) {
                const difficultyData = stats.questionDifficulty[currentQuestionId];
                const difficultyPercentage = 100 - difficultyData.difficulty; // Umkehren: 100% = schwer, 0% = leicht
                
                const discriminationValue = stats.questionDiscrimination[currentQuestionId] || 0;
                const discriminationPercentage = discriminationValue * 100;
                
                // Schwierigkeitsgrad-Anzeige aktualisieren
                const difficultyIndicator = questionAnalysis.querySelector('.difficulty-indicator .indicator-value');
                const difficultyValue = questionAnalysis.querySelector('.difficulty-indicator .value');
                
                if (difficultyIndicator && difficultyValue) {
                    difficultyIndicator.style.width = `${difficultyPercentage}%`;
                    difficultyValue.textContent = `${difficultyPercentage.toFixed(1)}%`;
                }
                
                // Trennschärfe-Anzeige aktualisieren
                const discriminationIndicator = questionAnalysis.querySelector('.discrimination-indicator .indicator-value');
                const discriminationValueElement = questionAnalysis.querySelector('.discrimination-indicator .value');
                
                if (discriminationIndicator && discriminationValueElement) {
                    discriminationIndicator.style.width = `${discriminationPercentage}%`;
                    discriminationValueElement.textContent = `${discriminationPercentage.toFixed(1)}%`;
                }
            }
            
        } catch (error) {
            console.error('Fehler beim Aktualisieren der Analyse-Anzeige:', error);
        }
    }
    
    /**
     * Aktualisiert die Bewertungsstatistiken
     * @param {string} assessmentId - ID der Bewertung
     */
    function _updateAssessmentStatistics(assessmentId) {
        try {
            if (!assessmentId) return;
            
            // Cache leeren, um neue Berechnungen zu erzwingen
            delete _statisticsCache[assessmentId];
            
            // Statistiken neu laden
            _loadAssessmentStatistics(assessmentId);
            
        } catch (error) {
            console.error('Fehler beim Aktualisieren der Bewertungsstatistiken:', error);
        }
    }
    
    /**
     * Generiert einen Bewertungsvorschlag für die aktuelle Frage
     */
    function _generateScoringProposal() {
        try {
            // In einer realen Implementierung würde hier ein komplexer Algorithmus verwendet
            // In diesem Beispiel: vereinfachter Ansatz
            
            // Aktuelle Frage identifizieren
            const container = document.getElementById('assessment-process-container');
            if (!container) return;
            
            // Frage-ID und Antworttext aus der aktuellen Ansicht extrahieren
            const questionElement = container.querySelector('.question-element');
            if (!questionElement) return;
            
            // In einer echten Implementierung würden hier Daten aus dem aktuellen Zustand verwendet
            // Hier vereinfacht für die Demonstration
            
            // Zufällige Vorschläge generieren (in einer echten Implementierung: datenbasiert)
            const suggestedScore = Math.floor(Math.random() * 10) + 1;
            const maxScore = 10; // Aus der aktuellen Frage extrahieren
            const percentage = (suggestedScore / maxScore) * 100;
            
            // Passende Vorlage finden
            let suggestedTemplate = null;
            for (const template of _feedbackTemplates) {
                if (percentage >= template.scoreRange.min && 
                    percentage <= template.scoreRange.max) {
                    suggestedTemplate = template;
                    break;
                }
            }
            
            // Vorschlag anzeigen
            const suggestionsContent = document.querySelector('.suggestions-content');
            if (suggestionsContent) {
                suggestionsContent.innerHTML = `
                    <div class="suggestion-result">
                        <h4>Bewertungsvorschlag</h4>
                        <div class="suggested-score">
                            <span class="score-label">Vorgeschlagene Punktzahl:</span>
                            <span class="score-value">${suggestedScore} von ${maxScore} (${percentage.toFixed(1)}%)</span>
                        </div>
                        ${suggestedTemplate ? `
                            <div class="suggested-template">
                                <span class="template-label">Empfohlene Vorlage:</span>
                                <span class="template-title">${suggestedTemplate.title}</span>
                                <button class="btn btn-sm btn-outline-primary apply-suggested-template">
                                    Vorlage anwenden
                                </button>
                            </div>
                        ` : ''}
                        <div class="suggestion-explanation">
                            <p>Dieser Vorschlag basiert auf der Analyse ähnlicher Antworten und Bewertungen.</p>
                        </div>
                        <div class="suggestion-actions">
                            <button class="btn btn-sm btn-primary apply-suggestion">
                                Vorschlag übernehmen
                            </button>
                            <button class="btn btn-sm btn-outline-secondary dismiss-suggestion">
                                Verwerfen
                            </button>
                        </div>
                    </div>
                `;
                
                // Event-Listener für Aktionen
                const applyButton = suggestionsContent.querySelector('.apply-suggestion');
                if (applyButton) {
                    applyButton.addEventListener('click', () => {
                        // Punktzahl übernehmen
                        const scoreInput = document.getElementById('question-score');
                        if (scoreInput) {
                            scoreInput.value = suggestedScore;
                            
                            // Event auslösen, um Änderungen zu registrieren
                            const event = new Event('change');
                            scoreInput.dispatchEvent(event);
                        }
                    });
                }
                
                const templateButton = suggestionsContent.querySelector('.apply-suggested-template');
                if (templateButton && suggestedTemplate) {
                    templateButton.addEventListener('click', () => {
                        _applyTemplate(suggestedTemplate.id);
                    });
                }
                
                const dismissButton = suggestionsContent.querySelector('.dismiss-suggestion');
                if (dismissButton) {
                    dismissButton.addEventListener('click', () => {
                        suggestionsContent.innerHTML = `
                            <div class="no-suggestions">
                                <i class="fas fa-robot"></i>
                                <p>Bewertungsvorschläge werden geladen, sobald genügend Daten vorliegen.</p>
                            </div>
                        `;
                    });
                }
            }
            
        } catch (error) {
            console.error('Fehler beim Generieren des Bewertungsvorschlags:', error);
        }
    }
    
    /**
     * Lädt teamspezifische Bewertungsrichtlinien
     */
    function _loadTeamGuidelines() {
        try {
            // Container finden
            const guidelinesContent = document.getElementById('team-specific-guidelines');
            if (!guidelinesContent) return;
            
            // Ladeanimation anzeigen
            guidelinesContent.innerHTML = `
                <div class="loading-guidelines">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Teamspezifische Richtlinien werden geladen...</p>
                </div>
            `;
            
            // In einer realen Implementierung würden hier Daten aus einer API abgerufen
            // Hier: verzögertes Laden simulieren
            setTimeout(() => {
                // Aktuelle Bewertung und Team identifizieren
                let userTeam = 'Allgemein';
                
                if (_currentAssessmentId) {
                    const testResults = window.ImmoLMS.DataStore.getTestResults() || [];
                    const currentResult = testResults.find(r => r.id === _currentAssessmentId);
                    
                    if (currentResult) {
                        const users = window.ImmoLMS.DataStore.getUsers() || [];
                        const user = users.find(u => u.id === currentResult.userId);
                        
                        if (user && user.team) {
                            userTeam = user.team;
                        }
                    }
                }
                
                // Richtlinien anhand des Teams anzeigen
                guidelinesContent.innerHTML = `
                    <div class="team-guidelines">
                        <h4>Richtlinien für Team: ${userTeam}</h4>
                        <div class="guideline-content">
                            ${userTeam === 'Vertrieb' ? `
                                <p>Für Vertriebsmitarbeiter sollten Sie besonders auf die Anwendung von Verkaufstechniken und Kundenberatungskompetenz achten. Relevante praktische Beispiele sind mit bis zu 10% Bonuspunkten zu bewerten.</p>
                                <ul>
                                    <li>Bewerten Sie die korrekte Verwendung von Fachbegriffen zur Immobilienvermarktung.</li>
                                    <li>Achten Sie auf die Qualität der Kundenberatungsansätze.</li>
                                    <li>Berücksichtigen Sie die Anwendung aktueller Marktentwicklungen.</li>
                                </ul>
                            ` : userTeam === 'Marketing' ? `
                                <p>Bei Marketingmitarbeitern sollten insbesondere Kreativität, Zielgruppenverständnis und medienübergreifende Strategien bewertet werden. Innovative Ansätze können mit Bonuspunkten honoriert werden.</p>
                                <ul>
                                    <li>Bewerten Sie die Qualität der Marketingstrategien und Kampagnenkonzepte.</li>
                                    <li>Achten Sie auf das Verständnis digitaler Marketingkanäle.</li>
                                    <li>Berücksichtigen Sie die Verbindung von Marketingaktivitäten mit Geschäftszielen.</li>
                                </ul>
                            ` : `
                                <p>Allgemeine Bewertungsrichtlinien:</p>
                                <ul>
                                    <li>Fokussieren Sie auf korrekte Fachbegriffe und präzise Antworten.</li>
                                    <li>Achten Sie auf strukturierte und nachvollziehbare Argumentationen.</li>
                                    <li>Bewerten Sie die praktische Anwendbarkeit des gezeigten Wissens.</li>
                                </ul>
                            `}
                        </div>
                    </div>
                `;
            }, 1000);
            
        } catch (error) {
            console.error('Fehler beim Laden der Team-Richtlinien:', error);
        }
    }
    
    // Öffentliche API
    AssessmentEnhancements.initialize = initialize;
    AssessmentEnhancements.refreshTemplates = _updateTemplatePanel;
    AssessmentEnhancements.applyTemplate = _applyTemplate;
    
    return AssessmentEnhancements;
})();

// Automatische Initialisierung
document.addEventListener('DOMContentLoaded', function() {
    window.ImmoLMS.TrainerDashboard.AssessmentEnhancements.initialize();
});
